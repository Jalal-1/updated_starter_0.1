This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
compact-js/
  compact-js/
    src/
      effect/
        internal/
          compactContext.ts
        CompactContext.ts
        CompiledContract.ts
        Contract.ts
        ContractConfigurationError.ts
        ContractExecutable.ts
        ContractExecutableRuntime.ts
        ContractRuntimeError.ts
        index.ts
        ZKConfiguration.ts
        ZKConfigurationReadError.ts
      index.ts
    test/
      contract/
        counter.compact
        index.ts
        unshielded.compact
      effect/
        Arbitrary.ts
        ContractExecutable.test.ts
        ContractExecutableRuntime.test.ts
        Unshielded.test.ts
      typetests/
        effect/
          CompiledContract.tst.ts
          ContractExecutable.tst.ts
        tsconfig.json
    LICENSE
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
    tsconfig.src.json
    tsconfig.test.json
    vitest.config.ts
  compact-js-command/
    src/
      effect/
        internal/
          args.ts
          circuitCommand.ts
          command.ts
          compiledContractReflection.ts
          contractState.ts
          deployCommand.ts
          encodedZswapLocalStateSchema.ts
          maintainCircuitCommand.ts
          maintainCommand.ts
          maintainContractCommand.ts
          options.ts
        CommandConfigProvider.ts
        CompiledContractReflection.ts
        ConfigCompilationError.ts
        ConfigCompiler.ts
        ConfigError.ts
        index.ts
      index.ts
    test/
      contract/
        counter/
          .gitignore
          contract.config.ts
      effect/
        Circuit.test.ts
        cleanup.ts
        CompiledContractReflection.test.ts
        ConfigCompiler.test.ts
        Deploy.test.ts
        MaintainCircuit.test.ts
        MaintainContract.test.ts
        MockConsole.ts
    LICENSE
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
    tsconfig.src.json
    tsconfig.test.json
    vitest.config.ts
  compact-js-node/
    src/
      effect/
        index.ts
        ZKFileConfiguration.ts
      index.ts
    LICENSE
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
    tsconfig.src.json
    tsconfig.test.json
    vitest.config.ts
  README.md
docs/
  api/
    midnight-js/
      @midnight-ntwrk/
        midnight-js-contracts/
          classes/
            CallTxFailedError.md
            ContractTypeError.md
            DeployTxFailedError.md
            IncompleteCallTxPrivateStateConfig.md
            IncompleteFindContractPrivateStateConfig.md
            InsertVerifierKeyTxFailedError.md
            RemoveVerifierKeyTxFailedError.md
            ReplaceMaintenanceAuthorityTxFailedError.md
            TxFailedError.md
          functions/
            call.md
            callContractConstructor.md
            createCallTxOptions.md
            createCircuitCallTxInterface.md
            createCircuitMaintenanceTxInterface.md
            createCircuitMaintenanceTxInterfaces.md
            createContractMaintenanceTxInterface.md
            createUnprovenCallTx.md
            createUnprovenCallTxFromInitialStates.md
            createUnprovenDeployTx.md
            createUnprovenDeployTxFromVerifierKeys.md
            deployContract.md
            findDeployedContract.md
            getPublicStates.md
            getStates.md
            getUnshieldedBalances.md
            submitCallTx.md
            submitCallTxAsync.md
            submitDeployTx.md
            submitInsertVerifierKeyTx.md
            submitRemoveVerifierKeyTx.md
            submitReplaceAuthorityTx.md
            submitTx.md
            submitTxAsync.md
            verifierKeysEqual.md
            verifyContractState.md
          interfaces/
            ContractMaintenanceTxInterface.md
          type-aliases/
            CallOptions.md
            CallOptionsBase.md
            CallOptionsProviderDataDependencies.md
            CallOptionsWithArguments.md
            CallOptionsWithPrivateState.md
            CallOptionsWithProviderDataDependencies.md
            CallResult.md
            CallResultPrivate.md
            CallResultPublic.md
            CallTxOptions.md
            CallTxOptionsBase.md
            CallTxOptionsWithPrivateStateId.md
            CircuitCallTxInterface.md
            CircuitMaintenanceTxInterface.md
            CircuitMaintenanceTxInterfaces.md
            ContractConstructorOptions.md
            ContractConstructorOptionsBase.md
            ContractConstructorOptionsProviderDataDependencies.md
            ContractConstructorOptionsWithArguments.md
            ContractConstructorOptionsWithPrivateState.md
            ContractConstructorOptionsWithProviderDataDependencies.md
            ContractConstructorResult.md
            ContractProviders.md
            ContractStates.md
            DeployContractOptions.md
            DeployContractOptionsBase.md
            DeployContractOptionsWithPrivateState.md
            DeployedContract.md
            DeployTxOptions.md
            DeployTxOptionsBase.md
            DeployTxOptionsWithPrivateState.md
            DeployTxOptionsWithPrivateStateId.md
            FinalizedCallTxData.md
            FinalizedDeployTxData.md
            FinalizedDeployTxDataBase.md
            FindDeployedContractOptions.md
            FindDeployedContractOptionsBase.md
            FindDeployedContractOptionsExistingPrivateState.md
            FindDeployedContractOptionsStorePrivateState.md
            FoundContract.md
            PublicContractStates.md
            SubmittedCallTx.md
            SubmitTxOptions.md
            SubmitTxProviders.md
            UnprovenCallTxProvidersBase.md
            UnprovenCallTxProvidersWithPrivateState.md
            UnprovenDeployTxOptions.md
            UnprovenDeployTxProviders.md
            UnsubmittedCallTxData.md
            UnsubmittedDeployTxData.md
            UnsubmittedDeployTxDataBase.md
            UnsubmittedDeployTxPrivateData.md
            UnsubmittedDeployTxPublicData.md
            UnsubmittedTxData.md
          README.md
        midnight-js-fetch-zk-config-provider/
          classes/
            FetchZkConfigProvider.md
          README.md
        midnight-js-http-client-proof-provider/
          functions/
            httpClientProofProvider.md
            serializeTransactionPayload.md
          variables/
            DEFAULT_CONFIG.md
          README.md
        midnight-js-indexer-public-data-provider/
          classes/
            IndexerFormattedError.md
          functions/
            indexerPublicDataProvider.md
            toUnshieldedBalances.md
            toUnshieldedUtxos.md
          type-aliases/
            IndexerUtxo.md
          README.md
        midnight-js-level-private-state-provider/
          classes/
            StorageEncryption.md
          functions/
            getStoragePassword.md
            levelPrivateStateProvider.md
          interfaces/
            LevelPrivateStateProviderConfig.md
          variables/
            DEFAULT_CONFIG.md
          README.md
        midnight-js-logger-provider/
          classes/
            LoggerProvider.md
          README.md
        midnight-js-network-id/
          functions/
            getNetworkId.md
            setNetworkId.md
          type-aliases/
            NetworkId.md
          README.md
        midnight-js-node-zk-config-provider/
          classes/
            NodeZkConfigProvider.md
          README.md
        midnight-js-types/
          classes/
            InvalidProtocolSchemeError.md
            ZKConfigProvider.md
          enumerations/
            LogLevel.md
          functions/
            createProverKey.md
            createVerifierKey.md
            createZKIR.md
            getImpureCircuitIds.md
          interfaces/
            Contract.md
            FinalizedTxData.md
            LoggerProvider.md
            MidnightProvider.md
            MidnightProviders.md
            PrivateStateProvider.md
            ProofProvider.md
            ProveTxConfig.md
            PublicDataProvider.md
            WalletProvider.md
            ZKConfig.md
          type-aliases/
            All.md
            BalancedProvingRecipe.md
            BalanceTransactionToProve.md
            BlockHash.md
            BlockHashConfig.md
            BlockHeightConfig.md
            CircuitParameters.md
            CircuitReturnType.md
            ContractStateObservableConfig.md
            Fees.md
            ImpureCircuit.md
            ImpureCircuitId.md
            ImpureCircuits.md
            InitialStateParameters.md
            Latest.md
            NothingToProve.md
            PrivateState.md
            PrivateStateId.md
            ProvenTransaction.md
            ProverKey.md
            ProvingRecipe.md
            SegmentStatus.md
            TransactionToProve.md
            TxIdConfig.md
            TxStatus.md
            UnshieldedBalance.md
            UnshieldedBalances.md
            UnshieldedUtxo.md
            UnshieldedUtxos.md
            VerifierKey.md
            Witness.md
            Witnesses.md
            ZKIR.md
          variables/
            BALANCE_TRANSACTION_TO_PROVE.md
            FailEntirely.md
            FailFallible.md
            NOTHING_TO_PROVE.md
            SegmentFail.md
            SegmentSuccess.md
            SucceedEntirely.md
            TRANSACTION_TO_PROVE.md
          README.md
        midnight-js-utils/
          functions/
            assertDefined.md
            assertIsContractAddress.md
            assertIsHex.md
            assertUndefined.md
            fromHex.md
            isHex.md
            parseCoinPublicKeyToHex.md
            parseEncPublicKeyToHex.md
            parseHex.md
            toHex.md
            ttlOneHour.md
          type-aliases/
            ParsedHexString.md
          README.md
      packages.md
      README.md
    testkit-js/
      classes/
        DynamicProofServerContainer.md
        EnvVarRemoteTestEnvironment.md
        FaucetClient.md
        GzipFile.md
        IndexerClient.md
        LocalTestConfiguration.md
        LocalTestEnvironment.md
        MidnightWalletProvider.md
        NodeClient.md
        ProofServerClient.md
        QanetTestEnvironment.md
        RemoteTestEnvironment.md
        StaticProofServerContainer.md
        TestEnvironment.md
        Testnet2TestEnvironment.md
        WalletBuilder.md
        WalletSaveStateProvider.md
      functions/
        createDefaultTestLogger.md
        createLogger.md
        delay.md
        expectFoundAndDeployedStatesEqual.md
        expectFoundAndDeployedTxDataEqual.md
        expectFoundAndDeployedTxPrivateDataEqual.md
        expectFoundAndDeployedTxPublicDataEqual.md
        expectSuccessfulCallTx.md
        expectSuccessfulDeployTx.md
        expectSuccessfulTxData.md
        extractHostnameAndPort.md
        getContainersConfiguration.md
        getInitialShieldedState.md
        getInitialState.md
        getInitialUnshieldedState.md
        getTestEnvironment.md
        getWalletStateFilename.md
        initializeMidnightProviders.md
        inMemoryPrivateStateProvider.md
        setContainersConfiguration.md
        stateValueEqual.md
        syncWallet.md
        txsEqual.md
        waitForFunds.md
      interfaces/
        ContainerEndpoints.md
        ContainersConfiguration.md
        ContractConfiguration.md
        EnvironmentConfiguration.md
        LogConfiguration.md
        ProofServerContainer.md
        ProofServerContainerConfiguration.md
        StandaloneContainerNames.md
        StandaloneContainersConfiguration.md
      type-aliases/
        ComponentPortsConfiguration.md
      variables/
        DEFAULT_WALLET_STATE_DIRECTORY.md
        defaultContainersConfiguration.md
        DustOptions.md
        latestContainersConfiguration.md
        logger.md
        MINUTE.md
      globals.md
      README.md
  README_API.md
packages/
  compact/
    src/
      fetch-compact.mts
      fetch-utils.ts
      run-compactc.cjs
      run-utils.ts
      version-manager.ts
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
    turbo.json
  contracts/
    src/
      test/
        utils/
          ledger-utils.test.ts
          zswap-utils.test.ts
        call-constructor.test.ts
        call.test.ts
        deploy-contract.test.ts
        find-deployed-contract.test.ts
        get-states.test.ts
        get-unshielded-balances.test.ts
        submit-call-tx.test.ts
        submit-deploy-tx.test.ts
        submit-insert-vk-tx.test.ts
        submit-remove-vk-tx.test.ts
        submit-replace-authority-tx.test.ts
        submit-tx.test.ts
        test-mocks.ts
        tx-interfaces.test.ts
        unproven-call-tx.test.ts
        unproven-deploy-tx.test.ts
      utils/
        index.ts
        ledger-utils.ts
        zswap-utils.ts
      call-constructor.ts
      call.ts
      contract-providers.ts
      deploy-contract.ts
      errors.ts
      find-deployed-contract.ts
      get-states.ts
      get-unshielded-balances.ts
      index.ts
      submit-call-tx.ts
      submit-deploy-tx.ts
      submit-insert-vk-tx.ts
      submit-remove-vk-tx.ts
      submit-replace-authority-tx.ts
      submit-tx.ts
      tx-interfaces.ts
      tx-model.ts
      unproven-call-tx.ts
      unproven-deploy-tx.ts
    package.json
    README.md
    rollup.config.mjs
    tsconfig.build.json
    tsconfig.json
    typedoc.json
    vitest.config.ts
  fetch-zk-config-provider/
    src/
      test/
        fetch-zk-config-provider.test.ts
      fetch-zk-config-provider.ts
      index.ts
    package.json
    README.md
    rollup.config.mjs
    tsconfig.build.json
    tsconfig.json
    typedoc.json
    vitest.config.ts
  http-client-proof-provider/
    src/
      test/
        resources/
          simple.compact
        commons.ts
        http-client-proof-provider-spied.test.ts
        http-client-proof-provider.test.ts
      http-client-proof-provider.ts
      index.ts
    package.json
    README.md
    rollup.config.mjs
    tsconfig.build.json
    tsconfig.json
    typedoc.json
    vitest.config.ts
  indexer-public-data-provider/
    src/
      gen/
        fragment-masking.ts
        gql.ts
        graphql.ts
        index.ts
      test/
        indexer-public-data-provider-spied.test.ts
        indexer-public-data-provider-unshielded-balances.test.ts
        indexer-public-data-provider.test.ts
      errors.ts
      index.ts
      indexer-public-data-provider.ts
      query-definitions.ts
    codegen.ts
    package.json
    README.md
    rollup.config.mjs
    schema.graphql
    tsconfig.build.json
    tsconfig.json
    typedoc.json
    vitest.config.ts
  level-private-state-provider/
    src/
      test/
        level-private-state-provider.test.ts
        storage-encryption.test.ts
      index.ts
      level-private-state-provider.ts
      storage-encryption.ts
    package.json
    README.md
    rollup.config.mjs
    tsconfig.build.json
    tsconfig.json
    typedoc.json
    vitest.config.ts
  logger-provider/
    src/
      test/
        logger-provider.test.ts
      index.ts
      logger-provider.ts
    package.json
    README.md
    rollup.config.mjs
    tsconfig.build.json
    tsconfig.json
    typedoc.json
    vitest.config.ts
  network-id/
    src/
      index.ts
      network-id.ts
    package.json
    README.md
    rollup.config.mjs
    tsconfig.build.json
    tsconfig.json
    typedoc.json
    vitest.config.ts
  node-zk-config-provider/
    src/
      test/
        node-zk-provider.test.ts
      index.ts
      node-zk-config-provider.ts
    package.json
    README.md
    rollup.config.mjs
    tsconfig.build.json
    tsconfig.json
    typedoc.json
    vitest.config.ts
  types/
    src/
      contract.ts
      errors.ts
      index.ts
      logger-provider.ts
      midnight-provider.ts
      midnight-types.ts
      private-state-provider.ts
      proof-provider.ts
      providers.ts
      public-data-provider.ts
      wallet-provider.ts
      zk-config-provider.ts
    package.json
    README.md
    rollup.config.mjs
    tsconfig.build.json
    tsconfig.json
    typedoc.json
    vitest.config.ts
  utils/
    src/
      test/
        hex-utils.test.ts
        type-utils.test.ts
      assertion-utils.ts
      date-utils.ts
      hex-utils.ts
      index.ts
      type-utils.ts
    package.json
    README.md
    rollup.config.mjs
    tsconfig.build.json
    tsconfig.json
    typedoc.json
    vitest.config.ts
platform-js/
  platform-js/
    src/
      effect/
        internal/
          hex.ts
        CoinPublicKey.ts
        Configuration.ts
        ContractAddress.ts
        DomainSeparator.ts
        Hex.ts
        index.ts
        IntegerRange.ts
        NetworkId.ts
        NetworkIdMoniker.ts
        ParseError.ts
        SigningKey.ts
      index.ts
    test/
      effect/
        Arbitrary.ts
        ContractAddress.test.ts
        Hex.test.ts
        IntegerRange.test.ts
        NetworkId.test.ts
        NetworkIdMoniker.test.ts
    LICENSE
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
    tsconfig.src.json
    tsconfig.test.json
    vitest.config.ts
  README.md
scripts/
  release.sh
testkit-js/
  testkit-js/
    src/
      client/
        faucet-client.ts
        index.ts
        indexer-client.ts
        node-client.ts
        proof-server-client.ts
      contract/
        contract-types.ts
        in-memory-private-state-provider.ts
        index.ts
        providers.ts
      test-environment/
        test-environments/
          env-var-remote-test-environment.ts
          index.ts
          local-test-environment.ts
          qanet-test-environment.ts
          remote-test-environment.ts
          test-environment.ts
          testnet2-test-environment.ts
        environment-configuration.ts
        environment-provider.ts
        index.ts
      wallet/
        gzip-file.ts
        index.ts
        midnight-wallet-provider.ts
        wallet-builder.ts
        wallet-configuration-mapper.ts
        wallet-seed-utils.ts
        wallet-state-provider.ts
        wallet-utils.ts
      assertions.ts
      configuration-types.ts
      configuration.ts
      env-vars.ts
      errors.ts
      index.ts
      logger.ts
      proof-server-container.ts
      utils.ts
    test/
      env-vars.ut.test.ts
      testing-api.e2e.test.ts
      testing-api.it.test.ts
      testing-api.ut.test.ts
    .npmignore
    package.json
    README.md
    rollup.config.mjs
    tsconfig.build.json
    tsconfig.docs.json
    tsconfig.json
    typedoc.json
    vitest.config.ts
    vitest.package.it.config.ts
    vitest.package.ut.config.ts
  testkit-js-e2e/
    src/
      contract/
        block-time.compact
        counter-clone.compact
        counter.compact
        index.ts
        simple.compact
        unshielded.compact
        witnesses.ts
      node/
        counter.ts
      block-time-api.ts
      block-time-types.ts
      constants.ts
      counter-api.ts
      counter-clone-types.ts
      counter-types.ts
      index.ts
      simple-types.ts
      unshielded-types.ts
    test/
      contracts.blocktime.it.test.ts
      contracts.it.test.ts
      contracts.singlecontract.nostate.it.test.ts
      contracts.snarkupgrade.it.test.ts
      contracts.snarkupgrade.singlecontract.it.test.ts
      contracts.snarkupgrade.smoke.it.test.ts
      indexer-public-data-provider.observable1.it.test.ts
      indexer-public-data-provider.observable2.it.test.ts
      indexer-public-data-provider.singlecontract.it.test.ts
      nodejs.it.test.ts
      proof-server.it.test.ts
      unshielded.it.test.ts
    .npmignore
    package.json
    README.md
    rollup.config.mjs
    tsconfig.build.json
    tsconfig.json
    typedoc.json
    vite.setup.mjs
    vitest.config.ts
    vitest.single.config.ts
  compose.yml
  proof-server.yml
.gitignore
.repomixignore
CHANGELOG.md
package.json
README.md
repomix.config.json

================================================================
Files
================================================================

================
File: compact-js/compact-js/src/effect/internal/compactContext.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Effect, type Types } from 'effect';

import type * as CompactContext from '../CompactContext.js';
import type { CompiledContract } from '../CompiledContract.js';
import { type Contract } from '../Contract.js';

/** @internal */
export const TypeId = Symbol();
/** @internal */
export type TypeId = typeof TypeId;

/** @internal */
export interface Context<C extends Contract.Any>
  extends CompactContext.Witnesses<C>, CompactContext.CompiledAssetsPath {
    readonly ctor: Types.Ctor<C>;
  }

/** @internal */
export const getContractContext: <C extends Contract<PS>, PS>(
  compiledContract: CompiledContract<C, PS>
) => Types.Simplify<Required<Context<C>>> = <C extends Contract<PS>, PS>(compiledContract: CompiledContract<C, PS>) =>
  compiledContract[TypeId] as Required<Context<C>>;

/** @internal */
export const createContract: <C extends Contract<PS>, PS>(
  compiledContract: CompiledContract<C, PS>
) => Effect.Effect<C> = <C extends Contract<PS>, PS>(compiledContract: CompiledContract<C, PS>) =>
  Effect.sync(() => {
    const context = getContractContext(compiledContract);

    if (!context.ctor) throw new Error('Invalid CompactContext (missing constructor)');
    return new context.ctor(context.witnesses);
  });

================
File: compact-js/compact-js/src/effect/CompactContext.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { Contract } from './Contract.js';

/**
 * Witness configuration.
 */
export type Witnesses<in C extends Contract.Any, W = Contract.Witnesses<C>> = {
  /**
   * An implementation of the witnesses of `C`.
   */
  readonly witnesses: W;
};

/**
 * Compiled asset path configuration.
 */
export type CompiledAssetsPath = {
  /**
   * A path to the compiled assets produced by the Compact compiler.
   */
  readonly compiledAssetsPath: string;
};

================
File: compact-js/compact-js/src/effect/CompiledContract.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { Types } from 'effect';
import { dual } from 'effect/Function';
import { type Pipeable, pipeArguments } from 'effect/Pipeable';

import type * as CompactContext from './CompactContext.js';
import type { Contract } from './Contract.js';
import * as CompactContextInternal from './internal/compactContext.js';

export const TypeId = Symbol.for('compact-js/CompiledContract');
export type TypeId = typeof TypeId;

/**
 * A binding to a Compact compiled contract.
 *
 * @remarks
 * Alongside the imported type and contract instance, we also need to provide an implementation of the
 * witnesses that the contract expects, along with a mechanism to retrieve the compiled ZK assets associated
 * with the compiled contract. A {@link CompiledContract} represents such a container within a hosting
 * TypeScript program. In order to make a contract executable, you should use the `ContractExecutable` module.
 *
 * @see {@link getContext} to retrieve the publicly visible properties associated with the compiled contract.
 */
export interface CompiledContract<in out C extends Contract<PS>, in out PS, out R = never>
  extends CompiledContract.Variance<C, PS, R>, Pipeable {
  /**
   * Gets the tag assigned to this compiled contract.
   */
  readonly tag: string;
  readonly [CompactContextInternal.TypeId]: Partial<CompactContextInternal.Context<C>>;
}

export declare namespace CompiledContract {
  /** @internal */
  export type Variance<in out C, in out PS, out R> = {
    readonly [TypeId]: {
      readonly _C: Types.Invariant<C>;
      readonly _PS: Types.Invariant<PS>;
      readonly _R: Types.Covariant<R>;
    };
  };

  /**
   * The context required to fully build a {@link CompiledContract}.
   *
   * @remarks
   * When looking to use a Compact compiled contract in a TypeScript program, we need to provide path
   * information to where the generated ZK assets can be found, along with an implementation of the witnesses
   * expected by the contract.
   */
  export type Context<C extends Contract.Any> = CompactContext.Witnesses<C> | CompactContext.CompiledAssetsPath;
}

const CompiledContractProto = {
  [TypeId]: {
    _C: (_: unknown) => _,
    _PS: (_: unknown) => _,
    _R: (_: never) => _
  },
  pipe() {
    return pipeArguments(this, arguments); // eslint-disable-line prefer-rest-params
  }
};

/**
 * Initializes an object that represents a binding to a Compact compiled contract.
 *
 * @param tag A unique identifier that represents this type of contract.
 * @param ctor The contract constructor, as imported from the compiled Compact output.
 * @returns A {@link CompiledContract}.
 *
 * @category constructors
 */
export const make: <C extends Contract<PS>, PS = Contract.PrivateState<C>, R = CompiledContract.Context<C>>(
  tag: string,
  ctor: Types.Ctor<C>
) => CompiledContract<C, PS, R> = <C extends Contract<PS>, PS, R = CompiledContract.Context<C>>(
  tag: string,
  ctor: Types.Ctor<C>
) => {
  const self = Object.create(CompiledContractProto) as Types.Mutable<CompiledContract<C, PS, R>>;
  self.tag = tag;
  self[CompactContextInternal.TypeId] = { ctor };
  return self;
};

/**
 * Associates an object that implements the contract witnesses for the Compact compiled contract.
 * 
 * @category combinators
 */
export const withWitnesses: {
  /**
   * @param witnesses An object implementing the witness functions required by the Compact compiled contract.
   * @returns A function that receives the {@link CompiledContract} that `witnesses` will be attached to.
   */
  <C extends Contract<PS>, PS, R>(
    witnesses: R extends CompactContext.Witnesses<C, infer W> ? W : never
  ): (self: CompiledContract<C, PS, R>) => CompiledContract<C, PS, Exclude<R, CompactContext.Witnesses<C>>>;
  /**
   * @param self The {@link CompiledContract} that `witnesses` will be attached to.
   * @param witnesses An object implementing the witness functions required by the Compact compiled contract.
   */
  <C extends Contract<PS>, PS, R>(
    self: CompiledContract<C, PS, R>,
    witnesses: R extends CompactContext.Witnesses<C, infer W> ? W : never
  ): CompiledContract<C, PS, Exclude<R, CompactContext.Witnesses<C>>>;
} = dual(
  2,
  <C extends Contract<PS>, PS, R>(
    self: CompiledContract<C, PS, R>,
    witnesses: R extends CompactContext.Witnesses<C, infer W> ? W : never
  ) => {
    return {
      ...self,
      [CompactContextInternal.TypeId]: {
        ...self[CompactContextInternal.TypeId],
        witnesses
      }
    };
  }
);

/**
 * Associates _vacant_ witnesses with a Compact compiled contract that specifies no witnesses.
 * 
 * @param self The {@link CompiledContract} for which no witnesses are required.
 * 
 * @category combinators
 */
export const withVacantWitnesses: <C extends Contract<PS>, PS, R>(
  self: CompiledContract<C, PS, R>
) => CompiledContract<C, PS, Exclude<R, CompactContext.Witnesses<C>>> =
  <C extends Contract<PS>, PS, R>(self: CompiledContract<C, PS, R>) => {
    return {
      ...self,
      [CompactContextInternal.TypeId]: {
        ...self[CompactContextInternal.TypeId],
        witnesses: {}
      }
    } as CompiledContract<C, PS, Exclude<R, CompactContext.Witnesses<C>>>;
  };

/**
 * Associates a file path of where to find the compiled assets for the Compact compiled contract.
 * 
 * @remarks
 * Relative file paths will be resolved relative to the base paths provided to each service that accesses
 * the compiled file assets. 
 *
 * @category combinators
 */
export const withCompiledFileAssets: {
  /**
   * @param compiledAssetsPath The file path.
   * @returns A function that receives the {@link CompiledContract} that `compiledAssetsPath` will be attached to.
   */
  <C extends Contract<PS>, PS, R>(
    compiledAssetsPath: R extends CompactContext.CompiledAssetsPath ? string : never
  ): (self: CompiledContract<C, PS, R>) => CompiledContract<C, PS, Exclude<R, CompactContext.CompiledAssetsPath>>;
  /**
   * @param self The {@link CompiledContract} that `compiledAssetsPath` will be attached to.
   * @param compiledAssetsPath The file path.
   */
  <C extends Contract<PS>, PS, R>(
    self: CompiledContract<C, PS, R>,
    compiledAssetsPath: R extends CompactContext.CompiledAssetsPath ? string : never
  ): CompiledContract<C, PS, Exclude<R, CompactContext.CompiledAssetsPath>>;
} = dual(
  2,
  <C extends Contract<PS>, PS, R>(
    self: CompiledContract<C, PS, R>,
    compiledAssetsPath: R extends CompactContext.CompiledAssetsPath ? string : never
  ) => {
    return {
      ...self,
      [CompactContextInternal.TypeId]: {
        ...self[CompactContextInternal.TypeId],
        compiledAssetsPath
      }
    };
  }
);

/**
 * Retrieves a path to file based assets associated with a compiled contract.
 *
 * @param self The {@link CompiledContract} from which the assets path should be retrieved.
 * @returns A string representing a path to the file assets configured for `self`.
 */
export const getCompiledAssetsPath: <C extends Contract<PS>, PS>(self: CompiledContract<C, PS>) => string =
  <C extends Contract<PS>, PS>(self: CompiledContract<C, PS>) => {
    const context = CompactContextInternal.getContractContext(self);
    return context.compiledAssetsPath;
  };

================
File: compact-js/compact-js/src/effect/Contract.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Provides types and utilities for working directly with Compact generated contract executables.
 *
 * @module
 */

/* eslint-disable @typescript-eslint/no-explicit-any */

import type {
  CircuitContext,
  CircuitResults,
  ConstructorContext,
  ConstructorResult,
  WitnessContext} from '@midnight-ntwrk/compact-runtime';
import { Brand } from 'effect';

export type Witness<PS, U = any> = (context: WitnessContext<U, PS>, ...args: any[]) => [PS, U];
export type Witnesses<PS> = Record<string, Witness<PS>>;

export type Circuit<PS, U = any> = (context: CircuitContext<PS>, ...args: any[]) => CircuitResults<PS, U>;
export type Circuits<PS> = Record<string, Circuit<PS>>;

export type ImpureCircuit<PS, U = any> = (context: CircuitContext<PS>, ...args: any[]) => CircuitResults<PS, U>;
export type ImpureCircuits<PS> = Record<string, ImpureCircuit<PS>>;

export type VerifierKey = Uint8Array & Brand.Brand<'VerifierKey'>;
export const VerifierKey = Brand.nominal<VerifierKey>();

export type ZKIR = Uint8Array & Brand.Brand<'ZKIR'>;
export const ZKIR = Brand.nominal<ZKIR>();

export type ImpureCircuitId<C extends Contract.Any = Contract.Any, K = Contract.ImpureCircuitId<C>> = K &
  Brand.Brand<'ImpureCircuitId'>;
const ImpureCircuitId_ = Brand.nominal<ImpureCircuitId>();
export const ImpureCircuitId = <C extends Contract.Any>(
  id: Brand.Brand.Unbranded<ImpureCircuitId<C>>
): ImpureCircuitId<C> => ImpureCircuitId_(id);

export interface Contract<PS, W extends Witnesses<PS> = Witnesses<PS>> {
  witnesses: W;

  circuits: Circuits<PS>;
  impureCircuits: ImpureCircuits<PS>;

  initialState(context: ConstructorContext<PS>, ...args: any[]): ConstructorResult<PS>;
}

export declare namespace Contract {
  export type Any = Contract<any>;

  export type PrivateState<C> = C extends Contract<infer PS>
    ? PS
    : never;

  // eslint-disable-next-line @typescript-eslint/no-shadow
  export type Witnesses<C> = C extends Contract<any, infer W>
    ? keyof W extends never
        ? never 
        : W
    : never;

  export type InitializeParameters<C extends Contract<any>> =
    Parameters<C['initialState']> extends [ConstructorContext<any>, ...infer A] ? A : never;

  export type ImpureCircuitId<C extends Contract<any>> = keyof C['impureCircuits'] & string;

  export type CircuitParameters<C extends Contract<any>, K extends ImpureCircuitId<C>> =
    Parameters<C['impureCircuits'][K]> extends [CircuitContext<any>, ...infer A] ? A : never;

  export type CircuitReturnType<C extends Contract<any>, K extends ImpureCircuitId<C>> =
    ReturnType<C['impureCircuits'][K]> extends CircuitResults<any, infer U> ? U : never;
}

export const getImpureCircuitIds: <C extends Contract.Any>(contract: C) => ImpureCircuitId<C>[] = (contract) =>
  Object.keys(contract.impureCircuits).map(ImpureCircuitId);

================
File: compact-js/compact-js/src/effect/ContractConfigurationError.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as Error from '@effect/platform/Error';
import { type ContractState } from '@midnight-ntwrk/compact-runtime';
import { hasProperty } from 'effect/Predicate';

const TypeId: unique symbol = Symbol.for('compact-js/effect/ContractConfigurationError');
type TypeId = typeof TypeId;

/**
 * An error occurred while executing a constructor, or a circuit, of an executable contract with regards to
 * its configuration.
 *
 * @category errors
 */
export class ContractConfigurationError extends Error.TypeIdError(TypeId, 'ContractConfigurationError')<{
  /** A displayable message. */
  readonly message: string;
  /** Indicates a more specific cause of the error. */
  readonly cause?: unknown;
  /** The current state of the contract. */
  readonly contractState?: ContractState | undefined;
}> { }

/**
 * Determines if a value is a contract configuration error.
 *
 * @param u The value to check.
 * @returns `true` if `u` is a {@link ContractConfigurationError}; `false` otherwise.
 *
 * @category guards
 */
export const isConfigurationError = (u: unknown): u is ContractConfigurationError => hasProperty(u, TypeId);

/**
 * Creates a new {@link ContractConfigurationError}.
 *
 * @category constructors
 */
export const make: {
  (message: string): ContractConfigurationError;
  (message: string, contractState: ContractState | undefined): ContractConfigurationError;
  (message: string, contractState: ContractState | undefined, cause: unknown): ContractConfigurationError;
} = (message: string, contractState?: ContractState, cause?: unknown) =>
  new ContractConfigurationError({ message, contractState, cause });

================
File: compact-js/compact-js/src/effect/ContractExecutable.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  type AlignedValue,
  CompactError,
  ContractMaintenanceAuthority,
  type ContractState,
  createCircuitContext,
  createConstructorContext,
  decodeZswapLocalState,
  emptyZswapLocalState,
  encodeZswapLocalState,
  type Op,
  type QueryContext,
  sampleSigningKey,
  signatureVerifyingKey,
  type StateValue,
  type ZswapLocalState
} from '@midnight-ntwrk/compact-runtime';
import {
  ChargedState as LedgerChargedState,
  ContractMaintenanceAuthority as LedgerContractMaintenanceAuthority,
  ContractOperationVersion,
  ContractOperationVersionedVerifierKey,
  LedgerParameters,
  MaintenanceUpdate,
  partitionTranscripts,
  PreTranscript,
  QueryContext as LedgerQueryContext,
  ReplaceAuthority,
  signData,
  type SingleUpdate,
  StateValue as LedgerStateValue,
  type Transcript,
  VerifierKeyInsert,
  VerifierKeyRemove} from '@midnight-ntwrk/ledger';
import * as CoinPublicKey from '@midnight-ntwrk/platform-js/effect/CoinPublicKey';
import * as Configuration from '@midnight-ntwrk/platform-js/effect/Configuration';
import type * as ContractAddress from '@midnight-ntwrk/platform-js/effect/ContractAddress';
import * as SigningKey from '@midnight-ntwrk/platform-js/effect/SigningKey';
import { Effect, Either,type Layer, Option } from 'effect';
import { dual, identity } from 'effect/Function';
import { type Pipeable, pipeArguments } from 'effect/Pipeable';

import { type CompiledContract } from './CompiledContract.js';
import * as Contract from './Contract.js';
import * as ContractConfigurationError from './ContractConfigurationError.js';
import * as ContractRuntimeError from './ContractRuntimeError.js';
import * as CompactContextInternal from './internal/compactContext.js';
import { ZKConfiguration } from './ZKConfiguration.js';
import { type ZKConfigurationReadError } from './ZKConfigurationReadError.js';

/**
 * An executable form of a Compact compiled contract.
 */
export interface ContractExecutable<in out C extends Contract.Contract<PS>, PS, out E = never, out R = never>
  extends Pipeable {
  readonly compiledContract: CompiledContract<C, PS>;

  /**
   * Creates and initializes a new instance of the contract.
   *
   * @param initialPrivateState The initial private state to apply when initializing the new contract instance.
   * @param args The arguments to supply the contract constructor.
   * @returns A {@link ContractExecutable.DeployResult} describing the result of initializing a new contract
   * instance.
   */
  initialize(
    initialPrivateState: PS,
    ...args: Contract.Contract.InitializeParameters<C>
  ): Effect.Effect<ContractExecutable.DeployResult<PS>, E, R>;

  /**
   * Invokes a circuit on deployed instance of the contract.
   *
   * @param impureCircuitId The circuit to be invoked.
   * @param circuitContext Execution context for `impureCircuitId` including its current onchain and private
   * states.
   * @param args The arguments to supply the circuit.
   * @returns A {@link ContractExecutable.CallResult} describing the result of invoking `impureCircuitId`.
   */
  circuit<K extends Contract.ImpureCircuitId<C> = Contract.ImpureCircuitId<C>>(
    impureCircuitId: K,
    circuitContext: ContractExecutable.CircuitContext<PS>,
    ...args: Contract.Contract.CircuitParameters<C, K>
  ): Effect.Effect<ContractExecutable.CallResult<C, PS, K>, E, R>;

  /**
   * Applies a new Contract Maintenance Authority (CMA) to a deployed instance of the contract.
   *
   * @param newSigningKey The signing key that will replace the current that is associated with the
   * deployed contract. If `Option.none` then a new singing key is sampled and used instead.
   * @param contractContext Execution context for the maintenance operation.
   * @returns A {@link ContractExecutable.MaintenanceResult} describing the result of the maintenance update.
   *
   * @remarks
   * The current signing key will be taken from the {@link Configuration.Keys} that is part of the executable
   * context, and used to sign the maintenance operation.
   */
  replaceContractMaintenanceAuthority(
    newSigningKey: Option.Option<SigningKey.SigningKey>,
    contractContext: ContractExecutable.ContractContext
  ): Effect.Effect<ContractExecutable.MaintenanceResult, E, R>;

  /**
   * Removes the current verifier key for an operation on a deployed instance of the contract.
   *
   * @param impureCircuitId The circuit to be removed from the deployed contract.
   * @param contractContext Execution context for the maintenance operation.
   * @returns A {@link ContractExecutable.MaintenanceResult} describing the result of the maintenance update.
   */
  removeContractOperation<K extends Contract.ImpureCircuitId<C> = Contract.ImpureCircuitId<C>>(
    impureCircuitId: K,
    contractContext: ContractExecutable.ContractContext
  ): Effect.Effect<ContractExecutable.MaintenanceResult, E, R>;

  /**
   * Adds or replaces a verifier key associated with a circuit on a deployed contract.
   *
   * @param impureCircuitId The circuit to add or replace on the deployed contract.
   * @param verifierKey The verifier key to apply to `impureCircuitId`.
   * @param contractContext Execution context for the maintenance operation.
   * @returns A {@link ContractExecutable.MaintenanceResult} describing the result of the maintenance update.
   */
  addOrReplaceContractOperation<K extends Contract.ImpureCircuitId<C> = Contract.ImpureCircuitId<C>>(
    impureCircuitId: K,
    verifierKey: Contract.VerifierKey,
    contractContext: ContractExecutable.ContractContext
  ): Effect.Effect<ContractExecutable.MaintenanceResult, E, R>;
}

export declare namespace ContractExecutable {
  /**
   * The services required as context for executing contracts.
   */
  export type Context = ZKConfiguration | Configuration.Keys | Configuration.Network;

  export type ContractContext = {
    readonly address: ContractAddress.ContractAddress;
    readonly contractState: ContractState;
  };

  export type CircuitContext<PS> = ContractContext & {
    readonly privateState: PS;
    readonly zswapLocalState?: ZswapLocalState;
  }

  export type DeployResultPublic = {
    readonly contractState: ContractState;
  };
  export type DeployResultPrivate<PS> = {
    readonly signingKey: SigningKey.SigningKey;
    readonly privateState: PS;
    readonly zswapLocalState: ZswapLocalState;
  };
  export type DeployResult<PS> = {
    readonly public: DeployResultPublic;
    readonly private: DeployResultPrivate<PS>;
  };

  export type PartitionedTranscript = [Transcript<AlignedValue> | undefined, Transcript<AlignedValue> | undefined];
  export type CallResultPublic = {
    readonly contractState: StateValue;
    readonly publicTranscript: Op<AlignedValue>[];
    readonly partitionedTranscript: PartitionedTranscript;
  };
  export type CallResultPrivate<C extends Contract.Contract<PS>, PS, K extends Contract.ImpureCircuitId<C>> = {
    readonly input: AlignedValue;
    readonly output: AlignedValue;
    readonly privateTranscriptOutputs: AlignedValue[];
    readonly result: Contract.Contract.CircuitReturnType<C, K>;
    readonly privateState: PS;
    readonly zswapLocalState: ZswapLocalState;
  };
  export type CallResult<C extends Contract.Contract<PS>, PS, K extends Contract.ImpureCircuitId<C>> = {
    readonly public: CallResultPublic;
    readonly private: CallResultPrivate<C, PS, K>;
  };

  export type MaintenanceResultPublic = {
    readonly maintenanceUpdate: MaintenanceUpdate;
  }
  export type MaintenanceResultPrivate = {
    readonly signingKey: SigningKey.SigningKey;
  }
  export type MaintenanceResult = {
    readonly public: MaintenanceResultPublic;
    readonly private: MaintenanceResultPrivate;
  }
}

/**
 * An error occurred while executing a constructor, or a circuit, of an executable contract.
 *`
 * @category errors
 */
export type ContractExecutionError =
  | ContractRuntimeError.ContractRuntimeError
  | ContractConfigurationError.ContractConfigurationError
  | ZKConfigurationReadError;

// A function that receives an `Effect`, and captures it within another `Effect` that is bound to some
// specified error and context type.
type Transform<E, R> = <A>(effect: Effect.Effect<A, any, any>) => Effect.Effect<A, E, R>; // eslint-disable-line @typescript-eslint/no-explicit-any

const DEFAULT_CMA_THRESHOLD = 1;
const DEFAULT_SIGNATURE_INDEX = 0n;

const asLedgerQueryContext = (queryContext: QueryContext): LedgerQueryContext => {
  const stateValue = LedgerStateValue.decode(queryContext.state.state.encode());
  const ledgerQueryContext = new LedgerQueryContext(new LedgerChargedState(stateValue), queryContext.address);
  // The above method of converting to ledger query context only retains the state. So, we have to set the settable properties manually
  ledgerQueryContext.block = queryContext.block;
  ledgerQueryContext.effects = queryContext.effects;
  return ledgerQueryContext;
}

const partitionTranscript = (
  txContext: QueryContext,
  finalTxContext: QueryContext,
  publicTranscript: Op<AlignedValue>[]
): Either.Either<ContractExecutable.PartitionedTranscript, Error> => {
  const partitionedTranscripts = partitionTranscripts(
    [
      new PreTranscript(
        Array.from(finalTxContext.comIndices).reduce(
          (queryContext, entry) => queryContext.insertCommitment(...entry),
          asLedgerQueryContext(txContext)
        ),
        publicTranscript
      )
    ],
    LedgerParameters.initialParameters()
  );
  return partitionedTranscripts.length === 1
    ? Either.right(partitionedTranscripts[0])
    : Either.left(new Error(`Expected one transcript partition pair, received: ${partitionedTranscripts.length}`));
};

class ContractExecutableImpl<C extends Contract.Contract<PS>, PS, E, R> implements ContractExecutable<C, PS, E, R> {
  compiledContract: CompiledContract<C, PS>;
  transform: Transform<E, R>;

  constructor(compiledContract: CompiledContract<C, PS, never>, transform: Transform<E, R> = identity) {
    this.compiledContract = compiledContract;
    this.transform = transform;
  }

  pipe() {
    return pipeArguments(this, arguments); // eslint-disable-line prefer-rest-params
  }

  initialize(
    initialPrivateState: PS,
    ...args: Contract.Contract.InitializeParameters<C>
  ): Effect.Effect<ContractExecutable.DeployResult<PS>, E, R> {
    return Effect.all({
      zkConfigReader: ZKConfiguration.pipe(
        Effect.andThen((zkConfig) => zkConfig.createReader<C, PS>(this.compiledContract))
      ),
      keyConfig: Configuration.Keys,
      contract: this.createContract()
    }).pipe(
      Effect.flatMap(({ zkConfigReader, keyConfig, contract }) =>
        Effect.try({
          try: () => {
            const { currentContractState, currentPrivateState, currentZswapLocalState } = contract.initialState(
              createConstructorContext(initialPrivateState, CoinPublicKey.asHex(keyConfig.coinPublicKey)),
              ...args
            );
            return {
              contractState: currentContractState,
              privateState: currentPrivateState,
              zswapLocalState: decodeZswapLocalState(currentZswapLocalState)
            };
          },
          catch: (err: unknown) =>
            err instanceof CompactError
              ? ContractRuntimeError.make('Failed to initialize contract', err)
              : ContractConfigurationError.make(
                  'Failed to configure constructor context with coin public key', undefined, err)
        }).pipe(
          Effect.flatMap(({ contractState, privateState, zswapLocalState }) =>
            Effect.gen(this, function* () {
              // Add the verifier keys.
              const verifierKeys = yield* zkConfigReader.getVerifierKeys(Contract.getImpureCircuitIds(contract));

              for (const [impureCircuitId, verifierKey] of verifierKeys) {
                const operation = contractState.operation(impureCircuitId);

                if (!operation) {
                  return yield* ContractConfigurationError.make(
                    `Circuit '${impureCircuitId}' is undefined for the given contract state`,
                    contractState
                  );
                }

                try {
                  operation.verifierKey = verifierKey;
                  contractState.setOperation(impureCircuitId, operation);
                } catch (err: unknown) {
                  return yield* ContractConfigurationError.make(
                    `Failed to configure verifier key for circuit '${impureCircuitId}' for the given contract state`,
                    contractState,
                    err
                  );
                }
              }

              const [cma, signingKey] = yield* this.createMaintenanceAuthority(keyConfig.getSigningKey());
              contractState.maintenanceAuthority = cma;

              return {
                public: {
                  contractState
                },
                private: {
                  signingKey,
                  privateState,
                  zswapLocalState
                }
              };
            })
          )
        )
      ),
      this.transform
    );
  }

  circuit<K extends Contract.ImpureCircuitId<C> = Contract.ImpureCircuitId<C>>(
    impureCircuitId: K,
    circuitContext: ContractExecutable.CircuitContext<PS>,
    ...args: Contract.Contract.CircuitParameters<C, K>
  ): Effect.Effect<ContractExecutable.CallResult<C, PS, K>, E, R> {
    return Effect.all({
      keyConfig: Configuration.Keys,
      contract: this.createContract()
    }).pipe(
      Effect.flatMap(({ keyConfig, contract }) =>
        Effect.try({
          try: () => {
            const circuit = contract.impureCircuits[impureCircuitId] as Contract.ImpureCircuit<
              PS,
              Contract.Contract.CircuitReturnType<C, K>
            >;
            if (!circuit) {
              throw new Error(`Circuit ${this.compiledContract.tag}#${impureCircuitId} could not be found.`);
            }
            const zswapLocalState = circuitContext.zswapLocalState
                ? encodeZswapLocalState(circuitContext.zswapLocalState)
                : emptyZswapLocalState(CoinPublicKey.asHex(keyConfig.coinPublicKey))
            const runtimeContext = createCircuitContext(circuitContext.address, zswapLocalState, circuitContext.contractState, circuitContext.privateState)
            const initialTxContext = runtimeContext.currentQueryContext
            return {
              ...circuit(runtimeContext, ...args),
              initialTxContext
            };
          },
          catch: identity
        }).pipe(
          Effect.flatMap(({ initialTxContext, result, context, proofData }) =>
            Effect.gen(function* () {
              return {
                public: {
                  contractState: context.currentQueryContext.state.state,
                  publicTranscript: proofData.publicTranscript,
                  partitionedTranscript: yield* partitionTranscript(
                    initialTxContext,
                    context.currentQueryContext,
                    proofData.publicTranscript
                  )
                },
                private: {
                  result,
                  input: proofData.input,
                  output: proofData.output,
                  privateTranscriptOutputs: proofData.privateTranscriptOutputs,
                  privateState: context.currentPrivateState,
                  zswapLocalState: decodeZswapLocalState(context.currentZswapLocalState)
                }
              };
            })
          ),
          Effect.mapError((err) => ContractRuntimeError.make(`Error executing circuit '${impureCircuitId}'`, err))
        )
      ),
      this.transform
    );
  }

  replaceContractMaintenanceAuthority(
    this: ContractExecutableImpl<C, PS, E, R>,
    newSigningKey: Option.Option<SigningKey.SigningKey>,
    contractContext: ContractExecutable.ContractContext
  ): Effect.Effect<ContractExecutable.MaintenanceResult, E, R> {
    return Effect.all({
      keyConfig: Configuration.Keys
    }).pipe(
      Effect.flatMap(({ keyConfig  }) => Effect.gen(this, function* () {
        const { contractState } = contractContext;
        const [cma, signingKey] = yield* this.createMaintenanceAuthority(newSigningKey, contractState);
        const ledger_cma = LedgerContractMaintenanceAuthority.deserialize(cma.serialize()) as unknown as LedgerContractMaintenanceAuthority;
        const update = yield* this.createSignedMaintenanceUpdate(
          () => {
            return Either.right([
              new ReplaceAuthority(ledger_cma)
            ]);
          },
          keyConfig,
          contractContext
        );
        return {
          ...update,
          private: {
            ...update.private,
            signingKey // We need to include the new signing key in the result (rather than the current).
          }
        }
      })),
      this.transform
    );
  }

  removeContractOperation<K extends Contract.ImpureCircuitId<C> = Contract.ImpureCircuitId<C>>(
    this: ContractExecutableImpl<C, PS, E, R>,
    impureCircuitId: K,
    contractContext: ContractExecutable.ContractContext
  ): Effect.Effect<ContractExecutable.MaintenanceResult, E, R> {
    return Effect.all({
      keyConfig: Configuration.Keys
    }).pipe(
      Effect.flatMap(({ keyConfig  }) => Effect.gen(this, function* () {
        return yield* this.createSignedMaintenanceUpdate(
          () => {
            return Either.right([
              new VerifierKeyRemove(impureCircuitId, new ContractOperationVersion('v2'))
            ]);
          },
          keyConfig,
          contractContext
        );
      })),
      this.transform
    );
  }

  addOrReplaceContractOperation<K extends Contract.ImpureCircuitId<C> = Contract.ImpureCircuitId<C>>(
    impureCircuitId: K,
    verifierKey: Contract.VerifierKey,
    contractContext: ContractExecutable.ContractContext
  ): Effect.Effect<ContractExecutable.MaintenanceResult, E, R> {
    return Effect.all({
      keyConfig: Configuration.Keys
    }).pipe(
      Effect.flatMap(({ keyConfig  }) => Effect.gen(this, function* () {
        return yield* this.createSignedMaintenanceUpdate(
          () => {
            return Either.right([
              new VerifierKeyInsert(impureCircuitId, new ContractOperationVersionedVerifierKey('v2', verifierKey))
            ]);
          },
          keyConfig,
          contractContext
        );
      })),
      this.transform
    );
  }

  protected createSignedMaintenanceUpdate(
    createUpdateFn: () => Either.Either<SingleUpdate[], ContractConfigurationError.ContractConfigurationError>,
    keyConfig: Configuration.Configuration.Keys,
    contractContext: ContractExecutable.ContractContext
  ): Either.Either<ContractExecutable.MaintenanceResult, ContractConfigurationError.ContractConfigurationError> {
    const { address, contractState } = contractContext;
    const currentSigningKey = keyConfig.getSigningKey();
    if (Option.isNone(currentSigningKey)) {
      return Either.left(ContractConfigurationError.make(
        'Signing key required to authorize contract maintenance update',
        contractState
      ));
    }
    const update = createUpdateFn();
    if (Either.isLeft(update)) return Either.left(update.left);
    const maintenanceUpdate = new MaintenanceUpdate(
      address,
      Either.getOrThrow(update),
      contractState.maintenanceAuthority.counter
    );
    return Either.right({
      public: {
        maintenanceUpdate: maintenanceUpdate.addSignature(
          DEFAULT_SIGNATURE_INDEX,
          signData(Option.getOrThrow(currentSigningKey), maintenanceUpdate.dataToSign)
        )
      },
      private: {
        signingKey: Option.getOrThrow(currentSigningKey)
      }
    });
  }

  protected createMaintenanceAuthority(
    key: Option.Option<SigningKey.SigningKey>,
    contractState?: ContractState
  ): Either.Either<[ContractMaintenanceAuthority, SigningKey.SigningKey], ContractConfigurationError.ContractConfigurationError> {
    const signingKey = Option.match(key, {
      onSome: identity,
      onNone: () => SigningKey.SigningKey(sampleSigningKey())
    });
    try {
      return Either.right([
        new ContractMaintenanceAuthority(
          [signatureVerifyingKey(signingKey)],
          DEFAULT_CMA_THRESHOLD,
          contractState ? contractState.maintenanceAuthority.counter + 1n : 0n
        ),
        signingKey
      ]);
    } catch (err: unknown) {
      return Either.left(ContractConfigurationError.make(
        `Failed to create a signature verifying key for signing key '${signingKey}'`,
        contractState,
        err
      ));
    }
  }

  protected createContract(): Effect.Effect<C, ContractRuntimeError.ContractRuntimeError> {
    return (this.contract ??= CompactContextInternal.createContract(this.compiledContract).pipe(
      Effect.mapError((err: unknown) => ContractRuntimeError.make(String(err), err)),
      Effect.cached,
      Effect.runSync
    ));
  }
  private contract?: Effect.Effect<C, ContractRuntimeError.ContractRuntimeError>; // Backing property for `createContract`.
}

/**
 * Takes a Compact compiled contract, and makes it executable.
 *
 * @param compiledContract A {@link CompiledContract}
 * @returns A {@link ContractExecutable} for `compiledContract`.
 *
 * @category constructors
 */
export const make: <C extends Contract.Contract<PS>, PS>(
  compiledContract: CompiledContract<C, PS, never>
) => ContractExecutable<C, PS, ContractExecutionError, ContractExecutable.Context> = <
  C extends Contract.Contract<PS>,
  PS
>(
  compiledContract: CompiledContract<C, PS, never>
) => new ContractExecutableImpl<C, PS, ContractExecutionError, ContractExecutable.Context>(compiledContract);

/**
 * Provides a layer to the executable contract.
 *
 * @category combinators
 */
export const provide: {
  /**
   * @param layer The layer to provide.
   * @returns A function that receives the {@link ContractExecutable} that `layer` should be provided to.
   */
  <LA, LE, LR>(
    layer: Layer.Layer<LA, LE, LR>
  ): <C extends Contract.Contract<PS>, PS, E, R>(
    self: ContractExecutable<C, PS, E, R>
  ) => ContractExecutable<C, PS, E | LE, LR | Exclude<R, LA>>;
  /**
   * @param self The {@link ContractExecutable} that `layer` should be provided with.
   * @param layer The layer to provide.
   */
  <C extends Contract.Contract<PS>, PS, E, R, LA, LE, LR>(
    self: ContractExecutable<C, PS, E, R>,
    layer: Layer.Layer<LA, LE, LR>
  ): ContractExecutable<C, PS, E | LE, LR | Exclude<R, LA>>;
} = dual(
  2,
  <C extends Contract.Contract<PS>, PS, E, R, LA, LE, LR>(
    self: ContractExecutable<C, PS, E, R>,
    layer: Layer.Layer<LA, LE, LR>
  ) =>
    new ContractExecutableImpl<C, PS, E | LE, LR | Exclude<R, LA>>(self.compiledContract, (e) =>
      Effect.provide(e, layer)
    )
);

================
File: compact-js/compact-js/src/effect/ContractExecutableRuntime.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type Layer, ManagedRuntime } from 'effect';

import { type ContractExecutable } from './ContractExecutable.js';

export const make = <E>(layer: Layer.Layer<ContractExecutable.Context, E>) => ManagedRuntime.make(layer)

================
File: compact-js/compact-js/src/effect/ContractRuntimeError.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as Error from '@effect/platform/Error';
import { hasProperty } from 'effect/Predicate';

const TypeId: unique symbol = Symbol.for('compact-js/effect/ContractRuntimeError');
type TypeId = typeof TypeId;

/**
 * A runtime error occurred while executing a constructor, or a circuit, of an executable contract.
 *
 * @category errors
 */
export class ContractRuntimeError extends Error.TypeIdError(TypeId, 'ContractRuntimeError')<{
  /** A displayable message. */
  readonly message: string;
  /** Indicates a more specific cause of the error. */
  readonly cause?: unknown;
}> { }

/**
 * Determines if a value is a contract runtime error.
 *
 * @param u The value to check.
 * @returns `true` if `u` is a {@link ContractRuntimeError}; `false` otherwise.
 *
 * @category guards
 */
export const isRuntimeError = (u: unknown): u is ContractRuntimeError => hasProperty(u, TypeId);

/**
 * Creates a new {@link ContractRuntimeError}.
 *
 * @category constructors
 */
export const make: (message: string, cause?: unknown) => ContractRuntimeError = (message, cause) =>
  new ContractRuntimeError({ message, cause });

================
File: compact-js/compact-js/src/effect/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * as CompactContext from './CompactContext.js';
export * as CompiledContract from './CompiledContract.js';
export * as Contract from './Contract.js';
export * as ContractConfigurationError from './ContractConfigurationError.js';
export * as ContractExecutable from './ContractExecutable.js';
export * as ContractExecutableRuntime from './ContractExecutableRuntime.js';
export * as ContractRuntimeError from './ContractRuntimeError.js';
export * as ZKConfiguration from './ZKConfiguration.js';
export * as ZKConfigurationReadError from './ZKConfigurationReadError.js';

================
File: compact-js/compact-js/src/effect/ZKConfiguration.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Context, type Effect } from 'effect';

import type { CompiledContract } from './CompiledContract.js';
import type * as Contract from './Contract.js';
import type * as ZKConfigurationError from './ZKConfigurationReadError.js';

/**
 * Provides utilities for working with the ZK assets of a compiled Compact contract.
 *
 * @category services
 */
export class ZKConfiguration extends Context.Tag('compact-js/ZKConfiguration')<
  ZKConfiguration,
  ZKConfiguration.Service
>() {}

export declare namespace ZKConfiguration {
  /**
   * Provides utilities for working with the ZK assets of a compiled Compact contract.
   */
  export interface Service {
    /**
     * Creates a ZK asset reader for a given compiled Compact contract.
     *
     * @param compiledContract The Compact compiled contract.
     * @returns An `Effect` that yields a {@link Reader}.
     */
    readonly createReader: <C extends Contract.Contract<PS>, PS>(
      compiledContract: CompiledContract<C, PS, never>
    ) => Effect.Effect<ZKConfiguration.Reader<C, PS>>;
  }

  /**
   * Reads ZK assets.
   */
  export interface Reader<C extends Contract.Contract<PS>, PS> {
    /**
     * Reads a verifier key for a given circuit identifier.
     *
     * @param impureCircuitId The identifier of the circuit to be read.
     * @returns An `Effect` that yields a {@link Contract.VerifierKey | VerifierKey} for `impureCircuitId`; or
     * fails with a {@link ZKConfigurationError.ZKConfigurationReadError | ZKConfigurationReadError}.
     */
    getVerifierKey(
      impureCircuitId: Contract.ImpureCircuitId<C>
    ): Effect.Effect<Contract.VerifierKey, ZKConfigurationError.ZKConfigurationReadError>;

    /**
     * Batch reads the verifier keys for an array of circuit identifiers.
     *
     * @param impureCircuitIds The identifiers of the circuits to be read.
     * @returns An `Effect` that yields an array of tuples describing a {@link Contract.VerifierKey | VerifierKey}
     * and its associated circuit identifier; or fails with a 
     * {@link ZKConfigurationError.ZKConfigurationReadError | ZKConfigurationReadError}.
     */
    getVerifierKeys(
      impureCircuitIds: Contract.ImpureCircuitId<C>[]
    ): Effect.Effect<
      readonly [Contract.ImpureCircuitId<C>, Contract.VerifierKey][],
      ZKConfigurationError.ZKConfigurationReadError
      >;
  }
}

================
File: compact-js/compact-js/src/effect/ZKConfigurationReadError.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as Error from '@effect/platform/Error';
import { hasProperty } from 'effect/Predicate';

import type * as Contract from './Contract.js';

const TypeId: unique symbol = Symbol.for('compact-js/effect/ZKConfigurationReadError');
type TypeId = typeof TypeId;

/**
 * Describes a type of ZK asset.
 */
export type AssetType = 'verifier-key' | 'ZKIR' | 'prover-key';

/**
 * Error indicating a failure to read a ZK asset.
 *
 * @category errors
 */
export class ZKConfigurationReadError extends Error.TypeIdError(TypeId, 'ZKConfigurationReadError')<{
  /** A displayable message. */
  readonly message: string;

  /** The underlying cause of the failed read operation. */
  readonly cause?: unknown;

  /** The tag of the compiled contract being read. */
  readonly contractTag: string;

  /** The circuit of the compiled contract being read. */
  readonly impureCircuitId: Contract.ImpureCircuitId;

  /** The type of asset that was being read. */
  readonly assetType: AssetType;
}> { }

/**
 * Determines if a value is a ZK configuration read error.
 *
 * @param u The value to check.
 * @returns `true` if `u` is a {@link ZKConfigurationReadError}; `false` otherwise.
 *
 * @category guards
 */
export const isReadError = (u: unknown): u is ZKConfigurationReadError => hasProperty(u, TypeId);

/**
 * Creates a new {@link ZKConfigurationReadError}.
 *
 * @category constructors
 */
export const  make: <C extends Contract.Contract.Any>(
  contractTag: string,
  impureCircuitId: Contract.ImpureCircuitId<C>,
  assetType: AssetType,
  cause?: unknown
) => ZKConfigurationReadError = (contractTag, impureCircuitId, assetType, cause?: unknown) =>
  new ZKConfigurationReadError({
    contractTag,
    impureCircuitId,
    assetType,
    message: `Failed to read ${assetType.replaceAll('-', ' ')} for ${contractTag}#${impureCircuitId}`,
    cause
  });

================
File: compact-js/compact-js/src/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * from './effect/index.js';

================
File: compact-js/compact-js/test/contract/counter.compact
================
import CompactStandardLibrary;

export ledger round: Counter;

witness private_increment(): [];

export circuit increment(): [] {
  round.increment(1);
  private_increment();
}

export circuit decrement(amount: Uint<16>): [] {
  round.decrement(disclose(amount));
  private_increment();
}

export circuit reset(): [] {
  round.resetToDefault();
  private_increment();
}

================
File: compact-js/compact-js/test/contract/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Contract as _CounterContract } from './managed/counter/contract';
import { Contract as _UnshieldedContract } from './managed/unshielded/contract';

type CounterPrivateState = {
  count: number;
};

export type CounterContract = _CounterContract<CounterPrivateState>;
export const CounterContract = _CounterContract;

export type UnshieldedContract = _UnshieldedContract<undefined>;
export const UnshieldedContract = _UnshieldedContract;

================
File: compact-js/compact-js/test/contract/unshielded.compact
================
import CompactStandardLibrary;

export circuit mintUnshieldedToSelfTest(domainSep: Bytes<32>, amount: Uint<64>): Bytes<32> {
  return mintUnshieldedToken(disclose(domainSep), disclose(amount), left<ContractAddress, UserAddress>(kernel.self()));
}

export circuit mintUnshieldedToContractTest(domainSep: Bytes<32>, address: ContractAddress, amount: Uint<64>): Bytes<32> {
  return mintUnshieldedToken(disclose(domainSep), disclose(amount), left<ContractAddress, UserAddress>(disclose(address)));
}

export circuit mintUnshieldedToUserTest(domainSep: Bytes<32>, address: UserAddress, amount: Uint<64>): Bytes<32> {
  return mintUnshieldedToken(disclose(domainSep), disclose(amount), right<ContractAddress, UserAddress>(disclose(address)));
}

export circuit sendUnshieldedToSelfTest(color: Bytes<32>, amount: Uint<128>): [] {
  sendUnshielded(disclose(color), disclose(amount), left<ContractAddress, UserAddress>(kernel.self()));
}

export circuit sendUnshieldedToContractTest(color: Bytes<32>, amount: Uint<128>, address: ContractAddress): [] {
  sendUnshielded(disclose(color), disclose(amount), left<ContractAddress, UserAddress>(disclose(address)));
}

export circuit sendUnshieldedToUserTest(color: Bytes<32>, amount: Uint<128>, address: UserAddress): [] {
  sendUnshielded(disclose(color), disclose(amount), right<ContractAddress, UserAddress>(disclose(address)));
}

export circuit receiveUnshieldedTest(color: Bytes<32>, amount: Uint<128>): [] {
  receiveUnshielded(disclose(color), disclose(amount));
}

================
File: compact-js/compact-js/test/effect/Arbitrary.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as ContractAddress from '@midnight-ntwrk/platform-js/effect/ContractAddress';
import * as DomainSeparator from '@midnight-ntwrk/platform-js/effect/DomainSeparator';
import * as fc from 'effect/FastCheck';

export const makeDomainSeparatorArbitrary: () => fc.Arbitrary<DomainSeparator.DomainSeparator> =
  () => fc.stringMatching(/^[0-9a-f]{64}$/).map(DomainSeparator.DomainSeparator);

export const makeContractAddressArbitrary: () => fc.Arbitrary<ContractAddress.ContractAddress> =
  () => fc.stringMatching(/^[0-9a-f]{64}$/).map(ContractAddress.ContractAddress);

export const getSampleDomainSeparator: () => DomainSeparator.DomainSeparator =
  (() => {
    const arbitrary = makeDomainSeparatorArbitrary();
    return () => fc.sample(arbitrary, 1)[0];
  })();

export const getSampleContractAddress: () => ContractAddress.ContractAddress =
  (() => {
    const arbitrary = makeContractAddressArbitrary();
    return () => fc.sample(arbitrary, 1)[0];
  })();

================
File: compact-js/compact-js/test/effect/ContractExecutable.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { resolve } from 'node:path';

import { NodeContext } from '@effect/platform-node';
import { beforeEach,describe, expect, it } from '@effect/vitest';
import {
  CompiledContract,
  Contract,
  ContractExecutable} from '@midnight-ntwrk/compact-js/effect';
import * as ContractConfigurationError from '@midnight-ntwrk/compact-js/effect/ContractConfigurationError';
import { ZKFileConfiguration } from '@midnight-ntwrk/compact-js-node/effect';
import { ContractState, sampleSigningKey } from '@midnight-ntwrk/compact-runtime';
import {
  ContractDeploy,
  ContractState as LedgerContractState,
  type ReplaceAuthority,
  type VerifierKeyInsert,
  type VerifierKeyRemove
} from '@midnight-ntwrk/ledger';
import * as Configuration from '@midnight-ntwrk/platform-js/effect/Configuration';
import * as ContractAddress from '@midnight-ntwrk/platform-js/effect/ContractAddress';
import { ConfigProvider, Effect, Layer, Option } from 'effect';

import { CounterContract } from '../contract';

const COUNTER_ASSETS_PATH = resolve(import.meta.dirname, '../contract/managed/counter');

const VALID_COIN_PUBLIC_KEY = 'd2dc8d175c0ef7d1f7e5b7f32bd9da5fcd4c60fa1b651f1d312986269c2d3c79';
const INVALID_COIN_PUBLIC_KEY = 'INVALIDd9da5fcd4c601';
const VALID_SIGNING_KEY = sampleSigningKey();

const asLedgerContractState = (contractState: ContractState): LedgerContractState =>
  LedgerContractState.deserialize(contractState.serialize());

const asContractState = (contractState: LedgerContractState): ContractState =>
  ContractState.deserialize(contractState.serialize());

const testLayer = (configMap: Map<string, string>) =>
  Layer.mergeAll(ZKFileConfiguration.layer(COUNTER_ASSETS_PATH), Configuration.layer).pipe(
    Layer.provideMerge(NodeContext.layer),
    Layer.provide(
      Layer.setConfigProvider(ConfigProvider.fromMap(configMap, { pathDelim: '_' }).pipe(ConfigProvider.constantCase))
    )
  );

describe('ContractExecutable', () => {
  const initialPS = { count: 0 };
  const counterContract = CompiledContract.make<CounterContract>('Counter', CounterContract).pipe(
    CompiledContract.withWitnesses({
      private_increment: ({ privateState }) => [{ count: privateState.count + 1 }, []]
    }),
    CompiledContract.withCompiledFileAssets(COUNTER_ASSETS_PATH),
    ContractExecutable.make
  );

  describe('initialize', () => {
    it.effect('should initialize a new instance', () =>
      Effect.gen(function* () {
        const contract = counterContract.pipe(
          ContractExecutable.provide(testLayer(new Map([['KEYS_COIN_PUBLIC', VALID_COIN_PUBLIC_KEY]])))
        );
        const result = yield* contract.initialize(initialPS);

        expect(result.public.contractState).toBeDefined();
        expect(result.public.contractState.data).toBeDefined();
        expect(result.private.signingKey).toBeDefined();
        expect(result.private.privateState).toMatchObject(initialPS);
      })
    );

    it.effect('should return the given signing key', () =>
      Effect.gen(function* () {
        const contract = counterContract.pipe(
          ContractExecutable.provide(
            testLayer(
              new Map([
                ['KEYS_COIN_PUBLIC', VALID_COIN_PUBLIC_KEY],
                ['KEYS_SIGNING', VALID_SIGNING_KEY]
              ])
            )
          )
        );
        const result = yield* contract.initialize(initialPS);

        expect(result.public.contractState).toBeDefined();
        expect(result.private.signingKey).toBe(VALID_SIGNING_KEY);
      })
    );

    it.effect('should fail with an invalid CoinPublicKey', () =>
      Effect.gen(function* () {
        const contract = counterContract.pipe(
          ContractExecutable.provide(testLayer(new Map([['KEYS_COIN_PUBLIC', INVALID_COIN_PUBLIC_KEY]])))
        );
        const error = yield* contract.initialize({ count: 0 }).pipe(Effect.flip);

        expect(error).toBeInstanceOf(ContractConfigurationError.ContractConfigurationError);
      })
    );
  });

  describe('circuits', () => {
    let contract: ContractExecutable.ContractExecutable<
      CounterContract,
      Contract.Contract.PrivateState<CounterContract>,
      unknown
    >;
    let deployment: ContractDeploy;

    // Create and initialize a new contract instance for each test.
    beforeEach(async () => {
      contract = counterContract.pipe(
        ContractExecutable.provide(testLayer(new Map([['KEYS_COIN_PUBLIC', VALID_COIN_PUBLIC_KEY]])))
      );
      const result = await contract.initialize({ count: 0 }).pipe(Effect.runPromise);
      deployment = new ContractDeploy(asLedgerContractState(result.public.contractState));
    });

    it.effect('should return updated contract state', () =>
      Effect.gen(function* () {
        const result = yield* contract.circuit(Contract.ImpureCircuitId<CounterContract>('increment'), {
          address: ContractAddress.ContractAddress(deployment.address),
          contractState: asContractState(deployment.initialState),
          privateState: { count: 0 }
        });

        expect(result.public.contractState).toBeDefined();
        expect(result.private.privateState).toMatchObject({ count: 1 });
      })
    );
  });

  describe('contract maintenance operations', () => {
    let contract: ContractExecutable.ContractExecutable<
      CounterContract,
      Contract.Contract.PrivateState<CounterContract>,
      unknown
    >;
    let deployment: ContractDeploy;

    // Create and initialize a new contract instance for each test.
    beforeEach(async () => {
      contract = counterContract.pipe(
        ContractExecutable.provide(testLayer(new Map([
          ['KEYS_COIN_PUBLIC', VALID_COIN_PUBLIC_KEY],
          ['KEYS_SIGNING', VALID_SIGNING_KEY]
        ])))
      );
      const result = await contract.initialize({ count: 0 }).pipe(Effect.runPromise);
      deployment = new ContractDeploy(asLedgerContractState(result.public.contractState));
    });

    it.effect('replaceContractMaintenanceAuthority should return new signing key', () =>
      Effect.gen(function* () {
        const result = yield* contract.replaceContractMaintenanceAuthority(
          Option.none(),
          {
            address: ContractAddress.ContractAddress(deployment.address),
            contractState: asContractState(deployment.initialState),
          }
        );

        expect(result.public.maintenanceUpdate).toBeDefined();
        expect(result.public.maintenanceUpdate.counter).toEqual(deployment.initialState.maintenanceAuthority.counter);
        expect(
          (result.public.maintenanceUpdate.updates[0] as ReplaceAuthority).authority.counter
            - deployment.initialState.maintenanceAuthority.counter
        ).toEqual(1n);
        expect(result.private.signingKey).not.toEqual(VALID_SIGNING_KEY);
      })
    );

    it.effect('removeContractOperation should work', () =>
      Effect.gen(function* () {
        const result = yield* contract.removeContractOperation(
          Contract.ImpureCircuitId<CounterContract>('increment'),
          {
            address: ContractAddress.ContractAddress(deployment.address),
            contractState: asContractState(deployment.initialState),
          }
        );

        expect(result.public.maintenanceUpdate).toBeDefined();
        expect(result.public.maintenanceUpdate.counter).toEqual(deployment.initialState.maintenanceAuthority.counter);
        expect((result.public.maintenanceUpdate.updates[0] as VerifierKeyRemove).operation).toEqual('increment');
        expect(result.private.signingKey).toEqual(VALID_SIGNING_KEY);
      })
    );

    it.effect('addOrReplaceContractOperation should work', () =>
      Effect.gen(function* () {
        const result = yield* contract.addOrReplaceContractOperation(
          Contract.ImpureCircuitId<CounterContract>('increment'),
          Contract.VerifierKey(deployment.initialState.operation('increment')!.verifierKey),
          {
            address: ContractAddress.ContractAddress(deployment.address),
            contractState: asContractState(deployment.initialState),
          }
        );

        expect(result.public.maintenanceUpdate).toBeDefined();
        expect(result.public.maintenanceUpdate.counter).toEqual(deployment.initialState.maintenanceAuthority.counter);
        expect((result.public.maintenanceUpdate.updates[0] as VerifierKeyInsert).operation).toEqual('increment');
        expect(result.private.signingKey).toEqual(VALID_SIGNING_KEY);
      })
    );
  });
});

================
File: compact-js/compact-js/test/effect/ContractExecutableRuntime.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { resolve } from 'node:path';

import { NodeContext } from '@effect/platform-node';
import { describe, expect,it } from '@effect/vitest';
import {
  CompiledContract,
  ContractExecutable,
  ContractExecutableRuntime
} from '@midnight-ntwrk/compact-js/effect';
import { ZKFileConfiguration } from '@midnight-ntwrk/compact-js-node/effect';
import * as Configuration from '@midnight-ntwrk/platform-js/effect/Configuration';
import { ConfigProvider, Effect, Layer } from 'effect';

import { CounterContract } from '../contract';

const COUNTER_ASSETS_PATH = resolve(import.meta.dirname, '../contract/managed/counter');

const VALID_COIN_PUBLIC_KEY = 'd2dc8d175c0ef7d1f7e5b7f32bd9da5fcd4c60fa1b651f1d312986269c2d3c79';

const testLayer = (configMap: Map<string, string>) =>
  Layer.mergeAll(ZKFileConfiguration.layer(COUNTER_ASSETS_PATH), Configuration.layer).pipe(
    Layer.provideMerge(NodeContext.layer),
    Layer.provide(
      Layer.setConfigProvider(ConfigProvider.fromMap(configMap, { pathDelim: '_' }).pipe(ConfigProvider.constantCase))
    )
  );

describe('ContractExecutableRuntime', () => {
  const initialPS = { count: 0 };
  const counterContract = CompiledContract.make<CounterContract>('Counter', CounterContract).pipe(
    CompiledContract.withWitnesses({
      private_increment: ({ privateState }) => [{ count: privateState.count + 1 }, []]
    }),
    CompiledContract.withCompiledFileAssets(COUNTER_ASSETS_PATH),
    ContractExecutable.make
  );

  it.effect('should use given context', () => Effect.gen(function* () {
    const runtime = ContractExecutableRuntime.make(testLayer(new Map([['KEYS_COIN_PUBLIC', VALID_COIN_PUBLIC_KEY]])));

    const result = yield* runtime.runFork(counterContract.initialize(initialPS));

    expect(result.public.contractState).toBeDefined();
    expect(result.public.contractState.data).toBeDefined();
    expect(result.private.signingKey).toBeDefined();
    expect(result.private.privateState).toMatchObject(initialPS);
  }));
});

================
File: compact-js/compact-js/test/effect/Unshielded.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable @typescript-eslint/no-explicit-any */

import { resolve } from 'node:path';

import { NodeContext } from '@effect/platform-node';
import { describe, expect,it } from '@effect/vitest';
import {
  CompiledContract,
  Contract,
  ContractExecutable,
  ContractExecutableRuntime
} from '@midnight-ntwrk/compact-js/effect';
import { ZKFileConfiguration } from '@midnight-ntwrk/compact-js-node/effect';
import { ContractState, decodeRawTokenType, encodeRawTokenType, rawTokenType } from '@midnight-ntwrk/compact-runtime';
import { ContractDeploy, ContractState as LedgerContractState } from '@midnight-ntwrk/ledger';
import { CoinPublicKey, ContractAddress, DomainSeparator } from '@midnight-ntwrk/platform-js';
import * as Configuration from '@midnight-ntwrk/platform-js/effect/Configuration';
import { ConfigProvider, Effect, Layer } from 'effect';

import { UnshieldedContract } from '../contract';
import * as Arbitrary from './Arbitrary.js';

const COUNTER_ASSETS_PATH = resolve(import.meta.dirname, '../contract/managed/unshielded');

const VALID_COIN_PUBLIC_KEY = 'd2dc8d175c0ef7d1f7e5b7f32bd9da5fcd4c60fa1b651f1d312986269c2d3c79';

const asLedgerContractState = (contractState: ContractState): LedgerContractState =>
  LedgerContractState.deserialize(contractState.serialize());

const asContractState = (contractState: LedgerContractState): ContractState =>
  ContractState.deserialize(contractState.serialize());

const testLayer = (configMap: Map<string, string>) =>
  Layer.mergeAll(ZKFileConfiguration.layer(COUNTER_ASSETS_PATH), Configuration.layer).pipe(
    Layer.provideMerge(NodeContext.layer),
    Layer.provide(
      Layer.setConfigProvider(ConfigProvider.fromMap(configMap, { pathDelim: '_' }).pipe(ConfigProvider.constantCase))
    )
  );
const runtime = ContractExecutableRuntime.make(testLayer(new Map([['KEYS_COIN_PUBLIC', VALID_COIN_PUBLIC_KEY]])));

const inputsAndOutputs: (
  partitionedTranscript: ContractExecutable.ContractExecutable.PartitionedTranscript
) => readonly [any, any] =
  (partitionedTranscript) => {
    const inputs = partitionedTranscript[0]!.effects.unshieldedInputs.entries()
      .reduce((agg, [tokenType, amount]) => ({
        ...agg,
        [(tokenType as any).raw]: {
          tokenTag: tokenType.tag,
          amount
        }
      }), {});
    const outputs = partitionedTranscript[0]!.effects.unshieldedOutputs.entries()
      .reduce((agg, [tokenType, amount]) => ({
        ...agg,
        [(tokenType as any).raw]: {
          tokenTag: tokenType.tag,
          amount
        }
      }), {});
    return [inputs, outputs] as const;
  };

const spendsAndMints: (
  partitionedTranscript: ContractExecutable.ContractExecutable.PartitionedTranscript
) => readonly [any, any] =
  (partitionedTranscript) => {
    const spends = partitionedTranscript[0]!.effects.claimedUnshieldedSpends.entries()
      .reduce((agg, [[tokenType, address], amount]) => ({
        ...agg,
        [address.address]: {
          addressTag: address.tag,
          tokenTag: tokenType.tag,
          amount
        }
      }), {});
    const mints = partitionedTranscript[0]!.effects.unshieldedMints.entries()
      .reduce((agg, [address, amount]) => ({
        ...agg,
        [address]: amount
      }), {});
    return [spends, mints] as const;
  };

describe('Unshielded Tokens', () => {
  let contract: ContractExecutable.ContractExecutable<UnshieldedContract, undefined, any, any>;
  let deployment: ContractDeploy;
  let domainSep: DomainSeparator.DomainSeparator;

  beforeEach(async () => {
    contract = CompiledContract.make<UnshieldedContract>('UnshieldedContract', UnshieldedContract).pipe(
      CompiledContract.withVacantWitnesses,
      CompiledContract.withCompiledFileAssets(COUNTER_ASSETS_PATH),
      ContractExecutable.make
    );

    const result = await runtime.runPromise(contract.initialize(undefined));
    
    deployment = new ContractDeploy(asLedgerContractState(result.public.contractState));
    domainSep = Arbitrary.getSampleDomainSeparator();
  });

  describe('minting', () => {
    it.effect('should return unshielded spends for a given contract address', () => Effect.gen(function* () {
      const address = Arbitrary.getSampleContractAddress();
      const mintResult = yield* runtime.runFork(contract.circuit(
        Contract.ImpureCircuitId<UnshieldedContract>('mintUnshieldedToContractTest'),
        {
          address: ContractAddress.ContractAddress(deployment.address),
          contractState: asContractState(deployment.initialState),
          privateState: undefined
        },
        DomainSeparator.asBytes(domainSep),
        { bytes: ContractAddress.asBytes(address) },
        1_000n
      ));

      expect(mintResult).toBeDefined();

      const [spends, mints] = spendsAndMints(mintResult.public.partitionedTranscript);

      expect(spends).toMatchObject({
        [address]: {
          addressTag: 'contract',
          tokenTag: 'unshielded',
          amount: 1_000n
        }
      });
      expect(mints).toMatchObject({
        [domainSep]: 1_000n
      });
    }));

    it.effect('should return unshielded spends for a given user address', () => Effect.gen(function* () {
      const mintResult = yield* runtime.runFork(contract.circuit(
        Contract.ImpureCircuitId<UnshieldedContract>('mintUnshieldedToUserTest'),
        {
          address: ContractAddress.ContractAddress(deployment.address),
          contractState: asContractState(deployment.initialState),
          privateState: undefined
        },
        DomainSeparator.asBytes(domainSep),
        { bytes: CoinPublicKey.asBytes(CoinPublicKey.Hex(VALID_COIN_PUBLIC_KEY)) },
        1_000n
      ));

      expect(mintResult).toBeDefined();

      const [spends, mints] = spendsAndMints(mintResult.public.partitionedTranscript);

      expect(spends).toMatchObject({
        [VALID_COIN_PUBLIC_KEY]: {
          addressTag: 'user',
          tokenTag: 'unshielded',
          amount: 1_000n
        }
      });
      expect(mints).toMatchObject({
        [domainSep]: 1_000n
      });
    }));

    it.effect('should return unshielded spends for the deployed contract when minting', () => Effect.gen(function* () {
      const mintResult = yield* runtime.runFork(contract.circuit(
        Contract.ImpureCircuitId<UnshieldedContract>('mintUnshieldedToSelfTest'),
        {
          address: ContractAddress.ContractAddress(deployment.address),
          contractState: asContractState(deployment.initialState),
          privateState: undefined
        },
        DomainSeparator.asBytes(domainSep),
        1_000n
      ));

      expect(mintResult).toBeDefined();

      const [spends, mints] = spendsAndMints(mintResult.public.partitionedTranscript);

      expect(spends).toMatchObject({
        [deployment.address]: {
          addressTag: 'contract',
          tokenTag: 'unshielded',
          amount: 1_000n
        }
      });
      expect(mints).toMatchObject({
        [domainSep]: 1_000n
      });
    }));
  });

  describe('sending', () => {
    it.effect('should return unshielded outputs and spends', () => Effect.gen(function* () {
      const color = encodeRawTokenType(rawTokenType(
        DomainSeparator.asBytes(domainSep),
        Arbitrary.getSampleContractAddress()
      ));
      const spendResult = yield* runtime.runFork(contract.circuit(
        Contract.ImpureCircuitId<UnshieldedContract>('sendUnshieldedToSelfTest'),
        {
          address: ContractAddress.ContractAddress(deployment.address),
          contractState: asContractState(deployment.initialState),
          privateState: undefined
        },
        color,
        1_000n
      ));

      expect(spendResult).toBeDefined();

      const [_, outputs] = inputsAndOutputs(spendResult.public.partitionedTranscript);
      const [spends, mints] = spendsAndMints(spendResult.public.partitionedTranscript);
      const tokenType = decodeRawTokenType(color);

      expect(spends).toMatchObject({
        [deployment.address]: {
          addressTag: 'contract',
          tokenTag: 'unshielded',
          amount: 1_000n
        }
      });
      expect(outputs).toMatchObject({
        [tokenType]: {
          tokenTag: 'unshielded',
          amount: 1_000n
        }
      });
      expect(mints).toMatchObject({});
    }));
  });

  describe('receiving', () => {
    it.effect('should return unshielded inputs', () => Effect.gen(function* () {
      const address = Arbitrary.getSampleContractAddress();
      const color = encodeRawTokenType(rawTokenType(DomainSeparator.asBytes(domainSep), address));
      const spendResult = yield* runtime.runFork(contract.circuit(
        Contract.ImpureCircuitId<UnshieldedContract>('receiveUnshieldedTest'),
        {
          address: ContractAddress.ContractAddress(deployment.address),
          contractState: asContractState(deployment.initialState),
          privateState: undefined
        },
        color,
        1_000n
      ));

      expect(spendResult).toBeDefined();

      const [inputs] = inputsAndOutputs(spendResult.public.partitionedTranscript);
      const [_, mints] = spendsAndMints(spendResult.public.partitionedTranscript);
      const tokenType = decodeRawTokenType(color);

      expect(inputs).toMatchObject({
        [tokenType]: {
          tokenTag: 'unshielded',
          amount: 1_000n
        }
      });
      expect(mints).toMatchObject({});
    }));
  });
});

================
File: compact-js/compact-js/test/typetests/effect/CompiledContract.tst.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type CompactContext,CompiledContract, type Contract } from '@midnight-ntwrk/compact-js/effect';
import { describe, expect, it } from 'tstyche';

import { Contract as Contract_ } from '../../contract/managed/counter/contract';

/* eslint-disable @typescript-eslint/no-explicit-any */

type MockCounterContract = Contract_<any>;
const MockCounterContract = Contract_;

describe('CompiledContract', () => {
  const compiledContract = CompiledContract.make<MockCounterContract>('MockCounter', MockCounterContract);

  describe('as initialized', () => {
    it('should require witnesses as defined by contract', () => {
      expect(compiledContract).type.toBeAssignableWith<
        CompiledContract.CompiledContract<MockCounterContract, any, CompactContext.Witnesses<MockCounterContract>>
      >();
    });

    it('should require ZK path configuration', () => {
      expect(compiledContract).type.toBeAssignableWith<
        CompiledContract.CompiledContract<MockCounterContract, any, CompactContext.CompiledAssetsPath>
      >();
    });

    describe('with resolved witnesses', () => {
      const contract = compiledContract.pipe(
        CompiledContract.withWitnesses({} as Contract.Contract.Witnesses<MockCounterContract>)
      );

      it('should not require further witnesses', () => {
        expect(contract).type.not.toBeAssignableWith<
          CompiledContract.CompiledContract<MockCounterContract, any, CompactContext.Witnesses<MockCounterContract>>
        >();
      });
    });

    describe('with resolved ZK path configuration', () => {
      const contract = compiledContract.pipe(CompiledContract.withCompiledFileAssets('~/contracts'));

      it('should not require further witnesses', () => {
        expect(contract).type.not.toBeAssignableWith<
          CompiledContract.CompiledContract<MockCounterContract, any, CompactContext.CompiledAssetsPath>
        >();
      });
    });

    describe('as fully resolved', () => {
      const contract = compiledContract.pipe(
        CompiledContract.withWitnesses({} as Contract.Contract.Witnesses<MockCounterContract>),
        CompiledContract.withCompiledFileAssets('/Users/hosky/compact_contracts/counter')
      );

      it('should require no further context', () => {
        expect(contract).type.toBe<CompiledContract.CompiledContract<MockCounterContract, any, never>>();
      });
    });
  });
});

================
File: compact-js/compact-js/test/typetests/effect/ContractExecutable.tst.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  CompiledContract,
  Contract,
  ContractExecutable,
  ZKConfiguration
} from '@midnight-ntwrk/compact-js/effect';
import * as Configuration from '@midnight-ntwrk/platform-js/effect/Configuration';
import * as NetworkId from '@midnight-ntwrk/platform-js/effect/NetworkId';
import * as NetworkIdMoniker from '@midnight-ntwrk/platform-js/effect/NetworkIdMoniker';
import { Context,Effect, Layer } from 'effect';
import { describe, expect, it } from 'tstyche';

import { Contract as Contract_ } from '../../contract/managed/counter/contract';

/* eslint-disable @typescript-eslint/no-explicit-any */

type MockCounterContract = Contract_<any>;
const MockCounterContract = Contract_;

class StringDep extends Context.Tag('StringDep')<StringDep, string>() {}

describe('ContractExecutable', () => {
  const compiledContract = CompiledContract.make<MockCounterContract>('MockCounter', MockCounterContract).pipe(
    CompiledContract.withWitnesses({} as Contract.Contract.Witnesses<MockCounterContract>),
    CompiledContract.withCompiledFileAssets('/Users/hosky/compact_contracts/counter')
  );
  const contractExecutable = ContractExecutable.make(compiledContract);

  describe('as initialized', () => {
    it('should require ZKConfig and KeyConfig', () => {
      expect(contractExecutable).type.toBeAssignableWith<
        ContractExecutable.ContractExecutable<
          MockCounterContract,
          any,
          ContractExecutable.ContractExecutionError,
          ZKConfiguration.ZKConfiguration | Configuration.Keys
        >
      >();
    });

    describe('with fully resolved layer', () => {
      const layer = Layer.mergeAll(
        Layer.effect(
          ZKConfiguration.ZKConfiguration,
          Effect.sync(() => ({})) as Effect.Effect<ZKConfiguration.ZKConfiguration.Service>
        ),
        Layer.effect(
          Configuration.Keys,
          Effect.sync(() => ({})) as Effect.Effect<Configuration.Configuration.Keys>
        ),
        Layer.effect(
          Configuration.Network,
          Effect.sync(() => NetworkId.make(NetworkIdMoniker.NetworkIdMoniker('hosky-devnet')))
        )
      );
      const executable = contractExecutable.pipe(ContractExecutable.provide(layer));

      it('should require no further context', () => {
        expect(executable).type.toBe<
          ContractExecutable.ContractExecutable<
            MockCounterContract,
            any,
            ContractExecutable.ContractExecutionError,
            never
          >
        >();
      });
    });

    describe('with partially resolved layer', () => {
      const layer = Layer.mergeAll(
        Layer.effect(
          ZKConfiguration.ZKConfiguration,
          Effect.sync(() => ({})) as unknown as Effect.Effect<ZKConfiguration.ZKConfiguration.Service, never, StringDep>
        ),
        Layer.effect(
          Configuration.Keys,
          Effect.sync(() => ({})) as Effect.Effect<Configuration.Configuration.Keys>
        ),
        Layer.effect(
          Configuration.Network,
          Effect.sync(() => NetworkId.make(NetworkIdMoniker.NetworkIdMoniker('hosky-devnet')))
        )
      );
      const executable = contractExecutable.pipe(ContractExecutable.provide(layer));

      it('should require additional context from the layer', () => {
        expect(executable).type.toBe<
          ContractExecutable.ContractExecutable<
            MockCounterContract,
            any,
            ContractExecutable.ContractExecutionError,
            StringDep
          >
        >();
        expect(executable.initialize({})).type.toBe<
          Effect.Effect<
            ContractExecutable.ContractExecutable.DeployResult<any>,
            ContractExecutable.ContractExecutionError,
            StringDep
          >
        >();
        expect(executable.circuit(Contract.ImpureCircuitId<MockCounterContract>('reset'), {} as any)).type.toBe<
          Effect.Effect<
            ContractExecutable.ContractExecutable.CallResult<
              MockCounterContract,
              any,
              Contract.ImpureCircuitId<MockCounterContract>
            >,
            ContractExecutable.ContractExecutionError,
            StringDep
          >
        >();
      });
    });
  });
});

================
File: compact-js/compact-js/test/typetests/tsconfig.json
================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "noEmit": true,
    "strict": true,
    "types": []
  },
  "include": [
    "./**/*.tst.ts",
    "../*.ts",
    "../../src/**/*.ts"
  ],
  "exclude": []
}

================
File: compact-js/compact-js/LICENSE
================
Copyright 2025 Midnight Foundation

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

================
File: compact-js/compact-js/README.md
================
# Compact.js

## Introduction

Compact.js provides a Typescript-based execution environment for smart contracts
compiled with the [Compact](https://docs.midnight.network/develop/reference/compact/) language.
When a Compact smart contract is compiled with `compactc`, part of the output includes:

1. A JavaScript file.
2. A TypeScript [declaration file](https://www.typescriptlang.org/docs/handbook/2/type-declarations.html).

The JavaScript file contains:

- The execution logic for each circuit in the source contract,
- Logic for constructing the contracts initial state,
- Utilities for converting on-chain contract state into a JavaScript representation.

Compact.js uses this file at run time to execute the circuits. The circuit execution results are
then used by higher level tools and frameworks (such as Midnight.js) in order to create and submit
transactions to the Midnight blockchain. At compile time, the types and utilities of Compact.js use
the TypeScript declaration file and the definitions it contains, to map types that make working with
the contract and its circuits more convenient, and TypeScript idiomatic.

> [!NOTE]  
> The term _runtime_ is often used to describe the JavaScript executable for a contract. This is
> distinct from the package `@midnight-ntwrk/compact-runtime`, which provides the utilities that each
> of these JavaScript executables use.

================
File: compact-js/compact-js/tsconfig.build.json
================
{
  "extends": "./tsconfig.src.json",
  "compilerOptions": {
    "tsBuildInfoFile": ".tsbuildinfo/build.tsbuildinfo",
    "outDir": "build/esm",
    "declarationDir": "build/dts",
    "stripInternal": true
  }
}

================
File: compact-js/compact-js/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [
    { "path": "./tsconfig.src.json" },
    { "path": "./tsconfig.test.json" }
  ]
}

================
File: compact-js/compact-js/tsconfig.src.json
================
{
  "extends": "../../tsconfig.base.json",
  "include": ["src"],
  "compilerOptions": {
    "tsBuildInfoFile": ".tsbuildinfo/src.tsbuildinfo",
    "rootDir": "src",
    "outDir": "build/src"
  }
}

================
File: compact-js/compact-js/tsconfig.test.json
================
{
  "extends": "../../tsconfig.base.json",
  "include": ["test"],
  "references": [
    { "path": "tsconfig.src.json" },
  ],
  "compilerOptions": {
    "tsBuildInfoFile": ".tsbuildinfo/test.tsbuildinfo",
    "rootDir": "test",
    "noEmit": true
  }
}

================
File: compact-js/compact-js/vitest.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// <reference types="vitest" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    include: ['test/**/*.test.ts'],
    exclude: ['node_modules', 'dist'],
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage'
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }]
    ]
  }
});

================
File: compact-js/compact-js-command/src/effect/internal/args.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Args } from '@effect/cli';
import * as ContractAddress from '@midnight-ntwrk/platform-js/effect/ContractAddress';
import * as SigningKey from '@midnight-ntwrk/platform-js/effect/SigningKey';
import { Schema } from 'effect';

export const contractArgs = Args.text({ name: 'arg' }).pipe(
  Args.withDescription('An argument that will be forwarded (in order), to the constructor or circuit being invoked.'),
  Args.repeated
);

export const contractAddress = Args.text({ name: 'contract_address' }).pipe(
  Args.withDescription('A contract address, hex-encoded.'),
  Args.withSchema(Schema.String.pipe(Schema.fromBrand(ContractAddress.ContractAddress)).annotations({ title: 'contract_address' }))
);

export const signingKey = Args.text({ name: 'signing_key' }).pipe(
  Args.withDescription('A signing key, hex-encoded.'),
  Args.withSchema(Schema.String.pipe(Schema.fromBrand(SigningKey.SigningKey)).annotations({ title: 'signing_key' }))
);

export const circuitId = Args.text({ name: 'circuit_id'}).pipe(
  Args.withDescription('A circuit identifier.')
);

export const verifierKeyPath = Args.file({ name: 'vk_path'}).pipe(
  Args.withDescription('A path to a verifier key.'),
  Args.optional
);

================
File: compact-js/compact-js-command/src/effect/internal/circuitCommand.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type Command } from '@effect/cli';
import { FileSystem } from '@effect/platform';
import { Contract, type ContractExecutable, ContractRuntimeError } from '@midnight-ntwrk/compact-js/effect';
import { decodeZswapLocalState, type EncodedZswapLocalState,
  encodeZswapLocalState } from '@midnight-ntwrk/compact-runtime';
import {
  communicationCommitmentRandomness,
  ContractCallPrototype,
  type ContractOperation as LedgerContractOption,
  Intent
} from '@midnight-ntwrk/ledger';
import { type ConfigError, Console,Duration, Effect, Option } from 'effect';

import * as CompiledContractReflection from '../CompiledContractReflection.js';
import { type ConfigCompiler } from '../ConfigCompiler.js';
import * as InternalArgs from './args.js';
import * as InternalCommand from './command.js';
import * as ContractState from './contractState.js';
import { decodeZswapLocalStateObject, encodeZswapLocalStateObject } from './encodedZswapLocalStateSchema.js'
import * as InternalOptions from './options.js';

/** @internal */
export type Args = Command.Command.ParseConfig<typeof Args>;
/** @internal */
export const Args = { 
  address: InternalArgs.contractAddress,
  circuitId: InternalArgs.circuitId,
  args: InternalArgs.contractArgs
};

/** @internal */
export type Options = Command.Command.ParseConfig<typeof Options>;
/** @internal */
export const Options = {
  inputFilePath: InternalOptions.inputFilePath,
  inputPrivateStateFilePath: InternalOptions.inputPrivateStateFilePath,
  inputZswapLocalStateFilePath: InternalOptions.inputZswapLocalStateFilePath,
  outputFilePath: InternalOptions.outputFilePath,
  outputPrivateStateFilePath: InternalOptions.outputPrivateStateFilePath,
  outputZswapLocalStateFilePath: InternalOptions.outputZswapLocalStateFilePath,
  outputResultFilePath: InternalOptions.outputResultFilePath
}

/** @internal */
export const handler: (inputs: Args & Options, moduleSpec: ConfigCompiler.ModuleSpec) =>
  Effect.Effect<
    void,
    ContractExecutable.ContractExecutionError | ConfigError.ConfigError,
    CompiledContractReflection.CompiledContractReflection | FileSystem.FileSystem
  > =
  (
    {
      address,
      circuitId,
      args,
      inputFilePath,
      inputPrivateStateFilePath,
      inputZswapLocalStateFilePath,
      outputFilePath,
      outputPrivateStateFilePath,
      outputZswapLocalStateFilePath,
      outputResultFilePath
    },
    moduleSpec
  ) => Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    const { module: { default: contractModule } } = moduleSpec;
    const contractReflector = yield* CompiledContractReflection.CompiledContractReflection;
    const argsParser = yield* contractReflector.createArgumentParser(contractModule.contractExecutable.compiledContract);
    const ledgerContractState = yield* fs.readFile(inputFilePath).pipe(
      Effect.flatMap(ContractState.asLedgerContractStateFromBytes)
    );
    const privateState = JSON.parse(yield* fs.readFileString(inputPrivateStateFilePath));
    const encodedZswapLocalState = Option.map(
      inputZswapLocalStateFilePath,
      (filePath) => fs.readFileString(filePath).pipe(
        Effect.flatMap((str) => decodeZswapLocalStateObject(JSON.parse(str))
      ))
    );

    const result = yield* contractModule.contractExecutable.circuit(
      Contract.ImpureCircuitId(circuitId),
      {
        address,
        contractState: yield* ContractState.asContractState(ledgerContractState),
        privateState: privateState ?? contractModule.createInitialPrivateState(),
        zswapLocalState: Option.isSome(encodedZswapLocalState)
          ? decodeZswapLocalState((yield* Option.getOrThrow(encodedZswapLocalState)) as EncodedZswapLocalState)
          : undefined 
      },
      ...(yield* argsParser.parseCircuitArgs(Contract.ImpureCircuitId(circuitId), args))
    );
    // Replacer function handles types that don't serialize properly in JSON:
    // - Uint8Array serializes as {"0": 215, "1": 182, ...} instead of [215, 182, ...]
    // - bigint cannot be serialized and throws TypeError without conversion
    yield* Console.log(
      JSON.stringify(
        result.private.result,
        (_, value) => {
          if (typeof value === 'bigint') return value.toString();
          if (value instanceof Uint8Array) return Array.from(value);
          return value;
        },
        2
      )
    );
    const intent = Intent.new(yield* InternalCommand.ttl(Duration.minutes(10)))
      .addCall(new ContractCallPrototype(
        address,
        circuitId,
        ledgerContractState.operation(circuitId) as LedgerContractOption,
        result.public.partitionedTranscript[0],
        result.public.partitionedTranscript[1],
        result.private.privateTranscriptOutputs,
        result.private.input,
        result.private.output,
        communicationCommitmentRandomness(),
        circuitId
      ));

    yield* fs.writeFileString(
      outputResultFilePath,
      JSON.stringify(
        result.private.result,
        (_, value) => {
          if (typeof value === 'bigint') return value.toString();
          if (value instanceof Uint8Array) return Array.from(value);
          return value;
        }
      )
    );
    yield* fs.writeFile(outputFilePath, intent.serialize());
    yield* fs.writeFileString(outputPrivateStateFilePath, JSON.stringify(result.private.privateState));
    yield* fs.writeFileString(
      outputZswapLocalStateFilePath,
      JSON.stringify(
        yield* encodeZswapLocalStateObject(encodeZswapLocalState(result.private.zswapLocalState))
      )
    );
  }).pipe(
    Effect.mapError(
      (err) => ContractRuntimeError.make('Failed to invoke circuit', err)
    )
  );

================
File: compact-js/compact-js-command/src/effect/internal/command.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { Command } from '@effect/cli';
import type { FileSystem, Path } from '@effect/platform';
import { type PlatformError } from '@effect/platform/Error';
import { NodeContext } from '@effect/platform-node';
import * as Ansi from '@effect/printer-ansi/Ansi';
import * as Doc from '@effect/printer-ansi/AnsiDoc';
import { type ContractExecutable, ContractExecutableRuntime,type ZKConfiguration } from '@midnight-ntwrk/compact-js/effect';
import { ZKFileConfiguration } from '@midnight-ntwrk/compact-js-node/effect';
import * as Configuration from '@midnight-ntwrk/platform-js/effect/Configuration';
import { ConfigError as EffectConfigError, type ConfigProvider, Console, DateTime, type Duration, Effect, Layer } from 'effect';

import * as CommandConfigProvider from '../CommandConfigProvider.js';
import * as CompiledContractReflection from '../CompiledContractReflection.js';
import * as ConfigCompilationError from '../ConfigCompilationError.js';
import * as ConfigCompiler from '../ConfigCompiler.js';
import type * as ConfigError from '../ConfigError.js';
import * as InternalOptions from './options.js';

/**
 * Applies a duration to the current date/time, returning a date/time that is in the future.
 *
 * @param duration A `Duration` describing how far into the future the returned date/time should be.
 * @returns An `Effect` that yields a `Date` that will be in the future from `duration`.
 */
export const ttl: (duration: Duration.Duration) => Effect.Effect<Date> = (duration) => 
  DateTime.now.pipe(Effect.map((utcNow) => DateTime.toDate(DateTime.addDuration(utcNow, duration))));

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const reportCausableError: (err: any) => Effect.Effect<void, never> =
  (err) => Effect.gen(function* () {
    const buildCauseDocs = () => {
      const docs: Doc.Doc<unknown>[] = [];
      const buildCauseDoc = (errOrDoc: any) => { // eslint-disable-line @typescript-eslint/no-explicit-any
        if (Doc.isDoc(errOrDoc)) {
          return docs.push(errOrDoc);
        }
        docs.push(Doc.text(errOrDoc.message));
        if (errOrDoc.cause) {
          buildCauseDoc(errOrDoc.cause);
        }
      }
      buildCauseDoc(err.cause);
      return docs;
    }
    let errorDoc: Doc.AnsiDoc = Doc.text(err.message);
    if (err.cause) {
      errorDoc = errorDoc.pipe(
        Doc.catWithLineBreak(Doc.annotate(Doc.text('(cause)'), Ansi.italicized)),
        Doc.catWithLineBreak(Doc.hsep([
          Doc.text('..'),
          Doc.align(Doc.vsep(buildCauseDocs()))
        ]))
      ) as Doc.AnsiDoc
    }
    yield* Console.log(Doc.render(errorDoc, {style: 'pretty'}));
    if (!process.env['VITEST']) {
      process.exit(1); // Terminate with non-zero exit code on any causable error (if not running inside a test).
    }
  });

/**
 * Pretty prints a configuration error from {@link ConfigCompiler.ConfigCompiler | ConfigCompiler} implementations.
 *
 * @param err The {@link ConfigError.ConfigError | ConfigError} or 
 * {@link ConfigCompilationError.ConfigCompilationError | ConfigCompilationError} to report for.
 * @returns An `Effect` that writes `err` to the console.
 */
export const reportContractConfigError: (err: ConfigError.ConfigError | ConfigCompilationError.ConfigCompilationError) =>
  Effect.Effect<void, never> =
    (err) => Effect.gen(function* () {
      if (err.cause && err.cause instanceof ConfigCompilationError.ConfigCompilationError) {
        return yield* reportCausableError({
          message: err.message,
          cause: Doc.annotate(Doc.text(err.cause.message), Ansi.italicized).pipe(
            Doc.catWithLineBreak(Doc.hsep([
              Doc.text('..'),
              Doc.align(Doc.vsep(err.cause.diagnostics.map((d) => Doc.text(d.messageText))))
            ]))
          )
        });
      }
      yield* reportCausableError(err);
    });

const ConfigErrorType = {
  MissingData: 1,
  InvalidData: 2,
  UnsupportedData: 4
}
type ConfigErrorType = typeof ConfigErrorType[keyof typeof ConfigErrorType];
type ReportedConfigError = readonly [flag: ConfigErrorType, messages: string[]];

const reduceConfigError = (err: EffectConfigError.ConfigError): ReportedConfigError =>
  EffectConfigError.reduceWithContext<undefined, ReportedConfigError>(err, undefined, {
    andCase: (_, left, right) => [left[0] | right[0], [...left[1], ...right[1]]],
    orCase: (_, left, right) => left || right,
    missingDataCase: (_, path) => [ConfigErrorType.MissingData, [`Missing data at path '${path.join(',')}'`]],
    invalidDataCase: (_, path) => [ConfigErrorType.InvalidData, [`Invalid data at path '${path.join(',')}'`]],
    sourceUnavailableCase: (_, path, message, cause) => [ConfigErrorType.MissingData, [`The underlying source for data at path '${path.join(',')}' could not be found`, message, cause.toString()]],
    unsupportedCase: (_, path) => [ConfigErrorType.UnsupportedData, [`Unsupported data at path '${path.join(',')}'`]],
  });

/**
 * Pretty prints a configuration or contract execution error.
 *
 * @param err The {@link ContractExecutable.ContractExecutionError | ContractExecutionError} or `ConfigError` to
 * report for.
 * @returns An `Effect` that writes `err` to the console.
 */
export const reportContractExecutionError: (
  err: ContractExecutable.ContractExecutionError | EffectConfigError.ConfigError | PlatformError
) => Effect.Effect<void, never> =
  (err) => Effect.gen(function* () {
    if (EffectConfigError.isConfigError(err)) {
      const [errorType, messages] = reduceConfigError(err);
      yield* reportCausableError({
        message: 'Invalid, missing, or unsupported configuration',
        cause: Doc.vsep(messages.map(Doc.text))
      });
      if (errorType & ConfigErrorType.InvalidData || errorType & ConfigErrorType.MissingData) {
        yield* Console.log();
        yield* Console.log(Doc.render(
          Doc.vsep([
            Doc.text('The reported error indicates that configuration may be missing, or is invalid.'),
            Doc.text('Check the values provided in the \'config\' property of the specified \'contract.config.ts\' file,'),
            Doc.text('or the supplied environment variables, or the values supplied as options on the command line.')
          ]),
          { style: 'compact' }
        ));
      }
      if (errorType & ConfigErrorType.UnsupportedData) {
        yield* Console.log();
        yield* Console.log(Doc.render(
          Doc.vsep([
            Doc.text('The reported error indicates that unsupported or incompatible configuration values was detected.'),
            Doc.text('Check the values (along with their formats and lengths), provided in the \'config\' property of'),
            Doc.text('the specified \'contract.config.ts\' file, or the supplied environment variables, or the values'),
            Doc.text('supplied as options on the command line.')
          ]),
          { style: 'compact' }
        ));
      }
      return;
    }
    yield* reportCausableError(err);
  });

/** @internal */
export type GlobalOptions = Command.Command.ParseConfig<typeof GlobalOptions>;
/** @internal */
export const GlobalOptions = {
  config: InternalOptions.config,
  coinPublicKey: InternalOptions.coinPublicKey,
  network: InternalOptions.network
}

/**
 * Creates a default layer that provides services for executing Compact contracts via a command line.
 *
 * @param configProvider 
 * @param zkBaseFolderPath A base path to a folder containing the ZK assets for the contract that will be in
 * scope during invocation
 *
 * @category layers
 */
export const layer: (configProvider: ConfigProvider.ConfigProvider, zkBaseFolderPath: string) =>
  Layer.Layer<
    ZKConfiguration.ZKConfiguration | Configuration.Keys | Configuration.Network | NodeContext.NodeContext,
    EffectConfigError.ConfigError
  > = (configProvider, zkBaseFolderPath) =>
    Layer.mergeAll(ZKFileConfiguration.layer(zkBaseFolderPath), Configuration.layer).pipe(
      Layer.provideMerge(NodeContext.layer),
      Layer.provide(Layer.setConfigProvider(configProvider))
    );

/**
 * Creates an appropriate runtime for a command handler.
 *
 * @param handler A handler function that executes a command based on its received command line inputs and
 * compiled configuration module.
 * @returns An `Effect` that adapts `handler` by compiling the configured configuration file, and invoking
 * `handler` within an appropriate `ContractExecutableRuntime`.
 */
export const invocationHandler: <I>(
  handler: (inputs: I & GlobalOptions, module: ConfigCompiler.ConfigCompiler.ModuleSpec) =>
    Effect.Effect<
      void,
      ContractExecutable.ContractExecutionError | EffectConfigError.ConfigError,
      Path.Path | FileSystem.FileSystem | CompiledContractReflection.CompiledContractReflection
    >
) =>
  (inputs: I & GlobalOptions) =>
    Effect.Effect<
      void,
      ConfigError.ConfigError | EffectConfigError.ConfigError,
      Path.Path | FileSystem.FileSystem | ConfigCompiler.ConfigCompiler
    > =
    (handler) => (inputs) => Effect.gen(function* () {
      const configCompiler = yield* ConfigCompiler.ConfigCompiler;
      const moduleSpec = yield* configCompiler.compile(inputs.config);
      const { moduleImportDirectoryPath, module: { default: contractModule } } = moduleSpec;
      const contractRuntime = ContractExecutableRuntime.make(
        layer(
          CommandConfigProvider.make(contractModule.config ?? {}, InternalOptions.asConfigProvider(inputs)),
          moduleImportDirectoryPath
        )
      );

      yield* handler(inputs, moduleSpec).pipe(
        Effect.provide(CompiledContractReflection.layer(moduleImportDirectoryPath).pipe(
          Layer.provideMerge(NodeContext.layer)
        )),
        contractRuntime.runFork,
        Effect.catchAll(reportContractExecutionError)
      );
    }).pipe(
      Effect.catchAll(reportContractConfigError)
    );

================
File: compact-js/compact-js-command/src/effect/internal/compiledContractReflection.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { FileSystem, Path } from '@effect/platform';
import { CompiledContract, type Contract, ContractRuntimeError } from '@midnight-ntwrk/compact-js/effect';
import * as Hex from '@midnight-ntwrk/platform-js/effect/Hex'
import { Effect, Either, identity, Layer } from 'effect';
import pkg from 'json5';
import TS from 'typescript';
const { parse, stringify } = pkg;

import { MidnightBech32m, UnshieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';

import * as CompiledContractReflection from "../CompiledContractReflection.js";

const CONTRACT_FOLDER = 'contract';
const CONTRACT_DECLARATION_FILE = 'index.d.ts';
const TRUE_OR_FALSE_REGEXP = /^true|false$/;

type FileSnapshot = {
  file: TS.IScriptSnapshot;
  version: number;
}

class BasicHost implements TS.LanguageServiceHost {
  #files: Record<string, FileSnapshot>;

  constructor(readonly files: Record<string, FileSnapshot>) {
    this.#files = {...files};
  }

  getCurrentDirectory(): string {
    return '';
  }
  getDefaultLibFileName(_: TS.CompilerOptions): string {
    return 'lib';
  }
  getCompilationSettings(): TS.CompilerOptions {
    return TS.getDefaultCompilerOptions();
  }
  getScriptVersion(fileName: string): string {
    return String(this.files[fileName].version);
  }
  getScriptSnapshot(fileName: string): TS.IScriptSnapshot | undefined {
    return this.files[fileName]?.file;
  }
  getScriptFileNames(): string[] {
    return Object.keys(this.#files);
  }
  fileExists(path: string): boolean {
    return !!this.files[path];
  }
  readFile(path: string): string | undefined {
    const file = this.files[path].file
    return file?.getText(0, file?.getLength())
  }
}

const parseBech32mToHex = (input: string): Either.Either<string, Error> =>
  Either.try({
    try: () => {
      const parsedBech32 = MidnightBech32m.parse(input);
      return UnshieldedAddress.codec.decode(parsedBech32.network, parsedBech32).hexString;
    },
    catch: (error) => error instanceof Error ? error : new Error(String(error))
  });

const typeNodeName: (type: TS.TypeNode) => string =
  (type) => {
    if (type.kind === TS.SyntaxKind.NumberKeyword) return 'number';
    if (type.kind === TS.SyntaxKind.BigIntKeyword) return 'bigint';
    if (type.kind === TS.SyntaxKind.StringKeyword) return 'string';
    if (type.kind === TS.SyntaxKind.BooleanKeyword) return 'boolean';
    if (type.kind === TS.SyntaxKind.ArrayType) {
      return `${typeNodeName((type as TS.ArrayTypeNode).elementType)}[]`;
    }
    if (type.kind === TS.SyntaxKind.TupleType) {
      return `[${(type as TS.TupleTypeNode).elements.map((_) => typeNodeName(_ as TS.TypeNode)).join(', ')}]`;
    }
    if (type.kind === TS.SyntaxKind.TypeLiteral) {
      const typeLiteral = type as TS.TypeLiteralNode;
      return `{ ${typeLiteral.members.map((_) => `${(_.name as TS.Identifier).escapedText.toString()}: ${typeNodeName((_ as TS.PropertySignature).type!)}`).join(', ')} }`;
    }
    if (type.kind === TS.SyntaxKind.TypeReference) {
      const typeName = (type as TS.TypeReferenceNode).typeName;
      if (TS.isIdentifier(typeName)) return typeName.escapedText.toString();
    }
    return '<unknown>';
  };

const transformParams: (
  args: string[],
  types: TS.TypeNode[],
  quotedStrings?: boolean
) => Either.Either<any[], ContractRuntimeError.ContractRuntimeError> = // eslint-disable-line @typescript-eslint/no-explicit-any
  (args, types, quotedStrings = false) => {
    if (args.length !== types.length) {
      return Either.left(
        ContractRuntimeError.make(
          `Invalid number of arguments. Expected ${types.length} arguments, but got ${args.length}`
        )
      );
    }
    const transformedArgs: any[] = []; // eslint-disable-line @typescript-eslint/no-explicit-any
    for (let idx = 0; idx < types.length; idx++) {
      const type = types[idx];
      const transformedArg = Either.try({
        try: () => {
          if (type!.kind === TS.SyntaxKind.NumberKeyword) {
            return Number(args[idx]);
          }
          if (type!.kind === TS.SyntaxKind.BigIntKeyword) {
            return BigInt(args[idx]);
          }
          if (type!.kind === TS.SyntaxKind.StringKeyword) {
            return quotedStrings ? args[idx].replaceAll('\'', '') : args[idx];
          }
          if (type!.kind === TS.SyntaxKind.BooleanKeyword) {
            if (!TRUE_OR_FALSE_REGEXP.test(args[idx])) throw new SyntaxError(`Cannot convert ${args[idx]} to a Boolean`);
            return args[idx] === 'true';
          }
          if (type!.kind === TS.SyntaxKind.ArrayType) {
            const arrayElems = parse(args[idx]);
            if (!Array.isArray(arrayElems)) {
              throw new SyntaxError(`Cannot convert ${args[idx]} to an array`);
            }
            return Either.getOrThrowWith(
              transformParams(
                arrayElems.map((arrayElem) => stringify(arrayElem)),
                Array(arrayElems.length).fill((type as TS.ArrayTypeNode).elementType), // Same type repeated.
                true
              ),
              identity // Rethrow the error from `transformParams`.
            );
          }
          if (type!.kind === TS.SyntaxKind.TupleType) {
            const tupleElems = parse(args[idx]);
            if (!Array.isArray(tupleElems)) {
              throw new SyntaxError(`Cannot convert ${args[idx]} to an array`);
            }
            return Either.getOrThrowWith(
              transformParams(
                tupleElems.map((tupleElem) => stringify(tupleElem)),
                (type as TS.TupleTypeNode).elements.map((elemType) => elemType as TS.TypeNode),
                true
              ),
              identity // Rethrow the error from `transformParams`.
            );
          }
          if (type!.kind === TS.SyntaxKind.TypeLiteral) {
            const typeLiteral = type as TS.TypeLiteralNode;
            const srcObj = parse(args[idx]);
            if (typeof srcObj !== 'object') {
              throw new SyntaxError(`Cannot convert ${args[idx]} to an object literal`);
            }
            for (const member of typeLiteral.members) {
              const propKey = ((member as TS.PropertySignature).name as TS.Identifier).escapedText.toString();
              const propType = (member as TS.PropertySignature).type!;
              const memberValue = Either.getOrThrowWith(
                transformParams([stringify(srcObj[propKey])], [propType], true),
                identity // Rethrow the error from `transformParams`.
              );
              srcObj[propKey] = memberValue[0];
            }
            return srcObj;
          }
          if (type!.kind === TS.SyntaxKind.TypeReference) {
            const typeName = (type as TS.TypeReferenceNode).typeName;
            if (TS.isIdentifier(typeName) && typeName.escapedText === 'Uint8Array') {
              const cleanInput = quotedStrings ? args[idx].replaceAll('\'', '') : args[idx];

              const bech32Result = parseBech32mToHex(cleanInput);
              const hexString = Either.match(bech32Result, {
                onLeft: () => cleanInput,
                onRight: (hex) => hex
              });

              return Either.match(Hex.parseHex(hexString), {
                onRight: (parsedHex) => Buffer.from(parsedHex.byteChars, 'hex'),
                onLeft: (parseErr) => {
                  throw new SyntaxError(
                    `Cannot convert ${args[idx]} to a Uint8Array: ${parseErr.message}`
                  );
                }
              });
            }
          }
        },
        catch: (err) => ContractRuntimeError.make(
          `Failed to parse argument with index ${idx}`,
          ContractRuntimeError.make(
            `Failed to parse string '${args[idx]}' as type of ${typeNodeName(type!)}`,
            err
          )
        )
      });
      if (Either.isLeft(transformedArg)) return transformedArg;
      transformedArgs.push(transformedArg.right);
    }
    return Either.right(transformedArgs);
  };

const makeArgumentParser =
  <C extends Contract.Contract<PS>, PS>(path: Path.Path, fs: FileSystem.FileSystem, baseAssetFolderPath: string) =>
  (compiledContract: CompiledContract.CompiledContract<C, PS>) =>
    Effect.gen(function* () {
      const assetsPath = CompiledContract.getCompiledAssetsPath(compiledContract);
      const tsDeclFilePath = path.join(path.resolve(baseAssetFolderPath, assetsPath), CONTRACT_FOLDER, CONTRACT_DECLARATION_FILE);
      const tsHost = new BasicHost({
        [tsDeclFilePath]: {
          file: TS.ScriptSnapshot.fromString(yield* fs.readFileString(tsDeclFilePath)),
          version: 1
        }
      });
      const tsLangService = TS.createLanguageService(tsHost, TS.createDocumentRegistry());
      const sourceFile = tsLangService.getProgram()!.getSourceFile(tsDeclFilePath);
      const impureCircuitsTypeNode = sourceFile?.statements.find(
        (_) => TS.isTypeAliasDeclaration(_)
          && _.name.escapedText === 'ImpureCircuits'
          && _.type.kind === TS.SyntaxKind.TypeLiteral
      ) as TS.TypeAliasDeclaration;
      const circuitMethodSignatureNodes =
        (impureCircuitsTypeNode.type as TS.TypeLiteralNode).members as TS.NodeArray<TS.MethodSignature>;
      const contractClassNode = sourceFile?.statements.find(
        (_) => TS.isClassDeclaration(_) && _.name!.escapedText === 'Contract'
      ) as TS.ClassDeclaration;
      const initialStateMethodSignatureNode = contractClassNode.members.find(
        (_) => TS.isMethodDeclaration(_)
          && (_.name as TS.Identifier).escapedText === 'initialState'
      );

      return {
        parseInitializationArgs: (args) => transformParams(args, (initialStateMethodSignatureNode as TS.MethodDeclaration).parameters.slice(1).map((_) => _.type!)) as Either.Either<Contract.Contract.InitializeParameters<C>, ContractRuntimeError.ContractRuntimeError>,
        parseCircuitArgs: (circuitId, args) => {
          const circuitNode = circuitMethodSignatureNodes.find((_) => (_.name as TS.Identifier)!.escapedText === circuitId);
          if (!circuitNode) {
            return Either.left(ContractRuntimeError.make(`Circuit '${circuitId}' not found on the Compact generated TypeScript declaration.`))
          }
          return transformParams(args, circuitNode.parameters.slice(1).map((_) => _.type!)) as Either.Either<Contract.Contract.CircuitParameters<C, Contract.ImpureCircuitId>, ContractRuntimeError.ContractRuntimeError>;
        }
      } satisfies CompiledContractReflection.CompiledContractReflection.ArgumentParser<C, PS>;
    });

export const layer = (baseAssetFolderPath = '.') => Layer.effect(
  CompiledContractReflection.CompiledContractReflection,
  Effect.gen(function* () {
    const path = yield* Path.Path;
    const fs = yield* FileSystem.FileSystem;

    return CompiledContractReflection.CompiledContractReflection.of({
      createArgumentParser: makeArgumentParser(path, fs, baseAssetFolderPath)
    })
  })
);

================
File: compact-js/compact-js-command/src/effect/internal/contractState.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { ContractRuntimeError } from '@midnight-ntwrk/compact-js/effect';
import { ContractState } from '@midnight-ntwrk/compact-runtime';
import { ContractState as LedgerContractState } from '@midnight-ntwrk/ledger';
import { Effect } from 'effect';

/** @internal */
export const asLedgerContractState: (
  contractState: ContractState
) => Effect.Effect<LedgerContractState, ContractRuntimeError.ContractRuntimeError> =
  (state) => Effect.try({
    try: () => LedgerContractState.deserialize(state.serialize()),
    catch: (err) => ContractRuntimeError.make('Unexpected error converting runtime contract state', err),
  });

/** @internal */
export const asLedgerContractStateFromBytes: (
  bytes: Uint8Array
) => Effect.Effect<LedgerContractState, ContractRuntimeError.ContractRuntimeError> =
  (bytes) => Effect.try({
    try: () => LedgerContractState.deserialize(bytes),
    catch: (err) => ContractRuntimeError.make('Unexpected error deserializing ledger contract state from bytes', err),
  });

/** @internal */
export const asContractState: (
  contractState: LedgerContractState
) => Effect.Effect<ContractState, ContractRuntimeError.ContractRuntimeError> =
  (state) => Effect.try({
    try: () => ContractState.deserialize(state.serialize()),
    catch: (err) => ContractRuntimeError.make('Unexpected error converting ledger contract state', err),
  });

================
File: compact-js/compact-js-command/src/effect/internal/deployCommand.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type Command } from '@effect/cli';
import { FileSystem } from '@effect/platform';
import { type ContractExecutable, ContractRuntimeError } from '@midnight-ntwrk/compact-js/effect';
import { encodeZswapLocalState } from '@midnight-ntwrk/compact-runtime';
import {
  ContractDeploy,
  Intent
} from '@midnight-ntwrk/ledger';
import { type ConfigError, Duration, Effect } from 'effect';

import * as CompiledContractReflection from '../CompiledContractReflection.js';
import { type ConfigCompiler } from '../ConfigCompiler.js';
import * as InternalArgs from './args.js';
import * as InternalCommand from './command.js';
import * as ContractState from './contractState.js';
import { encodeZswapLocalStateObject } from './encodedZswapLocalStateSchema.js'
import * as InternalOptions from './options.js';

/** @internal */
export type Args = Command.Command.ParseConfig<typeof Args>;
/** @internal */
export const Args = { args: InternalArgs.contractArgs };

/** @internal */
export type Options = Command.Command.ParseConfig<typeof Options>;
/** @internal */
export const Options = {
  signingKey: InternalOptions.signingKey,
  outputFilePath: InternalOptions.outputFilePath,
  outputPrivateStateFilePath: InternalOptions.outputPrivateStateFilePath,
  outputZswapLocalStateFilePath: InternalOptions.outputZswapLocalStateFilePath
}

/** @internal */
export const handler: (inputs: Args & Options, moduleSpec: ConfigCompiler.ModuleSpec) =>
  Effect.Effect<
    void,
    ContractExecutable.ContractExecutionError | ConfigError.ConfigError,
    CompiledContractReflection.CompiledContractReflection | FileSystem.FileSystem
  > =
  (
    {
      outputFilePath,
      outputPrivateStateFilePath,
      outputZswapLocalStateFilePath,
      args
    },
    moduleSpec
  ) => Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    const { module: { default: contractModule } } = moduleSpec;
    const contractReflector = yield* CompiledContractReflection.CompiledContractReflection;
    const argsParser = yield* contractReflector.createArgumentParser(contractModule.contractExecutable.compiledContract);
    const result = yield* contractModule.contractExecutable.initialize(
      contractModule.createInitialPrivateState(),
      ...(yield* argsParser.parseInitializationArgs(args))
    );
    const intent = Intent.new(yield* InternalCommand.ttl(Duration.minutes(10)))
      .addDeploy(new ContractDeploy(yield* ContractState.asLedgerContractState(result.public.contractState)));

    yield* fs.writeFile(outputFilePath, intent.serialize());
    yield* fs.writeFileString(outputPrivateStateFilePath, JSON.stringify(result.private.privateState));
    yield* fs.writeFileString(
      outputZswapLocalStateFilePath,
      JSON.stringify(
        yield* encodeZswapLocalStateObject(encodeZswapLocalState(result.private.zswapLocalState))
      )
    );
  }).pipe(
    Effect.mapError(
      (err) => ContractRuntimeError.make('Failed to initialize contract', err)
    )
  );

================
File: compact-js/compact-js-command/src/effect/internal/encodedZswapLocalStateSchema.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as Schema from 'effect/Schema';

export const EncodedCoinPublicKeySchema = Schema.Struct({
  bytes: Schema.Uint8Array
});

export const EncodedContractAddressSchema = Schema.Struct({
  bytes: Schema.Uint8Array
});

export const EncodedQualifiedShieldedCoinInfoSchema = Schema.Struct({
  nonce: Schema.Uint8Array,
  color: Schema.Uint8Array,
  value: Schema.BigInt,
  mt_index: Schema.BigInt
});

export const EncodedShieldedCoinInfoSchema = Schema.Struct({
  nonce: Schema.Uint8Array,
  color: Schema.Uint8Array,
  value: Schema.BigInt
});

export const EncodedRecipientSchema = Schema.Struct({
  is_left: Schema.Boolean,
  left: EncodedCoinPublicKeySchema,
  right: EncodedContractAddressSchema
});

export const EncodedZswapLocalStateSchema = Schema.Struct({
  coinPublicKey: EncodedCoinPublicKeySchema,
  currentIndex: Schema.BigInt,
  inputs: Schema.Array(EncodedQualifiedShieldedCoinInfoSchema),
  outputs: Schema.Array(Schema.Struct({
    coinInfo: EncodedShieldedCoinInfoSchema,
    recipient: EncodedRecipientSchema
  }))
});

export const encodeZswapLocalStateObject = Schema.encodeUnknown(EncodedZswapLocalStateSchema);
export const decodeZswapLocalStateObject = Schema.decodeUnknown(EncodedZswapLocalStateSchema);

================
File: compact-js/compact-js-command/src/effect/internal/maintainCircuitCommand.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type Command } from '@effect/cli';
import { FileSystem } from '@effect/platform';
import { Contract, type ContractExecutable, ContractRuntimeError } from '@midnight-ntwrk/compact-js/effect';
import { Intent } from '@midnight-ntwrk/ledger';
import { type ConfigError, Duration, Effect, Option } from 'effect';

import { type ConfigCompiler } from '../ConfigCompiler.js';
import * as InternalArgs from './args.js';
import * as InternalCommand from './command.js';
import * as ContractState from './contractState.js';
import * as InternalMaintainCommand from './maintainCommand.js';
import * as InternalOptions from './options.js';

/** @internal */
export type Args = Command.Command.ParseConfig<typeof Args>;
/** @internal */
export const Args = {
  ...InternalMaintainCommand.Args,
  circuitId: InternalArgs.circuitId,
  verifierKeyPath: InternalArgs.verifierKeyPath
};

/** @internal */
export type Options = Command.Command.ParseConfig<typeof Options>;
/** @internal */
export const Options = {
  ...InternalMaintainCommand.Options,
  signingKey: InternalOptions.signingKey,
}

const removeCircuit = (
  contract: ContractExecutable.ContractExecutable<any, any>, // eslint-disable-line @typescript-eslint/no-explicit-any
  circuitId: Contract.ImpureCircuitId,
  contractContext: ContractExecutable.ContractExecutable.ContractContext
) => contract.removeContractOperation(circuitId, contractContext);

const addOrReplaceCircuit = (
  contract: ContractExecutable.ContractExecutable<any, any>, // eslint-disable-line @typescript-eslint/no-explicit-any
  circuitId: Contract.ImpureCircuitId,
  verifierKey: Contract.VerifierKey,
  contractContext: ContractExecutable.ContractExecutable.ContractContext
) => contract.addOrReplaceContractOperation(circuitId, verifierKey, contractContext);

/** @internal */
export const handler: (inputs: Args & Options, moduleSpec: ConfigCompiler.ModuleSpec) =>
  Effect.Effect<
    void,
    ContractExecutable.ContractExecutionError | ConfigError.ConfigError,
    FileSystem.FileSystem
  > =
  (
    { inputFilePath, outputFilePath, address, circuitId, verifierKeyPath },
    moduleSpec
  ) => Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    const { module: { default: contractModule } } = moduleSpec;
    const ledgerContractState = yield* fs.readFile(inputFilePath).pipe(
      Effect.flatMap(ContractState.asLedgerContractStateFromBytes)
    );
    const contractContext: ContractExecutable.ContractExecutable.ContractContext = {
      address,
      contractState: yield* ContractState.asContractState(ledgerContractState)
    }
    const result = yield* Option.match(verifierKeyPath, {
      onSome: (filePath) => fs.readFile(filePath).pipe(
        Effect.flatMap((data) => addOrReplaceCircuit(
          contractModule.contractExecutable,
          Contract.ImpureCircuitId(circuitId),
          Contract.VerifierKey(data),
          contractContext)
        )
      ),
      onNone: () => removeCircuit(contractModule.contractExecutable, Contract.ImpureCircuitId(circuitId), contractContext)
    });
    const intent = Intent.new(yield* InternalCommand.ttl(Duration.minutes(10)))
      .addMaintenanceUpdate(result.public.maintenanceUpdate);
    yield* fs.writeFile(outputFilePath, intent.serialize());
  }).pipe(
    Effect.mapError(
      (err) => ContractRuntimeError.make('Failed to apply maintenance operation', err)
    )
  );

================
File: compact-js/compact-js-command/src/effect/internal/maintainCommand.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type Command } from '@effect/cli';
import { type ContractExecutable, ContractRuntimeError } from '@midnight-ntwrk/compact-js/effect';
import { type ConfigError, Effect } from 'effect';

import { type ConfigCompiler } from '../ConfigCompiler.js';
import * as InternalArgs from './args.js';
import * as InternalOptions from './options.js';

/** @internal */
export type Args = Command.Command.ParseConfig<typeof Args>;
/** @internal */
export const Args = { 
  address: InternalArgs.contractAddress
};

/** @internal */
export type Options = Command.Command.ParseConfig<typeof Options>;
/** @internal */
export const Options = {
  inputFilePath: InternalOptions.inputFilePath,
  outputFilePath: InternalOptions.outputFilePath
}

/** @internal */
export const handler: (inputs: Args & Options, moduleSpec: ConfigCompiler.ModuleSpec) =>
  Effect.Effect<
    void,
    ContractExecutable.ContractExecutionError | ConfigError.ConfigError
  > =
  (_, __) => Effect.gen(function* () {
    // TODO: The root `maintain` command. Currently there is no logic attached to this command, but in the
    // future, perhaps it could produce a 'diff' of the circuits found in the currently compiled assets vs.
    // what it present in the given contract state.
    return yield* ContractRuntimeError.make('This command is not implemented.');
  });

================
File: compact-js/compact-js-command/src/effect/internal/maintainContractCommand.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type Command } from '@effect/cli';
import { FileSystem } from '@effect/platform';
import { type ContractExecutable, ContractRuntimeError } from '@midnight-ntwrk/compact-js/effect';
import { Intent } from '@midnight-ntwrk/ledger';
import { type ConfigError, Duration, Effect, Option } from 'effect';

import { type ConfigCompiler } from '../ConfigCompiler.js';
import * as InternalArgs from './args.js';
import * as InternalCommand from './command.js';
import * as ContractState from './contractState.js';
import * as InternalMaintainCommand from './maintainCommand.js';
import * as InternalOptions from './options.js';

/** @internal */
export type Args = Command.Command.ParseConfig<typeof Args>;
/** @internal */
export const Args = {
  ...InternalMaintainCommand.Args,
  newSigningKey: InternalArgs.signingKey
};

/** @internal */
export type Options = Command.Command.ParseConfig<typeof Options>;
/** @internal */
export const Options = {
  ...InternalMaintainCommand.Options,
  signingKey: InternalOptions.signingKey,
}

/** @internal */
export const handler: (inputs: Args & Options, moduleSpec: ConfigCompiler.ModuleSpec) =>
  Effect.Effect<
    void,
    ContractExecutable.ContractExecutionError | ConfigError.ConfigError,
    FileSystem.FileSystem
  > =
  (
    { address, inputFilePath, newSigningKey, outputFilePath },
    moduleSpec
  ) => Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    const { module: { default: contractModule } } = moduleSpec;
    const ledgerContractState = yield* fs.readFile(inputFilePath).pipe(
      Effect.flatMap(ContractState.asLedgerContractStateFromBytes)
    );
    const result = yield* contractModule.contractExecutable.replaceContractMaintenanceAuthority(
      Option.some(newSigningKey),
      {
        address,
        contractState: yield* ContractState.asContractState(ledgerContractState),
      }
    );
    const intent = Intent.new(yield* InternalCommand.ttl(Duration.minutes(10)))
      .addMaintenanceUpdate(result.public.maintenanceUpdate);
    yield* fs.writeFile(outputFilePath, intent.serialize());
  }).pipe(
    Effect.mapError(
      (err) => ContractRuntimeError.make('Failed to apply maintenance operation', err)
    )
  );

================
File: compact-js/compact-js-command/src/effect/internal/options.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type Command, Options } from '@effect/cli';
import { Path } from '@effect/platform';
import * as CoinPublicKey from '@midnight-ntwrk/platform-js/effect/CoinPublicKey';
import * as SigningKey from '@midnight-ntwrk/platform-js/effect/SigningKey';
import { ConfigProvider, Effect, Option,Schema } from 'effect';

/** @internal */
export const config = Options.file('config', { exists: 'either' }).pipe(
  Options.withAlias('c'),
  Options.withDefault('contract.config.ts'),
  Options.mapEffect((filePath) => Path.Path.pipe(Effect.map((path) => path.resolve(filePath))))
);

/** @internal */
export const coinPublicKey = Options.text('coin-public').pipe(
  Options.withAlias('p'),
  Options.withDescription('A user public key capable of receiving Zswap coins, hex or Bech32m encoded.'),
  Options.withSchema(Schema.Union(
    Schema.String.pipe(Schema.fromBrand(CoinPublicKey.Hex)),
    Schema.String.pipe(Schema.fromBrand(CoinPublicKey.Bech32m))
  ).annotations({ title: 'coin-public' })),
  Options.optional
);

/** @internal */
export const signingKey = Options.text('signing').pipe(
  Options.withAlias('s'),
  Options.withDescription('A public BIP-340 signing key, hex encoded.'),
  Options.withSchema(Schema.String.pipe(Schema.fromBrand(SigningKey.SigningKey)).annotations({ title: 'signing' })),
  Options.optional
);

/** @internal */
export const outputFilePath = Options.file('output', { exists: 'either' }).pipe(
  Options.withAlias('o'),
  Options.withDescription('A file path of where the generated \'Intent\' data should be written.'),
  Options.withDefault('output.bin'),
  Options.mapEffect((filePath) => Path.Path.pipe(Effect.map((path) => path.resolve(filePath))))
);

/** @internal */
export const outputPrivateStateFilePath = Options.file('output-ps', { exists: 'either' }).pipe(
  Options.withDescription('A file path of where the generated \'PrivateState\' data should be written.'),
  Options.withDefault('output.ps.json'),
  Options.mapEffect((filePath) => Path.Path.pipe(Effect.map((path) => path.resolve(filePath))))
);

/** @internal */
export const outputZswapLocalStateFilePath = Options.file('output-zswap', { exists: 'either' }).pipe(
  Options.withDescription('A file path of where the generated \'ZswapLocalState\' data should be written.'),
  Options.withDefault('zswap.json'),
  Options.mapEffect((filePath) => Path.Path.pipe(Effect.map((path) => path.resolve(filePath))))
);

/** @internal */
export const outputResultFilePath = Options.file('output-result', { exists: 'either' }).pipe(
  Options.withDescription('A file path of where the invoked circuit result data should be written.'),
  Options.withDefault('result.json'),
  Options.mapEffect((filePath) => Path.Path.pipe(Effect.map((path) => path.resolve(filePath))))
);

/** @internal */
export const network = Options.text('network').pipe(
  Options.withAlias('n'),
  Options.withDescription('Optional network identifier. Defaults to the Midnight \'MainNet\' if not specified.'),
  Options.optional
);

/** @internal */
export const inputFilePath = Options.file('input', { exists: 'either' }).pipe(
  Options.withAlias('i'),
  Options.withDescription('A file path of where the current onchain (or ledger), state data can be read.'),
  Options.mapEffect((filePath) => Path.Path.pipe(Effect.map((path) => path.resolve(filePath))))
);

/** @internal */
export const inputPrivateStateFilePath = Options.file('input-ps', { exists: 'either' }).pipe(
  Options.withDescription('A file path of where the current private state data can be read.'),
  Options.mapEffect((filePath) => Path.Path.pipe(Effect.map((path) => path.resolve(filePath))))
);

/** @internal */
export const inputZswapLocalStateFilePath = Options.file('input-zswap', { exists: 'either' }).pipe(
  Options.withDescription('A file path of where the current Zswap local state data can be read.'),
  Options.optional,
  Options.mapEffect((_) => Option.match(_, {
    onSome: (filePath) => Path.Path.pipe(Effect.map((path) => Option.some(path.resolve(filePath)))),
    onNone: () => Effect.succeed(Option.none())
  }))
);

export type ConfigOptionInput = Command.Command.ParseConfig<{
  config: typeof config;
}>;

/**
 * All the options that contribute to the underlying `ConfigurationProvider`.
 *
 * @see {@link asConfigProvider}
 * @internal
 */
export type AllConfigurableOptionInputs = Command.Command.ParseConfig<{
  coinPublicKey: typeof coinPublicKey,
  signingKey: typeof signingKey,
  network: typeof network
}>;

export const asConfigProvider: (configurableOptions: Partial<AllConfigurableOptionInputs>) => ConfigProvider.ConfigProvider =
  (configurableOptions) => ConfigProvider.fromJson({
    keys: {
      coinPublic: Option.getOrUndefined(configurableOptions.coinPublicKey ?? Option.none()),
      signing: Option.getOrUndefined(configurableOptions.signingKey ?? Option.none())
    },
    network: Option.getOrUndefined(configurableOptions.network ?? Option.none())
  });

================
File: compact-js/compact-js-command/src/effect/CommandConfigProvider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as Configuration from '@midnight-ntwrk/platform-js/effect/Configuration';
import { ConfigProvider } from 'effect';

/** @internal */
export const make: (jsonConfg: unknown, cliConfigProvider: ConfigProvider.ConfigProvider) =>
  ConfigProvider.ConfigProvider =
    (jsonConfig, cliConfigProvider) => cliConfigProvider.pipe(
      ConfigProvider.orElse(() => Configuration.configProvider(jsonConfig))
    );

================
File: compact-js/compact-js-command/src/effect/CompiledContractReflection.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type FileSystem, type Path } from '@effect/platform';
import { type PlatformError } from '@effect/platform/Error';
import { type CompiledContract, type Contract, type ContractRuntimeError } from '@midnight-ntwrk/compact-js/effect';
import { Context, type Effect,type Layer } from 'effect';

import * as internal from './internal/compiledContractReflection.js';

/**
 * Provides utilities for inspecting a compiled Compact contract.
 * 
 * @category services
 */
export class CompiledContractReflection extends Context.Tag('compact-js-command/CompiledContractReflection')<
  CompiledContractReflection,
  CompiledContractReflection.Service
>() {}

export declare namespace CompiledContractReflection {
  /**
   * Provides utilities for inspecting a compiled Compact contract.
   */
  export interface Service {
    /**
     * Creates a parser that transforms an array of string, into an array of values, typed by the reflected
     * argument types of the compiled Compact contract's initializer or circuits.
     * 
     * @param compiledContract The Compact compiled contract.
     * @returns An `Effect` that yields an {@link ArgumentParser} for `compiledContract`; or a `PlatformError` 
     * if the Compact generated TypeScript declaration file could not be found.
     */
    readonly createArgumentParser: <C extends Contract.Contract<PS>, PS>(
      compiledContract: CompiledContract.CompiledContract<C, PS, never>
    ) => Effect.Effect<ArgumentParser<C, PS>, PlatformError>
  }

  /**
   * Uses the argument types of a compiled Compact contract's initializer or circuits, to transform an array
   * of string into an array of values that can be used when executing the contract.
   */
  export interface ArgumentParser<C extends Contract.Contract<PS>, PS> {
    /**
     * Transforms an array of strings into an array of contract initialization arguments.
     * 
     * @param args The array of strings to be transformed.
     * @returns An `Effect` that yields an array of initialization arguments; or fails with a 
     * {@link ContractRuntimeError.ContractRuntimeError | ContractRuntimeError}.
     */
    parseInitializationArgs(args: string[]): Effect.Effect<Contract.Contract.InitializeParameters<C>, ContractRuntimeError.ContractRuntimeError>;

    /**
     * Transforms an array of strings into an array of circuit arguments.
     * 
     * @param impureCircuitId The identifier of the circuit that will be invoked with `args`.
     * @param args The array of strings to be transformed.
     * @returns An `Effect` that yields an array of circuit arguments; or fails with a 
     * {@link ContractRuntimeError.ContractRuntimeError | ContractRuntimeError}.
     */
    parseCircuitArgs<K extends Contract.ImpureCircuitId<C>>(
      impureCircuitId: K,
      args: string[]
    ): Effect.Effect<Contract.Contract.CircuitParameters<C, K>, ContractRuntimeError.ContractRuntimeError>;
  }

  /**
   * Represents an {@link ArgumentParser} for any contract.
   */
  export type AnyArgumentParser = ArgumentParser<any, any>; // eslint-disable-line @typescript-eslint/no-explicit-any
}

/**
 * A {@link CompiledContractReflection} implementation that uses a TypeScript declaration file (*.d.ts) produced
 * by the Compact compiler, to reflect over an associated contract's types.
 * 
 * @param baseAssetFolderPath A base path to a folder containing the compiled contract assets.
 * 
 * @category layers
 */
export const layer: (baseAssetFolderPath?: string) => Layer.Layer<
  CompiledContractReflection,
  PlatformError,
  FileSystem.FileSystem | Path.Path
> = internal.layer;

================
File: compact-js/compact-js-command/src/effect/ConfigCompilationError.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as Error from '@effect/platform/Error';
import { hasProperty } from 'effect/Predicate';

const TypeId: unique symbol = Symbol.for('compact-js-command/effect/ConfigCompilationError');
type TypeId = typeof TypeId;

/**
 * An error occurred while compiling the contract configuration file.
 *
 * @category errors
 */
export class ConfigCompilationError extends Error.TypeIdError(TypeId, 'ConfigCompilationError')<{
  /** A displayable message. */
  readonly message: string;
  /** An array of diagnostic messages from the TypeScript compiler. */
  readonly diagnostics: { messageText: string }[];
}> { }

/**
 * Determines if a value is a config compilation error.
 *
 * @param u The value to check.
 * @returns `true` if `u` is a {@link ConfigCompilationError}; `false` otherwise.
 *
 * @category guards
 */
export const isConfigCompilationError = (u: unknown): u is ConfigCompilationError => hasProperty(u, TypeId);

/**
 * Creates a new {@link ConfigCompilationError}.
 * 
 * @category constructors
 */
export const make: (message: string, diagnostics: { messageText: string }[]) => ConfigCompilationError =
  (message, diagnostics) => new ConfigCompilationError({ message, diagnostics });

================
File: compact-js/compact-js-command/src/effect/ConfigCompiler.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { FileSystem,Path } from '@effect/platform';
import { type PlatformError } from '@effect/platform/Error';
import type { Contract,ContractExecutable } from '@midnight-ntwrk/compact-js/effect';
import { Context, Effect, Layer, Option } from 'effect';
import { create } from 'ts-node';

import * as ConfigCompilationError from './ConfigCompilationError.js';
import * as ConfigError from './ConfigError.js';

/**
 * Compiles a contract configuration file into a JavaScript module.
 * 
 * @category services
 */
export class ConfigCompiler extends Context.Tag('compact-js-command/ConfigCompiler')<
  ConfigCompiler,
  ConfigCompiler.Service
>() {}

export declare namespace ConfigCompiler {
  /**
   * Represents the _shape_ of an exported configuration module.
   */
  export type ModuleExport<PS = any> = { // eslint-disable-line @typescript-eslint/no-explicit-any
    default: {
      config: Record<string, any>; // eslint-disable-line @typescript-eslint/no-explicit-any
      createInitialPrivateState: () => PS;
      contractExecutable: ContractExecutable.ContractExecutable<Contract.Contract<PS>, PS>;
    }
  }

  /**
   * Describes a configuration module, the JavaScript module compiled from a contract configuration file.
   */
  export type ModuleSpec<PS = any> = { // eslint-disable-line @typescript-eslint/no-explicit-any
    moduleImportDirectoryPath: string;
    module: ModuleExport<PS>;
  }

  export interface Service {
    /**
     * Compiles a contract configuration file.
     *
     * @param filePath A file path to the contract configuration file.
     * @returns An `Effect` that yields a {@link ModuleSpec}; or fails with a
     * {@link ConfigError.ConfigError | ConfigError} or a 
     * {@link ConfigCompilationError.ConfigCompilationError | ConfigCompilationError}.
     */
    readonly compile: (filePath: string) => Effect.Effect<
      ModuleSpec,
      ConfigError.ConfigError | ConfigCompilationError.ConfigCompilationError
    >;
  }
}

/**
 * A {@link ConfigCompiler} implementation that uses TypeScript to compile the given file path and then load
 * it as a JavaScript module.
 * 
 * @category layers
 */
export const layer = Layer.effect(
  ConfigCompiler,
  Effect.gen(function* () {
    const path = yield* Path.Path;
    const fs = yield* FileSystem.FileSystem;

    const getFilePathProperties = (filePath: string) => Effect.gen(function* () {
      const absoluteFilePath = path.resolve(filePath);
      const parsedAbsoluteFilePath = path.parse(absoluteFilePath);
      const absoluteFileImportPath = path.join(parsedAbsoluteFilePath.dir, `${parsedAbsoluteFilePath.name}.js`);
      const filePathModifiedTime = (yield* fs.stat(absoluteFilePath)).mtime;
      const fileImportPathModifiedTime = (yield* fs.exists(absoluteFileImportPath))
        ? (yield* fs.stat(absoluteFileImportPath)).mtime
        : Option.some(Option.getOrThrow(filePathModifiedTime));

      return {
        absoluteFilePath,
        absoluteWorkingDirectory: parsedAbsoluteFilePath.dir,
        absoluteFileImportPath,
        requiresCompilation: Option.getOrThrow(fileImportPathModifiedTime) <= Option.getOrThrow(filePathModifiedTime)
      };
    });

    const transpileTypeScript: (_: Effect.Effect.Success<ReturnType<typeof getFilePathProperties>>) =>
      Effect.Effect<string, PlatformError | ConfigCompilationError.ConfigCompilationError | ConfigError.ConfigError> =
        ({ absoluteFilePath, absoluteFileImportPath, absoluteWorkingDirectory, requiresCompilation }) => Effect.gen(function* () {
            if (!requiresCompilation) {
              return absoluteFileImportPath;
            }

            try {
              const tsNodeService = create({ cwd: absoluteWorkingDirectory });

              yield* fs.writeFileString(
                absoluteFileImportPath,
                tsNodeService.compile(yield* fs.readFileString(absoluteFilePath), absoluteFilePath)
              );
            }
            catch (err: any) { // eslint-disable-line @typescript-eslint/no-explicit-any
              return yield* err?.name === 'TSError'
                ? ConfigCompilationError.make('Failed to compile TypeScript configuration', err.diagnostics)
                : ConfigError.make('Unexpected error while compiling TypeScript configuration', err);
            }

            return absoluteFileImportPath;
        });

    return ConfigCompiler.of({
      compile: (filePath: string) => getFilePathProperties(filePath).pipe(
        Effect.flatMap(transpileTypeScript),
        Effect.flatMap((fileImportPath) => Effect.tryPromise<ConfigCompiler.ModuleSpec>(
          async () => ({
            moduleImportDirectoryPath: path.dirname(fileImportPath),
            module: await import(fileImportPath)
          })
        )),
        Effect.mapError((err) => ConfigError.make(`Error loading configuration '${filePath}'`, err))
      )
    });
  })
)

================
File: compact-js/compact-js-command/src/effect/ConfigError.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as Error from '@effect/platform/Error';
import { hasProperty } from 'effect/Predicate';

const TypeId: unique symbol = Symbol.for('compact-js-command/effect/ConfigError');
type TypeId = typeof TypeId;

/**
 * An error occurred while reading or processing the contract configuration file.
 *
 * @category errors
 */
export class ConfigError extends Error.TypeIdError(TypeId, 'ConfigError')<{
  /** A displayable message. */
  readonly message: string;
  /** Indicates a more specific cause of the error. */
  readonly cause?: unknown;
}> { }

/**
 * Determines if a value is a configuration error.
 *
 * @param u The value to check.
 * @returns `true` if `u` is a {@link ConfigError}; `false` otherwise.
 *
 * @category guards
 */
export const isConfigError = (u: unknown): u is ConfigError => hasProperty(u, TypeId);

/**
 * Creates a new {@link ConfigError}.
 *
 * @category constructors
 */
export const make: (message: string, cause?: unknown) => ConfigError = (message, cause) =>
  new ConfigError({ message, cause });

================
File: compact-js/compact-js-command/src/effect/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Command } from '@effect/cli';

import * as InternalCircuitCommand from './internal/circuitCommand.js';
import * as InternalCommand from './internal/command.js';
import * as InternalDeployCommand from './internal/deployCommand.js';
import * as InternalMaintainCircuitCommand from './internal/maintainCircuitCommand.js';
import * as InternalMaintainContractCommand from './internal/maintainContractCommand.js';

export const deployCommand = Command.make(
  'deploy',
  {
    ...InternalCommand.GlobalOptions,
    ...InternalDeployCommand.Options,
    ...InternalDeployCommand.Args
  }).pipe(
  Command.withDescription('Initialize a new contract instance and returns a ContractDeploy intent for it.'),
  Command.withHandler(InternalCommand.invocationHandler(InternalDeployCommand.handler))
);

export const circuitCommand = Command.make(
  'circuit',
  {
    ...InternalCommand.GlobalOptions,
    ...InternalCircuitCommand.Options,
    ...InternalCircuitCommand.Args
  }).pipe(
    Command.withDescription('Invokes a circuit on a contract instance and returns a ContractCall intent for it.'),
    Command.withHandler(InternalCommand.invocationHandler(InternalCircuitCommand.handler))
  );

export const maintainCommand = Command.make('maintain').pipe(
    Command.withDescription('Performs maintenance operations on deployed contract state and returns a MaintenanceUpdate intent for it.'),
    Command.withSubcommands([
      Command.make(
        'contract',
        {
          ...InternalCommand.GlobalOptions,
          ...InternalMaintainContractCommand.Options,
          ...InternalMaintainContractCommand.Args
        }).pipe(
          Command.withDescription('Updates the Contract Maintenance Authority for deployed contract state and returns a MaintenanceUpdate intent for it.'),
          Command.withHandler(InternalCommand.invocationHandler(InternalMaintainContractCommand.handler))
        ),
      Command.make(
        'circuit',
        {
          ...InternalCommand.GlobalOptions,
          ...InternalMaintainCircuitCommand.Options,
          ...InternalMaintainCircuitCommand.Args
        }).pipe(
          Command.withDescription('Updates the circuits associated with deployed contract state and returns a MaintenanceUpdate intent for it.'),
          Command.withHandler(InternalCommand.invocationHandler(InternalMaintainCircuitCommand.handler))
        )
    ])
  );

export * as CompiledContractReflection from './CompiledContractReflection.js';
export * as ConfigCompilationError from './ConfigCompilationError.js';
export * as ConfigCompiler from './ConfigCompiler.js';
export * as ConfigError from './ConfigError.js';

================
File: compact-js/compact-js-command/src/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { fileURLToPath } from 'node:url';

import { CliConfig,Command } from '@effect/cli';
import { NodeContext, NodeRuntime } from "@effect/platform-node";
import { Effect, Equal, Layer, Logger, LogLevel } from 'effect';

import { circuitCommand, ConfigCompiler, deployCommand, maintainCommand } from './effect/index.js';

// #region Entry Point
// This region of code hosts and executes the commands present in the package if this module was loaded
// as the root of the process.
const isProcessRootModule = () => {
  try {
    if (!import.meta.url.startsWith("file:")) {
      return false;
    }
    const urlPath = fileURLToPath(import.meta.url);
    return Equal.equals(urlPath, process.argv[1]) || urlPath.startsWith(process.argv[1]);
  }
  catch {
    return false;
  }
}

if (isProcessRootModule()) {
  const cli = Command.run(
    Command.make('cptexec').pipe(
      Command.withDescription('Executes Compact compiled contracts from the command line.'),
      Command.withSubcommands([ deployCommand, circuitCommand, maintainCommand ])
    ),
    {
      name: 'Compact Contract Execute',
      version: '0.0.0'
    }
  );

  cli(process.argv).pipe(
    Logger.withMinimumLogLevel(LogLevel.None),
    Effect.provide(Layer.mergeAll(
      ConfigCompiler.layer.pipe(Layer.provideMerge(NodeContext.layer)),
      CliConfig.layer({ showBuiltIns: false })
    )),
    NodeRuntime.runMain({ disableErrorReporting: true })
  );
}

// #endregion

export * from './effect/index.js';

================
File: compact-js/compact-js-command/test/contract/counter/.gitignore
================
*.js
*.bin

================
File: compact-js/compact-js-command/test/contract/counter/contract.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { CompiledContract, type Contract,ContractExecutable } from '@midnight-ntwrk/compact-js/effect';

import { Contract as C_ } from '../../../../compact-js/test/contract/managed/counter/contract/index';

type PrivateState = {
  count: number;
};

type CounterContract = C_<PrivateState>;
const CounterContract = C_;

const witnesses: Contract.Contract.Witnesses<CounterContract> = {
  private_increment: ({ privateState }) => [{ count: privateState.count + 1 }, []]
}

const createInitialPrivateState: () => PrivateState = () => ({
  count: 0
});

export default {
  contractExecutable: CompiledContract.make<CounterContract>('CounterContract', CounterContract).pipe(
    CompiledContract.withWitnesses(witnesses),
    CompiledContract.withCompiledFileAssets('../../../../compact-js/test/contract/managed/counter'),
    ContractExecutable.make
  ),
  createInitialPrivateState,
  config: {
    keys: {
      coinPublic: 'd2dc8d175c0ef7d1f7e5b7f32bd9da5fcd4c60fa1b651f1d312986269c2d3c79',
    },
    network: 'undeployed'
  }
}

================
File: compact-js/compact-js-command/test/effect/Circuit.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { resolve } from 'node:path';

import { Command } from '@effect/cli';
import { FileSystem } from '@effect/platform';
import { NodeContext } from '@effect/platform-node';
import { describe, it } from '@effect/vitest';
import { circuitCommand,ConfigCompiler } from '@midnight-ntwrk/compact-js-command/effect';
import { Console,Effect, Layer } from 'effect';

import { ensureRemovePath } from './cleanup.js';
import * as MockConsole from './MockConsole.js';

const COUNTER_CONFIG_FILEPATH = resolve(import.meta.dirname, '../contract/counter/contract.config.ts');
const COUNTER_STATE_FILEPATH = resolve(import.meta.dirname, '../contract/counter/state.bin');
const COUNTER_OUTPUT_FILEPATH = resolve(import.meta.dirname, '../contract/counter/output_circuit.bin');
const COUNTER_OUTPUT_PS_FILEPATH = resolve(import.meta.dirname, '../contract/counter/output_circuit.json');
const COUNTER_OUTPUT_ZSWAP_FILEPATH = resolve(import.meta.dirname, '../contract/counter/output_zswap.json');
const COUNTER_RESULT_FILEPATH = resolve(import.meta.dirname, '../contract/counter/result.json');

const testLayer: Layer.Layer<ConfigCompiler.ConfigCompiler | NodeContext.NodeContext | FileSystem.FileSystem> =
  Effect.gen(function* () {
    const console = yield* MockConsole.make;
    return Layer.mergeAll(
      Console.setConsole(console),
      ConfigCompiler.layer.pipe(Layer.provideMerge(NodeContext.layer))
    );
  }).pipe(Layer.unwrapEffect);

describe('Circuit Command', () => {
  it.effect('should report success with valid setup', () =>
    Effect.gen(function* () {
      const fs = yield* FileSystem.FileSystem;
      yield* fs.writeFileString(COUNTER_OUTPUT_PS_FILEPATH, JSON.stringify({ count: 100 }));

      const cli = Command.run(circuitCommand, { name: 'circuit', version: '0.0.0' });

      yield* cli([
        'node', 'circuit.ts',
        '-c', COUNTER_CONFIG_FILEPATH,
        '--input', COUNTER_STATE_FILEPATH,
        '--input-ps', COUNTER_OUTPUT_PS_FILEPATH,
        '--output', COUNTER_OUTPUT_FILEPATH,
        '--output-ps', COUNTER_OUTPUT_PS_FILEPATH,
        '--output-zswap', COUNTER_OUTPUT_ZSWAP_FILEPATH,
        '--output-result', COUNTER_RESULT_FILEPATH,
        '0a2d0e34db258f640dc2ec410fb0e4eea9cd6f9661ba6a86f0c35a708e1b811a', 'increment'
      ]);

      const lines = yield* MockConsole.getLines({ stripAnsi: true });

      expect(lines.length).toBe(0);
      expect(JSON.parse(yield* fs.readFileString(COUNTER_OUTPUT_PS_FILEPATH))).toMatchObject({ count: 101 });
    }).pipe(
      Effect.ensuring(ensureRemovePath(COUNTER_CONFIG_FILEPATH.replace('.ts', '.js'))),
      Effect.ensuring(ensureRemovePath(COUNTER_OUTPUT_FILEPATH)),
      Effect.ensuring(ensureRemovePath(COUNTER_OUTPUT_PS_FILEPATH)),
      Effect.ensuring(ensureRemovePath(COUNTER_OUTPUT_ZSWAP_FILEPATH)),
      Effect.ensuring(ensureRemovePath(COUNTER_RESULT_FILEPATH)),
      Effect.provide(testLayer)
    ),
    30_000
  );
});

================
File: compact-js/compact-js-command/test/effect/cleanup.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { FileSystem } from '@effect/platform';
import { Effect } from 'effect';

/**
 * Force remove a file or directory.
 *
 * @remarks
 * The returned `Effect` can be safely used with `Effect.ensuring`.
 */
export const ensureRemovePath = (path: string) =>
  FileSystem.FileSystem.pipe(
    Effect.flatMap((fs) => fs.remove(path, { force: true, recursive: true }).pipe(
      Effect.catchAll((_) => Effect.void)
    ))
  );

================
File: compact-js/compact-js-command/test/effect/CompiledContractReflection.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { join } from 'node:path';

import { FileSystem } from '@effect/platform';
import { type PlatformError } from '@effect/platform/Error';
import { NodeContext } from '@effect/platform-node';
import { describe, it } from '@effect/vitest';
import { ContractRuntimeError } from '@midnight-ntwrk/compact-js/effect';
import * as CompiledContract from '@midnight-ntwrk/compact-js/effect/CompiledContract';
import { CompiledContractReflection } from '@midnight-ntwrk/compact-js-command/effect';
import { Effect, Layer, String } from 'effect';

import { ensureRemovePath } from './cleanup.js';

const BASE_PATH = join(import.meta.dirname);
const DECLARATION_FILEPATH = join(BASE_PATH, 'contract', 'index.d.ts');
const testLayer: Layer.Layer<
  CompiledContractReflection.CompiledContractReflection
  | NodeContext.NodeContext,
  PlatformError
> = CompiledContractReflection.layer(BASE_PATH).pipe(Layer.provideMerge(NodeContext.layer));

/**
 * Sets up a dummy contract and context for an `ArgumentParser` test fixture.
 *
 * @param argText A string defining on or more JS/TS arguments (in the form `'argName: argType'`).
 * @param fn A function receiving an `ArgumentParser` that should return an array  from arguments
 * called with it.
 * @returns An `Effect` that yields the parsed arguments defined by `argText`, or fails with a `ContractRuntimeError`
 * if the invocation failed.
 */
const parseArgumentsTest = (
  argText: string,
  fn: (argsParser: CompiledContractReflection.CompiledContractReflection.AnyArgumentParser)
    => Effect.Effect<any[], ContractRuntimeError.ContractRuntimeError> // eslint-disable-line @typescript-eslint/no-explicit-any
) => Effect.gen(function* () {
      const NullContract = (() => ({} as any)) as any; // eslint-disable-line @typescript-eslint/no-explicit-any
      const fs = yield* FileSystem.FileSystem;

      yield* fs.makeDirectory(join(BASE_PATH, 'contract'));
      yield* fs.writeFileString(DECLARATION_FILEPATH, String.stripMargin(`
        |export type ImpureCircuits<T> = {
        | circuit(_: any, ${argText}): void;
        |}
        |
        |export declare class Contract<T, W> {
        | initialState(_: any, ${argText}): void;
        |}
      `));

      const contractReflection = yield* CompiledContractReflection.CompiledContractReflection;
      const argsParser = yield* contractReflection.createArgumentParser(
        CompiledContract.make('NullContract', NullContract).pipe(
          CompiledContract.withWitnesses({} as never),
          CompiledContract.withCompiledFileAssets(BASE_PATH)
        )
      );
      return yield* fn(argsParser);
  }).pipe(
    Effect.ensuring(ensureRemovePath(join(BASE_PATH, 'contract')))
  );

describe.sequential('CompiledContractReflection', () => {
  describe('argument parsing', () => {
    it.each([
      ['bigint', 'abc'],
      ['boolean', 'maybe']
    ])('should fail to parse with an invalid argument (%s)', async (type, invalidValue) => {
      await Effect.runPromise(Effect.gen(function* () {
        expect(yield* parseArgumentsTest(
            `a: ${type}`,
            (_) => _.parseInitializationArgs([invalidValue])
          ).pipe(Effect.flip)
        ).toBeInstanceOf(ContractRuntimeError.ContractRuntimeError);
      }).pipe(Effect.provide(testLayer)));
    });

    it.each([
      ['number', '3'],
      ['bigint', '100'],
      ['boolean', 'true'],
      ['boolean', 'false'],
      ['string', 'hosky'],
      ['Uint8Array', 'ffffff']
    ])('should parse with a valid argument (%s)', async (type, validString) => {
      await Effect.runPromise(Effect.gen(function* () {
        expect(yield* parseArgumentsTest(
            `a: ${type}`,
            (_) => _.parseInitializationArgs([validString])
          )
        ).toHaveLength(1);
      }).pipe(Effect.provide(testLayer)));
    });

    it('should parse multiple arguments', async () => {
      await Effect.runPromise(Effect.gen(function* () {
        expect(yield* parseArgumentsTest(
          'a: bigint, b: string, c: boolean',
          (_) => _.parseInitializationArgs(['100', 'hosky', 'true'])
        )).toStrictEqual([100n, 'hosky', true]);
      }).pipe(Effect.provide(testLayer)));
    });

    it('should fail when parsing an invalid tuple element', async () => {
      await Effect.runPromise(Effect.gen(function* () {
          expect(yield* parseArgumentsTest(
            'a: [bigint, boolean]',
            (_) => _.parseInitializationArgs(['[100, maybe]'])
          ).pipe(Effect.flip)
        ).toBeInstanceOf(ContractRuntimeError.ContractRuntimeError)
      }).pipe(Effect.provide(testLayer)));
    });

    it('should parse multiple valid tuple type elements', async () => {
      await Effect.runPromise(Effect.gen(function* () {
        expect(yield* parseArgumentsTest(
          'a: [bigint, string, boolean]',
          (_) => _.parseInitializationArgs(["[100, 'hosky', true]"])
        )).toStrictEqual([[100n, 'hosky', true]]);
      }).pipe(Effect.provide(testLayer)));
    });

    it('should parse nested tuple type elements', async () => {
      await Effect.runPromise(Effect.gen(function* () {
        expect(yield* parseArgumentsTest(
          'a: [bigint, [string, boolean], boolean]',
          (_) => _.parseInitializationArgs(["[100, ['hosky', false], true]"])
        )).toStrictEqual([[100n, ['hosky', false], true]]);
      }).pipe(Effect.provide(testLayer)));
    });


    it('should parse object literal type elements', async () => {
      await Effect.runPromise(Effect.gen(function* () {
        const parsedArgs = yield* parseArgumentsTest(
          'a: { x: Uint8Array; y: bigint; z: string; }',
          (_) => _.parseInitializationArgs(["{ x: 'ffffff', y: 100, z: 'hosky' }"])
        );
        expect(parsedArgs[0].x).toBeInstanceOf(Uint8Array);
        expect(parsedArgs[0]).toMatchObject({ y: 100n, z: 'hosky' });
      }).pipe(Effect.provide(testLayer)));
    });

    it('should parse object literal type elements containing tuple types', async () => {
      await Effect.runPromise(Effect.gen(function* () {
        expect(yield* parseArgumentsTest(
          'a: { x: [bigint, string]; y: string; }',
          (_) => _.parseInitializationArgs(["{ x: [100, 'doggo'], y: 'hosky' }"])
        )).toStrictEqual([{ x: [100n, 'doggo'], y: 'hosky' }]);
      }).pipe(Effect.provide(testLayer)));
    });

    it('should parse nested object literal type elements', async () => {
      await Effect.runPromise(Effect.gen(function* () {
        const parsedArgs = yield* parseArgumentsTest(
          'a: { x: Uint8Array; y: { y1: bigint, y2: string  }; z: string; }',
          (_) => _.parseInitializationArgs(["{ x: 'ffffff', y: { y1: 200, y2: 'doggo' }, z: 'hosky' }"])
        );
        expect(parsedArgs[0].x).toBeInstanceOf(Uint8Array);
        expect(parsedArgs[0]).toMatchObject({ y: { y1: 200n, y2: 'doggo' }, z: 'hosky' });
      }).pipe(Effect.provide(testLayer)));
    });

    it('should parse object with bytes property as Bech32m-encoded string', async () => {
      await Effect.runPromise(Effect.gen(function* () {
        const bech32Address = 'mn_addr_undeployed1h3ssm5ru2t6eqy4g3she78zlxn96e36ms6pq996aduvmateh9p9sk96u7s';
        const expected = 'bc610dd07c52f59012a88c2f9f1c5f34cbacc75b868202975d6f19beaf37284b';

        const parsedArgs = yield* parseArgumentsTest(
          'a: { bytes: Uint8Array }',
          (_) => _.parseInitializationArgs([`{ bytes: '${bech32Address}' }`])
        );

        expect(parsedArgs[0].bytes).toBeInstanceOf(Uint8Array);
        const bytesAsHex = Buffer.from(parsedArgs[0].bytes).toString('hex');
        expect(bytesAsHex).toEqual(expected);
      }).pipe(Effect.provide(testLayer)));
    });

    it('should successfully parse object with bytes property as hex string', async () => {
      await Effect.runPromise(Effect.gen(function* () {
        const parsedArgs = yield* parseArgumentsTest(
          'a: { bytes: Uint8Array }',
          (_) => _.parseInitializationArgs(["{ bytes: 'ffffff' }"])
        );

        expect(parsedArgs[0].bytes).toBeInstanceOf(Uint8Array);
        expect(Array.from(parsedArgs[0].bytes)).toEqual([255, 255, 255]);
      }).pipe(Effect.provide(testLayer)));
    });

    it('should parse object with nested bytes property as Bech32m string', async () => {
      await Effect.runPromise(Effect.gen(function* () {
        const bech32Address = 'mn_addr_undeployed1h3ssm5ru2t6eqy4g3she78zlxn96e36ms6pq996aduvmateh9p9sk96u7s';

        const parsedArgs = yield* parseArgumentsTest(
          'a: { data: { bytes: Uint8Array }, label: string }',
          (_) => _.parseInitializationArgs([`{ data: { bytes: '${bech32Address}' }, label: 'test' }`])
        );

        expect(parsedArgs[0].data.bytes).toBeInstanceOf(Uint8Array);
        expect(parsedArgs[0].label).toBe('test');
      }).pipe(Effect.provide(testLayer)));
    });
  });
});

================
File: compact-js/compact-js-command/test/effect/ConfigCompiler.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { resolve } from 'node:path';

import { NodeContext } from '@effect/platform-node';
import { describe, expect,it } from '@effect/vitest';
import { ConfigCompiler } from '@midnight-ntwrk/compact-js-command/effect';
import { Effect, Layer } from 'effect';

import { ensureRemovePath } from './cleanup.js';

const COUNTER_CONFIG_FILEPATH = resolve(import.meta.dirname, '../contract/counter/contract.config.ts');

describe('ConfigCompiler', () => {
  describe('layer', () => {
    describe('with valid and well formed configuration file', () => {
      it.effect('should compile and return module', () =>
        Effect.gen(function* () {
          const compiler = yield* ConfigCompiler.ConfigCompiler;
          const configModuleSpec = yield* compiler.compile(COUNTER_CONFIG_FILEPATH);

          expect(configModuleSpec).toMatchObject({
            moduleImportDirectoryPath: expect.any(String),
            module: expect.objectContaining({
              default: expect.objectContaining({
                config: expect.any(Object),
                contractExecutable: expect.objectContaining({
                  compiledContract: expect.objectContaining({
                    tag: 'CounterContract'
                  })
                })
              })
            })
          });
        }).pipe(
          Effect.ensuring(ensureRemovePath(COUNTER_CONFIG_FILEPATH.replace('.ts', '.js'))),
          Effect.provide(ConfigCompiler.layer.pipe(Layer.provideMerge(NodeContext.layer))),
          Effect.catchAll((err) => {
            console.log(err);
            return Effect.void
          })
        ),
        30_000
      );
    });
  });
});

================
File: compact-js/compact-js-command/test/effect/Deploy.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { resolve } from 'node:path';

import { Command } from '@effect/cli';
import { NodeContext } from '@effect/platform-node';
import { describe, it } from '@effect/vitest';
import { deployCommand } from '@midnight-ntwrk/compact-js-command/effect';
import { ConfigCompiler } from '@midnight-ntwrk/compact-js-command/effect';
import { Console,Effect, Layer } from 'effect';

import { ensureRemovePath } from './cleanup.js';
import * as MockConsole from './MockConsole.js';

const COUNTER_CONFIG_FILEPATH = resolve(import.meta.dirname, '../contract/counter/contract.config.ts');
const COUNTER_OUTPUT_FILEPATH = resolve(import.meta.dirname, '../contract/counter/output_deploy.bin');
const COUNTER_OUTPUT_PS_FILEPATH = resolve(import.meta.dirname, '../contract/counter/output_deploy.json');
const COUNTER_OUTPUT_ZSWAP_FILEPATH = resolve(import.meta.dirname, '../contract/counter/output_zswap.json');

const testLayer: Layer.Layer<ConfigCompiler.ConfigCompiler | NodeContext.NodeContext> =
  Effect.gen(function* () {
    const console = yield* MockConsole.make;
    return Layer.mergeAll(
      Console.setConsole(console),
      ConfigCompiler.layer.pipe(Layer.provideMerge(NodeContext.layer)),
    );
  }).pipe(Layer.unwrapEffect);

describe('Deploy Command', () => {
  it.effect('should report success with valid setup', () =>
    Effect.gen(function* () {
      const cli = Command.run(deployCommand, { name: 'deploy', version: '0.0.0' });

      yield* cli([
        'node', 'deploy.ts',
        '-c', COUNTER_CONFIG_FILEPATH,
        '--output', COUNTER_OUTPUT_FILEPATH,
        '--output-ps', COUNTER_OUTPUT_PS_FILEPATH,
        '--output-zswap', COUNTER_OUTPUT_ZSWAP_FILEPATH
      ]);

      const lines = yield* MockConsole.getLines({ stripAnsi: true });

      expect(lines.length).toBe(0);
    }).pipe(
      Effect.ensuring(ensureRemovePath(COUNTER_CONFIG_FILEPATH.replace('.ts', '.js'))),
      Effect.ensuring(ensureRemovePath(COUNTER_OUTPUT_FILEPATH)),
      Effect.ensuring(ensureRemovePath(COUNTER_OUTPUT_PS_FILEPATH)),
      Effect.ensuring(ensureRemovePath(COUNTER_OUTPUT_ZSWAP_FILEPATH)),
      Effect.provide(testLayer)
    ),
    30_000
  );
});

================
File: compact-js/compact-js-command/test/effect/MaintainCircuit.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { resolve } from 'node:path';

import { Command } from '@effect/cli';
import { NodeContext } from '@effect/platform-node';
import { describe, it } from '@effect/vitest';
import { ConfigCompiler, maintainCommand } from '@midnight-ntwrk/compact-js-command/effect';
import { sampleSigningKey } from '@midnight-ntwrk/ledger';
import { Console,Effect, Layer } from 'effect';

import { ensureRemovePath } from './cleanup.js';
import * as MockConsole from './MockConsole.js';

const COUNTER_CONFIG_FILEPATH = resolve(import.meta.dirname, '../contract/counter/contract.config.ts');
const COUNTER_STATE_FILEPATH = resolve(import.meta.dirname, '../contract/counter/state.bin');
const COUNTER_OUTPUT_FILEPATH = resolve(import.meta.dirname, '../contract/counter/output_circuit.bin');

const testLayer: Layer.Layer<ConfigCompiler.ConfigCompiler | NodeContext.NodeContext> =
  Effect.gen(function* () {
    const console = yield* MockConsole.make;
    return Layer.mergeAll(
      Console.setConsole(console),
      ConfigCompiler.layer.pipe(Layer.provideMerge(NodeContext.layer))
    );
  }).pipe(Layer.unwrapEffect);

// Skipped. The current yarn workspace setup (with the root dependent on Ledger@4), means that Ledger@6 that
// both `compact-js` and `compact-js-command` depended on are not being deduped on install. At runtime this
// means that two instances of the Ledger WASM is being loaded. `compact-js` creates an instance of 
// `MaintenanceUpdate` that is then added to an `Intent` created in `compact-js-command`, and since these two types
// are originated from different instances of the Ledger WASM, the `Intent.addMaintenanceUpdate()` function
// throws an `'expected instance of MaintenanceUpdate'` error. To fix this we need to properly segregate the
// workspace. The Contract Maintenance Operations are tested (outside of the command) in the `compact-js` package.
// @seealso ./MaintainContract.test.ts
describe.skip('Maintain Circuit Command', () => {
  it.effect('should report success with valid setup', () =>
    Effect.gen(function* () {
      const cli = Command.run(maintainCommand, { name: 'maintain', version: '0.0.0' });

      yield* cli([
        'node', 'maintain.ts',
        'maintain', 'circuit',
        '-s', sampleSigningKey(),
        '-c', COUNTER_CONFIG_FILEPATH,
        '--input', COUNTER_STATE_FILEPATH,
        '--output', COUNTER_OUTPUT_FILEPATH,
        '0a2d0e34db258f640dc2ec410fb0e4eea9cd6f9661ba6a86f0c35a708e1b811a', 'increment'
      ]);

      const lines = yield* MockConsole.getLines({ stripAnsi: true });

      expect(lines.length).toBe(0);
    }).pipe(
      Effect.ensuring(ensureRemovePath(COUNTER_CONFIG_FILEPATH.replace('.ts', '.js'))),
      Effect.ensuring(ensureRemovePath(COUNTER_OUTPUT_FILEPATH)),
      Effect.provide(testLayer)
    ),
    30_000
  );
});

================
File: compact-js/compact-js-command/test/effect/MaintainContract.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { resolve } from 'node:path';

import { Command } from '@effect/cli';
import { NodeContext } from '@effect/platform-node';
import { describe, it } from '@effect/vitest';
import { ConfigCompiler, maintainCommand } from '@midnight-ntwrk/compact-js-command/effect';
import { sampleSigningKey } from '@midnight-ntwrk/ledger';
import { Console,Effect, Layer } from 'effect';

import { ensureRemovePath } from './cleanup.js';
import * as MockConsole from './MockConsole.js';

const COUNTER_CONFIG_FILEPATH = resolve(import.meta.dirname, '../contract/counter/contract.config.ts');
const COUNTER_STATE_FILEPATH = resolve(import.meta.dirname, '../contract/counter/state.bin');
const COUNTER_OUTPUT_FILEPATH = resolve(import.meta.dirname, '../contract/counter/output_circuit.bin');

const testLayer: Layer.Layer<ConfigCompiler.ConfigCompiler | NodeContext.NodeContext> =
  Effect.gen(function* () {
    const console = yield* MockConsole.make;
    return Layer.mergeAll(
      Console.setConsole(console),
      ConfigCompiler.layer.pipe(Layer.provideMerge(NodeContext.layer))
    );
  }).pipe(Layer.unwrapEffect);

// Skipped. The current yarn workspace setup (with the root dependent on Ledger@4), means that Ledger@6 that
// both `compact-js` and `compact-js-command` depended on are not being deduped on install. At runtime this
// means that two instances of the Ledger WASM is being loaded. `compact-js` creates an instance of 
// `MaintenanceUpdate` that is then added to an `Intent` created in `compact-js-command`, and since these two types
// are originated from different instances of the Ledger WASM, the `Intent.addMaintenanceUpdate()` function
// throws an `'expected instance of MaintenanceUpdate'` error. To fix this we need to properly segregate the
// workspace. The Contract Maintenance Operations are tested (outside of the command) in the `compact-js` package.
// @seealso ./MaintainCircuit.test.ts
describe.skip('Maintain Contract Command', () => {
  it.effect('should report success with valid setup', () =>
    Effect.gen(function* () {
      const cli = Command.run(maintainCommand, { name: 'maintain', version: '0.0.0' });

      yield* cli([
        'node', 'maintain.ts',
        'maintain', 'contract',
        '-s', sampleSigningKey(),
        '-c', COUNTER_CONFIG_FILEPATH,
        '--input', COUNTER_STATE_FILEPATH,
        '--output', COUNTER_OUTPUT_FILEPATH,
        '0a2d0e34db258f640dc2ec410fb0e4eea9cd6f9661ba6a86f0c35a708e1b811a', sampleSigningKey()
      ]);

      const lines = yield* MockConsole.getLines({ stripAnsi: true });

      expect(lines.length).toBe(0);
    }).pipe(
      Effect.ensuring(ensureRemovePath(COUNTER_CONFIG_FILEPATH.replace('.ts', '.js'))),
      Effect.ensuring(ensureRemovePath(COUNTER_OUTPUT_FILEPATH)),
      Effect.provide(testLayer)
    ),
    30_000
  );
});

================
File: compact-js/compact-js-command/test/effect/MockConsole.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Array, Console, Context, Effect, Ref } from 'effect';

export class MockConsole extends Context.Tag('compact-js-command#test/MockConsole')<
  Console.Console,
  MockConsole.Service
>() {}

export declare namespace MockConsole {
  export interface Service extends Console.Console {
    readonly getLines: (
      params?: Partial<{
        readonly stripAnsi: boolean
      }>
    ) => Effect.Effect<readonly string[]>;
  }
}

const pattern = new RegExp(
  [
    '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
    '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))'
  ].join('|'),
  'g'
);

const stripAnsi = (str: string) => str.replace(pattern, '');

export const make = Effect.gen(function*() {
  const consoleLines = yield* Ref.make(Array.empty<string>());

  const getLines: MockConsole.Service['getLines'] = (params = {}) =>
    Ref.get(consoleLines).pipe(Effect.map((lines) =>
      params.stripAnsi
        ? Array.map(lines, stripAnsi)
        : lines
    ));

  const log: MockConsole.Service['log'] = (...args) => Ref.update(consoleLines, Array.appendAll(args));

  return MockConsole.of({
    [Console.TypeId]: Console.TypeId,
    getLines,
    log,
    unsafe: globalThis.console,
    assert: () => Effect.void,
    clear: Effect.void,
    count: () => Effect.void,
    countReset: () => Effect.void,
    debug: () => Effect.void,
    dir: () => Effect.void,
    dirxml: () => Effect.void,
    error: () => Effect.void,
    group: () => Effect.void,
    groupEnd: Effect.void,
    info: () => Effect.void,
    table: () => Effect.void,
    time: () => Effect.void,
    timeEnd: () => Effect.void,
    timeLog: () => Effect.void,
    trace: () => Effect.void,
    warn: () => Effect.void
  });
});

export const getLines = (
  params?: Partial<{
    readonly stripAnsi?: boolean
  }>
): Effect.Effect<readonly string[]> =>
  Effect.consoleWith((console) => (console as MockConsole.Service).getLines(params));

================
File: compact-js/compact-js-command/LICENSE
================
Copyright 2025 Midnight Foundation

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

================
File: compact-js/compact-js-command/README.md
================
# Compact.js (Command Line Utilities)

## Introduction

Provides an opinionated command line interface for Compact.js, allowing `compactc` compiled contracts to be
executed from the command line. The package exports commands that can be used programmatically within other
command line tools, or executed directly in its own process through its own CLI.

## Commands

### Prerequisites & Configuration

Since Compact.js commands operate over Compact compiled contracts, we need the following prerequisites in order
to execute them:

1. A `.compact` contract that has been compiled using the `compactc` compiler.  
The Compact compiler generates a JavaScript based _contract executable_ that will be the target of the invocations
made by the commands present in Compact.js. It also generates other assets that are required in order to fulfill
contract deployment and execution. Specifically, these are the TypeScript declaration file that describes the
contract, and the ZK file assets including prover and verifier keys.
2. With the above in place, we also need a configuration file (written in TypeScript), that:
   * Imports the _contract executable_ and makes it invocable via the `CompiledContract` and `ContractExecutable`
   types present in Compact.js,
   * Provides a type for private state, and a function that creates its initial value,
   * Provides the implementation of the Witnesses required by the contract, and,
   * Optionally provides some default configuration that can be set for all Compact.js commands.

An example configuration file for the canonical "Counter" contract is shown below:

```ts
import { CompiledContract, type Contract, ContractExecutable } from '@midnight-ntwrk/compact-js/effect';
import { Contract as C_ } from './<path>/managed/counter/contract/index.cjs';

// The type of private state to use in contract execution.
type PrivateState = {
  count: number;
};

type CounterContract = C_<PrivateState>;
const CounterContract = C_;

// An implementation of the required Witnesses.
const witnesses: Contract.Contract.Witnesses<CounterContract> = {
  private_increment: ({ privateState }) => [{ count: privateState.count + 1 }, []]
}

// A function that creates the initial private state given to the contract when an instance is
// being deployed.
const createInitialPrivateState: () => PrivateState = () => ({
  count: 0
});

// The default export that describes the binding to the Contract.
export default {
  // Creates an executable from the imported contract, along with the assets it will require at runtime.
  contractExecutable: CompiledContract.make<CounterContract>('CounterContract', CounterContract).pipe(
    CompiledContract.withWitnesses(witnesses),
    CompiledContract.withCompiledFileAssets('./<path>/managed/counter'),
    ContractExecutable.make
  ),
  createInitialPrivateState,
  config: {
    keys: {
      coinPublic: '...',
      signing: '...'
    },
    network: 'undeployed'
  }
}
```
**Note**: The `config` property is entirely optional along with its keys. The values can also be provided (or
overridden via precedence), via environment variables, or through the command line options documented below.

### Global Options

The following options can be used with all commands:

- `-c | --config pathToConfig`. The file path to the previously mentioned Contract Configuration file.  
Defaults to `'contract.config.ts'` in the current working folder.
- `-p | --coin-public key`. The user public key capable of receiving Zswap coins.  
The string can be hex or Bech32m encoded. Its value can also be specified using an environment variable named
`KEYS_COIN_PUBLIC`.
- `-n | --network networkId`. An optional network identifier.  
Defaults to the Midnight MainNet if not specified. Its value can also be specified using an environment variable named
`NETWORK`.

### `deploy` Command

```
<binName> deploy [-c ...]
                 [-p ...]
                 [-n ...]
                 [-s | --signing ...]
                 [--output ...]
                 [--output-ps ...]
                 [--output-zswap ...]
                 ...args
```

This command executes the contract constructor and generates a serialized `Intent` describing a contract deployment.
The constructor is executed with the given `...args`, and the serialized `Intent` is written to the `--output` file
path. The private state and Zswap local state is written to the `--output-ps` and `--output-zswap` file paths
respectively, both formatted as JSON.

#### Options

- `-s | --signing key`. An optional public BIP-340 signing key, hex encoded.  
If not provided, a sample signing key is used in order to create a valid Contract Maintenance Authority (CMA) but it
will not be available for use in future maintenance operations. Its value can also be specified using an environment
variable named `KEYS_SIGNING`.
- `--output pathToStateOutput`. The file path to where the serialized `Intent` data should be written.  
Defaults to `'output.bin'` in the current working folder.
- `--output-ps pathToPrivateStateOutput`. The file path to where the private state data should be written.  
Defaults to `'output.ps.json'` in the current working folder.
- `--output-zswap pathToZswapLocalStateOutput`. The file path to where the the local Zswap  state data should be written.  
Defaults to `'zswap.json'` in the current working folder.

### `circuit` Command

```
<binName> circuit [-c ...]
                  [-p ...]
                  [-n ...]
                  --input ...
                  --input-ps ...
                  [--input-zswap ...]
                  [--output ...]
                  [--output-ps ...]
                  [--output-zswap ...]
                  contractAddress,
                  circuitId,
                  ...args
```

Executes a circuit on the contract and generates a serialized `Intent` describing a contract call. The circuit is
executed with the given `...args` in the context of some prior state provided by the `--input` file path, and private
state found in the `--input-ps` file path. Optionally, Zswap data describing coins can be provided via a JSON file
via the `--input-ps` file path.

As with the previously described `'deploy'` command, the `--output-*` options provide file paths to the outputs in
the same way.

#### Options

- `--input pathToStateInput`. The required file path to the serialized state data.  
The state data is provided as part of the context given to the executing circuit.
- `--input-ps pathToPrivateStateInput`. The required file path to the private state data.  
Private state is provided to the associated Witness implementations.
- `--input-zswap pathToZswapLocalStateInput`. The file path to the the local Zswap state data.  
If not provided, then empty Zswap local state data will be provided to the circuit.
- `--output pathToStateOutput`. The file path to where the serialized `Intent` data should be written.  
Defaults to `'output.bin'` in the current working folder.
- `--output-ps pathToPrivateStateOutput`. The file path to where the private state data should be written.  
Defaults to `'output.ps.json'` in the current working folder.
- `--output-zswap pathToZswapLocalStateOutput`. The file path to where the the local Zswap state data should be written.  
Defaults to `'zswap.json'` in the current working folder.

### Contract Arguments

Compact allows contract constructors and circuits to receive arguments. As described in the
[Compact Language Reference](https://github.com/midnightntwrk/compactc/blob/main/doc/lang-ref.mdx#representations-in-typescript)
Compact types are mapped to TypeScript equivalents, and each command attempts to process its `...args` based on
the associated TypeScript type. Internally, the previously mentioned TypeScript declaration file (generated by
`compactc`), is reflected over to determine the required TypeScript argument types. Each argument provided in
`...args` is then parsed according to its TypeScript type before being presented to the Compact runtime.

#### Tuples & Objects

Tuples and object literals (Compact structs) can be written by enclosing them in quotes:
- `... "[100n, 200n, true]" ...`
- `... "{a: 100n, b: 200n, c: false}" ...`

Nested tuples and nested object literals are supported:
- `... "[100n, [200n, 300n], true]" ...`
- `... "{a: 100n, b: {bx: true, by: false}, c: false}" ...`
- `... "[100n, {a: 200n, b: false}, true]" ...`
- `... "{a: 100n, b: [true, false], c: false}" ...`

#### Strings

Since command line arguments are implicitly string types, you can pass them as is. Obviously, if the string has to
contain whitespace then it should be enclosed in quotes as it would for any command line argument:
- `... AString ...`
- `... "A longer string" ...`

When used in Tuple types or object literals, since the enclosing type requires enclosing quotes, strings should be
enclosed in single quotes:
- `... "[100n, 'AString']" ...`
- `... "[100n, 'A longer string']" ...`
- `... "{a: 100n, b: 'AString'}" ...`
- `... "{a: 100n, b: 'A longer string'}" ...`

================
File: compact-js/compact-js-command/tsconfig.build.json
================
{
  "extends": "./tsconfig.src.json",
  "compilerOptions": {
    "tsBuildInfoFile": ".tsbuildinfo/build.tsbuildinfo",
    "outDir": "build/esm",
    "declarationDir": "build/dts",
    "stripInternal": true
  }
}

================
File: compact-js/compact-js-command/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [
    { "path": "./tsconfig.src.json" },
    { "path": "./tsconfig.test.json" }
  ]
}

================
File: compact-js/compact-js-command/tsconfig.src.json
================
{
  "extends": "../../tsconfig.base.json",
  "include": ["src"],
  "references": [
    { "path": "../compact-js/tsconfig.src.json" },
    { "path": "../compact-js-node/tsconfig.src.json" }
  ],
  "compilerOptions": {
    "tsBuildInfoFile": ".tsbuildinfo/src.tsbuildinfo",
    "rootDir": "src",
    "outDir": "build/src"
  }
}

================
File: compact-js/compact-js-command/tsconfig.test.json
================
{
  "extends": "../../tsconfig.base.json",
  "include": ["test"],
  "references": [
    { "path": "tsconfig.src.json" },
  ],
  "compilerOptions": {
    "tsBuildInfoFile": ".tsbuildinfo/test.tsbuildinfo",
    "rootDir": "test",
    "noEmit": true
  }
}

================
File: compact-js/compact-js-command/vitest.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// <reference types="vitest" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    include: ['test/**/*.test.ts'],
    exclude: ['node_modules', 'dist'],
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage'
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }]
    ]
  }
});

================
File: compact-js/compact-js-node/src/effect/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * as ZKFileConfiguration from './ZKFileConfiguration.js';

================
File: compact-js/compact-js-node/src/effect/ZKFileConfiguration.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { FileSystem,Path } from '@effect/platform';
import { CompiledContract, Contract, ZKConfiguration, ZKConfigurationReadError } from '@midnight-ntwrk/compact-js/effect';
import { Effect, Layer } from 'effect';

const KEYS_FOLDER = 'keys';
const VERIFIER_EXT = '.verifier';

/**
 * Returns a function, that when invoked, will create a ZK asset reader over the file system.
 * 
 * @param path A `Path` implementation.
 * @param fs A `FileSystem` implementation.
 * @returns A function that receives a `CompiledContract` instance and returns a ZK asset reader over `fs`.
 *
 * @internal
 */
const makeFileSystemReader =
  <C extends Contract.Contract<PS>, PS>(path: Path.Path, fs: FileSystem.FileSystem, baseAssetFolderPath: string) =>
  (compiledContract: CompiledContract.CompiledContract<C, PS>) =>
    // eslint-disable-next-line require-yield
    Effect.gen(function* () {
      const assetsPath = CompiledContract.getCompiledAssetsPath(compiledContract);
      const getVerifierKey = (impureCircuitId: Contract.ImpureCircuitId<C>) =>
        Effect.gen(function* () {
          const data = yield* fs.readFile(
            path.join(path.resolve(baseAssetFolderPath, assetsPath), KEYS_FOLDER, `${impureCircuitId}${VERIFIER_EXT}`)
          );
          return Contract.VerifierKey(data);
        }).pipe(
          Effect.mapError((err: unknown) =>
            ZKConfigurationReadError.make(compiledContract.tag, impureCircuitId, 'verifier-key', err)
          )
        );

      return {
        getVerifierKey,
        getVerifierKeys: (impureCircuitIds) =>
          Effect.forEach(
            impureCircuitIds,
            (impureCircuitId) =>
              getVerifierKey(impureCircuitId).pipe(
                Effect.map((verifierKey) => [impureCircuitId, verifierKey] as const)
              ),
            { concurrency: 'unbounded', discard: false }
          )
      } satisfies ZKConfiguration.ZKConfiguration.Reader<C, PS>;
    });

/**
 * A {@link ZKConfiguration.ZKConfiguration | ZKConfiguration} implementation that reads ZK assets from the
 * file system.
 *
 * @param baseAssetFolderPath A base path to a folder containing the compiled contract assets.
 *
 * @category layers
 */
export const layer = (baseAssetFolderPath = '.') => Layer.effect(
  ZKConfiguration.ZKConfiguration,
  Effect.gen(function* () {
    const path = yield* Path.Path;
    const fs = yield* FileSystem.FileSystem;

    return ZKConfiguration.ZKConfiguration.of({
      createReader: makeFileSystemReader(path, fs, baseAssetFolderPath)
    });
  })
);

================
File: compact-js/compact-js-node/src/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * from './effect/index.js';

================
File: compact-js/compact-js-node/LICENSE
================
Copyright 2025 Midnight Foundation

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

================
File: compact-js/compact-js-node/README.md
================
# Compact.js (Node.js Platform)

## Introduction

Provides implementations of Compact.js service types that are specific to the Node.js runtime.

## Services Provided

- `ZKFileConfiguration`. An implementation of `ZKConfiguration` that reads ZK assets from the file system.

================
File: compact-js/compact-js-node/tsconfig.build.json
================
{
  "extends": "./tsconfig.src.json",
  "compilerOptions": {
    "tsBuildInfoFile": ".tsbuildinfo/build.tsbuildinfo",
    "outDir": "build/esm",
    "declarationDir": "build/dts",
    "stripInternal": true
  }
}

================
File: compact-js/compact-js-node/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [
    { "path": "./tsconfig.src.json" },
    { "path": "./tsconfig.test.json" }
  ]
}

================
File: compact-js/compact-js-node/tsconfig.src.json
================
{
  "extends": "../../tsconfig.base.json",
  "include": ["src"],
  "references": [
    { "path": "../compact-js/tsconfig.src.json" }
  ],
  "compilerOptions": {
    "tsBuildInfoFile": ".tsbuildinfo/src.tsbuildinfo",
    "rootDir": "src",
    "outDir": "build/src"
  }
}

================
File: compact-js/compact-js-node/tsconfig.test.json
================
{
  "extends": "../../tsconfig.base.json",
  "include": ["test"],
  "references": [
    { "path": "tsconfig.src.json" },
  ],
  "compilerOptions": {
    "tsBuildInfoFile": ".tsbuildinfo/test.tsbuildinfo",
    "rootDir": "test",
    "noEmit": true
  }
}

================
File: compact-js/compact-js-node/vitest.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// <reference types="vitest" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    include: ['test/**/*.test.ts'],
    exclude: ['node_modules', 'dist'],
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage'
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }]
    ]
  }
});

================
File: compact-js/README.md
================
# Compact.js

## Introduction

Compact.js provides a Typescript-based execution environment for smart contracts
compiled with the [Compact](https://docs.midnight.network/develop/reference/compact/) language.
When a Compact smart contract is compiled with `compactc`, part of the output includes:

1. A JavaScript file.
2. A TypeScript [declaration file](https://www.typescriptlang.org/docs/handbook/2/type-declarations.html).

The JavaScript file contains:

- The execution logic for each circuit in the source contract,
- Logic for constructing the contracts initial state,
- Utilities for converting on-chain contract state into a JavaScript representation.

Compact.js uses this file at run time to execute the circuits. The circuit execution results are
then used by higher level tools and frameworks (such as Midnight.js) in order to create and submit
transactions to the Midnight blockchain. At compile time, the types and utilities of Compact.js use
the TypeScript declaration file and the definitions it contains, to map types that make working with
the contract and its circuits more convenient, and TypeScript idiomatic.

> [!NOTE]  
> The term _runtime_ is often used to describe the JavaScript executable for a contract. This is
> distinct from the package `@midnight-ntwrk/compact-runtime`, which provides the utilities that each
> of these JavaScript executables use.

================
File: docs/README_API.md
================
# Midnight.js

Midnight.js is a Typescript-based application development framework for the 
Midnight blockchain. Analogous to [Web3.js](https://web3js.org/) for Ethereum, or
[polkadot.js](https://polkadot.js.org/) for Polkadot, it contains utilities for:

- Creating and submitting transactions
- Interacting with wallets
- Querying for block and state information
- Subscribing to chain events

Due to the privacy-preservation properties of the Midnight system, Midnight.js also 
contains a number of utilities that are unique to it:

- Executing smart contracts locally
- Incorporating private state into contract execution
- Persisting, querying, and updating private state
- Creating and verifying zero-knowledge proofs

## Package structure

- `types` - Contains types and interfaces common to all other packages.
- `contracts` - Contains utilities for interacting with Midnight smart contracts.
- `indexer-public-data-provider` - Contains a cross-environment implementation of a Midnight indexer client.
- `node-zk-config-provider` - Contains a file system based Node.js utility for retrieving zero-knowledge artifacts.
- `fetch-zk-config-provider` - Contains a [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) based cross-environment utility for retrieving zero-knowledge artifacts.
- `network-id` - Contains utilities for setting the network id used by `ledger`, `zswap`, and `compact-runtime` dependencies.
- `http-client-proof-provider` - Contains a cross-environment implementation of a proof-server client.
- `level-private-state-provider` - Contains a cross-environment implementation of a persistent private state store based on [Level](https://github.com/Level/level).

================
File: packages/compact/src/fetch-compact.mts
================
#!/usr/bin/env node
import * as childProcess from 'node:child_process';
import * as console from 'node:console';
import * as fs from 'node:fs';
import * as path from 'node:path';
import * as process from 'node:process';

import { parseArgs, printHelp,shouldSkipDownload } from './fetch-utils.js';
import { VersionManager } from './version-manager.js';

console.log('Fetching Compactc...');

const [_node, _script, ...args] = process.argv;
const options = parseArgs(args);

const packageDir = path.resolve(new URL(import.meta.url).pathname, '..', '..');
const versionManager = new VersionManager(packageDir);

if (options.help) {
  printHelp();
  process.exit(0);
}

if (options.listVersions) {
  const versions = versionManager.listVersions();
  if (versions.length === 0) {
    console.log('No versions installed');
  } else {
    console.log('Installed versions:');
    versions.forEach(version => console.log(`  ${version}`));
  }
  process.exit(0);
}

if (options.cleanup) {
  console.log(`Cleaning up, keeping ${options.cleanup} latest versions...`);
  versionManager.cleanupOldVersions(options.cleanup);
  console.log('Cleanup completed');
  process.exit(0);
}

if (shouldSkipDownload()) {
  console.log(`COMPACT_HOME env variable is set, skipping fetch to use Compact from ${process.env.COMPACT_HOME}`);
  process.exit(0);
}

const compactcVersion = options.version || process.env.COMPACTC_VERSION;
if (!compactcVersion) {
  console.error('COMPACTC_VERSION env var is missing or --version flag not provided. I don\'t know which version to download.');
  process.exit(1);
}

const targetCompactDir = versionManager.getVersionDir(compactcVersion);
console.log(`Target directory: ${targetCompactDir}`);

if (shouldSkipDownload(targetCompactDir, options.force)) {
  console.warn(`Version ${compactcVersion} already exists. Use --force to re-download.`);
  process.exit(0);
}

const targetFile = path.resolve(packageDir, `compactc-${compactcVersion}.zip`);
const currentPlatform = process.platform;
const currentCpu = process.arch;

const fetchCompact = async (): Promise<void> => {
  const githubToken = process.env['GITHUB_TOKEN'];

  if (githubToken == undefined || githubToken == '') {
    throw new Error(`No GitHub token present. Expected GITHUB_TOKEN env var to be present`);
  }

  type Release = { assets_url: string }
  const urlString = `https://api.github.com/repos/midnight-ntwrk/artifacts/releases/tags/compactc-v${compactcVersion}`;
  console.log(`Trying to fetch release from: ${urlString}`);
  const release: Release = await fetch(urlString, {
    headers: {
      Authorization: `Bearer ${githubToken}`
    }
  }).then((r) => {
    if (r.ok) {
      return r.json() as unknown as Release;
    } else {
      console.error(`Error downloading ${urlString} ${r.status} ${r.statusText}`);
      process.exit(r.status);
    }
  });

  type Asset = { name: string; url: string }
  const assets: Asset[] = await fetch(release.assets_url, {
    headers: {
      Authorization: `Bearer ${githubToken}`
    }
  }).then((r) => r.json() as unknown as Asset[]);

  const platformToAssetSuffix = (): string => {
    if (currentPlatform === 'darwin') {
      if (currentCpu === 'arm64') {
        return 'aarch64-darwin';
      } else if (currentCpu === 'x64') {
        return 'x86_64-darwin';
      } else {
        throw new Error(`Unexpected platform architecture combination: platform=${currentPlatform}, architecture=${currentCpu}`);
      }
    } else if (currentPlatform === 'linux') {
      return 'x86_64-unknown-linux-musl';
    } else {
      throw new Error(`Unsupported platform: ${currentPlatform}`);
    }
  };

  const assetName = `compactc_v${compactcVersion}_${platformToAssetSuffix()}.zip`;
  const asset = assets.find((assetLocal) => assetLocal.name === assetName);

  if (!asset) {
    throw new Error(`No matching asset found! : ${assetName}`);
  }

  const assetData = await fetch(asset.url, {
    headers: {
      Authorization: `Bearer ${githubToken}`,
      Accept: 'application/octet-stream'
    }
  }).then(async (response) => {
    if (response.ok) {
      console.log(`Fetching Compact archive: ${urlString}`);
      console.log(`Compact version: ${compactcVersion}`);
      return response.arrayBuffer();
    } else {
      console.error('Error: could not fetch asset: ', response.statusText, response.status);
      console.error(await response.text());
      throw new Error('Could not fetch asset');
    }
  });

  fs.writeFileSync(targetFile, Buffer.from(assetData));
  console.log(`Compact archive fetched and saved to ${targetFile}`);

  fs.rmSync(targetCompactDir, { force: true, recursive: true });
  fs.mkdirSync(targetCompactDir, { recursive: true });

  childProcess.execSync(`unzip ${targetFile} -d ${targetCompactDir}`);
  childProcess.execSync(`chmod -R +w ${targetCompactDir}`);
  console.log(`Compact extracted to ${targetCompactDir}`);

  fs.rmSync(targetFile);
  console.log('Compact archive removed');
  console.log(`Compactc v${compactcVersion} ready`);
};

const fetchDockerImage = () => {
  console.log('Fetching Compact docker image...');
  const dockerImage = `ghcr.io/midnight-ntwrk/compactc:v${compactcVersion}`;
  const child = childProcess.exec(`docker pull ${dockerImage}`);
  child.on('exit', (code, signal) => {
    console.log(`Child process exited with code ${code}`);
    if (code === 0) {
      process.exit(0);
    } else {
      process.exit(code ?? signal);
    }
  });

  child.stdout?.on('data', (data) => {
    console.log(`${data.toString().trim()}`);
  });

  child.stderr?.on('data', (data) => {
    console.error(`${data.toString().trim()}`);
  });
};

const checkOs = (): string => {
  let compactOS;
  if (currentPlatform === 'darwin' && (currentCpu === 'arm64' || currentCpu === 'x64')) {
    compactOS = 'macos';
  } else if (currentPlatform === 'linux') {
    compactOS = 'linux';
  } else {
    compactOS = 'docker';
  }
  return compactOS;
};

versionManager.ensureManagedDirExists();

if (checkOs() === 'docker') {
  fetchDockerImage();
} else {
  await fetchCompact();
}

================
File: packages/compact/src/fetch-utils.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as fs from 'node:fs';
import * as path from 'node:path';

export interface FetchOptions {
  help: boolean;
  force: boolean;
  version?: string;
  listVersions: boolean;
  cleanup?: number;
}

export const parseArgs = (args: string[]): FetchOptions => {
  const options: FetchOptions = {
    help: false,
    force: false,
    listVersions: false,
  };

  args.forEach(arg => {
    if (arg === '--help') {
      options.help = true;
    } else if (arg === '--force') {
      options.force = true;
    } else if (arg.startsWith('--version=')) {
      options.version = arg.split('=')[1];
    } else if (arg === '--list-versions') {
      options.listVersions = true;
    } else if (arg.startsWith('--cleanup=')) {
      const value = parseInt(arg.split('=')[1], 10);
      if (!isNaN(value) && value > 0) {
        options.cleanup = value;
      }
    }
  });

  return options;
};

export const shouldSkipDownload = (versionDir?: string, force = false): boolean => {
  const compactHomeEnv = process.env.COMPACT_HOME;
  
  if (compactHomeEnv) {
    return true;
  }

  if (!versionDir) {
    return false;
  }

  if (force) {
    return false;
  }

  const compactcPath = path.join(versionDir, 'compactc');
  return fs.existsSync(compactcPath);
};

export const printHelp = (): void => {
  console.log(`Supported flags:
    --help                    - this help
    --force                   - force download, even if version exists
    --version=<version>       - specify the version to download
    --list-versions           - list all installed versions
    --cleanup=<count>         - keep only the latest <count> versions`);
};

================
File: packages/compact/src/run-compactc.cjs
================
#!/usr/bin/env node

const childProcess = require('child_process');
const path = require('path');
const fs = require('fs');
const { exec } = require("node:child_process");

const [_node, _script, ...args] = process.argv;
const COMPACT_HOME_ENV = process.env.COMPACT_HOME;

console.log(`Trying to compile: ${args.join(' ')}`)

function resolveCompactPath(packageDir, version) {
  if (COMPACT_HOME_ENV != null) {
    console.log(`COMPACT_HOME env variable is set; using Compact from ${COMPACT_HOME_ENV}`);
    return COMPACT_HOME_ENV;
  }

  const managedDir = path.resolve(packageDir, 'managed');

  if (version) {
    const versionDir = path.resolve(managedDir, version);
    const compactcPath = path.join(versionDir, 'compactc');

    if (fs.existsSync(compactcPath)) {
      console.log(`Using Compact version ${version} from ${versionDir}`);
      return versionDir;
    } else {
      throw new Error(`Compact version ${version} not found at ${versionDir}. Run fetch-compactc --version=${version} first.`);
    }
  }

  const versions = fs.existsSync(managedDir)
    ? fs.readdirSync(managedDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name)
        .filter(versionName => {
          const compactcPath = path.join(managedDir, versionName, 'compactc');
          return fs.existsSync(compactcPath);
        })
        .sort((a, b) => b.localeCompare(a, undefined, { numeric: true }))
    : [];

  if (versions.length === 0) {
    throw new Error('No Compact versions found. Run fetch-compactc first.');
  }

  const latestVersion = versions[0];
  const latestVersionDir = path.resolve(managedDir, latestVersion);
  console.log(`Using latest Compact version ${latestVersion} from ${latestVersionDir}`);

  return latestVersionDir;
}

function checkOs() {
  const currentPlatform = process.platform;
  const currentCpu = process.arch;
  let compactOS;
  if (currentPlatform === 'darwin' && (currentCpu === 'arm64' || currentCpu === 'x64')) {
    compactOS = 'macos';
  } else if (currentPlatform === 'linux') {
    compactOS = 'linux';
  } else {
    compactOS = 'docker';
  }
  return compactOS;
}

let child;
if (checkOs() === 'docker') {
  console.log('Using docker image...');
  const currentDir = process.cwd();
  const currentVersion = process.env.COMPACTC_VERSION;
  if (!currentVersion) {
    console.error("COMPACTC_VERSION env var is missing. I don't know which version to execute.");
    process.exit(1);
  }
  const dockerImage = `ghcr.io/midnight-ntwrk/compactc:v${currentVersion}`;

  const argsCompact = args
    .map(arg => arg.startsWith('-') ? arg : `/compact/${arg}`)
    .join(' ');

  const containerName = 'compactc-docker';

  const argsDocker = [
    'run', '--name', containerName, '--rm', '-v', `${currentDir}:/compact`, `${dockerImage}`, `"compactc ${argsCompact}"`
  ];

  const dockerCommand = `docker ${argsDocker.join(" ")}`;

  child = exec(dockerCommand);

  child.on('exit', (code, signal) => {
    console.log(`Child process exited with code ${code}`);
    if (code === 0) {
      process.exit(0);
    } else {
      process.exit(code ?? signal);
    }
  });

  child.stdout.on('data', (data) => {
    console.log(`${data.toString().trim()}`);
  });

  child.stderr.on('data', (data) => {
      console.error(`${data.toString().trim()}`);
  });
} else {
  console.log('Using compactc binary...');

  const packageDir = path.resolve(__dirname, '..');
  const requestedVersion = process.env.COMPACTC_VERSION;

  try {
    const compactPath = resolveCompactPath(packageDir, requestedVersion);

    child = childProcess.spawn(path.resolve(compactPath, 'compactc'), args, {
      stdio: 'inherit'
    });

    child.on('exit', (code, signal) => {
      console.log(`Child process exited with code ${code}`);
      if (code === 0) {
        process.exit(0);
      } else {
        process.exit(code ?? signal);
      }
    });
  } catch (error) {
    console.error(`Error: ${error.message}`);
    process.exit(1);
  }
}

================
File: packages/compact/src/run-utils.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as fs from 'node:fs';
import * as path from 'node:path';

export const resolveCompactPath = (packageDir: string, version?: string): string => {
  const compactHomeEnv = process.env.COMPACT_HOME;
  
  if (compactHomeEnv) {
    console.log(`COMPACT_HOME env variable is set; using Compact from ${compactHomeEnv}`);
    return compactHomeEnv;
  }

  const managedDir = path.resolve(packageDir, 'managed');
  
  if (version) {
    const versionDir = path.resolve(managedDir, version);
    const compactcPath = path.join(versionDir, 'compactc');
    
    if (fs.existsSync(compactcPath)) {
      console.log(`Using Compact version ${version} from ${versionDir}`);
      return versionDir;
    } else {
      throw new Error(`Compact version ${version} not found at ${versionDir}. Run fetch-compactc --version=${version} first.`);
    }
  }

  const versions = fs.existsSync(managedDir) 
    ? fs.readdirSync(managedDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name)
        .filter(versionName => {
          const compactcPath = path.join(managedDir, versionName, 'compactc');
          return fs.existsSync(compactcPath);
        })
        .sort((a, b) => b.localeCompare(a, undefined, { numeric: true }))
    : [];

  if (versions.length === 0) {
    throw new Error('No Compact versions found. Run fetch-compactc first.');
  }

  const latestVersion = versions[0];
  const latestVersionDir = path.resolve(managedDir, latestVersion);
  console.log(`Using latest Compact version ${latestVersion} from ${latestVersionDir}`);
  
  return latestVersionDir;
};

================
File: packages/compact/src/version-manager.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as fs from 'node:fs';
import * as path from 'node:path';

export class VersionManager {
  constructor(private packageDir: string) {}

  getVersionDir(version: string): string {
    return path.resolve(this.packageDir, 'managed', version);
  }

  versionExists(version: string): boolean {
    const versionDir = this.getVersionDir(version);
    const compactcPath = path.join(versionDir, 'compactc');
    return fs.existsSync(compactcPath);
  }

  listVersions(): string[] {
    const managedDir = path.resolve(this.packageDir, 'managed');
    
    if (!fs.existsSync(managedDir)) {
      return [];
    }

    return fs.readdirSync(managedDir, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => dirent.name)
      .filter(version => this.versionExists(version))
      .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
  }

  getCompactcPath(version: string): string {
    return path.join(this.getVersionDir(version), 'compactc');
  }

  removeVersion(version: string): void {
    const versionDir = this.getVersionDir(version);
    fs.rmSync(versionDir, { recursive: true, force: true });
  }

  cleanupOldVersions(keepCount: number): void {
    const versions = this.listVersions();
    const toRemove = versions.slice(0, -keepCount);
    
    toRemove.forEach(version => this.removeVersion(version));
  }

  ensureManagedDirExists(): void {
    const managedDir = path.resolve(this.packageDir, 'managed');
    if (!fs.existsSync(managedDir)) {
      fs.mkdirSync(managedDir, { recursive: true });
    }
  }
}

================
File: packages/compact/README.md
================
# Compact compiler manager for Midnight.js TypeScript Library

## Overview

This README provides information on the compact compiler manager for Midnight.js. 
The purpose of this package is to provide a single, easy-to-use, and lightweight 
package that fetches and compiles smart contracts written in Compact.

## Usage

### Install

```shell
yarn add -D @midnight-ntwrk/midnight-js-compact
yarn install
```

### Compile Compact contract 

**NOTE:** It can be executed even if you don't have compactc installed and set up.

```shell
yarn fetch-compactc
yarn run-compactc ./contract.compact ./contract-output
```

================
File: packages/compact/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": [
    "./src/test/**/*.mts",
    "./src/test/**/*.ts"
  ]
}

================
File: packages/compact/turbo.json
================
{
  "$schema": "https://turbo.build/v2/schema.json",
  "extends": ["//"],
  "tasks": {
    "build": {
      "outputs": ["dist/**", "managed/**"],
      "inputs": ["src/**", "tsconfig.json"],
      "cache": true
    }
  }
}

================
File: packages/contracts/src/test/utils/ledger-utils.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  type AlignedValue,
  ContractOperation,
  ContractState as CompactContractState,
  QueryContext
} from '@midnight-ntwrk/compact-runtime';
import {
  MaintenanceUpdate,
  type PartitionedTranscript,
  type PublicAddress,
  sampleCoinPublicKey,
  sampleContractAddress,
  sampleEncryptionPublicKey,
  sampleSigningKey,
  Transaction,
  type Transcript,
  unshieldedToken,
  ZswapChainState
} from '@midnight-ntwrk/ledger-v6';
import { createVerifierKey } from '@midnight-ntwrk/midnight-js-types';
import { toHex } from '@midnight-ntwrk/midnight-js-utils';
import { randomBytes } from 'crypto';

import {
  contractMaintenanceAuthority,
  createUnprovenLedgerCallTx,
  createUnprovenRemoveVerifierKeyTx,
  createUnprovenReplaceAuthorityTx,
  fromLedgerContractState,
  insertVerifierKey,
  removeVerifierKey,
  replaceAuthority,
  toLedgerContractState,
  toLedgerQueryContext,
  unprovenTxFromContractUpdates} from '../../utils';

describe('ledger-utils', () => {
  const dummySigningKey = sampleSigningKey();
  const dummySigningKey2 = sampleSigningKey();
  const dummyContractState = new CompactContractState();
  const dummyContractState2 = new CompactContractState();
  const dummyContractAddress = sampleContractAddress();
  const dummyEncPublicKey = sampleEncryptionPublicKey();
  // Generate a concrete Uint8Array for use as a verifier key
  const verifierKey = createVerifierKey(new Uint8Array(32));

  it('toLedgerContractState and fromLedgerContractState are inverses', () => {
    const ledgerState = toLedgerContractState(dummyContractState);
    const roundTrip = fromLedgerContractState(ledgerState);
    expect(roundTrip.constructor.name).toBe('ContractState');
    expect(roundTrip).toHaveProperty('maintenanceAuthority');
  });

  it('toLedgerQueryContext returns a LedgerQueryContext', () => {
    const queryContext = new QueryContext(dummyContractState.data, dummyContractAddress);
    const ledgerQueryContext = toLedgerQueryContext(queryContext);
    expect(ledgerQueryContext.address).toEqual(queryContext.address);
    // RuntimeError: unreachable
    // WASM Error
  });

  it('contractMaintenanceAuthority returns a valid authority', () => {
    const authority = contractMaintenanceAuthority(dummySigningKey, dummyContractState);
    expect(authority.threshold).toBe(1);
    expect(authority.committee.length).toBe(1);
    expect(authority.counter).toBe(1n);
  });

  it('replaceAuthority returns a ReplaceAuthority', () => {
    const ra = replaceAuthority(dummySigningKey, dummyContractState);
    expect(ra).toBeDefined();
    expect(ra.authority.threshold).toBe(1);
  });

  it('removeVerifierKey returns a VerifierKeyRemove', () => {
    const vkRemove = removeVerifierKey('op');
    expect(vkRemove).toBeDefined();
    expect(vkRemove.operation).toBe('op');
  });

  it.skip('insertVerifierKey returns a VerifierKeyInsert', () => {
    const vkInsert = insertVerifierKey('op', verifierKey);
    expect(vkInsert).toBeDefined();
    expect(vkInsert.operation).toBe('op');
  });

  it('unprovenTxFromContractUpdates returns an UnprovenTransaction', () => {
    const tx = unprovenTxFromContractUpdates(
      dummyContractAddress,
      [replaceAuthority(dummySigningKey, dummyContractState)],
      dummyContractState2,
      dummySigningKey2
    );
    expect(tx).toBeInstanceOf(Transaction);
  });

  it('createUnprovenLedgerCallTx returns an UnprovenTransaction', () => {
    const circuitId = 'unProvenLedgerTx';
    const tokenType = unshieldedToken();
    const contractState = dummyContractState;
    const contractOperation = new ContractOperation();
    const address = { tag: 'contract', address: sampleContractAddress() } as PublicAddress;

    contractState.setOperation(circuitId, contractOperation);

    const transcript: Transcript<AlignedValue> = {
      gas: {
        readTime: 1n,
        computeTime: 2n,
        bytesWritten: 4n,
        bytesDeleted: 8n,
      },
      effects: {
        claimedNullifiers: [toHex(randomBytes(32))],
        claimedShieldedReceives: [toHex(randomBytes(32))],
        claimedShieldedSpends: [toHex(randomBytes(32))],
        claimedContractCalls: new Array([5n, sampleContractAddress(), toHex(randomBytes(32)), new Uint8Array([0])]),
        shieldedMints: new Map([[toHex(randomBytes(32)), 1n]]),
        unshieldedInputs: new Map([[tokenType, 1n]]),
        unshieldedOutputs: new Map([[tokenType, 1n]]),
        unshieldedMints: new Map([[toHex(randomBytes(32)), 1n]]),
        claimedUnshieldedSpends: new Map([[[tokenType, address], 1n]])
      },
      program: ['new', { noop: { n: 5 } }]
    };

    const alignedValue: AlignedValue = {
      value: [new Uint8Array()],
      alignment: [
        {
          tag: 'atom',
          value: { tag: 'field' }
        }
      ]
    };

    const contractAddress = sampleContractAddress();
    const zswapChainState = new ZswapChainState();
    const partitionedTranscript: PartitionedTranscript = [transcript, transcript];
    const privateTranscriptOutputs: AlignedValue[] = [];
    const nextZswapLocalState = {
      outputs: [],
      inputs: [],
      coinPublicKey: sampleCoinPublicKey(),
      currentIndex: 0n
    };

    const tx = createUnprovenLedgerCallTx(
      circuitId,
      contractAddress,
      contractState,
      zswapChainState,
      partitionedTranscript,
      privateTranscriptOutputs,
      alignedValue,
      alignedValue,
      nextZswapLocalState,
      dummyEncPublicKey
    );
    expect(tx).toBeInstanceOf(Transaction);
  });

  it('createUnprovenReplaceAuthorityTx returns an UnprovenTransaction', () => {
    const tx = createUnprovenReplaceAuthorityTx(
      dummyContractAddress,
      dummySigningKey,
      dummyContractState,
      dummySigningKey2
    );
    expect(tx).toBeInstanceOf(Transaction);
  });

  it('createUnprovenRemoveVerifierKeyTx returns an UnprovenTransaction', () => {
    const tx = createUnprovenRemoveVerifierKeyTx(dummyContractAddress, 'op', dummyContractState, dummySigningKey);
    expect(tx).toBeInstanceOf(Transaction);
  });

  it('contractMaintenanceAuthority without contract state starts at 0', () => {
    const authority = contractMaintenanceAuthority(dummySigningKey);

    expect(authority.counter).toBe(0n);
    expect(authority.threshold).toBe(1);
    expect(authority.committee.length).toBe(1);
  });

  it('removeVerifierKey with Uint8Array operation', () => {
    const opBytes = new Uint8Array([1, 2, 3, 4]);
    const vkRemove = removeVerifierKey(opBytes);
    expect(vkRemove).toBeDefined();
    expect(vkRemove.operation).toBeDefined();
  });

  it('removeVerifierKey with string operation', () => {
    const vkRemove = removeVerifierKey('string-operation');
    expect(vkRemove).toBeDefined();
    expect(vkRemove.operation).toBe('string-operation');
  });

  it('creates unproven tx with multiple updates', () => {
    const updates = [
      replaceAuthority(dummySigningKey, dummyContractState),
      removeVerifierKey('circuit1')
    ];

    const tx = unprovenTxFromContractUpdates(
      dummyContractAddress,
      updates,
      dummyContractState2,
      dummySigningKey2
    );

    expect(tx).toBeInstanceOf(Transaction);
    expect(tx.intents?.get(1)?.actions.at(0), tx.toString()).toBeInstanceOf(MaintenanceUpdate);
    expect((tx.intents?.get(1)?.actions.at(0) as MaintenanceUpdate).updates.length).toEqual(2);
  });

  it('createUnprovenRemoveVerifierKeyTx with Uint8Array operation', () => {
    const opBytes = new Uint8Array([5, 6, 7, 8]);
    const tx = createUnprovenRemoveVerifierKeyTx(dummyContractAddress, opBytes, dummyContractState, dummySigningKey);
    expect(tx).toBeInstanceOf(Transaction);
  });

  it('replaceAuthority with different contract states', () => {
    const ra1 = replaceAuthority(dummySigningKey, dummyContractState);
    const ra2 = replaceAuthority(dummySigningKey2, dummyContractState2);

    expect(ra1).toBeDefined();
    expect(ra2).toBeDefined();
    expect(ra1.authority.threshold).toBe(1);
    expect(ra2.authority.threshold).toBe(1);
  });

  it('contractMaintenanceAuthority handles different signing keys', () => {
    const authority1 = contractMaintenanceAuthority(dummySigningKey);
    const authority2 = contractMaintenanceAuthority(dummySigningKey2);

    expect(authority1).toBeDefined();
    expect(authority2).toBeDefined();
    expect(authority1.threshold).toBe(authority2.threshold);
    expect(authority1.committee.length).toBe(authority2.committee.length);
  });
});

================
File: packages/contracts/src/test/utils/zswap-utils.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { fc } from '@fast-check/vitest';
import { type Recipient } from '@midnight-ntwrk/compact-runtime';
import {
  type CoinPublicKey,
  createShieldedCoinInfo,
  nativeToken,
  type QualifiedShieldedCoinInfo,
  sampleCoinPublicKey,
  sampleContractAddress,
  sampleEncryptionPublicKey,
  sampleRawTokenType,
  type ShieldedCoinInfo,
  shieldedToken,
  Transaction,
  ZswapChainState,
  ZswapOffer} from '@midnight-ntwrk/ledger-v6';
import { getNetworkId } from '@midnight-ntwrk/midnight-js-network-id';
import { toHex } from '@midnight-ntwrk/midnight-js-utils';
import { randomBytes } from 'crypto';
import { expect } from 'vitest';

import {
  createZswapOutput,
  deserializeCoinInfo,
  serializeCoinInfo,
  serializeQualifiedShieldedCoinInfo,
  zswapStateToNewCoins,
  zswapStateToOffer
} from '../../utils';

const arbitraryBytes = fc.uint8Array({ minLength: 32, maxLength: 32 });

const arbitraryValue = fc.bigInt({ min: 0n, max: (1n << 64n) - 1n });

const arbitraryPositiveValue = fc.bigInt({ min: 1n, max: (1n << 64n) - 1n });

const arbitraryNativeCoinInfo = arbitraryValue.map((value) => createShieldedCoinInfo(nativeToken().raw, value));

const arbitraryPositiveNativeCoinInfo = arbitraryPositiveValue.map((value) => createShieldedCoinInfo(nativeToken().raw, value));

const arbitraryHex = arbitraryBytes.map(toHex);

const arbitraryCoinPublicKey = fc.boolean().map(() => sampleCoinPublicKey());

const arbitraryContractAddress = fc.boolean().map(() => sampleContractAddress());

const arbitraryTokenType = fc.boolean().map(() => sampleRawTokenType());

const arbitraryCoinInfo = fc
  .tuple(arbitraryTokenType, arbitraryValue)
  .map(([tokenType, value]) => createShieldedCoinInfo(tokenType, value));

const arbitraryPositiveCoinInfo = fc
  .tuple(arbitraryTokenType, arbitraryPositiveValue)
  .map(([tokenType, value]) => createShieldedCoinInfo(tokenType, value));

const arbitraryQualifiedShieldedCoinInfo = fc.record({
  mt_index: arbitraryValue,
  type: arbitraryTokenType,
  nonce: arbitraryHex,
  value: arbitraryValue
});

const arbitraryContractRecipient = fc.record({
  is_left: fc.constant(false),
  left: arbitraryCoinPublicKey,
  right: arbitraryContractAddress
});

const sampleOne = <T>(arbitrary: fc.Arbitrary<T>): T => fc.sample(arbitrary, 1)[0]!;

const arbitraryNonContractRecipient = fc.record({
  is_left: fc.constant(true),
  left: arbitraryCoinPublicKey,
  right: arbitraryContractAddress
});

const arbitraryRecipient = fc.oneof(arbitraryContractRecipient, arbitraryNonContractRecipient);

const randomOutputData = () =>
  sampleOne(
    fc.record({
      coinInfo: arbitraryPositiveCoinInfo,
      recipient: arbitraryNonContractRecipient
    })
  );

const randomQualifiedShieldedCoinInfo = () => sampleOne(arbitraryQualifiedShieldedCoinInfo);

const randomEncryptionPublicKey = () => sampleOne(arbitraryHex);

const randomCoinPublicKey = () => sampleOne(arbitraryCoinPublicKey);


const dropMtIndex = ({ mt_index: _, ...coin }: QualifiedShieldedCoinInfo) => coin;

const toOutputData = (recipient: Recipient, coinInfos: (QualifiedShieldedCoinInfo | ShieldedCoinInfo)[]) =>
  coinInfos.map((coinInfo) =>
    'mt_index' in coinInfo ? { recipient, coinInfo: dropMtIndex(coinInfo) } : { recipient, coinInfo }
  );

const distinctFrom = (coinInfos: (ShieldedCoinInfo | QualifiedShieldedCoinInfo)[]) => {
  const set = new Set(coinInfos.map(({ nonce }) => nonce));
  return (coinInfo: ShieldedCoinInfo) => !set.has(coinInfo.nonce);
};

const withZeroMtIndex = (coinInfos: ShieldedCoinInfo[]): QualifiedShieldedCoinInfo[] =>
  coinInfos.map((coin) => ({ ...coin, mt_index: 0n }));

describe('Zswap utilities', () => {
  test("should work with instanceof on 'Uint8Array' and 'Buffer'", () => {
    expect(randomBytes(32) instanceof Uint8Array).toBe(true);
    expect(randomBytes(32) instanceof Buffer).toBe(true);
    expect(randomBytes(32).valueOf() instanceof Uint8Array).toBe(true);
    expect(randomBytes(32).valueOf() instanceof Buffer).toBe(true);
  });

  test("should throw error when attempting to serialize a 'CoinInfo' with additional properties", () =>
    expect(() =>
      serializeCoinInfo({
        nonce: toHex(randomBytes(32)),
        type: toHex(randomBytes(32)),
        value: 0n,
        hello: 'darkness'
      } as ShieldedCoinInfo)
    ).toThrowError());

  test("should throw error when attempting to deserialize a string representing a 'CoinInfo' with additional properties", () =>
    expect(() =>
      deserializeCoinInfo(
        JSON.stringify({
          value: { __big_int_val__: 0n.toString() },
          nonce: { __uint8Array_val__: toHex(randomBytes(32)) },
          color: { __uint8Array_val__: toHex(randomBytes(32)) },
          old: 'friend'
        })
      )
    ).toThrowError());

  test("should produce the original value when serializing then deserializing 'CoinInfo'", () =>
    fc.assert(
      fc.property(arbitraryCoinInfo, (coinInfo) => {
        expect(deserializeCoinInfo(serializeCoinInfo(coinInfo))).toEqual(coinInfo);
      })
    ));

  test("should produce the original value without 'mt_index' when serializing 'QualifiedShieldedCoinInfo' then deserializing 'CoinInfo'", () =>
    fc.assert(
      fc.property(arbitraryQualifiedShieldedCoinInfo, (qualifiedCoinInfo) => {
        expect(deserializeCoinInfo(serializeQualifiedShieldedCoinInfo(qualifiedCoinInfo))).toEqual(
          dropMtIndex(qualifiedCoinInfo)
        );
      })
    ));

  test("should have equal serialized strings for 'QualifiedShieldedCoinInfo' and extracted 'CoinInfo'", () =>
    fc.assert(
      fc.property(arbitraryQualifiedShieldedCoinInfo, (qualifiedCoinInfo) => {
        expect(serializeCoinInfo(dropMtIndex(qualifiedCoinInfo))).toEqual(
          serializeQualifiedShieldedCoinInfo(qualifiedCoinInfo)
        );
      })
    ));

  test("should throw error when calling 'zswapStateToOffer' with no chain state and inputs", () =>
    expect(() =>
      zswapStateToOffer(
        {
          currentIndex: 0n,
          coinPublicKey: randomCoinPublicKey(),
          inputs: [randomQualifiedShieldedCoinInfo()],
          outputs: [randomOutputData()]
        },
        randomEncryptionPublicKey()
      )
    ).toThrowError());

  const sum = (bs: (ShieldedCoinInfo | { recipient: Recipient; coinInfo: ShieldedCoinInfo })[]): bigint =>
    bs.reduce((prev, curr) => {
      if (typeof curr === 'object' && 'recipient' in curr && 'coinInfo' in curr) {
        return prev + curr.coinInfo.value;
      }
      return prev + curr.value;
    }, 0n);

  const zswapChainStateWithNonMatchingInputs = (recipient: Recipient, values: bigint[]) => {
    const nonMatchingInputs: QualifiedShieldedCoinInfo[] = [];
    const zswapChainState = values.reduce((prevZSwapChainState, value) => {
      const coinInfo = createShieldedCoinInfo(shieldedToken().raw, value);
      const output = createZswapOutput({ coinInfo, recipient }, randomEncryptionPublicKey());
      const proofErasedOffer = Transaction.fromParts(
        getNetworkId(), ZswapOffer.fromOutput(output, nativeToken().raw, value)
      ).eraseProofs().guaranteedOffer;
      if (proofErasedOffer) {
        const [newZswapChainState, mtIndices] = prevZSwapChainState.tryApply(proofErasedOffer);
        nonMatchingInputs.push({ ...coinInfo, mt_index: mtIndices.get(output.commitment)! });
        return newZswapChainState;
      }
      return prevZSwapChainState;
    }, new ZswapChainState());
    const zswapChainStateUpdated = zswapChainState.postBlockUpdate(new Date());
    return { zswapChainState: zswapChainStateUpdated, nonMatchingInputs };
  };

  const arbitraryMatchingInputOutputPairs = (
    recipient: Recipient,
    preExistingCoins: (QualifiedShieldedCoinInfo | ShieldedCoinInfo)[]
  ): fc.Arbitrary<[QualifiedShieldedCoinInfo[], { recipient: Recipient; coinInfo: ShieldedCoinInfo }[]]> =>
    fc.array(arbitraryPositiveNativeCoinInfo.filter(distinctFrom(preExistingCoins)), { minLength: 0 }).map((matchingOutputsNoRecipient) => [
      withZeroMtIndex(matchingOutputsNoRecipient), // matching inputs
      toOutputData(recipient, matchingOutputsNoRecipient) // matching outputs
    ]);

  // Helper types for better readability
  type ZswapScenarioData = {
    zswapChainState: ZswapChainState;
    expectedInputCount: number;
    expectedInputsSum: bigint;
    expectedOutputCount: number;
    expectedOutputsSum: bigint;
    expectedTransientCount: number;
    zswapState: {
      currentIndex: bigint;
      coinPublicKey: CoinPublicKey;
      inputs: QualifiedShieldedCoinInfo[];
      outputs: { recipient: Recipient; coinInfo: ShieldedCoinInfo }[];
    };
    addressAndChainStateTuple?: {
      contractAddress: CoinPublicKey;
      zswapChainState: ZswapChainState;
    };
  };

  const createZswapScenarioData = (
    recipient: Recipient,
    values: bigint[],
    nonMatchingOutputsNoRecipient: ShieldedCoinInfo[],
    matchingInputs: QualifiedShieldedCoinInfo[],
    matchingOutputs: { recipient: Recipient; coinInfo: ShieldedCoinInfo }[],
    useAddressAndChainStateTuple: boolean,
    zswapChainState: ZswapChainState,
    nonMatchingInputs: QualifiedShieldedCoinInfo[]
  ): ZswapScenarioData => {
    const nonMatchingOutputs = toOutputData(recipient, nonMatchingOutputsNoRecipient);

    return {
      zswapChainState,
      expectedInputCount: useAddressAndChainStateTuple ? nonMatchingInputs.length : 0,
      expectedInputsSum: useAddressAndChainStateTuple ? sum(nonMatchingInputs) : 0n,
      expectedOutputCount: nonMatchingOutputsNoRecipient.length,
      expectedOutputsSum: sum(nonMatchingOutputs),
      expectedTransientCount: matchingOutputs.length,
      zswapState: {
        currentIndex: 0n,
        coinPublicKey: randomCoinPublicKey(),
        inputs: useAddressAndChainStateTuple ? nonMatchingInputs.concat(matchingInputs) : matchingInputs,
        outputs: nonMatchingOutputs.concat(matchingOutputs)
      },
      addressAndChainStateTuple: useAddressAndChainStateTuple
        ? {
            contractAddress: recipient.right,
            zswapChainState
          }
        : undefined
    };
  };

  const arbitraryZswapScenario: fc.Arbitrary<ZswapScenarioData> = fc
    // TODO: Generalize to arbitrary recipients to capture scenarios where no inputs are created.
    .tuple(arbitraryContractRecipient, fc.array(arbitraryPositiveValue, { minLength: 0 }))
    .chain(([recipient, values]) => {
      const { nonMatchingInputs, zswapChainState } = zswapChainStateWithNonMatchingInputs(recipient, values);

      return fc
        .array(arbitraryPositiveNativeCoinInfo.filter(distinctFrom(nonMatchingInputs)), { minLength: 1 })
        .chain((nonMatchingOutputsNoRecipient) =>
          arbitraryMatchingInputOutputPairs(recipient, nonMatchingOutputsNoRecipient.concat(nonMatchingInputs))
            .chain(([matchingInputs, matchingOutputs]) =>
              fc.boolean().map((useParams) =>
                createZswapScenarioData(
                  recipient,
                  values,
                  nonMatchingOutputsNoRecipient,
                  matchingInputs,
                  matchingOutputs,
                  useParams,
                  zswapChainState,
                  nonMatchingInputs
                )
              )
            )
        );
    });

  test('should create expected number of inputs, outputs, and transients [@slow]', () =>
    fc.assert(
      fc.property(
        arbitraryZswapScenario,
        ({
          expectedInputCount,
          expectedInputsSum,
          expectedOutputCount,
          expectedOutputsSum,
          expectedTransientCount,
          zswapState,
          addressAndChainStateTuple
        }) => {
          const unprovenOffer = zswapStateToOffer(zswapState, randomEncryptionPublicKey(), addressAndChainStateTuple);
          expect(unprovenOffer).toBeDefined();
          expect(unprovenOffer!.outputs.length).toBe(expectedOutputCount);
          expect(unprovenOffer!.inputs.length).toBe(expectedInputCount);
          expect(unprovenOffer!.transients.length).toBe(expectedTransientCount);

          const delta = unprovenOffer!.deltas.get(nativeToken().raw);
          if (addressAndChainStateTuple) {
            const expectedDelta = expectedInputsSum - expectedOutputsSum;
            if (expectedInputCount > 0 && expectedOutputCount > 0 && expectedDelta !== 0n) {
              expect(delta).toBe(expectedDelta);
            } else if (expectedInputCount > 0 && expectedInputsSum !== 0n) {
              expect(delta).toBe(expectedInputsSum);
            } else if (expectedOutputCount > 0 && expectedOutputsSum !== 0n) {
              expect(delta).toBe(-expectedOutputsSum);
            } else {
              expect(delta).toBeUndefined();
            }
          } else if (expectedOutputCount > 0) {
            expect(delta).toBe(-expectedOutputsSum);
          } else {
            expect(delta).toBeUndefined();
          }
        }
      )
    ));

  test('should return only coins meant for provided wallet in zswapStateToNewCoins', () => {
    type ScenarioData = {
      walletCoinPublicKey: CoinPublicKey;
      outputsForWallet: { recipient: Recipient; coinInfo: ShieldedCoinInfo }[];
      outputsNotForWallet: { recipient: Recipient; coinInfo: ShieldedCoinInfo }[];
    }
    const arbitraryScenario = arbitraryCoinPublicKey.chain((walletCoinPublicKey) =>
      fc.record<ScenarioData>({
        walletCoinPublicKey: fc.constant(walletCoinPublicKey),
        outputsForWallet: fc.array(arbitraryPositiveCoinInfo, { minLength: 1 }).map((coins) =>
          coins.map((coinInfo) => ({
            coinInfo,
            recipient: {
              is_left: true,
              left: walletCoinPublicKey,
              right: sampleContractAddress()
            }
          }))
        ),
        outputsNotForWallet: fc
          .array(fc.tuple(arbitraryPositiveCoinInfo, arbitraryRecipient), { minLength: 0 })
          .map((coinsAndRecipients) => coinsAndRecipients.map(([coinInfo, recipient]) => ({ coinInfo, recipient })))
      })
    );

    fc.assert(
      fc.property(arbitraryScenario, (data) => {
        const zswapState = {
          currentIndex: 0n,
          coinPublicKey: data.walletCoinPublicKey,
          inputs: [],
          outputs: [...data.outputsForWallet, ...data.outputsNotForWallet]
        };
        const newCoins = zswapStateToNewCoins(data.walletCoinPublicKey, zswapState);
        const expected = data.outputsForWallet.map((output) => output.coinInfo);
        expect(newCoins).toEqual(expected);
      })
    );
  });

  describe('Edge cases for inputs, outputs, and transients', () => {
    test('should return undefined offer for empty zswap state - changed in ledger 6', () => {
      const emptyZswapState = {
        currentIndex: 0n,
        coinPublicKey: randomCoinPublicKey(),
        inputs: [],
        outputs: []
      };

      const result = zswapStateToOffer(emptyZswapState, randomEncryptionPublicKey());
      expect(result).toBeUndefined();
    });

    test('should create correct number of outputs when no inputs', () => {
      const outputData = randomOutputData();
      const zswapState = {
        currentIndex: 0n,
        coinPublicKey: sampleCoinPublicKey(),
        inputs: [],
        outputs: [outputData]
      };

      const result = zswapStateToOffer(zswapState, sampleEncryptionPublicKey());
      expect(result).toBeDefined();
      expect(result!.outputs.length).toBe(1);
      expect(result!.inputs.length).toBe(0);
      expect(result!.transients.length).toBe(0);
    });

    test('should create correct number of inputs when addressAndChainStateTuple provided', () => {
      const recipient = sampleOne(arbitraryContractRecipient);
      const { zswapChainState, nonMatchingInputs } = zswapChainStateWithNonMatchingInputs(recipient, [100n]);

      const zswapState = {
        currentIndex: 0n,
        coinPublicKey: randomCoinPublicKey(),
        inputs: nonMatchingInputs,
        outputs: []
      };

      const addressAndChainStateTuple = {
        contractAddress: recipient.right,
        zswapChainState
      };

      const result = zswapStateToOffer(zswapState, randomEncryptionPublicKey(), addressAndChainStateTuple);
      expect(result).toBeDefined();
      expect(result!.inputs.length).toBe(1);
      expect(result!.outputs.length).toBe(0);
      expect(result!.transients.length).toBe(0);
    });

    test('should handle mixed inputs, outputs, and transients', () => {
      const recipient = sampleOne(arbitraryContractRecipient);
      const { zswapChainState, nonMatchingInputs } = zswapChainStateWithNonMatchingInputs(recipient, [50n]);

      const outputCoinInfo = sampleOne(arbitraryNativeCoinInfo);
      const transientCoinInfo = sampleOne(arbitraryNativeCoinInfo);
      const qualifiedTransientCoinInfo = { ...transientCoinInfo, mt_index: 1n };

      const zswapState = {
        currentIndex: 0n,
        coinPublicKey: randomCoinPublicKey(),
        inputs: [...nonMatchingInputs, qualifiedTransientCoinInfo],
        outputs: [
          { recipient, coinInfo: outputCoinInfo },
          { recipient, coinInfo: transientCoinInfo }
        ]
      };

      const addressAndChainStateTuple = {
        contractAddress: recipient.right,
        zswapChainState
      };

      const result = zswapStateToOffer(zswapState, randomEncryptionPublicKey(), addressAndChainStateTuple);
      expect(result).toBeDefined();
      expect(result!.inputs.length).toBe(1); // nonMatchingInputs
      expect(result!.outputs.length).toBe(1); // outputCoinInfo
      expect(result!.transients.length).toBe(1); // transientCoinInfo
    });

    test('should handle zero value outputs correctly', () => {
      const zeroValueOutput = {
        recipient: sampleOne(arbitraryContractRecipient),
        coinInfo: createShieldedCoinInfo(nativeToken().raw, 0n)
      };

      const zswapState = {
        currentIndex: 0n,
        coinPublicKey: randomCoinPublicKey(),
        inputs: [],
        outputs: [zeroValueOutput]
      };

      const result = zswapStateToOffer(zswapState, randomEncryptionPublicKey());

      expect(result!.outputs.length).toBe(1);
      expect(result!.inputs.length).toBe(0);
      expect(result!.transients.length).toBe(0);
      expect(result!.deltas.get(nativeToken().raw), result!.toString()).toBe(0n);
    });

    test('should handle zero value inputs with addressAndChainStateTuple correctly', () => {
      const recipient = sampleOne(arbitraryContractRecipient);
      const { zswapChainState } = zswapChainStateWithNonMatchingInputs(recipient, [0n]);
      const zeroValueInput = { ...createShieldedCoinInfo(nativeToken().raw, 0n), mt_index: 0n };

      const zswapState = {
        currentIndex: 0n,
        coinPublicKey: randomCoinPublicKey(),
        inputs: [zeroValueInput],
        outputs: []
      };

      const addressAndChainStateTuple = {
        contractAddress: recipient.right,
        zswapChainState
      };

      const result = zswapStateToOffer(zswapState, randomEncryptionPublicKey(), addressAndChainStateTuple);

      expect(result!.inputs.length).toBe(1);
      expect(result!.outputs.length).toBe(0);
      expect(result!.transients.length).toBe(0);
      expect(result!.deltas.get(nativeToken().raw), result!.toString()).toBe(0n);
    });

    test('should create transient for single matching input-output pair', () => {
      const recipient = sampleOne(arbitraryContractRecipient);
      const coinInfo = createShieldedCoinInfo(nativeToken().raw, 100n);
      const qualifiedInput = { ...coinInfo, mt_index: 0n };
      const output = { recipient, coinInfo };

      const zswapState = {
        currentIndex: 0n,
        coinPublicKey: randomCoinPublicKey(),
        inputs: [qualifiedInput],
        outputs: [output]
      };

      const result = zswapStateToOffer(zswapState, randomEncryptionPublicKey());

      expect(result!.inputs.length).toBe(0);
      expect(result!.outputs.length).toBe(0);
      expect(result!.transients.length).toBe(1);
      expect(result!.deltas.get(nativeToken().raw)).toBeUndefined();
    });

    test('should create transient with zero delta for zero value matching pair', () => {
      const recipient = sampleOne(arbitraryContractRecipient);
      const coinInfo = createShieldedCoinInfo(nativeToken().raw, 0n);
      const qualifiedInput = { ...coinInfo, mt_index: 0n };
      const output = { recipient, coinInfo };

      const zswapState = {
        currentIndex: 0n,
        coinPublicKey: randomCoinPublicKey(),
        inputs: [qualifiedInput],
        outputs: [output]
      };

      const result = zswapStateToOffer(zswapState, randomEncryptionPublicKey());

      expect(result!.inputs.length).toBe(0);
      expect(result!.outputs.length).toBe(0);
      expect(result!.transients.length).toBe(1);
      expect(result!.deltas.get(nativeToken().raw), result!.toString()).toBeUndefined();
    });

    test('should produce negative delta for only outputs without addressAndChainStateTuple', () => {
      const output = {
        recipient: sampleOne(arbitraryContractRecipient),
        coinInfo: createShieldedCoinInfo(nativeToken().raw, 50n)
      };

      const zswapState = {
        currentIndex: 0n,
        coinPublicKey: randomCoinPublicKey(),
        inputs: [],
        outputs: [output]
      };

      const result = zswapStateToOffer(zswapState, randomEncryptionPublicKey());

      expect(result!.outputs.length).toBe(1);
      expect(result!.inputs.length).toBe(0);
      expect(result!.transients.length).toBe(0);
      expect(result!.deltas.get(nativeToken().raw)).toBe(-50n);
    });

    test('should produce positive delta for only inputs with addressAndChainStateTuple', () => {
      const recipient = sampleOne(arbitraryContractRecipient);
      const { zswapChainState, nonMatchingInputs } = zswapChainStateWithNonMatchingInputs(recipient, [75n]);

      const zswapState = {
        currentIndex: 0n,
        coinPublicKey: randomCoinPublicKey(),
        inputs: nonMatchingInputs,
        outputs: []
      };

      const addressAndChainStateTuple = {
        contractAddress: recipient.right,
        zswapChainState
      };

      const result = zswapStateToOffer(zswapState, randomEncryptionPublicKey(), addressAndChainStateTuple);

      expect(result!.inputs.length).toBe(1);
      expect(result!.outputs.length).toBe(0);
      expect(result!.transients.length).toBe(0);
      expect(result!.deltas.get(nativeToken().raw)).toBe(75n);
    });

    // reference: PM-19382
    test('should produce undefined delta for balanced inputs and outputs with addressAndChainStateTuple', () => {
      const recipient = sampleOne(arbitraryContractRecipient);
      const { zswapChainState, nonMatchingInputs } = zswapChainStateWithNonMatchingInputs(recipient, [100n]);

      const output = {
        recipient,
        coinInfo: createShieldedCoinInfo(nativeToken().raw, 100n)
      };

      const zswapState = {
        currentIndex: 0n,
        coinPublicKey: randomCoinPublicKey(),
        inputs: nonMatchingInputs,
        outputs: [output]
      };

      const addressAndChainStateTuple = {
        contractAddress: recipient.right,
        zswapChainState
      };

      const result = zswapStateToOffer(zswapState, randomEncryptionPublicKey(), addressAndChainStateTuple);

      expect(result).toBeDefined();
      expect(result!.inputs.length).toBe(1);
      expect(result!.outputs.length).toBe(1);
      expect(result!.transients.length).toBe(0);
      expect(result!.deltas.get(nativeToken().raw), result!.toString()).toBe(undefined);
    });
  });
});

================
File: packages/contracts/src/test/call-constructor.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { beforeEach, describe, expect, it, vi } from 'vitest';

import { callContractConstructor, type ContractConstructorOptionsWithPrivateState } from '../call-constructor';
import {
  createMockCoinPublicKey,
  createMockConstructorResult,
  createMockContract,
  createMockZswapLocalState
} from './test-mocks';

vi.mock('@midnight-ntwrk/compact-runtime', async (importOriginal) => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const actual = await importOriginal() as any;
  return {
    ...actual,
    decodeZswapLocalState: vi.fn()
  };
});

describe('callContractConstructor', () => {
  beforeEach(async () => {
    const { decodeZswapLocalState } = await import('@midnight-ntwrk/compact-runtime');
    vi.mocked(decodeZswapLocalState).mockReturnValue(createMockZswapLocalState());
  });

  it('should call contract constructor without arguments', () => {
    const contract = createMockContract();
    const constructorResult = createMockConstructorResult();

    contract.initialState = vi.fn().mockReturnValue({
      currentContractState: constructorResult.nextContractState,
      currentPrivateState: constructorResult.nextPrivateState,
      currentZswapLocalState: constructorResult.nextZswapLocalState
    });

    const options = {
      contract,
      coinPublicKey: createMockCoinPublicKey()
    } as ContractConstructorOptionsWithPrivateState<never>;

    const result = callContractConstructor(options);

    expect(result).toBeDefined();
    expect(result.nextContractState).toBe(constructorResult.nextContractState);
    expect(result.nextPrivateState).toBe(constructorResult.nextPrivateState);
    expect(result.nextZswapLocalState).toBeDefined();
    expect(contract.initialState).toHaveBeenCalledOnce();
  });

  it('should call contract constructor with arguments', () => {
    const contract = createMockContract();
    const constructorResult = createMockConstructorResult();

    contract.initialState = vi.fn().mockReturnValue({
      currentContractState: constructorResult.nextContractState,
      currentPrivateState: constructorResult.nextPrivateState,
      currentZswapLocalState: constructorResult.nextZswapLocalState
    });

    const options = {
      contract,
      coinPublicKey: createMockCoinPublicKey(),
      args: ['arg1', 'arg2']
    };

    const result = callContractConstructor(options);

    expect(result).toBeDefined();
    expect(result.nextContractState).toBe(constructorResult.nextContractState);
    expect(result.nextPrivateState).toBe(constructorResult.nextPrivateState);
    expect(contract.initialState).toHaveBeenCalledWith(
      expect.any(Object),
      'arg1',
      'arg2'
    );
  });

  it('should call contract constructor with private state', () => {
    const contract = createMockContract();
    const constructorResult = createMockConstructorResult();

    contract.initialState = vi.fn().mockReturnValue({
      currentContractState: constructorResult.nextContractState,
      currentPrivateState: constructorResult.nextPrivateState,
      currentZswapLocalState: constructorResult.nextZswapLocalState
    });

    const options = {
      contract,
      coinPublicKey: createMockCoinPublicKey(),
      initialPrivateState: { test: 'initial-private-state' }
    } as ContractConstructorOptionsWithPrivateState<never>;

    const result = callContractConstructor(options);

    expect(result).toBeDefined();
    expect(result.nextContractState).toBe(constructorResult.nextContractState);
    expect(result.nextPrivateState).toBe(constructorResult.nextPrivateState);
    expect(contract.initialState).toHaveBeenCalledOnce();
  });

  it('should call contract constructor with both arguments and private state', () => {
    const contract = createMockContract();
    const constructorResult = createMockConstructorResult();

    contract.initialState = vi.fn().mockReturnValue({
      currentContractState: constructorResult.nextContractState,
      currentPrivateState: constructorResult.nextPrivateState,
      currentZswapLocalState: constructorResult.nextZswapLocalState
    });

    const options = {
      contract,
      coinPublicKey: createMockCoinPublicKey(),
      args: ['constructor-arg'],
      initialPrivateState: { test: 'initial-private-state' }
    };

    const result = callContractConstructor(options);

    expect(result).toBeDefined();
    expect(result.nextContractState).toBe(constructorResult.nextContractState);
    expect(result.nextPrivateState).toBe(constructorResult.nextPrivateState);
    expect(contract.initialState).toHaveBeenCalledWith(
      expect.any(Object),
      'constructor-arg'
    );
  });
});

================
File: packages/contracts/src/test/call.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  ChargedState,
  type CircuitContext,
  type CircuitResults,
  CostModel,
  emptyZswapLocalState,
  StateValue
} from '@midnight-ntwrk/compact-runtime';
import {
  type AlignedValue,
  type Effects,
  sampleCoinPublicKey,
  type TokenType
} from '@midnight-ntwrk/ledger-v6';
import { type Contract, type PrivateState } from '@midnight-ntwrk/midnight-js-types';
import { beforeEach, describe, expect, it, type Mock, vi } from 'vitest';

import { call } from '../call';
import { createMockCallOptions, createMockCallOptionsWithPrivateState, createMockContractAddress, createMockContractState } from './test-mocks';

// TODO: add test: circuit with invalid arguments
// TODO: add test: circuit with not matching arguments (e.g.: Boolean -> Field)

describe('call', () => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let mockCircuit: Mock<(...args: any[]) => any>;

  beforeEach(() => {
    mockCircuit?.mockClear();

    mockCircuit = vi.fn().mockReturnValue({
      result: 'test-result',
      context: {
        currentQueryContext: {
          block: {
            ownAddress: '',
            comIndices: {} as Map<string, number>,
            balance: {} as Map<TokenType, bigint>,
            secondsSinceEpoch: 0n,
            secondsSinceEpochErr: 0,
            parentBlockHash: ''
          },
          state: new ChargedState(StateValue.newNull()),
          effects: {} as Effects,
          comIndices: new Map(),
          insertCommitment: vi.fn(),
          qualify: vi.fn(),
          runTranscript: vi.fn(),
          query: vi.fn(),
          intoTranscript: vi.fn(),
          address: createMockContractAddress(),
          toVmStack: vi.fn()
        },
        originalState: createMockContractState(),
        currentPrivateState: { test: 'private-state' } as PrivateState<Contract>,
        currentZswapLocalState: emptyZswapLocalState(sampleCoinPublicKey()),
        costModel: CostModel.initialCostModel()
      } as CircuitContext<Contract>,
      proofData: {
        input: {} as AlignedValue,
        output: {} as AlignedValue,
        privateTranscriptOutputs: [{}],
        publicTranscript: [{ noop: { n: 1 } }]
      },
    } as CircuitResults<Contract, string>);
  });

  it('should call circuit without initial private state', () => {
    const options = createMockCallOptions();
    options.contract.impureCircuits[options.circuitId] = mockCircuit;

    const result = call(options);

    expect(result).toBeDefined();
    expect(result.public).toBeDefined();
    expect(result.private).toBeDefined();
    expect(result.public.nextContractState).toBeDefined();
    expect(result.public.publicTranscript).toEqual([{ noop: { n: 1 } }]);
    expect(result.private.result).toBe('test-result');
    expect(mockCircuit).toHaveBeenCalledOnce();
  });

  it('should call circuit with private state', () => {
    const options = createMockCallOptionsWithPrivateState();

    options.contract.impureCircuits[options.circuitId] = mockCircuit;

    const result = call(options);

    expect(result).toBeDefined();
    expect(result.public.publicTranscript).toEqual([{ noop: { n: 1 } }]);
    expect(result.private.result).toBe('test-result');
    expect(result.private.nextPrivateState).toEqual({ test: 'private-state' });
    expect(mockCircuit).toHaveBeenCalledOnce();
  });

  it('should call circuit with arguments', () => {
    const options = {
      ...createMockCallOptions(),
      args: ['arg1', 'arg2']
    };

    options.contract.impureCircuits[options.circuitId] = mockCircuit;

    const result = call(options);

    expect(result).toBeDefined();
    expect(result.private.result).toBe('test-result');
    expect(mockCircuit).toHaveBeenCalledWith(
      expect.objectContaining({
        originalState: options.initialContractState,
        currentPrivateState: undefined
      }),
      'arg1',
      'arg2'
    );
  });

  it('should throw error for undefined circuit', () => {
    const options = createMockCallOptions({
      circuitId: 'nonExistentCircuit'
    });

    expect(() => call(options)).toThrow("Circuit 'nonExistentCircuit' is not defined");
  });
});

================
File: packages/contracts/src/test/deploy-contract.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type ZswapLocalState } from '@midnight-ntwrk/compact-runtime';
import { type UnprovenTransaction } from '@midnight-ntwrk/ledger-v6';
import { type Contract, type PrivateState } from '@midnight-ntwrk/midnight-js-types';
import { beforeEach, describe, expect, it, vi } from 'vitest';

import { type ContractProviders } from '../contract-providers';
import { deployContract, type DeployContractOptionsBase, type DeployedContract } from '../deploy-contract';
import { type UnsubmittedDeployTxData } from '../tx-model';
import {
  createMockContract, createMockContractState,
  createMockFinalizedTxData,
  createMockPrivateStateId,
  createMockProviders,
  createMockSigningKey
} from './test-mocks';

vi.mock('../submit-deploy-tx', () => ({
  submitDeployTx: vi.fn()
}));

vi.mock('../tx-interfaces', () => ({
  createCircuitCallTxInterface: vi.fn().mockReturnValue({ call: 'mock-call-interface' }),
  createCircuitMaintenanceTxInterfaces: vi.fn().mockReturnValue({ maintenance: 'mock-maintenance-interfaces' }),
  createContractMaintenanceTxInterface: vi.fn().mockReturnValue({ contractMaintenance: 'mock-contract-maintenance' })
}));

describe('deployContract', () => {
  let mockSubmitDeployTx: ReturnType<typeof vi.fn>;
  let mockDeployTxData: UnsubmittedDeployTxData<Contract>;
  let providers: ContractProviders;
  let baseOptions: DeployContractOptionsBase<Contract>;

  const createMockDeployTxData = (initialPrivateState?: PrivateState<Contract>): UnsubmittedDeployTxData<Contract> => ({
    public: {
      ...createMockFinalizedTxData(),
      contractAddress: 'mock-contract-address',
      initialContractState: createMockContractState()
    },
    private: {
      signingKey: createMockSigningKey(),
      initialPrivateState,
      initialZswapState: {} as ZswapLocalState,
      unprovenTx: {} as UnprovenTransaction,
      newCoins: []
    }
  });

  const assertDeployResult = (result: DeployedContract<Contract>, deployTxData: UnsubmittedDeployTxData<Contract>) => {
    expect(result).toBeDefined();
    expect(result.deployTxData).toBe(deployTxData);
    expect(result.callTx).toBeDefined();
    expect(result.circuitMaintenanceTx).toBeDefined();
    expect(result.contractMaintenanceTx).toBeDefined();
  };

  beforeEach(async () => {
    const { submitDeployTx } = await import('../submit-deploy-tx');
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    mockSubmitDeployTx = submitDeployTx as any;
    vi.clearAllMocks();

    providers = createMockProviders();
    baseOptions = {
      contract: createMockContract(),
      args: ['deploy-arg']
    };
  });

  it('should deploy contract without private state', async () => {
    mockDeployTxData = createMockDeployTxData();
    mockSubmitDeployTx.mockResolvedValue(mockDeployTxData);

    const result = await deployContract(providers, baseOptions);

    assertDeployResult(result, mockDeployTxData);
    expect(mockSubmitDeployTx).toHaveBeenCalledWith(
      providers,
      expect.objectContaining({
        contract: baseOptions.contract,
        args: baseOptions.args,
        signingKey: expect.not.stringMatching(createMockSigningKey())
      })
    );
  });

  it('should deploy contract with provided signing key', async () => {
    mockDeployTxData = createMockDeployTxData();
    mockSubmitDeployTx.mockResolvedValue(mockDeployTxData);

    const signingKey = createMockSigningKey();
    const options = { ...baseOptions, signingKey };

    const result = await deployContract(providers, options);

    assertDeployResult(result, mockDeployTxData);
    expect(mockSubmitDeployTx).toHaveBeenCalledWith(
      providers,
      expect.objectContaining({
        contract: options.contract,
        signingKey,
        args: options.args
      })
    );
  });

  it('should deploy contract with private state', async () => {
    const initialPrivateState = { test: 'initial-private-state' };
    mockDeployTxData = createMockDeployTxData(initialPrivateState);
    mockSubmitDeployTx.mockResolvedValue(mockDeployTxData);

    const options = {
      ...baseOptions,
      privateStateId: createMockPrivateStateId(),
      initialPrivateState
    };

    const result = await deployContract(providers, options);

    assertDeployResult(result, mockDeployTxData);
    expect(mockSubmitDeployTx).toHaveBeenCalledWith(
      providers,
      expect.objectContaining({
        contract: options.contract,
        privateStateId: options.privateStateId,
        initialPrivateState,
        args: options.args,
        signingKey: expect.not.stringMatching(createMockSigningKey())
      })
    );
  });

  it('should deploy contract with both custom signing key and private state', async () => {
    const initialPrivateState = { test: 'initial-private-state' };
    mockDeployTxData = createMockDeployTxData(initialPrivateState);
    mockSubmitDeployTx.mockResolvedValue(mockDeployTxData);

    const signingKey = createMockSigningKey();
    const options = {
      ...baseOptions,
      signingKey,
      privateStateId: createMockPrivateStateId(),
      initialPrivateState
    };

    const result = await deployContract(providers, options);

    assertDeployResult(result, mockDeployTxData);
    expect(mockSubmitDeployTx).toHaveBeenCalledWith(
      providers,
      expect.objectContaining({
        contract: options.contract,
        signingKey,
        privateStateId: options.privateStateId,
        initialPrivateState,
        args: options.args
      })
    );
  });
});

================
File: packages/contracts/src/test/find-deployed-contract.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type Contract } from '@midnight-ntwrk/midnight-js-types';
import { beforeEach, describe, expect, it, vi } from 'vitest';

import { findDeployedContract, type FoundContract } from '../find-deployed-contract';
import {
  createMockContract,
  createMockContractAddress,
  createMockContractState,
  createMockFinalizedTxData,
  createMockPrivateStateId,
  createMockProviders,
  createMockSigningKey,
  createMockVerifierKeys
} from './test-mocks';

vi.mock('../tx-interfaces', () => ({
  createCircuitCallTxInterface: vi.fn().mockReturnValue({ call: 'mock-call-interface' }),
  createCircuitMaintenanceTxInterfaces: vi.fn().mockReturnValue({ maintenance: 'mock-maintenance-interfaces' }),
  createContractMaintenanceTxInterface: vi.fn().mockReturnValue({ contractMaintenance: 'mock-contract-maintenance' })
}));

vi.mock('@midnight-ntwrk/midnight-js-types', async (importOriginal) => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const actual = await importOriginal() as any;
  return {
    ...actual,
    getImpureCircuitIds: vi.fn().mockReturnValue(['testCircuit'])
  };
});

describe('findDeployedContract', () => {
  let providers: ReturnType<typeof createMockProviders>;
  let contractAddress: ReturnType<typeof createMockContractAddress>;
  let contract: ReturnType<typeof createMockContract>;
  let finalizedTxData: ReturnType<typeof createMockFinalizedTxData>;
  let contractState: ReturnType<typeof createMockContractState>;
  let verifierKeys: ReturnType<typeof createMockVerifierKeys>;

  const setupCommonMocks = () => {
    vi.mocked(providers.publicDataProvider.watchForDeployTxData).mockResolvedValue(finalizedTxData);
    vi.mocked(providers.publicDataProvider.queryDeployContractState).mockResolvedValue(contractState);
    vi.mocked(providers.publicDataProvider.queryContractState).mockResolvedValue(contractState);
    vi.mocked(providers.zkConfigProvider.getVerifierKeys).mockResolvedValue(verifierKeys);
  };

  const expectBasicResult = (result: FoundContract<Contract>) => {
    expect(result).toBeDefined();
    expect(result.deployTxData).toBeDefined();
    expect(result.deployTxData.public.contractAddress).toBe(contractAddress);
    expect(result.deployTxData.public.initialContractState).toBe(contractState);
    expect(result.callTx).toBeDefined();
    expect(result.circuitMaintenanceTx).toBeDefined();
    expect(result.contractMaintenanceTx).toBeDefined();
  };

  const expectCommonProviderCalls = () => {
    expect(providers.publicDataProvider.watchForDeployTxData).toHaveBeenCalledWith(contractAddress);
    expect(providers.publicDataProvider.queryDeployContractState).toHaveBeenCalledWith(contractAddress);
    expect(providers.publicDataProvider.queryContractState).toHaveBeenCalledWith(contractAddress);
    expect(providers.zkConfigProvider.getVerifierKeys).toHaveBeenCalledWith(['testCircuit']);
  };

  beforeEach(() => {
    providers = createMockProviders();
    contractAddress = createMockContractAddress();
    contract = createMockContract();
    finalizedTxData = createMockFinalizedTxData();
    contractState = createMockContractState();
    verifierKeys = createMockVerifierKeys();

    setupCommonMocks();
  });

  it('should find deployed contract without private state', async () => {
    vi.mocked(providers.privateStateProvider.getSigningKey).mockResolvedValue(null);
    vi.mocked(providers.privateStateProvider.setSigningKey).mockResolvedValue(undefined);

    const options = {
      contract,
      contractAddress
    };

    const result = await findDeployedContract(providers, options);

    expectBasicResult(result);
    expectCommonProviderCalls();
  });

  it('should find deployed contract with provided signing key', async () => {
    const signingKey = createMockSigningKey();
    vi.mocked(providers.privateStateProvider.setSigningKey).mockResolvedValue(undefined);

    const options = {
      contract,
      contractAddress,
      signingKey
    };

    const result = await findDeployedContract(providers, options);

    expectBasicResult(result);
    expect(result.deployTxData.private.signingKey).toBe(signingKey);
    expect(providers.privateStateProvider.setSigningKey).toHaveBeenCalledWith(contractAddress, signingKey);
  });

  it('should find deployed contract with existing private state', async () => {
    const privateStateId = createMockPrivateStateId();
    const existingPrivateState = { test: 'existing-private-state' };

    vi.mocked(providers.privateStateProvider.getSigningKey).mockResolvedValue(null);
    vi.mocked(providers.privateStateProvider.setSigningKey).mockResolvedValue(undefined);
    vi.mocked(providers.privateStateProvider.get).mockResolvedValue(existingPrivateState);

    const options = {
      contract,
      contractAddress,
      privateStateId
    };

    const result = await findDeployedContract(providers, options);

    expectBasicResult(result);
    expect(result.deployTxData.private.initialPrivateState).toBe(existingPrivateState);
    expect(providers.privateStateProvider.get).toHaveBeenCalledWith(privateStateId);
  });

  it('should find deployed contract and store new private state', async () => {
    const privateStateId = createMockPrivateStateId();
    const initialPrivateState = { test: 'initial-private-state' };

    vi.mocked(providers.privateStateProvider.getSigningKey).mockResolvedValue(null);
    vi.mocked(providers.privateStateProvider.setSigningKey).mockResolvedValue(undefined);
    vi.mocked(providers.privateStateProvider.set).mockResolvedValue(undefined);

    const options = {
      contract,
      contractAddress,
      privateStateId,
      initialPrivateState
    };

    const result = await findDeployedContract(providers, options);

    expectBasicResult(result);
    expect(result.deployTxData.private.initialPrivateState).toBe(initialPrivateState);
    expect(providers.privateStateProvider.set).toHaveBeenCalledWith(privateStateId, initialPrivateState);
  });

  it('should find deployed contract with existing signing key', async () => {
    const existingSigningKey = createMockSigningKey();
    vi.mocked(providers.privateStateProvider.getSigningKey).mockResolvedValue(existingSigningKey);

    const options = {
      contract,
      contractAddress
    };

    const result = await findDeployedContract(providers, options);

    expectBasicResult(result);
    expect(result.deployTxData.private.signingKey).toBe(existingSigningKey);
    expect(providers.privateStateProvider.getSigningKey).toHaveBeenCalledWith(contractAddress);
    expect(providers.privateStateProvider.setSigningKey).not.toHaveBeenCalled();
  });

  it('should throw error when contract is not found', async () => {
    vi.mocked(providers.publicDataProvider.watchForDeployTxData).mockResolvedValue(finalizedTxData);
    vi.mocked(providers.publicDataProvider.queryDeployContractState).mockResolvedValue(null);

    const options = {
      contract,
      contractAddress
    };

    await expect(findDeployedContract(providers, options)).rejects.toThrow(
      `No contract deployed at contract address '${contractAddress}'`
    );

    expect(providers.publicDataProvider.watchForDeployTxData).toHaveBeenCalledWith(contractAddress);
    expect(providers.publicDataProvider.queryDeployContractState).toHaveBeenCalledWith(contractAddress);
    expect(providers.publicDataProvider.queryContractState).not.toHaveBeenCalled();
    expect(providers.zkConfigProvider.getVerifierKeys).not.toHaveBeenCalled();
  });
});

================
File: packages/contracts/src/test/get-states.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ZswapChainState } from '@midnight-ntwrk/ledger';
import type { PrivateStateId } from '@midnight-ntwrk/midnight-js-types';
import { beforeEach, describe, expect, it, vi } from 'vitest';

import { getPublicStates, getStates } from '../get-states';
import {
  createMockContractAddress,
  createMockContractState,
  createMockPrivateStateId,
  createMockProviders,
} from './test-mocks';

describe('get-states', () => {
  let mockProviders: ReturnType<typeof createMockProviders>;
  let mockContractAddress: ReturnType<typeof createMockContractAddress>;
  let mockContractState: ReturnType<typeof createMockContractState>;
  let mockZswapChainState: ZswapChainState;
  let mockPrivateStateId: PrivateStateId;
  let mockPrivateState: { test: string };

  beforeEach(() => {
    vi.clearAllMocks();

    mockProviders = createMockProviders();
    mockContractAddress = createMockContractAddress();
    mockContractState = createMockContractState();
    mockZswapChainState = {} as ZswapChainState;
    mockPrivateStateId = createMockPrivateStateId();
    mockPrivateState = { test: 'mock-private-state' };
  });

  describe('getPublicStates', () => {
    describe('happy path', () => {
      it('should successfully retrieve public states', async () => {
        mockProviders.publicDataProvider.queryZSwapAndContractState = vi.fn()
          .mockResolvedValue([mockZswapChainState, mockContractState]);

        const result = await getPublicStates(mockProviders.publicDataProvider, mockContractAddress);

        expect(mockProviders.publicDataProvider.queryZSwapAndContractState)
          .toHaveBeenCalledWith(mockContractAddress);
        expect(result).toEqual({
          zswapChainState: mockZswapChainState,
          contractState: mockContractState
        });
      });
    });
  });

  describe('getStates', () => {
    describe('happy path', () => {
      it('should successfully retrieve all states', async () => {
        mockProviders.publicDataProvider.queryZSwapAndContractState = vi.fn()
          .mockResolvedValue([mockZswapChainState, mockContractState]);
        mockProviders.privateStateProvider.get = vi.fn().mockResolvedValue(mockPrivateState);

        const result = await getStates(
          mockProviders.publicDataProvider,
          mockProviders.privateStateProvider,
          mockContractAddress,
          mockPrivateStateId
        );

        expect(mockProviders.publicDataProvider.queryZSwapAndContractState)
          .toHaveBeenCalledWith(mockContractAddress);
        expect(mockProviders.privateStateProvider.get).toHaveBeenCalledWith(mockPrivateStateId);
        expect(result).toEqual({
          zswapChainState: mockZswapChainState,
          contractState: mockContractState,
          privateState: mockPrivateState
        });
      });
    });
  });
});

================
File: packages/contracts/src/test/get-unshielded-balances.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ContractAddress } from '@midnight-ntwrk/ledger-v6';
import { sampleContractAddress } from '@midnight-ntwrk/ledger-v6';
import type { PublicDataProvider } from '@midnight-ntwrk/midnight-js-types';
import type { UnshieldedBalances } from '@midnight-ntwrk/midnight-js-types';
import { describe, expect, it, vi } from 'vitest';

import { getUnshieldedBalances } from '../get-unshielded-balances';

describe('getUnshieldedBalances', () => {
  const mockContractAddress = sampleContractAddress();
  const mockUnshieldedBalances: UnshieldedBalances = [
    {
      balance: 1000n,
      tokenType: 'token-type-1'
    },
    {
      balance: 2000n,
      tokenType: 'token-type-2'
    }
  ];

  it('should return unshielded balances when data exists', async () => {
    const mockPublicDataProvider: PublicDataProvider = {
      queryUnshieldedBalances: vi.fn().mockResolvedValue(mockUnshieldedBalances)
    } as unknown as PublicDataProvider;

    const result = await getUnshieldedBalances(mockPublicDataProvider, mockContractAddress);

    expect(mockPublicDataProvider.queryUnshieldedBalances).toHaveBeenCalledWith(mockContractAddress);
    expect(result).toEqual(mockUnshieldedBalances);
  });

  it('should throw error when no unshielded balances found', async () => {
    const mockPublicDataProvider: PublicDataProvider = {
      queryUnshieldedBalances: vi.fn().mockResolvedValue(null)
    } as unknown as PublicDataProvider;

    await expect(getUnshieldedBalances(mockPublicDataProvider, mockContractAddress))
      .rejects
      .toThrow(`No unshielded balances found at contract address '${mockContractAddress}'`);

    expect(mockPublicDataProvider.queryUnshieldedBalances).toHaveBeenCalledWith(mockContractAddress);
  });

  it('should validate contract address', async () => {
    const mockPublicDataProvider: PublicDataProvider = {
      queryUnshieldedBalances: vi.fn()
    } as unknown as PublicDataProvider;

    const invalidAddress = 'invalid-address' as ContractAddress;

    await expect(getUnshieldedBalances(mockPublicDataProvider, invalidAddress))
      .rejects
      .toThrow('input string');

    expect(mockPublicDataProvider.queryUnshieldedBalances).not.toHaveBeenCalled();
  });

  it('should return empty array when balances exist but are empty', async () => {
    const mockPublicDataProvider: PublicDataProvider = {
      queryUnshieldedBalances: vi.fn().mockResolvedValue([])
    } as unknown as PublicDataProvider;

    const result = await getUnshieldedBalances(mockPublicDataProvider, mockContractAddress);

    expect(mockPublicDataProvider.queryUnshieldedBalances).toHaveBeenCalledWith(mockContractAddress);
    expect(result).toEqual([]);
  });
});

================
File: packages/contracts/src/test/submit-deploy-tx.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type Contract, FailEntirely, FailFallible, type PrivateStateId } from '@midnight-ntwrk/midnight-js-types';
import { beforeEach, describe, expect, it, vi } from 'vitest';

import { DeployTxFailedError } from '../errors';
import { submitDeployTx } from '../submit-deploy-tx';
import { submitTx } from '../submit-tx';
import { createUnprovenDeployTx } from '../unproven-deploy-tx';
import {
  createMockContract,
  createMockContractAddress,
  createMockFinalizedTxData,
  createMockPrivateStateId,
  createMockProviders,
  createMockSigningKey,
  createMockUnprovenDeployTxData,
  createMockUnprovenTx,
  createMockZswapLocalState
} from './test-mocks';

vi.mock('../unproven-deploy-tx');
vi.mock('../submit-tx');
vi.mock('@midnight-ntwrk/compact-runtime');
vi.mock('@midnight-ntwrk/ledger-v6');

describe('submit-deploy-tx', () => {
  let mockContract: Contract<undefined>;
  let mockContractAddress: ReturnType<typeof createMockContractAddress>;
  let mockSigningKey: ReturnType<typeof createMockSigningKey>;
  let mockPrivateStateId: PrivateStateId;
  let mockProviders: ReturnType<typeof createMockProviders>;
  let mockUnprovenTx: ReturnType<typeof createMockUnprovenTx>;

  beforeEach(() => {
    vi.clearAllMocks();

    mockContract = createMockContract();
    mockContractAddress = createMockContractAddress();
    mockSigningKey = createMockSigningKey();
    mockPrivateStateId = createMockPrivateStateId();
    mockProviders = createMockProviders();
    mockUnprovenTx = createMockUnprovenTx();
  });

  describe('submitDeployTx', () => {
    describe('successful deployment without private state ID', () => {
      it('should successfully submit deploy transaction and set signing key', async () => {
        const options = {
          contract: mockContract,
          args: [],
          signingKey: mockSigningKey
        };

        const mockUnprovenDeployTxData = createMockUnprovenDeployTxData();
        const mockFinalizedTxData = createMockFinalizedTxData();

        vi.mocked(createUnprovenDeployTx).mockResolvedValue(mockUnprovenDeployTxData);
        vi.mocked(submitTx).mockResolvedValue(mockFinalizedTxData);

        const result = await submitDeployTx(mockProviders, options);

        expect(createUnprovenDeployTx).toHaveBeenCalledWith(mockProviders, options);
        expect(submitTx).toHaveBeenCalledWith(mockProviders, {
          unprovenTx: mockUnprovenDeployTxData.private.unprovenTx,
          newCoins: mockUnprovenDeployTxData.private.newCoins
        });
        expect(mockProviders.privateStateProvider.setSigningKey).toHaveBeenCalledWith(
          mockContractAddress,
          mockSigningKey
        );
        expect(mockProviders.privateStateProvider.set).not.toHaveBeenCalled();
        expect(result).toEqual({
          private: mockUnprovenDeployTxData.private,
          public: {
            ...mockFinalizedTxData,
            ...mockUnprovenDeployTxData.public
          }
        });
      });
    });

    describe('successful deployment with private state ID', () => {
      it('should successfully submit deploy transaction and set both signing key and private state', async () => {
        const initialPrivateState = { someState: 'test' };
        const options = {
          contract: mockContract,
          args: [],
          signingKey: mockSigningKey,
          privateStateId: mockPrivateStateId,
          initialPrivateState
        };

        const mockUnprovenDeployTxData = createMockUnprovenDeployTxData({
          private: {
            initialPrivateState: initialPrivateState,
            signingKey: mockSigningKey,
            unprovenTx: mockUnprovenTx,
            newCoins: [],
            initialZswapState: createMockZswapLocalState()
          }
        });
        const mockFinalizedTxData = createMockFinalizedTxData();

        vi.mocked(createUnprovenDeployTx).mockResolvedValue(mockUnprovenDeployTxData);
        vi.mocked(submitTx).mockResolvedValue(mockFinalizedTxData);

        const result = await submitDeployTx(mockProviders, options);

        expect(mockProviders.privateStateProvider.set).toHaveBeenCalledWith(mockPrivateStateId, initialPrivateState);
        expect(mockProviders.privateStateProvider.setSigningKey).toHaveBeenCalledWith(
          mockContractAddress,
          mockSigningKey
        );
        expect(result).toEqual({
          private: mockUnprovenDeployTxData.private,
          public: {
            ...mockFinalizedTxData,
            ...mockUnprovenDeployTxData.public
          }
        });
      });
    });

    describe('failed deployment scenarios', () => {
      it('should throw DeployTxFailedError when transaction fails with FailFallible', async () => {
        const options = {
          contract: mockContract,
          args: [],
          signingKey: mockSigningKey
        };

        const mockUnprovenDeployTxData = createMockUnprovenDeployTxData();
        const mockFailedTxData = createMockFinalizedTxData(FailFallible);

        vi.mocked(createUnprovenDeployTx).mockResolvedValue(mockUnprovenDeployTxData);
        vi.mocked(submitTx).mockResolvedValue(mockFailedTxData);

        await expect(submitDeployTx(mockProviders, options)).rejects.toThrow(DeployTxFailedError);

        expect(mockProviders.privateStateProvider.set).not.toHaveBeenCalled();
        expect(mockProviders.privateStateProvider.setSigningKey).not.toHaveBeenCalled();
      });

      it('should throw DeployTxFailedError when transaction fails with FailEntirely', async () => {
        const options = {
          contract: mockContract,
          args: [],
          signingKey: mockSigningKey
        };

        const mockUnprovenDeployTxData = createMockUnprovenDeployTxData();
        const mockFailedTxData = createMockFinalizedTxData(FailEntirely);

        vi.mocked(createUnprovenDeployTx).mockResolvedValue(mockUnprovenDeployTxData);
        vi.mocked(submitTx).mockResolvedValue(mockFailedTxData);

        await expect(submitDeployTx(mockProviders, options)).rejects.toThrow(DeployTxFailedError);

        expect(mockProviders.privateStateProvider.set).not.toHaveBeenCalled();
        expect(mockProviders.privateStateProvider.setSigningKey).not.toHaveBeenCalled();
      });

      it('should include failure data in DeployTxFailedError', async () => {
        const options = {
          contract: mockContract,
          args: [],
          signingKey: mockSigningKey
        };

        const mockUnprovenDeployTxData = createMockUnprovenDeployTxData();
        const mockFailedTxData = createMockFinalizedTxData(FailEntirely);

        vi.mocked(createUnprovenDeployTx).mockResolvedValue(mockUnprovenDeployTxData);
        vi.mocked(submitTx).mockResolvedValue(mockFailedTxData);

        try {
          await submitDeployTx(mockProviders, options);
          expect.fail('Expected DeployTxFailedError to be thrown');
        } catch (error) {
          expect(error).toBeInstanceOf(DeployTxFailedError);
          expect((error as DeployTxFailedError).finalizedTxData).toEqual(mockFailedTxData);
        }
      });
    });

    describe('error propagation', () => {
      it('should propagate errors from createUnprovenDeployTx', async () => {
        const options = {
          contract: mockContract,
          args: [],
          signingKey: mockSigningKey
        };

        const createError = new Error('Failed to create unproven deploy tx');
        vi.mocked(createUnprovenDeployTx).mockRejectedValue(createError);

        await expect(submitDeployTx(mockProviders, options)).rejects.toThrow('Failed to create unproven deploy tx');
        expect(submitTx).not.toHaveBeenCalled();
      });

      it('should propagate errors from submitTx', async () => {
        const options = {
          contract: mockContract,
          args: [],
          signingKey: mockSigningKey
        };

        const mockUnprovenDeployTxData = createMockUnprovenDeployTxData();

        const submitError = new Error('Network error during submission');
        vi.mocked(createUnprovenDeployTx).mockResolvedValue(mockUnprovenDeployTxData);
        vi.mocked(submitTx).mockRejectedValue(submitError);

        await expect(submitDeployTx(mockProviders, options)).rejects.toThrow('Network error during submission');
      });

      it('should propagate errors from privateStateProvider.set', async () => {
        const options = {
          contract: mockContract,
          args: [],
          signingKey: mockSigningKey,
          privateStateId: mockPrivateStateId,
          initialPrivateState: { someState: 'test' }
        };

        const mockUnprovenDeployTxData = createMockUnprovenDeployTxData({
          private: {
            initialPrivateState: { someState: 'test' },
            signingKey: mockSigningKey,
            unprovenTx: mockUnprovenTx,
            newCoins: [],
            initialZswapState: createMockZswapLocalState()
          }
        });

        const mockFinalizedTxData = createMockFinalizedTxData();

        const stateError = new Error('Failed to set private state');
        vi.mocked(createUnprovenDeployTx).mockResolvedValue(mockUnprovenDeployTxData);
        vi.mocked(submitTx).mockResolvedValue(mockFinalizedTxData);
        mockProviders.privateStateProvider.set = vi.fn().mockRejectedValue(stateError);

        await expect(submitDeployTx(mockProviders, options)).rejects.toThrow('Failed to set private state');
      });

      it('should propagate errors from privateStateProvider.setSigningKey', async () => {
        const options = {
          contract: mockContract,
          args: [],
          signingKey: mockSigningKey
        };

        const mockUnprovenDeployTxData = createMockUnprovenDeployTxData();
        const mockFinalizedTxData = createMockFinalizedTxData();

        const signingKeyError = new Error('Failed to set signing key');
        vi.mocked(createUnprovenDeployTx).mockResolvedValue(mockUnprovenDeployTxData);
        vi.mocked(submitTx).mockResolvedValue(mockFinalizedTxData);
        mockProviders.privateStateProvider.setSigningKey = vi.fn().mockRejectedValue(signingKeyError);

        await expect(submitDeployTx(mockProviders, options)).rejects.toThrow('Failed to set signing key');
      });
    });

    describe('edge cases', () => {
      it('should handle empty new coins array', async () => {
        const options = {
          contract: mockContract,
          args: [],
          signingKey: mockSigningKey
        };

        const mockUnprovenDeployTxData = createMockUnprovenDeployTxData({
          private: {
            unprovenTx: mockUnprovenTx,
            newCoins: [],
            signingKey: mockSigningKey,
            initialPrivateState: undefined,
            initialZswapState: createMockZswapLocalState()
          }
        });
        const mockFinalizedTxData = createMockFinalizedTxData();

        vi.mocked(createUnprovenDeployTx).mockResolvedValue(mockUnprovenDeployTxData);
        vi.mocked(submitTx).mockResolvedValue(mockFinalizedTxData);

        const result = await submitDeployTx(mockProviders, options);

        expect(submitTx).toHaveBeenCalledWith(mockProviders, {
          unprovenTx: mockUnprovenTx,
          newCoins: []
        });
        expect(result).toEqual({
          private: mockUnprovenDeployTxData.private,
          public: {
            ...mockFinalizedTxData,
            ...mockUnprovenDeployTxData.public
          }
        });
      });

      it('should handle undefined initial private state with private state ID', async () => {
        const options = {
          contract: mockContract,
          args: [],
          signingKey: mockSigningKey,
          privateStateId: mockPrivateStateId,
          initialPrivateState: undefined
        };

        const mockUnprovenDeployTxData = createMockUnprovenDeployTxData();
        const mockFinalizedTxData = createMockFinalizedTxData();

        vi.mocked(createUnprovenDeployTx).mockResolvedValue(mockUnprovenDeployTxData);
        vi.mocked(submitTx).mockResolvedValue(mockFinalizedTxData);

        await submitDeployTx(mockProviders, options);

        expect(mockProviders.privateStateProvider.set).toHaveBeenCalledWith(mockPrivateStateId, undefined);
      });
    });
  });
});

================
File: packages/contracts/src/test/submit-insert-vk-tx.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type VerifierKey } from '@midnight-ntwrk/midnight-js-types';
import { beforeEach, describe, expect, it, vi } from 'vitest';

import { submitInsertVerifierKeyTx } from '../submit-insert-vk-tx';
import { submitTx } from '../submit-tx';
import { createUnprovenInsertVerifierKeyTx } from '../utils';
import {
  createMockContractAddress,
  createMockContractState,
  createMockFinalizedTxData,
  createMockProviders,
  createMockSigningKey,
  createMockUnprovenTx
} from './test-mocks';

vi.mock('../submit-tx');
vi.mock('../utils');

describe('submitInsertVerifierKeyTx', () => {
  let mockProviders: ReturnType<typeof createMockProviders>;
  let mockContractAddress: ReturnType<typeof createMockContractAddress>;
  let mockContractState: ReturnType<typeof createMockContractState>;
  let mockSigningKey: ReturnType<typeof createMockSigningKey>;
  let mockUnprovenTx: ReturnType<typeof createMockUnprovenTx>;
  let mockVerifierKey: VerifierKey;

  beforeEach(() => {
    vi.clearAllMocks();
    
    mockProviders = createMockProviders();
    mockContractAddress = createMockContractAddress();
    mockContractState = createMockContractState();
    mockSigningKey = createMockSigningKey();
    mockUnprovenTx = createMockUnprovenTx();
    mockVerifierKey = new Uint8Array(32) as VerifierKey;
  });

  describe('happy path', () => {
    it('should successfully submit insert verifier key transaction', async () => {
      const circuitId = 'testCircuit';
      const mockFinalizedTxData = createMockFinalizedTxData();

      mockProviders.publicDataProvider.queryContractState = vi.fn().mockResolvedValue(mockContractState);
      mockProviders.privateStateProvider.getSigningKey = vi.fn().mockResolvedValue(mockSigningKey);
      mockContractState.operation = vi.fn().mockReturnValue(undefined);
      
      vi.mocked(createUnprovenInsertVerifierKeyTx).mockReturnValue(mockUnprovenTx);
      vi.mocked(submitTx).mockResolvedValue(mockFinalizedTxData);

      const result = await submitInsertVerifierKeyTx(
        mockProviders,
        mockContractAddress,
        circuitId,
        mockVerifierKey
      );

      expect(mockProviders.publicDataProvider.queryContractState).toHaveBeenCalledWith(mockContractAddress);
      expect(mockProviders.privateStateProvider.getSigningKey).toHaveBeenCalledWith(mockContractAddress);
      expect(mockContractState.operation).toHaveBeenCalledWith(circuitId);
      expect(createUnprovenInsertVerifierKeyTx).toHaveBeenCalledWith(
        mockContractAddress,
        circuitId,
        mockVerifierKey,
        mockContractState,
        mockSigningKey
      );
      expect(submitTx).toHaveBeenCalledWith(mockProviders, { unprovenTx: mockUnprovenTx });
      expect(result).toBe(mockFinalizedTxData);
    });
  });

  describe('error scenarios', () => {
    it('should throw InsertVerifierKeyTxFailedError when transaction fails', async () => {
      const { InsertVerifierKeyTxFailedError } = await import('../errors');
      const { FailEntirely } = await import('@midnight-ntwrk/midnight-js-types');
      
      const circuitId = 'testCircuit';
      const failedTxData = createMockFinalizedTxData(FailEntirely);

      mockProviders.publicDataProvider.queryContractState = vi.fn().mockResolvedValue(mockContractState);
      mockProviders.privateStateProvider.getSigningKey = vi.fn().mockResolvedValue(mockSigningKey);
      mockContractState.operation = vi.fn().mockReturnValue(undefined);
      
      vi.mocked(createUnprovenInsertVerifierKeyTx).mockReturnValue(mockUnprovenTx);
      vi.mocked(submitTx).mockResolvedValue(failedTxData);

      await expect(
        submitInsertVerifierKeyTx(mockProviders, mockContractAddress, circuitId, mockVerifierKey)
      ).rejects.toThrow(InsertVerifierKeyTxFailedError);
    });
  });
});

================
File: packages/contracts/src/test/submit-remove-vk-tx.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { beforeEach, describe, expect, it, vi } from 'vitest';

import { submitRemoveVerifierKeyTx } from '../submit-remove-vk-tx';
import { submitTx } from '../submit-tx';
import { createUnprovenRemoveVerifierKeyTx } from '../utils';
import {
  createMockContractAddress,
  createMockContractState,
  createMockFinalizedTxData,
  createMockProviders,
  createMockSigningKey,
  createMockUnprovenTx
} from './test-mocks';

vi.mock('../submit-tx');
vi.mock('../utils');

describe('submitRemoveVerifierKeyTx', () => {
  let mockProviders: ReturnType<typeof createMockProviders>;
  let mockContractAddress: ReturnType<typeof createMockContractAddress>;
  let mockContractState: ReturnType<typeof createMockContractState>;
  let mockSigningKey: ReturnType<typeof createMockSigningKey>;
  let mockUnprovenTx: ReturnType<typeof createMockUnprovenTx>;

  beforeEach(() => {
    vi.clearAllMocks();
    
    mockProviders = createMockProviders();
    mockContractAddress = createMockContractAddress();
    mockContractState = createMockContractState();
    mockSigningKey = createMockSigningKey();
    mockUnprovenTx = createMockUnprovenTx();
  });

  describe('happy path', () => {
    it('should successfully submit remove verifier key transaction', async () => {
      const circuitId = 'testCircuit';
      const mockFinalizedTxData = createMockFinalizedTxData();
      const mockOperation = { verifierKey: new Uint8Array(32) };

      mockProviders.publicDataProvider.queryContractState = vi.fn().mockResolvedValue(mockContractState);
      mockProviders.privateStateProvider.getSigningKey = vi.fn().mockResolvedValue(mockSigningKey);
      mockContractState.operation = vi.fn().mockReturnValue(mockOperation);
      
      vi.mocked(createUnprovenRemoveVerifierKeyTx).mockReturnValue(mockUnprovenTx);
      vi.mocked(submitTx).mockResolvedValue(mockFinalizedTxData);

      const result = await submitRemoveVerifierKeyTx(
        mockProviders,
        mockContractAddress,
        circuitId
      );

      expect(mockProviders.publicDataProvider.queryContractState).toHaveBeenCalledWith(mockContractAddress);
      expect(mockProviders.privateStateProvider.getSigningKey).toHaveBeenCalledWith(mockContractAddress);
      expect(mockContractState.operation).toHaveBeenCalledWith(circuitId);
      expect(createUnprovenRemoveVerifierKeyTx).toHaveBeenCalledWith(
        mockContractAddress,
        circuitId,
        mockContractState,
        mockSigningKey
      );
      expect(submitTx).toHaveBeenCalledWith(mockProviders, { unprovenTx: mockUnprovenTx });
      expect(result).toBe(mockFinalizedTxData);
    });
  });

  describe('error scenarios', () => {
    it('should throw RemoveVerifierKeyTxFailedError when transaction fails', async () => {
      const { RemoveVerifierKeyTxFailedError } = await import('../errors');
      const { FailEntirely } = await import('@midnight-ntwrk/midnight-js-types');
      
      const circuitId = 'testCircuit';
      const failedTxData = createMockFinalizedTxData(FailEntirely);
      const mockOperation = { verifierKey: new Uint8Array(32) };

      mockProviders.publicDataProvider.queryContractState = vi.fn().mockResolvedValue(mockContractState);
      mockProviders.privateStateProvider.getSigningKey = vi.fn().mockResolvedValue(mockSigningKey);
      mockContractState.operation = vi.fn().mockReturnValue(mockOperation);
      
      vi.mocked(createUnprovenRemoveVerifierKeyTx).mockReturnValue(mockUnprovenTx);
      vi.mocked(submitTx).mockResolvedValue(failedTxData);

      await expect(
        submitRemoveVerifierKeyTx(mockProviders, mockContractAddress, circuitId)
      ).rejects.toThrow(RemoveVerifierKeyTxFailedError);
    });
  });
});

================
File: packages/contracts/src/test/submit-replace-authority-tx.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { beforeEach, describe, expect, it, vi } from 'vitest';

import { submitReplaceAuthorityTx } from '../submit-replace-authority-tx';
import { submitTx } from '../submit-tx';
import { createUnprovenReplaceAuthorityTx } from '../utils';
import {
  createMockContractAddress,
  createMockContractState,
  createMockFinalizedTxData,
  createMockProviders,
  createMockSigningKey,
  createMockUnprovenTx
} from './test-mocks';

vi.mock('../submit-tx');
vi.mock('../utils');

describe('submitReplaceAuthorityTx', () => {
  let mockProviders: ReturnType<typeof createMockProviders>;
  let mockContractAddress: ReturnType<typeof createMockContractAddress>;
  let mockContractState: ReturnType<typeof createMockContractState>;
  let mockCurrentAuthority: ReturnType<typeof createMockSigningKey>;
  let mockNewAuthority: ReturnType<typeof createMockSigningKey>;
  let mockUnprovenTx: ReturnType<typeof createMockUnprovenTx>;

  beforeEach(() => {
    vi.clearAllMocks();
    
    mockProviders = createMockProviders();
    mockContractAddress = createMockContractAddress();
    mockContractState = createMockContractState();
    mockCurrentAuthority = createMockSigningKey();
    mockNewAuthority = createMockSigningKey();
    mockUnprovenTx = createMockUnprovenTx();
  });

  describe('happy path', () => {
    it('should successfully submit replace authority transaction and update signing key', async () => {
      const mockFinalizedTxData = createMockFinalizedTxData();

      mockProviders.publicDataProvider.queryContractState = vi.fn().mockResolvedValue(mockContractState);
      mockProviders.privateStateProvider.getSigningKey = vi.fn().mockResolvedValue(mockCurrentAuthority);
      mockProviders.privateStateProvider.setSigningKey = vi.fn().mockResolvedValue(undefined);
      
      vi.mocked(createUnprovenReplaceAuthorityTx).mockReturnValue(mockUnprovenTx);
      vi.mocked(submitTx).mockResolvedValue(mockFinalizedTxData);

      const replaceAuthorityFn = submitReplaceAuthorityTx(mockProviders, mockContractAddress);
      const result = await replaceAuthorityFn(mockNewAuthority);

      expect(mockProviders.publicDataProvider.queryContractState).toHaveBeenCalledWith(mockContractAddress);
      expect(mockProviders.privateStateProvider.getSigningKey).toHaveBeenCalledWith(mockContractAddress);
      expect(createUnprovenReplaceAuthorityTx).toHaveBeenCalledWith(
        mockContractAddress,
        mockNewAuthority,
        mockContractState,
        mockCurrentAuthority
      );
      expect(submitTx).toHaveBeenCalledWith(mockProviders, { unprovenTx: mockUnprovenTx });
      expect(mockProviders.privateStateProvider.setSigningKey).toHaveBeenCalledWith(mockContractAddress, mockNewAuthority);
      expect(result).toBe(mockFinalizedTxData);
    });
  });

  describe('error scenarios', () => {
    it('should throw ReplaceMaintenanceAuthorityTxFailedError when transaction fails', async () => {
      const { ReplaceMaintenanceAuthorityTxFailedError } = await import('../errors');
      const { FailEntirely } = await import('@midnight-ntwrk/midnight-js-types');
      
      const failedTxData = createMockFinalizedTxData(FailEntirely);

      mockProviders.publicDataProvider.queryContractState = vi.fn().mockResolvedValue(mockContractState);
      mockProviders.privateStateProvider.getSigningKey = vi.fn().mockResolvedValue(mockCurrentAuthority);
      mockProviders.privateStateProvider.setSigningKey = vi.fn().mockResolvedValue(undefined);
      
      vi.mocked(createUnprovenReplaceAuthorityTx).mockReturnValue(mockUnprovenTx);
      vi.mocked(submitTx).mockResolvedValue(failedTxData);

      const replaceAuthorityFn = submitReplaceAuthorityTx(mockProviders, mockContractAddress);
      
      await expect(replaceAuthorityFn(mockNewAuthority)).rejects.toThrow(ReplaceMaintenanceAuthorityTxFailedError);
    });
  });
});

================
File: packages/contracts/src/test/tx-interfaces.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { VerifierKey } from '@midnight-ntwrk/midnight-js-types';
import { beforeEach, describe, expect, it, vi } from 'vitest';

import {
  createCallTxOptions,
  createCircuitCallTxInterface,
  createCircuitMaintenanceTxInterface,
  createCircuitMaintenanceTxInterfaces,
  createContractMaintenanceTxInterface
} from '../tx-interfaces';
import {
  createMockContract,
  createMockContractAddress,
  createMockFinalizedTxData,
  createMockPrivateStateId,
  createMockProviders
} from './test-mocks';

vi.mock('../submit-call-tx');
vi.mock('../submit-insert-vk-tx');
vi.mock('../submit-remove-vk-tx');
vi.mock('../submit-replace-authority-tx');

describe('tx-interfaces', () => {
  let mockContract: ReturnType<typeof createMockContract>;
  let mockProviders: ReturnType<typeof createMockProviders>;
  let mockContractAddress: ReturnType<typeof createMockContractAddress>;
  let mockPrivateStateId: ReturnType<typeof createMockPrivateStateId>;
  let mockFinalizedTxData: ReturnType<typeof createMockFinalizedTxData>;

  beforeEach(() => {
    vi.clearAllMocks();

    mockContract = createMockContract();
    mockProviders = createMockProviders();
    mockContractAddress = createMockContractAddress();
    mockPrivateStateId = createMockPrivateStateId();
    mockFinalizedTxData = createMockFinalizedTxData();
  });

  describe('createCallTxOptions', () => {
    it('should create call tx options without args', () => {
      const circuitId = 'testCircuit';
      const options = createCallTxOptions(
        mockContract,
        circuitId,
        mockContractAddress,
        undefined,
        []
      );

      expect(options).toEqual({
        contract: mockContract,
        circuitId,
        contractAddress: mockContractAddress
      });
    });

    it('should create call tx options with args', () => {
      const circuitId = 'testCircuit';
      const args = ['arg1', 'arg2'];
      const options = createCallTxOptions(
        mockContract,
        circuitId,
        mockContractAddress,
        undefined,
        args as never[]
      );

      expect(options).toEqual({
        contract: mockContract,
        circuitId,
        contractAddress: mockContractAddress,
        args
      });
    });

    it('should create call tx options with private state ID', () => {
      const circuitId = 'testCircuit';
      const args = ['arg1'];
      const options = createCallTxOptions(
        mockContract,
        circuitId,
        mockContractAddress,
        mockPrivateStateId,
        args as never[]
      );

      expect(options).toEqual({
        contract: mockContract,
        circuitId,
        contractAddress: mockContractAddress,
        privateStateId: mockPrivateStateId,
        args
      });
    });
  });

  describe('createCircuitCallTxInterface', () => {
    it('should create circuit call interface without private state', () => {
      const callInterface = createCircuitCallTxInterface(
        mockProviders,
        mockContract,
        mockContractAddress,
        undefined
      );

      expect(callInterface).toHaveProperty('testCircuit');
      expect(typeof callInterface.testCircuit).toBe('function');
    });

    it('should create circuit call interface with private state', () => {
      const callInterface = createCircuitCallTxInterface(
        mockProviders,
        mockContract,
        mockContractAddress,
        mockPrivateStateId
      );

      expect(callInterface).toHaveProperty('testCircuit');
      expect(typeof callInterface.testCircuit).toBe('function');
    });
  });

  describe('createCircuitMaintenanceTxInterface', () => {
    it('should create circuit maintenance interface', () => {
      const circuitId = 'testCircuit';
      const maintenanceInterface = createCircuitMaintenanceTxInterface(
        mockProviders,
        circuitId,
        mockContractAddress
      );

      expect(maintenanceInterface).toHaveProperty('removeVerifierKey');
      expect(maintenanceInterface).toHaveProperty('insertVerifierKey');
      expect(typeof maintenanceInterface.removeVerifierKey).toBe('function');
      expect(typeof maintenanceInterface.insertVerifierKey).toBe('function');
    });

    it('should call removeVerifierKey function', async () => {
      const circuitId = 'testCircuit';
      const maintenanceInterface = createCircuitMaintenanceTxInterface(
        mockProviders,
        circuitId,
        mockContractAddress
      );

      const { submitRemoveVerifierKeyTx } = await import('../submit-remove-vk-tx');
      vi.mocked(submitRemoveVerifierKeyTx).mockResolvedValue(mockFinalizedTxData);

      const result = await maintenanceInterface.removeVerifierKey();

      expect(submitRemoveVerifierKeyTx).toHaveBeenCalledWith(mockProviders, mockContractAddress, circuitId);
      expect(result).toBe(mockFinalizedTxData);
    });

    it('should call insertVerifierKey function', async () => {
      const circuitId = 'testCircuit';
      const mockVerifierKey = new Uint8Array(32) as VerifierKey;
      const maintenanceInterface = createCircuitMaintenanceTxInterface(
        mockProviders,
        circuitId,
        mockContractAddress
      );

      const { submitInsertVerifierKeyTx } = await import('../submit-insert-vk-tx');
      vi.mocked(submitInsertVerifierKeyTx).mockResolvedValue(mockFinalizedTxData);

      const result = await maintenanceInterface.insertVerifierKey(mockVerifierKey);

      expect(submitInsertVerifierKeyTx).toHaveBeenCalledWith(
        mockProviders,
        mockContractAddress,
        circuitId,
        mockVerifierKey
      );
      expect(result).toBe(mockFinalizedTxData);
    });
  });

  describe('createCircuitMaintenanceTxInterfaces', () => {
    it('should create maintenance interfaces for all circuits', () => {
      const interfaces = createCircuitMaintenanceTxInterfaces(
        mockProviders,
        mockContract,
        mockContractAddress
      );

      expect(interfaces).toHaveProperty('testCircuit');
      expect(interfaces.testCircuit).toHaveProperty('removeVerifierKey');
      expect(interfaces.testCircuit).toHaveProperty('insertVerifierKey');
    });
  });

  describe('createContractMaintenanceTxInterface', () => {
    it('should create contract maintenance interface', () => {
      const contractInterface = createContractMaintenanceTxInterface(
        mockProviders,
        mockContractAddress
      );

      expect(contractInterface).toBeDefined();
      expect(contractInterface).toBeTypeOf('object');
    });
  });
});

================
File: packages/contracts/src/test/unproven-call-tx.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { StateValue, type ZswapLocalState } from '@midnight-ntwrk/compact-runtime';
import { type AlignedValue } from '@midnight-ntwrk/ledger-v6';
import { type Contract, type ImpureCircuitId } from '@midnight-ntwrk/midnight-js-types';
import { describe, expect, it, vi } from 'vitest';

import { type CallResult } from '../call';
import { createUnprovenCallTx, createUnprovenCallTxFromInitialStates } from '../unproven-call-tx';
import {
  createMockCallOptions,
  createMockCallOptionsWithPrivateState,
  createMockContract,
  createMockContractAddress,
  createMockContractState,
  createMockEncryptionPublicKey,
  createMockPrivateStateId,
  createMockProviders
} from './test-mocks';

// Mock the call function and utility functions
vi.mock('../call', () => ({
  call: vi.fn()
}));

vi.mock('../get-states', () => ({
  getStates: vi.fn(),
  getPublicStates: vi.fn()
}));

vi.mock('../utils', () => ({
  createUnprovenLedgerCallTx: vi.fn().mockReturnValue({ test: 'unproven-tx' }),
  encryptionPublicKeyForZswapState: vi.fn().mockReturnValue('encrypted-key'),
  zswapStateToNewCoins: vi.fn().mockReturnValue([{ test: 'coin' }])
}));

describe('unproven-call-tx', () => {
  describe('createUnprovenCallTxFromInitialStates', () => {
    it('should create unproven call tx from initial states without private state', async () => {
      const { call } = await import('../call');
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const mockCall = call as any;

      const callResult = {
        public: {
          nextContractState: StateValue.newNull(),
          publicTranscript: [{ noop: { n: 1 } }],
          partitionedTranscript: [undefined, undefined]
        },
        private: {
          result: 'test-result',
          input: {} as AlignedValue,
          output: {} as AlignedValue,
          privateTranscriptOutputs: [],
          nextPrivateState: undefined,
          nextZswapLocalState: {} as ZswapLocalState
        }
      } as CallResult<Contract, ImpureCircuitId>;

      mockCall.mockReturnValue(callResult);

      const options = createMockCallOptions();
      const walletCoinPublicKey = 'wallet-coin-key';
      const walletEncryptionPublicKey = createMockEncryptionPublicKey();

      const result = createUnprovenCallTxFromInitialStates(
        options,
        walletCoinPublicKey,
        walletEncryptionPublicKey
      );

      expect(result).toBeDefined();
      expect(result.public).toBeDefined();
      expect(result.private).toBeDefined();
      expect(result.private.unprovenTx).toBeDefined();
      expect(result.private.newCoins).toBeDefined();
      expect(mockCall).toHaveBeenCalledWith(options);
    });

    it('should create unproven call tx from initial states with private state', async () => {
      const { call } = await import('../call');
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const mockCall = call as any;

      const callResult = {
        public: {
          nextContractState: StateValue.newNull(),
          publicTranscript: [{ noop: { n: 1 } }],
          partitionedTranscript: [undefined, undefined]
        },
        private: {
          result: 'test-result',
          input: { test: 'input' },
          output: { test: 'output' },
          privateTranscriptOutputs: [],
          nextPrivateState: { test: 'next-private-state' },
          nextZswapLocalState: { test: 'zswap-state' }
        }
      };

      mockCall.mockReturnValue(callResult);

      const options = createMockCallOptionsWithPrivateState();
      const walletCoinPublicKey = 'wallet-coin-key';
      const walletEncryptionPublicKey = createMockEncryptionPublicKey();

      const result = createUnprovenCallTxFromInitialStates(
        options,
        walletCoinPublicKey,
        walletEncryptionPublicKey
      );

      expect(result).toBeDefined();
      expect(result.public).toBeDefined();
      expect(result.private).toBeDefined();
      expect(result.private.nextPrivateState).toEqual({ test: 'next-private-state' });
      expect(mockCall).toHaveBeenCalledWith(options);
    });
  });

  describe('createUnprovenCallTx', () => {
    it('should create unproven call tx without private state provider', async () => {
      const { getPublicStates } = await import('../get-states');
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const mockGetPublicStates = getPublicStates as any;

      mockGetPublicStates.mockResolvedValue({
        zswapChainState: { test: 'zswap-chain-state' },
        contractState: createMockContractState()
      });

      const providers = {
        publicDataProvider: createMockProviders().publicDataProvider,
        walletProvider: createMockProviders().walletProvider
      };

      const options = {
        contract: createMockContract(),
        circuitId: 'testCircuit',
        contractAddress: createMockContractAddress(),
        args: ['test-arg']
      };

      const result = await createUnprovenCallTx(providers, options);

      expect(result).toBeDefined();
      expect(mockGetPublicStates).toHaveBeenCalledWith(
        providers.publicDataProvider,
        options.contractAddress
      );
    });

    it('should create unproven call tx with private state provider', async () => {
      const { getStates } = await import('../get-states');
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const mockGetStates = getStates as any;

      mockGetStates.mockResolvedValue({
        zswapChainState: { test: 'zswap-chain-state' },
        contractState: createMockContractState(),
        privateState: { test: 'private-state' }
      });

      const providers = {
        publicDataProvider: createMockProviders().publicDataProvider,
        walletProvider: createMockProviders().walletProvider,
        privateStateProvider: createMockProviders().privateStateProvider
      };

      const options = {
        contract: createMockContract(),
        circuitId: 'testCircuit',
        contractAddress: createMockContractAddress(),
        privateStateId: createMockPrivateStateId(),
        args: ['test-arg']
      };

      const result = await createUnprovenCallTx(providers, options);

      expect(result).toBeDefined();
      expect(mockGetStates).toHaveBeenCalledWith(
        providers.publicDataProvider,
        providers.privateStateProvider,
        options.contractAddress,
        options.privateStateId
      );
    });
  });
});

================
File: packages/contracts/src/test/unproven-deploy-tx.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { describe, expect, it, vi } from 'vitest';

import { createUnprovenDeployTx, createUnprovenDeployTxFromVerifierKeys } from '../unproven-deploy-tx';
import {
  createMockConstructorResult,
  createMockContract,
  createMockEncryptionPublicKey,
  createMockProviders,
  createMockSigningKey,
  createMockVerifierKeys
} from './test-mocks';

vi.mock('../call-constructor', () => ({
  callContractConstructor: vi.fn()
}));

vi.mock('../utils', () => ({
  createUnprovenLedgerDeployTx: vi.fn().mockReturnValue([
    'mock-contract-address',
    { test: 'initial-contract-state' },
    { test: 'unproven-tx' }
  ]),
  zswapStateToNewCoins: vi.fn().mockReturnValue([{ test: 'coin' }])
}));

vi.mock('@midnight-ntwrk/midnight-js-types', () => ({
  getImpureCircuitIds: vi.fn().mockReturnValue(['testCircuit'])
}));

describe('unproven-deploy-tx', () => {
  describe('createUnprovenDeployTxFromVerifierKeys', () => {
    it('should create unproven deploy tx from verifier keys without private state', async () => {
      const { callContractConstructor } = await import('../call-constructor');
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const mockCallContractConstructor = callContractConstructor as any;

      const constructorResult = createMockConstructorResult();
      mockCallContractConstructor.mockReturnValue(constructorResult);

      const verifierKeys = createMockVerifierKeys();
      const coinPublicKey = 'test-coin-public-key';
      const encryptionPublicKey = createMockEncryptionPublicKey();

      const options = {
        contract: createMockContract(),
        signingKey: createMockSigningKey(),
        args: ['deploy-arg']
      };

      const result = createUnprovenDeployTxFromVerifierKeys(
        verifierKeys,
        coinPublicKey,
        options,
        encryptionPublicKey
      );

      expect(result).toBeDefined();
      expect(result.public).toBeDefined();
      expect(result.private).toBeDefined();
      expect(result.public.contractAddress).toBe('mock-contract-address');
      expect(result.public.initialContractState).toEqual({ test: 'initial-contract-state' });
      expect(result.private.signingKey).toBe(options.signingKey);
      expect(result.private.unprovenTx).toEqual({ test: 'unproven-tx' });
      expect(mockCallContractConstructor).toHaveBeenCalledOnce();
    });

    it('should create unproven deploy tx from verifier keys with private state', async () => {
      const { callContractConstructor } = await import('../call-constructor');
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const mockCallContractConstructor = callContractConstructor as any;

      const constructorResult = createMockConstructorResult();
      mockCallContractConstructor.mockReturnValue(constructorResult);

      const verifierKeys = createMockVerifierKeys();
      const coinPublicKey = 'test-coin-public-key';
      const encryptionPublicKey = createMockEncryptionPublicKey();

      const options = {
        contract: createMockContract(),
        signingKey: createMockSigningKey(),
        initialPrivateState: { test: 'initial-private-state' },
        args: ['deploy-arg']
      };

      const result = createUnprovenDeployTxFromVerifierKeys(
        verifierKeys,
        coinPublicKey,
        options,
        encryptionPublicKey
      );

      expect(result).toBeDefined();
      expect(result.public).toBeDefined();
      expect(result.private).toBeDefined();
      expect(result.private.initialPrivateState).toBe(constructorResult.nextPrivateState);
      expect(result.private.signingKey).toBe(options.signingKey);
      expect(mockCallContractConstructor).toHaveBeenCalledWith(
        expect.objectContaining({
          contract: options.contract,
          coinPublicKey,
          initialPrivateState: options.initialPrivateState,
          args: options.args
        })
      );
    });
  });

  describe('createUnprovenDeployTx', () => {
    it('should create unproven deploy tx without private state', async () => {
      const providers = {
        zkConfigProvider: createMockProviders().zkConfigProvider,
        walletProvider: createMockProviders().walletProvider
      };

      vi.mocked(providers.zkConfigProvider.getVerifierKeys).mockResolvedValue(createMockVerifierKeys());

      const options = {
        contract: createMockContract(),
        signingKey: createMockSigningKey(),
        args: ['deploy-arg']
      };

      const result = await createUnprovenDeployTx(providers, options);

      expect(result).toBeDefined();
      expect(providers.zkConfigProvider.getVerifierKeys).toHaveBeenCalledWith(['testCircuit']);
    });

    it('should create unproven deploy tx with private state', async () => {
      const providers = {
        zkConfigProvider: createMockProviders().zkConfigProvider,
        walletProvider: createMockProviders().walletProvider
      };

      vi.mocked(providers.zkConfigProvider.getVerifierKeys).mockResolvedValue(createMockVerifierKeys());

      const options = {
        contract: createMockContract(),
        signingKey: createMockSigningKey(),
        initialPrivateState: { test: 'initial-private-state' },
        args: ['deploy-arg']
      };

      const result = await createUnprovenDeployTx(providers, options);

      expect(result).toBeDefined();
      expect(providers.zkConfigProvider.getVerifierKeys).toHaveBeenCalledWith(['testCircuit']);
    });
  });
});

================
File: packages/contracts/src/utils/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * from './ledger-utils';
export * from './zswap-utils';

================
File: packages/contracts/src/utils/ledger-utils.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  type AlignedValue,
  type ContractAddress,
  ContractState,
  type QueryContext,
  signatureVerifyingKey,
  type SigningKey,
  type ZswapLocalState} from '@midnight-ntwrk/compact-runtime';
import {
  ChargedState,
  communicationCommitmentRandomness,
  ContractCallPrototype,
  ContractDeploy,
  ContractMaintenanceAuthority,
  ContractOperationVersion,
  ContractOperationVersionedVerifierKey,
  ContractState as LedgerContractState,
  type EncPublicKey,
  Intent,
  MaintenanceUpdate,
  type PartitionedTranscript,
  QueryContext as LedgerQueryContext,
  ReplaceAuthority,
  signData,
  type SingleUpdate,
  StateValue as LedgerStateValue,
  type UnprovenTransaction,
  VerifierKeyInsert,
  VerifierKeyRemove,
  type ZswapChainState
} from '@midnight-ntwrk/ledger-v6';
import { getNetworkId } from '@midnight-ntwrk/midnight-js-network-id';
import {
  type ImpureCircuitId,
  Transaction,
  type VerifierKey
} from '@midnight-ntwrk/midnight-js-types';
import { assertDefined, ttlOneHour } from '@midnight-ntwrk/midnight-js-utils';

import { zswapStateToOffer } from './zswap-utils';

export const toLedgerContractState = (contractState: ContractState): LedgerContractState =>
  LedgerContractState.deserialize(contractState.serialize());

export const fromLedgerContractState = (contractState: LedgerContractState): ContractState =>
  ContractState.deserialize(contractState.serialize(), );

export const toLedgerQueryContext = (queryContext: QueryContext): LedgerQueryContext => {
  const stateValue = LedgerStateValue.decode(queryContext.state.state.encode());
  const ledgerQueryContext = new LedgerQueryContext(new ChargedState(stateValue), queryContext.address);
  // The above method of converting to ledger query context only retains the state. So, we have to set the settable properties manually
  ledgerQueryContext.block = queryContext.block;
  ledgerQueryContext.effects = queryContext.effects;
  return ledgerQueryContext;
}

const addVerifierKeys = (verifierKeys: [ImpureCircuitId, VerifierKey][], contractState: LedgerContractState): void => {
  verifierKeys.forEach(([impureCircuitId, verifierKey]) => {
    const operation = contractState.operation(impureCircuitId);
    assertDefined(
      operation,
      `Circuit '${impureCircuitId}' is undefined for contract state ${contractState.toString(false)}`
    );
    // TODO: Remove mutability
    operation.verifierKey = verifierKey;
    contractState.setOperation(impureCircuitId, operation);
  });
};

export const contractMaintenanceAuthority = (
  sk: SigningKey,
  contractState?: ContractState
): ContractMaintenanceAuthority => {
  const svk = signatureVerifyingKey(sk);
  const threshold = 1;
  return new ContractMaintenanceAuthority(
    [svk],
    threshold,
    contractState ? contractState.maintenanceAuthority.counter + 1n : 0n
  );
};

const addMaintenanceAuthority = (sk: SigningKey, contractState: LedgerContractState): void => {
  contractState.maintenanceAuthority = contractMaintenanceAuthority(sk);
};

export const createUnprovenLedgerDeployTx = (
  verifierKeys: [ImpureCircuitId, VerifierKey][],
  sk: SigningKey,
  contractState: ContractState,
  zswapLocalState: ZswapLocalState,
  encryptionPublicKey: EncPublicKey
): [ContractAddress, ContractState, UnprovenTransaction] => {
  const ledgerContractState = toLedgerContractState(contractState);
  addVerifierKeys(verifierKeys, ledgerContractState);
  addMaintenanceAuthority(sk, ledgerContractState);
  const contractDeploy = new ContractDeploy(ledgerContractState);
  return [
    contractDeploy.address,
    fromLedgerContractState(contractDeploy.initialState),
    Transaction.fromParts(
      getNetworkId(),
      zswapStateToOffer(zswapLocalState, encryptionPublicKey),
      undefined,
      Intent.new(ttlOneHour()).addDeploy(contractDeploy)
    )
  ];
};

export const createUnprovenLedgerCallTx = (
  circuitId: ImpureCircuitId,
  contractAddress: ContractAddress,
  initialContractState: ContractState,
  zswapChainState: ZswapChainState,
  partitionedTranscript: PartitionedTranscript,
  privateTranscriptOutputs: AlignedValue[],
  input: AlignedValue,
  output: AlignedValue,
  nextZswapLocalState: ZswapLocalState,
  encryptionPublicKey: EncPublicKey
): UnprovenTransaction => {
  const op = toLedgerContractState(initialContractState).operation(circuitId);
  assertDefined(op, `Operation '${circuitId}' is undefined for contract state ${initialContractState.toString(false)}`);
  return Transaction.fromParts(
    getNetworkId(),
    zswapStateToOffer(nextZswapLocalState, encryptionPublicKey, {
      contractAddress,
      zswapChainState
    }),
    undefined,
    Intent.new(ttlOneHour()).addCall(
      new ContractCallPrototype(
        contractAddress,
        circuitId,
        op,
        partitionedTranscript[0],
        partitionedTranscript[1],
        privateTranscriptOutputs,
        input,
        output,
        communicationCommitmentRandomness(),
        circuitId
      )
    )
  );
};

// Utilities for creating single contract updates.

export const replaceAuthority = (newAuthority: SigningKey, contractState: ContractState): ReplaceAuthority =>
  new ReplaceAuthority(contractMaintenanceAuthority(newAuthority, contractState));

export const removeVerifierKey = (operation: string | Uint8Array): VerifierKeyRemove =>
  new VerifierKeyRemove(operation, new ContractOperationVersion('v2'));

export const insertVerifierKey = (operation: string | Uint8Array, newVk: VerifierKey): VerifierKeyInsert =>
  new VerifierKeyInsert(operation, new ContractOperationVersionedVerifierKey('v2', newVk));

// Utilities for unproven transactions for the single contract updates above.

export const unprovenTxFromContractUpdates = (
  contractAddress: ContractAddress,
  updates: SingleUpdate[],
  contractState: ContractState,
  sk: SigningKey
): UnprovenTransaction => {
  const maintenanceUpdate = new MaintenanceUpdate(contractAddress, updates, contractState.maintenanceAuthority.counter);
  // 'idx' is '0n' because Midnight.js currently only supports single-party maintenance update authorities
  const idx = 0n;
  const signedMaintenanceUpdate = maintenanceUpdate.addSignature(idx, signData(sk, maintenanceUpdate.dataToSign));
  return Transaction.fromParts(
    getNetworkId(),
    undefined,
    undefined,
    Intent.new(ttlOneHour()).addMaintenanceUpdate(signedMaintenanceUpdate)
  );
};

export const createUnprovenReplaceAuthorityTx = (
  contractAddress: ContractAddress,
  newAuthority: SigningKey,
  contractState: ContractState,
  currentAuthority: SigningKey
): UnprovenTransaction =>
  unprovenTxFromContractUpdates(
    contractAddress,
    [replaceAuthority(newAuthority, contractState)],
    contractState,
    currentAuthority
  );

export const createUnprovenRemoveVerifierKeyTx = (
  contractAddress: ContractAddress,
  operation: string | Uint8Array,
  contractState: ContractState,
  currentAuthority: SigningKey
): UnprovenTransaction =>
  unprovenTxFromContractUpdates(contractAddress, [removeVerifierKey(operation)], contractState, currentAuthority);

export const createUnprovenInsertVerifierKeyTx = (
  contractAddress: ContractAddress,
  operation: string | Uint8Array,
  newVk: VerifierKey,
  contractState: ContractState,
  currentAuthority: SigningKey
): UnprovenTransaction =>
  unprovenTxFromContractUpdates(
    contractAddress,
    [insertVerifierKey(operation, newVk)],
    contractState,
    currentAuthority
  );

================
File: packages/contracts/src/utils/zswap-utils.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type Recipient, type ZswapLocalState } from '@midnight-ntwrk/compact-runtime';
import {
  type CoinPublicKey,
  type ContractAddress,
  type EncPublicKey,
  type QualifiedShieldedCoinInfo,
  type ShieldedCoinInfo,
  type UnprovenInput,
  type UnprovenOffer,
  type UnprovenOutput,
  type UnprovenTransient,
  type ZswapChainState,
  ZswapInput,
  ZswapOffer,
  ZswapOutput,
  ZswapTransient} from '@midnight-ntwrk/ledger-v6';
import { getNetworkId } from '@midnight-ntwrk/midnight-js-network-id';
import {
  assertDefined,
  assertIsContractAddress,
  fromHex,
  parseCoinPublicKeyToHex,
  parseEncPublicKeyToHex
} from '@midnight-ntwrk/midnight-js-utils';

// A default segment number to use when creating inputs and outputs. The Ledger has exposed this parameter
// now but we don't know what the value should be, and assume that everything first in segment '0'. This
// will change with work on Unshielded Tokens and I believe the Ledger will come with utility that will inform
// the segment numbers.
const DEFAULT_SEGMENT_NUMBER = 0;

export const checkKeys = (coinInfo: ShieldedCoinInfo): void =>
  Object.keys(coinInfo).forEach((key) => {
    if (key !== 'value' && key !== 'type' && key !== 'nonce') {
      throw new TypeError(`Key '${key}' should not be present in output data ${coinInfo}`);
    }
  });

export const serializeCoinInfo = (coinInfo: ShieldedCoinInfo): string => {
  checkKeys(coinInfo);
  return JSON.stringify({
    ...coinInfo,
    value: { __big_int_val__: coinInfo.value.toString() }
  });
};

export const serializeQualifiedShieldedCoinInfo = (coinInfo: QualifiedShieldedCoinInfo): string => {
  const { mt_index: _, ...rest } = coinInfo;
  return serializeCoinInfo(rest);
};

export const deserializeCoinInfo = (coinInfo: string): ShieldedCoinInfo => {
  const res = JSON.parse(coinInfo, (key: string, value: unknown) => {
    if (
      key === 'value' &&
      value != null &&
      typeof value === 'object' &&
      '__big_int_val__' in value &&

      typeof value.__big_int_val__ === 'string'
    ) {

      return BigInt(value.__big_int_val__);
    }
    if (
      (key === 'color' || key === 'nonce') &&
      value != null &&
      typeof value === 'object' &&
      '__uint8Array_val__' in value &&

      typeof value.__uint8Array_val__ === 'string'
    ) {

      return fromHex(value.__uint8Array_val__);
    }
    return value;
  });
  checkKeys(res);
  return res;
};

export const createZswapOutput = (
  {
    coinInfo,
    recipient
  }: {
    coinInfo: ShieldedCoinInfo;
    recipient: Recipient;
  },
  encryptionPublicKey: EncPublicKey,
  segmentNumber = 0
): UnprovenOutput =>
  // TBD need to confirm segment number and wallet encryptionPublicKey usage.
  recipient.is_left
    ? ZswapOutput.new(coinInfo, segmentNumber, recipient.left, encryptionPublicKey)
    : ZswapOutput.newContractOwned(coinInfo, segmentNumber, recipient.right);

const unprovenOfferFromCoinInfo = <U extends UnprovenInput | UnprovenOutput | UnprovenTransient>(
  [coinInfo, unproven]: [string, U],
  f: (u: U, type: string, value: bigint) => UnprovenOffer
): UnprovenOffer => {
  const { type, value } = deserializeCoinInfo(coinInfo);
  return f(unproven, type, value);
};

export const unprovenOfferFromMap = <U extends UnprovenInput | UnprovenOutput | UnprovenTransient>(
  map: Map<string, U>,
  f: (u: U, type: string, value: bigint) => UnprovenOffer
): UnprovenOffer | undefined => {
  if (map.size === 0) {
    return undefined;
  }

  const offers = Array.from(map, (entry) => unprovenOfferFromCoinInfo(entry, f)).filter((offer) => offer != null);

  if (offers.length === 0) {
    return undefined;
  }

  return offers.reduce((acc, curr) => acc.merge(curr));
};

export const zswapStateToOffer = (
  zswapLocalState: ZswapLocalState,
  encryptionPublicKey: EncPublicKey,
  addressAndChainStateTuple?: { contractAddress: ContractAddress; zswapChainState: ZswapChainState }
): UnprovenOffer | undefined => {
  const unprovenOutputs = new Map<string, UnprovenOutput>(
    zswapLocalState.outputs.map((output) => [
      serializeCoinInfo(output.coinInfo),
      createZswapOutput(output, encryptionPublicKey, DEFAULT_SEGMENT_NUMBER)
    ])
  );
  const unprovenInputs = new Map<string, UnprovenInput>();
  const unprovenTransients = new Map<string, UnprovenTransient>();
  zswapLocalState.inputs.forEach((qualifiedCoinInfo) => {
    const serializedCoinInfo =  serializeQualifiedShieldedCoinInfo(qualifiedCoinInfo);
    const unprovenOutput = unprovenOutputs.get(serializedCoinInfo);
    if (unprovenOutput) {
      unprovenTransients.set(
        serializedCoinInfo,
        ZswapTransient.newFromContractOwnedOutput(qualifiedCoinInfo, DEFAULT_SEGMENT_NUMBER, unprovenOutput)
      );
      unprovenOutputs.delete(serializedCoinInfo);
    } else {
      assertDefined(addressAndChainStateTuple, `Only outputs or transients are expected when no chain state is provided`);
      assertIsContractAddress(addressAndChainStateTuple.contractAddress);
      unprovenInputs.set(
        serializedCoinInfo,
        ZswapInput.newContractOwned(
          qualifiedCoinInfo,
          DEFAULT_SEGMENT_NUMBER,
          addressAndChainStateTuple.contractAddress,
          addressAndChainStateTuple.zswapChainState
        )
      );
    }
  });

   const inputsOffer = unprovenOfferFromMap(unprovenInputs, ZswapOffer.fromInput);
   const outputsOffer = unprovenOfferFromMap(unprovenOutputs, ZswapOffer.fromOutput);
   const transientsOffer = unprovenOfferFromMap(unprovenTransients, ZswapOffer.fromTransient);

   const offers = [inputsOffer, outputsOffer, transientsOffer].filter(offer => offer != null);

   if (offers.length === 0) {
     return undefined;
   }

   if (offers.length === 1) {
     return offers[0];
   }

   return offers.reduce((acc, curr) => acc.merge(curr));
};

export const zswapStateToNewCoins = (receiverCoinPublicKey: CoinPublicKey, zswapState: ZswapLocalState): ShieldedCoinInfo[] =>
  zswapState.outputs
    .filter((output) => output.recipient.left === receiverCoinPublicKey)
    .map(({ coinInfo }) => coinInfo);

export const encryptionPublicKeyForZswapState = (
  zswapState: ZswapLocalState,
  walletCoinPublicKey: CoinPublicKey,
  walletEncryptionPublicKey: EncPublicKey
): EncPublicKey => {
  const networkId = getNetworkId();
  const walletCoinPublicKeyLocal = parseCoinPublicKeyToHex(walletCoinPublicKey, networkId);
  const localCoinPublicKey = parseCoinPublicKeyToHex(zswapState.coinPublicKey, networkId);

  if (localCoinPublicKey !== walletCoinPublicKeyLocal) {
    throw new Error('Unable to lookup encryption public key (Unsupported coin)');
  }

  return parseEncPublicKeyToHex(walletEncryptionPublicKey, networkId);
};

================
File: packages/contracts/src/call-constructor.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  type CoinPublicKey,
  type ConstructorContext,
  type ContractState,
  decodeZswapLocalState,
  emptyZswapLocalState,
  type ZswapLocalState
} from '@midnight-ntwrk/compact-runtime';
import type { Contract, InitialStateParameters, PrivateState } from '@midnight-ntwrk/midnight-js-types';

/**
 * Describes the target of a circuit invocation.
 */
export type ContractConstructorOptionsBase<C extends Contract> = {
  /**
   * The contract defining the circuit to call.
   */
  readonly contract: C;
}

/**
 * Conditional type that optionally adds the inferred contract constructor argument types
 * to the constructor options.
 */
export type ContractConstructorOptionsWithArguments<C extends Contract> =
  InitialStateParameters<C> extends []
    ? ContractConstructorOptionsBase<C>
    : ContractConstructorOptionsBase<C> & {
        /**
         * Arguments to pass to the circuit being called.
         */
        readonly args: InitialStateParameters<C>;
      };

/**
 * Data retrieved via providers that should be included in the constructor call options.
 */
export type ContractConstructorOptionsProviderDataDependencies = {
  /**
   * The current user's ZSwap public key.
   */
  readonly coinPublicKey: CoinPublicKey;
}

/**
 * Contract constructor options including arguments and provider data.
 */
export type ContractConstructorOptionsWithProviderDataDependencies<C extends Contract> =
  ContractConstructorOptionsWithArguments<C> & ContractConstructorOptionsProviderDataDependencies;

/**
 * Conditional type that optionally adds the inferred circuit argument types to
 * the target of a circuit invocation.
 */
export type ContractConstructorOptionsWithPrivateState<C extends Contract> =
  ContractConstructorOptionsWithProviderDataDependencies<C> & {
    /**
     * The private state to run the circuit against.
     */
    readonly initialPrivateState: PrivateState<C>;
  };

/**
 * Conditional type that optionally adds the inferred circuit argument types to
 * the target of a circuit invocation.
 */
export type ContractConstructorOptions<C extends Contract> =
  | ContractConstructorOptionsWithProviderDataDependencies<C>
  | ContractConstructorOptionsWithPrivateState<C>;

/**
 * The updated states resulting from executing a contract constructor.
 */
export type ContractConstructorResult<C extends Contract> = {
  /**
   * The public state resulting from executing the contract constructor.
   */
  readonly nextContractState: ContractState;
  /**
   * The private state resulting from executing the contract constructor.
   */
  readonly nextPrivateState: PrivateState<C>;
  /**
   * The Zswap local state resulting from executing the contract constructor.
   */
  readonly nextZswapLocalState: ZswapLocalState;
}

/**
 * Calls the constructor of the given contract according to the given configuration.
 *
 * @param options Configuration.
 */
export const callContractConstructor = <C extends Contract>(
  options: ContractConstructorOptions<C>
): ContractConstructorResult<C> => {
  const constructorResult = options.contract.initialState(
    {
      initialPrivateState: 'initialPrivateState' in options ? options.initialPrivateState : undefined,
      // TODO: IMPORTANT - consult
      initialZswapLocalState: emptyZswapLocalState(options.coinPublicKey)
    } as ConstructorContext<C>,
    ...('args' in options ? options.args : [])
  );
  return {
    nextContractState: constructorResult.currentContractState,
    nextPrivateState: constructorResult.currentPrivateState,
    nextZswapLocalState: decodeZswapLocalState(constructorResult.currentZswapLocalState)
  };
};

================
File: packages/contracts/src/call.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  type AlignedValue,
  type CircuitContext,
  type CoinPublicKey,
  type ContractAddress,
  type ContractState,
  CostModel,
  decodeZswapLocalState,
  emptyZswapLocalState,
  type Op,
  QueryContext,
  type StateValue,
  type ZswapLocalState
} from '@midnight-ntwrk/compact-runtime';
import {
  LedgerParameters,
  type PartitionedTranscript,
  partitionTranscripts,
  PreTranscript,
  type ZswapChainState
} from '@midnight-ntwrk/ledger-v6';
import { getNetworkId } from '@midnight-ntwrk/midnight-js-network-id';
import type {
  CircuitParameters,
  CircuitReturnType,
  Contract,
  ImpureCircuitId,
  PrivateState
} from '@midnight-ntwrk/midnight-js-types';
import { assertDefined, parseCoinPublicKeyToHex } from '@midnight-ntwrk/midnight-js-utils';

import { toLedgerQueryContext } from './utils';

/**
 * Describes the target of a circuit invocation.
 */
export type CallOptionsBase<C extends Contract, ICK extends ImpureCircuitId<C>> = {
  /**
   * The contract defining the circuit to call.
   */
  readonly contract: C;
  /**
   * The identifier of the circuit to call.
   */
  readonly circuitId: ICK;
  /**
   * The address of the contract being executed.
   */
  readonly contractAddress: ContractAddress;
};

/**
 * Conditional type that optionally adds the inferred circuit argument types to
 * the options for a circuit call.
 */
export type CallOptionsWithArguments<C extends Contract, ICK extends ImpureCircuitId<C>> =
  CircuitParameters<C, ICK> extends []
    ? CallOptionsBase<C, ICK>
    : CallOptionsBase<C, ICK> & {
    /**
     * Arguments to pass to the circuit being called.
     */
    readonly args: CircuitParameters<C, ICK>;
  };

/**
 * Data retrieved via providers that should be included in the call options.
 */
export type CallOptionsProviderDataDependencies = {
  /**
   * The Zswap public key of the current user.
   */
  readonly coinPublicKey: CoinPublicKey;
  /**
   * The initial public state of the contract to run the circuit against.
   */
  readonly initialContractState: ContractState;
  /**
   * The initial public Zswap state of the contract to run the circuit against.
   */
  readonly initialZswapChainState: ZswapChainState;
};

/**
 * Call options with circuit arguments and data
 */
export type CallOptionsWithProviderDataDependencies<
  C extends Contract,
  ICK extends ImpureCircuitId<C>
> = CallOptionsWithArguments<C, ICK> & CallOptionsProviderDataDependencies;

/**
 * Call options for contracts with private state.
 */
export type CallOptionsWithPrivateState<
  C extends Contract,
  ICK extends ImpureCircuitId<C>
> = CallOptionsWithProviderDataDependencies<C, ICK> & {
  /**
   * The private state to run the circuit against.
   */
  readonly initialPrivateState: PrivateState<C>;
};

/**
 * Call options for a given contract and circuit.
 */
export type CallOptions<C extends Contract, ICK extends ImpureCircuitId<C>> =
  | CallOptionsWithProviderDataDependencies<C, ICK>
  | CallOptionsWithPrivateState<C, ICK>;

/**
 * The private (sensitive) portions of the call result.
 */
export type CallResultPrivate<C extends Contract, ICK extends ImpureCircuitId<C>> = {
  /**
   * ZK representation of the circuit arguments.
   */
  readonly input: AlignedValue;
  /**
   * ZK representation of the circuit result.
   */
  readonly output: AlignedValue;
  /**
   * ZK representation of the circuit witness call results.
   */
  readonly privateTranscriptOutputs: AlignedValue[];
  /**
   * The JS representation of the input to the circuit.
   */
  readonly result: CircuitReturnType<C, ICK>;
  /**
   * The private state resulting from executing the circuit.
   */
  readonly nextPrivateState: PrivateState<C>;
  /**
   * The Zswap local state resulting from executing the circuit.
   */
  readonly nextZswapLocalState: ZswapLocalState;
};

/**
 * The public portions of the call result.
 */
export type CallResultPublic = {
  /**
   * The public state resulting from executing the circuit.
   */
  readonly nextContractState: StateValue;
  /**
   * The public transcript resulting from executing the circuit.
   */
  readonly publicTranscript: Op<AlignedValue>[];
  /**
   * A {@link publicTranscript} partitioned into guaranteed and fallible sections.
   * The guaranteed section of a public transcript must succeed for the corresponding
   * transaction to be considered valid. The fallible section of a public transcript
   * can fail without invalidating the transaction, as long as the guaranteed section succeeds.
   */
  readonly partitionedTranscript: PartitionedTranscript;
};

/**
 * Contains all information resulting from circuit execution.
 */
export type CallResult<C extends Contract, ICK extends ImpureCircuitId<C>> = {
  /**
   * The public/non-sensitive data produced by the circuit execution.
   */
  readonly public: CallResultPublic;
  /**
   * The private/sensitive data produced by the circuit execution.
   */
  readonly private: CallResultPrivate<C, ICK>;
};

const partitionTranscript = (
  initialTxContext: QueryContext,
  finalTxContext: QueryContext,
  publicTranscript: Op<AlignedValue>[]
): PartitionedTranscript => {
  const partitionedTranscripts = partitionTranscripts(
    [
      new PreTranscript(
        Array.from(finalTxContext.comIndices).reduce(
          (queryContext, entry) => queryContext.insertCommitment(...entry),
          toLedgerQueryContext(initialTxContext)
        ),
        publicTranscript
      )
    ],
    LedgerParameters.initialParameters()
  );
  if (partitionedTranscripts.length !== 1) {
    throw new Error(`Expected one transcript partition pair, received: ${partitionedTranscripts.length}`);
  }
  return partitionedTranscripts[0]!;
};

/**
 * Calls a circuit in the given contract according to the given configuration.
 *
 * @param options Configuration.
 */
export const call = <C extends Contract, ICK extends ImpureCircuitId<C>>(
  options: CallOptions<C, ICK>
): CallResult<C, ICK> => {
  const { contract, circuitId, contractAddress, coinPublicKey, initialContractState } = options;
  const circuit = contract.impureCircuits[circuitId];
  assertDefined(circuit, `Circuit '${circuitId}' is not defined`);
  const initialTxContext = new QueryContext(initialContractState.data, contractAddress);
  initialTxContext.block = {
    ...initialTxContext.block,
    secondsSinceEpoch: BigInt(Math.floor(Date.now() / 1_000)),
  }
  const { result, context, proofData } = circuit(
    {
      //TODO: validate this originalState
      originalState: initialContractState,
      currentPrivateState: 'initialPrivateState' in options ? options.initialPrivateState : undefined,
      currentQueryContext: initialTxContext,
      currentZswapLocalState: emptyZswapLocalState(parseCoinPublicKeyToHex(coinPublicKey, getNetworkId())),
      costModel: CostModel.initialCostModel(),
    } as CircuitContext<C>,
    ...('args' in options ? options.args : [])
  );
  return {
    public: {
      nextContractState: context.currentQueryContext.state.state,
      publicTranscript: proofData.publicTranscript,
      partitionedTranscript: partitionTranscript(
        initialTxContext,
        context.currentQueryContext,
        proofData.publicTranscript
      )
    },
    private: {
      result,
      input: proofData.input,
      output: proofData.output,
      privateTranscriptOutputs: proofData.privateTranscriptOutputs,
      nextPrivateState: context.currentPrivateState,
      nextZswapLocalState: decodeZswapLocalState(context.currentZswapLocalState)
    }
  };
};

================
File: packages/contracts/src/contract-providers.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type {
  Contract,
  ImpureCircuitId,
  MidnightProviders,
  PrivateState,
  PrivateStateId
} from '@midnight-ntwrk/midnight-js-types';

/**
 * Convenience type for representing the set of providers necessary to use
 * a given contract.
 */
export type ContractProviders<
  C extends Contract = Contract,
  ICK extends ImpureCircuitId<C> = ImpureCircuitId<C>,
  PS = PrivateState<C>
> = MidnightProviders<ICK, PrivateStateId, PS>;

================
File: packages/contracts/src/deploy-contract.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { sampleSigningKey, type SigningKey } from '@midnight-ntwrk/compact-runtime';
import type { Contract, ImpureCircuitId, PrivateState, PrivateStateId } from '@midnight-ntwrk/midnight-js-types';

import type { ContractConstructorOptionsWithArguments } from './call-constructor';
import { type ContractProviders } from './contract-providers';
import type { FoundContract } from './find-deployed-contract';
import { type DeployTxOptions, submitDeployTx } from './submit-deploy-tx';
import {
  createCircuitCallTxInterface,
  createCircuitMaintenanceTxInterfaces,
  createContractMaintenanceTxInterface
} from './tx-interfaces';
import type { FinalizedDeployTxData } from './tx-model';

/**
 * Base type for configuration for {@link deployContract}; identical to
 * {@link ContractConstructorOptionsWithArguments} except the `signingKey` is
 * now optional, since {@link deployContract} will generate a fresh signing key
 * in the event that `signingKey` is undefined.
 */
export type DeployContractOptionsBase<C extends Contract> = ContractConstructorOptionsWithArguments<C> & {
  /**
   * The signing key to add as the to-be-deployed contract's maintenance authority.
   * If undefined, a new signing key is sampled and used as the CMA then stored
   * in the private state provider under the newly deployed contract's address.
   * Otherwise, the passed signing key is added as the CMA. The second case is
   * useful when you want to use the same CMA for two different contracts.
   */
  readonly signingKey?: SigningKey;
};

/**
 * {@link deployContract} base options with information needed to store private states;
 * only used if the contract being deployed has a private state.
 */
export type DeployContractOptionsWithPrivateState<C extends Contract> = DeployContractOptionsBase<C> & {
  /**
   * An identifier for the private state of the contract being found.
   */
  readonly privateStateId: PrivateStateId;
  /**
   * The private state to run the circuit against.
   */
  readonly initialPrivateState: PrivateState<C>;
};

/**
 * Configuration for {@link deployContract}.
 */
export type DeployContractOptions<C extends Contract> =
  | DeployContractOptionsBase<C>
  | DeployContractOptionsWithPrivateState<C>;

/**
 * Interface for a contract that has been deployed to the blockchain.
 */
export type DeployedContract<C extends Contract> = FoundContract<C> & {
  /**
   * Data resulting from the deployment transaction that created this contract. The information in a
   * {@link deployTxData} contains additional private information that does not
   * exist in {@link FoundContract.deployTxData} because certain private data is only available to
   * the deployer of a contract.
   */
  readonly deployTxData: FinalizedDeployTxData<C>;
};

const createDeployTxOptions = <C extends Contract>(
  deployContractOptions: DeployContractOptions<C>
): DeployTxOptions<C> => {
  const deployTxOptionsBase = {
    ...deployContractOptions,
    signingKey: deployContractOptions.signingKey ?? sampleSigningKey()
  };

  return 'privateStateId' in deployContractOptions
    ? ({
        ...deployTxOptionsBase,
        privateStateId: deployContractOptions.privateStateId,
        initialPrivateState: deployContractOptions.initialPrivateState
      } as DeployTxOptions<C>)
    : deployTxOptionsBase;
};

export async function deployContract<C extends Contract<undefined>>(
  providers: ContractProviders<C, ImpureCircuitId<C>, unknown>,
  options: DeployContractOptionsBase<C>
): Promise<DeployedContract<C>>;

export async function deployContract<C extends Contract>(
  providers: ContractProviders<C>,
  options: DeployContractOptionsWithPrivateState<C>
): Promise<DeployedContract<C>>;

/**
 * Creates and submits a contract deployment transaction. This function is the entry point for the transaction
 * construction workflow and is used to create a {@link DeployedContract} instance.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @throws DeployTxFailedError If the transaction is submitted successfully but produces an error
 *                             when executed by the node.
 */
export async function deployContract<C extends Contract>(
  providers: ContractProviders<C>,
  options: DeployContractOptions<C>
): Promise<DeployedContract<C>> {
  const deployTxData = await submitDeployTx(providers, createDeployTxOptions(options));
  return {
    deployTxData,
    callTx: createCircuitCallTxInterface(
      providers,
      options.contract,
      deployTxData.public.contractAddress,
      'privateStateId' in options ? options.privateStateId : undefined
    ),
    circuitMaintenanceTx: createCircuitMaintenanceTxInterfaces(
      providers,
      options.contract,
      deployTxData.public.contractAddress
    ),
    contractMaintenanceTx: createContractMaintenanceTxInterface(providers, deployTxData.public.contractAddress)
  };
}

================
File: packages/contracts/src/errors.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ContractState } from '@midnight-ntwrk/compact-runtime';
import type { FinalizedTxData, ImpureCircuitId } from '@midnight-ntwrk/midnight-js-types';

/**
 * An error indicating that a transaction submitted to a consensus node failed.
 */
export class TxFailedError extends Error {
  /**
   * @param finalizedTxData The finalization data of the transaction that failed.
   * @param circuitId The name of the circuit that was called to create the call
   *                  transaction that failed. Only defined if a call transaction
   *                  failed.
   */
  constructor(
    public readonly finalizedTxData: FinalizedTxData,
    public readonly circuitId?: ImpureCircuitId
  ) {
    super('Transaction failed');
    this.message = JSON.stringify(
      {
        ...(circuitId && { circuitId }),
        ...finalizedTxData
      },
      null,
      '\t'
    );
  }
}

/**
 * An error indicating that a deploy transaction was not successfully applied by the consensus node.
 */
export class DeployTxFailedError extends TxFailedError {
  /**
   * @param finalizedTxData The finalization data of the deployment transaction that failed.
   */
  constructor(finalizedTxData: FinalizedTxData) {
    super(finalizedTxData);
    this.name = 'DeployTxFailedError';
  }
}

/**
 * An error indicating that a call transaction was not successfully applied by the consensus node.
 */
export class CallTxFailedError extends TxFailedError {
  /**
   * @param finalizedTxData The finalization data of the call transaction that failed.
   * @param circuitId The name of the circuit that was called to build the transaction.
   */
  constructor(finalizedTxData: FinalizedTxData, circuitId: ImpureCircuitId) {
    super(finalizedTxData, circuitId);
    this.name = 'CallTxFailedError';
  }
}

/**
 * The error that is thrown when there is a contract type mismatch between a given contract type,
 * and the initial state that is deployed at a given contract address.
 *
 * @remarks
 * This error is typically thrown during calls to {@link findDeployedContract} where the supplied contract
 * address represents a different type of contract to the contract type given.
 */
export class ContractTypeError extends TypeError {
  /**
   * Initializes a new {@link ContractTypeError}.
   *
   * @param contractState The initial deployed contract state.
   * @param circuitIds The circuits that are undefined, or have a verifier key mismatch with the
   *                   key present in `contractState`.
   */
  constructor(
    readonly contractState: ContractState,
    readonly circuitIds: ImpureCircuitId[]
  ) {
    super(
      `Following operations: ${circuitIds.join(
        ', '
      )}, are undefined or have mismatched verifier keys for contract state ${contractState.toString(false)}`
    );
  }
}

/**
 * An error indicating that a contract maintenance authority replacement transaction failed.
 */
export class ReplaceMaintenanceAuthorityTxFailedError extends TxFailedError {
  constructor(finalizedTxData: FinalizedTxData) {
    super(finalizedTxData);
    this.name = 'ReplaceMaintenanceAuthorityTxFailedError';
  }
}

/**
 * An error indicating that a verifier key removal transaction failed.
 */
export class RemoveVerifierKeyTxFailedError extends TxFailedError {
  constructor(finalizedTxData: FinalizedTxData) {
    super(finalizedTxData);
    this.name = 'RemoveVerifierKeyTxFailedError';
  }
}

/**
 * An error indicating that a verifier key insertion transaction failed.
 */
export class InsertVerifierKeyTxFailedError extends TxFailedError {
  constructor(finalizedTxData: FinalizedTxData) {
    super(finalizedTxData);
    this.name = 'InsertVerifierKeyTxFailedError';
  }
}

/**
 * An error indicating that a private state ID was specified for a call transaction while a private
 * state provider was not. We want to let the user know so that they aren't under the impression the
 * private state of a contract was updated when it wasn't.
 */
export class IncompleteCallTxPrivateStateConfig extends Error {
  constructor() {
    super('Incorrect call transaction configuration');
    this.message = "'privateStateId' was defined for call transaction while 'privateStateProvider' was undefined";
  }
}

/**
 * An error indicating that an initial private state was specified for a contract find while a
 * private state ID was not. We can't store the initial private state if we don't have a private state ID,
 * and we need to let the user know that.
 */
export class IncompleteFindContractPrivateStateConfig extends Error {
  constructor() {
    super('Incorrect find contract configuration');
    this.message = "'initialPrivateState' was defined for contract find while 'privateStateId' was undefined";
  }
}

================
File: packages/contracts/src/find-deployed-contract.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  type ContractAddress,
  type ContractState,
  sampleSigningKey,
  type SigningKey
} from '@midnight-ntwrk/compact-runtime';
import {
  type Contract,
  getImpureCircuitIds,
  type ImpureCircuitId,
  type PrivateState,
  type PrivateStateId,
  type PrivateStateProvider,
  type VerifierKey} from '@midnight-ntwrk/midnight-js-types';
import { assertDefined, assertIsContractAddress, toHex } from '@midnight-ntwrk/midnight-js-utils';

import { type ContractProviders } from './contract-providers';
import { ContractTypeError, IncompleteFindContractPrivateStateConfig } from './errors';
import {
  type CircuitCallTxInterface,
  type CircuitMaintenanceTxInterfaces,
  type ContractMaintenanceTxInterface,
  createCircuitCallTxInterface,
  createCircuitMaintenanceTxInterfaces,
  createContractMaintenanceTxInterface
} from './tx-interfaces';
import type { FinalizedDeployTxDataBase } from './tx-model';

const setOrGetInitialSigningKey = async (
  privateStateProvider: PrivateStateProvider,
  options: FindDeployedContractOptions<Contract>
): Promise<SigningKey> => {
  if (options.signingKey) {
    await privateStateProvider.setSigningKey(options.contractAddress, options.signingKey);
    return options.signingKey;
  }
  const existingSigningKey = await privateStateProvider.getSigningKey(options.contractAddress);
  if (existingSigningKey) {
    return existingSigningKey;
  }
  const freshSigningKey = sampleSigningKey();
  await privateStateProvider.setSigningKey(options.contractAddress, freshSigningKey);
  return freshSigningKey;
};

const setOrGetInitialPrivateState = async <C extends Contract>(
  privateStateProvider: PrivateStateProvider<PrivateStateId, PrivateState<C>>,
  options: FindDeployedContractOptions<C>
): Promise<PrivateState<C>> => {
  /**
   * If both 'privateStateId' and 'initialPrivateState' are defined,
   * then 'initialPrivateState' is stored in private state provider at 'privateStateId'.
   *
   * If 'privateStateId' is defined and 'initialPrivateState' is undefined,
   * and the private state provider has an entry at 'privateStateId',
   * then the find reports the stored private state as the initialPrivateState.
   *
   * If 'privateStateId' is defined and 'initialPrivateState' is undefined,
   * and the private state provider does not have an entry at 'privateStateId',
   * then an error is returned.
   *
   * If 'privateStateId' is undefined and 'initialPrivateState' is defined,
   * then an error is returned.
   *
   * If 'privateStateId' is undefined and 'initialPrivateState' is undefined,
   * then no private state is stored.
   */
  const hasPrivateStateId = 'privateStateId' in options;
  const hasInitialPrivateState = 'initialPrivateState' in options;

  if (hasPrivateStateId) {
    if (hasInitialPrivateState) {
      await privateStateProvider.set(options.privateStateId, options.initialPrivateState);
      return options.initialPrivateState;
    }
    const currentPrivateState = await privateStateProvider.get(options.privateStateId);
    assertDefined(currentPrivateState, `No private state found at private state ID '${options.privateStateId}'`);
    return currentPrivateState;
  }
  if (hasInitialPrivateState) {
    throw new IncompleteFindContractPrivateStateConfig();
  }
  // Cast to 'PrivateState<C>' because if we've reached this point, the private state of
  // the contract should be 'undefined'.
  return undefined as PrivateState<C>;
};

/**
 * Checks that two verifier keys are equal. Does initial length check match for efficiency.
 *
 * @param a First verifier key.
 * @param b Second verifier key.
 */
export const verifierKeysEqual = (a: Uint8Array, b: Uint8Array): boolean =>
  a.length === b.length && toHex(a) === toHex(b);

/**
 * Checks that the given `contractState` contains the given `verifierKeys`.
 *
 * @param verifierKeys The verifier keys the client has for the deployed contract we're checking.
 * @param contractState The (typically already deployed) contract state containing verifier keys.
 *
 * @throws ContractTypeError When one or more of the local and deployed verifier keys do not match.
 */
export const verifyContractState = (
  verifierKeys: [ImpureCircuitId, VerifierKey][],
  contractState: ContractState
): void => {
  const mismatchedCircuitIds = verifierKeys.reduce(
    (acc, [circuitId, localVk]) =>
      !contractState.operation(circuitId) ||
      !verifierKeysEqual(localVk, contractState.operation(circuitId)!.verifierKey)
        ? [...acc, circuitId]
        : acc,
    [] as string[]
  );
  if (mismatchedCircuitIds.length > 0) {
    throw new ContractTypeError(contractState, mismatchedCircuitIds);
  }
};

/**
 * Base type for the configuration options for {@link findDeployedContract}.
 */
export type FindDeployedContractOptionsBase<C extends Contract> = {
  /**
   * The contract to use to execute circuits.
   */
  readonly contract: C;
  /**
   * The address of a previously deployed contract.
   */
  readonly contractAddress: ContractAddress;
  /**
   * The signing key to use to perform contract maintenance updates. If defined, the given signing
   * key is stored for this contract address. This is useful when someone has already added the given signing
   * key to the contract maintenance authority. If undefined, and there is an existing signing key for the
   * contract address locally, the existing signing key is kept. This is useful when the contract was
   * deployed locally. If undefined, and there is not an existing signing key for the contract address
   * locally, a fresh signing key is generated and stored for the contract address locally. This is
   * useful when you want to give a signing key to someone else to add you as a maintenance authority.
   */
  readonly signingKey?: SigningKey;
}

/**
 * {@link findDeployedContract} base configuration that includes an initial private
 * state to store and the private state ID at which to store it. Only used if
 * the intention is to overwrite the private state currently stored at the given
 * private state ID.
 */
export type FindDeployedContractOptionsExistingPrivateState<C extends Contract> = FindDeployedContractOptionsBase<C> & {
  /**
   * An identifier for the private state of the contract being found.
   */
  readonly privateStateId: PrivateStateId;
};

/**
 * {@link findDeployedContract} configuration that includes an initial private
 * state to store and the private state ID at which to store it. Only used if
 * the intention is to overwrite the private state currently stored at the given
 * private state ID.
 */
export type FindDeployedContractOptionsStorePrivateState<C extends Contract> =
  FindDeployedContractOptionsExistingPrivateState<C> & {
    /**
     * For types of contract that make no use of private state and or witnesses that operate upon it, this
     * property may be `undefined`. Otherwise, the value provided via this property should be same initial
     * state that was used when calling {@link deployContract}.
     */
    readonly initialPrivateState: PrivateState<C>;
  };

/**
 * Configuration for {@link findDeployedContract}.
 */
export type FindDeployedContractOptions<C extends Contract> =
  | FindDeployedContractOptionsBase<C>
  | FindDeployedContractOptionsExistingPrivateState<C>
  | FindDeployedContractOptionsStorePrivateState<C>;

/**
 * Base type for a deployed contract that has been found on the blockchain.
 */
export type FoundContract<C extends Contract> = {
  /**
   * Data for the finalized deploy transaction corresponding to this contract.
   */
  readonly deployTxData: FinalizedDeployTxDataBase<C>;
  /**
   * Interface for creating call transactions for a contract.
   */
  readonly callTx: CircuitCallTxInterface<C>;
  /**
   * An interface for creating maintenance transactions for circuits defined in the
   * contract that was deployed.
   */
  readonly circuitMaintenanceTx: CircuitMaintenanceTxInterfaces<C>;
  /**
   * Interface for creating maintenance transactions for the contract that was
   * deployed.
   */
  readonly contractMaintenanceTx: ContractMaintenanceTxInterface;
}

export async function findDeployedContract<C extends Contract<undefined>>(
  providers: ContractProviders<C, ImpureCircuitId<C>, unknown>,
  options: FindDeployedContractOptionsBase<C>
): Promise<FoundContract<C>>;

export async function findDeployedContract<C extends Contract>(
  providers: ContractProviders<C>,
  options: FindDeployedContractOptionsExistingPrivateState<C>
): Promise<FoundContract<C>>;

export async function findDeployedContract<C extends Contract>(
  providers: ContractProviders<C>,
  options: FindDeployedContractOptionsStorePrivateState<C>
): Promise<FoundContract<C>>;

/**
 * Creates an instance of {@link FoundContract} given the address of a deployed contract and an
 * optional private state ID at which an existing private state is stored. When given, the current value
 * at the private state ID is used as the `initialPrivateState` value in the `finalizedDeployTxData`
 * property of the returned `FoundContract`.
 *
 * @param providers The providers used to manage transaction lifecycles.
 * @param options Configuration.
 *
 * @throws Error Improper `privateStateId` and `initialPrivateState` configuration.
 * @throws Error No contract state could be found at `contractAddress`.
 * @throws TypeError Thrown if `contractAddress` is not correctly formatted as a contract address.
 * @throws ContractTypeError One or more circuits defined on `contract` are undefined on the contract
 *                           state found at `contractAddress`, or have mis-matched verifier keys.
 * @throws IncompleteFindContractPrivateStateConfig If an `initialPrivateState` is given but no
 *                                                  `privateStateId` is given to store it under.
 */
export async function findDeployedContract<C extends Contract>(
  providers: ContractProviders<C>,
  options: FindDeployedContractOptions<C>
): Promise<FoundContract<C>> {
  const { contract, contractAddress } = options;
  assertIsContractAddress(contractAddress);

  const finalizedTxData = await providers.publicDataProvider.watchForDeployTxData(contractAddress);

  const initialContractState = await providers.publicDataProvider.queryDeployContractState(contractAddress);
  assertDefined(initialContractState, `No contract deployed at contract address '${contractAddress}'`);

  const currentContractState = await providers.publicDataProvider.queryContractState(contractAddress);
  assertDefined(currentContractState, `No contract deployed at contract address '${contractAddress}'`);

  const verifierKeys = await providers.zkConfigProvider.getVerifierKeys(getImpureCircuitIds(contract));
  verifyContractState(verifierKeys, currentContractState);

  const signingKey = await setOrGetInitialSigningKey(providers.privateStateProvider, options);
  const initialPrivateState = await setOrGetInitialPrivateState(providers.privateStateProvider, options);

  return {
    deployTxData: {
      private: {
        signingKey,
        initialPrivateState
      },
      public: {
        ...finalizedTxData,
        contractAddress,
        initialContractState
      }
    },
    callTx: createCircuitCallTxInterface(
      providers,
      contract,
      contractAddress,
      'privateStateId' in options ? options.privateStateId : undefined
    ),
    circuitMaintenanceTx: createCircuitMaintenanceTxInterfaces(providers, contract, contractAddress),
    contractMaintenanceTx: createContractMaintenanceTxInterface(providers, contractAddress)
  };
}

================
File: packages/contracts/src/get-states.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ContractState } from '@midnight-ntwrk/compact-runtime';
import type { ContractAddress, ZswapChainState } from '@midnight-ntwrk/ledger-v6';
import type { PrivateStateId,PrivateStateProvider, PublicDataProvider } from '@midnight-ntwrk/midnight-js-types';
import { assertDefined, assertIsContractAddress } from '@midnight-ntwrk/midnight-js-utils';

/**
 * Object containing the publicly visible states of a contract.
 */
export type PublicContractStates = {
  /**
   * The (public) Zswap chain state of a contract.
   */
  readonly zswapChainState: ZswapChainState;
  /**
   * The (public) ledger state of a contract.
   */
  readonly contractState: ContractState;
}

/**
 * Object containing the publicly visible states of a contract and the private
 * state of a contract.
 */
export type ContractStates<PS> = PublicContractStates & {
  /**
   * The private state of a contract.
   */
  readonly privateState: PS;
};

/**
 * Fetches only the public visible (Zswap and ledger) states of a contract.
 *
 * @param publicDataProvider The provider to use to fetch the public states (Zswap and ledger)
 *                           from the blockchain.
 * @param contractAddress The ledger address of the contract.
 */
export const getPublicStates = async (
  publicDataProvider: PublicDataProvider,
  contractAddress: ContractAddress
): Promise<PublicContractStates> => {
  assertIsContractAddress(contractAddress);
  const zswapAndContractState = await publicDataProvider.queryZSwapAndContractState(contractAddress);
  assertDefined(zswapAndContractState, `No public state found at contract address '${contractAddress}'`);
  const [zswapChainState, contractState] = zswapAndContractState;
  return { contractState, zswapChainState };
};

/**
 * Retrieves the Zswap, ledger, and private states of the contract corresponding
 * to the given identifier using the given providers.
 *
 * @param publicDataProvider The provider to use to fetch the public states (Zswap and ledger)
 *                           from the blockchain.
 * @param privateStateProvider The provider to use to fetch the private state.
 * @param contractAddress The ledger address of the contract.
 * @param privateStateId The identifier for the private state of the contract.
 */
export const getStates = async <PS>(
  publicDataProvider: PublicDataProvider,
  privateStateProvider: PrivateStateProvider<PrivateStateId, PS>,
  contractAddress: ContractAddress,
  privateStateId: PrivateStateId
): Promise<ContractStates<PS>> => {
  const publicContractStates = await getPublicStates(publicDataProvider, contractAddress);
  const privateState = await privateStateProvider.get(privateStateId);
  assertDefined(privateState, `No private state found at private state ID '${privateStateId}'`);
  return { ...publicContractStates, privateState };
};

================
File: packages/contracts/src/get-unshielded-balances.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ContractAddress } from '@midnight-ntwrk/ledger-v6';
import type { PublicDataProvider, UnshieldedBalances } from '@midnight-ntwrk/midnight-js-types';
import { assertDefined, assertIsContractAddress } from '@midnight-ntwrk/midnight-js-utils';

/**
 * Fetches the unshielded balances associated with a specific contract address.
 *
 * @param publicDataProvider The provider to use to fetch the unshielded balances from the blockchain.
 * @param contractAddress The ledger address of the contract.
 */
export const getUnshieldedBalances = async (
  publicDataProvider: PublicDataProvider,
  contractAddress: ContractAddress
): Promise<UnshieldedBalances> => {
  assertIsContractAddress(contractAddress);
  const unshieldedBalances = await publicDataProvider.queryUnshieldedBalances(contractAddress);
  assertDefined(unshieldedBalances, `No unshielded balances found at contract address '${contractAddress}'`);
  return unshieldedBalances;
};

================
File: packages/contracts/src/tx-interfaces.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { SigningKey } from '@midnight-ntwrk/compact-runtime';
import type { ContractAddress } from '@midnight-ntwrk/ledger-v6';
import {
  type CircuitParameters,
  type Contract,
  type FinalizedTxData,
  getImpureCircuitIds,
  type ImpureCircuitId,
  type PrivateStateId,
  type VerifierKey} from '@midnight-ntwrk/midnight-js-types';
import { assertIsContractAddress } from '@midnight-ntwrk/midnight-js-utils';

import { type ContractProviders } from './contract-providers';
import { submitCallTx } from './submit-call-tx';
import { submitInsertVerifierKeyTx } from './submit-insert-vk-tx';
import { submitRemoveVerifierKeyTx } from './submit-remove-vk-tx';
import { submitReplaceAuthorityTx } from './submit-replace-authority-tx';
import type { FinalizedCallTxData } from './tx-model';
import type { CallTxOptions } from './unproven-call-tx';

/**
 * A type that lifts each circuit defined in a contract to a function that builds
 * and submits a call transaction.
 */
export type CircuitCallTxInterface<C extends Contract> = {
  [ICK in ImpureCircuitId<C>]: (...args: CircuitParameters<C, ICK>) => Promise<FinalizedCallTxData<C, ICK>>;
};

/**
 * Creates a {@link CallTxOptions} object from various data.
 */
export const createCallTxOptions = <C extends Contract, ICK extends ImpureCircuitId<C>>(
  contract: C,
  circuitId: ICK,
  contractAddress: ContractAddress,
  privateStateId: PrivateStateId | undefined,
  args: CircuitParameters<C, ICK>
): CallTxOptions<C, ICK> => {
  const callOptionsBase = {
    contract,
    circuitId,
    contractAddress
  };
  const callTxOptionsBase = args.length !== 0 ? { ...callOptionsBase, args } : callOptionsBase;
  const callTxOptions = privateStateId ? { ...callTxOptionsBase, privateStateId } : callTxOptionsBase;
  return callTxOptions as CallTxOptions<C, ICK>;
};

/**
 * Creates a circuit call transaction interface for a contract.
 *
 * @param providers The providers to use to build transactions.
 * @param contract The contract to use to execute circuits.
 * @param contractAddress The ledger address of the contract.
 * @param privateStateId The identifier of the state of the witnesses of the contract.
 */
export const createCircuitCallTxInterface = <C extends Contract>(
  providers: ContractProviders<C>,
  contract: C,
  contractAddress: ContractAddress,
  privateStateId: PrivateStateId | undefined
): CircuitCallTxInterface<C> => {
  assertIsContractAddress(contractAddress);
  return getImpureCircuitIds(contract).reduce(
    (acc, circuitId) => ({
      ...acc,
      [circuitId]: (...args: CircuitParameters<C, typeof circuitId>) =>
        submitCallTx(providers, createCallTxOptions(contract, circuitId, contractAddress, privateStateId, args))
    }),
    {}
  ) as CircuitCallTxInterface<C>;
};

/**
 * An interface for creating maintenance transactions for a specific circuit defined in a
 * given contract.
 */
export type CircuitMaintenanceTxInterface = {
  /**
   * Constructs and submits a transaction that removes the current verifier key stored
   * on the blockchain for this circuit at this contract's address.
   */
  removeVerifierKey(): Promise<FinalizedTxData>;
  /**
   * Constructs and submits a transaction that adds a new verifier key to the
   * blockchain for this circuit at this contract's address.
   *
   * @param newVk The new verifier key to add for this circuit.
   */
  insertVerifierKey(newVk: VerifierKey): Promise<FinalizedTxData>;
}

/**
 * Creates a {@link CircuitMaintenanceTxInterface}.
 *
 * @param providers The providers to use to create and submit transactions.
 * @param circuitId The circuit ID the interface is for.
 * @param contractAddress The address of the deployed contract for which this
 *                        interface is being created.
 */
export const createCircuitMaintenanceTxInterface = <C extends Contract, ICK extends ImpureCircuitId<C>>(
  providers: ContractProviders<C, ICK>,
  circuitId: ICK,
  contractAddress: ContractAddress
): CircuitMaintenanceTxInterface => {
  assertIsContractAddress(contractAddress);
  return {
    removeVerifierKey(): Promise<FinalizedTxData> {
      return submitRemoveVerifierKeyTx(providers, contractAddress, circuitId);
    },
    insertVerifierKey(newVk: VerifierKey): Promise<FinalizedTxData> {
      return submitInsertVerifierKeyTx(providers, contractAddress, circuitId, newVk);
    }
  };
};

/**
 * A set of maintenance transaction creation interfaces, one for each circuit defined in
 * a given contract, keyed by the circuit name.
 */
export type CircuitMaintenanceTxInterfaces<C extends Contract> = Record<ImpureCircuitId<C>, CircuitMaintenanceTxInterface>;

/**
 * Creates a {@link CircuitMaintenanceTxInterfaces}.
 *
 * @param providers The providers to use to build transactions.
 * @param contract The contract to use to execute circuits.
 * @param contractAddress The ledger address of the contract.
 */
export const createCircuitMaintenanceTxInterfaces = <C extends Contract>(
  providers: ContractProviders<C>,
  contract: C,
  contractAddress: ContractAddress
): CircuitMaintenanceTxInterfaces<C> => {
  assertIsContractAddress(contractAddress);
  return getImpureCircuitIds(contract).reduce(
    (acc, circuitId) => ({
      ...acc,
      [circuitId]: createCircuitMaintenanceTxInterface(providers, circuitId, contractAddress)
    }),
    {}
  ) as CircuitMaintenanceTxInterfaces<C>;
};

/**
 * Interface for creating maintenance transactions for a contract that was
 * deployed.
 */
export interface ContractMaintenanceTxInterface {
  /**
   * Constructs and submits a transaction that replaces the maintenance
   * authority stored on the blockchain for this contract.
   *
   * @param newAuthority The new contract maintenance authority for this contract.
   */
  replaceAuthority(newAuthority: SigningKey): Promise<FinalizedTxData>;
}

/**
 * Creates a {@link ContractMaintenanceTxInterface}.
 *
 * @param providers The providers to use to build transactions.
 * @param contractAddress The ledger address of the contract.
 */
export const createContractMaintenanceTxInterface = (
  providers: ContractProviders,
  contractAddress: ContractAddress
): ContractMaintenanceTxInterface => {
  assertIsContractAddress(contractAddress);
  return {
    replaceAuthority: submitReplaceAuthorityTx(providers, contractAddress)
  };
};

================
File: packages/contracts/README.md
================
# What is this?
Provides utilities for interacting with Midnight contracts.  

This package was created for the [Midnight network](https://midnight.network).

Please visit the [Midnight Developer Hub](https://midnight.network/developer-hub) to learn more.

# Use only in Midnight test environments
Image exclusively for Midnight test environments use.  

# Agree to Terms
By downloading and using this image, you agree to [Midnights Terms and Conditions](https://midnight.network/static/terms.pdf), which includes the [Privacy Policy](https://midnight.network/static/privacy-policy.pdf).

# License
The software provided herein is licensed under the [Apache License V2.0](http://www.apache.org/licenses/LICENSE-2.0).

================
File: packages/contracts/rollup.config.mjs
================
import { createRollupConfig } from '../../build-tools/rollup.config.factory.mjs';
import packageJson from './package.json' with { type: 'json' };

export default createRollupConfig(packageJson);

================
File: packages/contracts/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": [
    "./src/test/**/*.ts"
  ]
}

================
File: packages/contracts/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": [
    "./src/**/*.ts"
  ]
}

================
File: packages/contracts/typedoc.json
================
{
  "extends": ["../../typedoc.base.json"],
  "readme": "none",
  "entryPoints": ["src/index.ts"]
}

================
File: packages/fetch-zk-config-provider/src/test/fetch-zk-config-provider.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { BinaryLike } from 'crypto';
import * as crypto from 'crypto';
import express from 'express';
import * as fs from 'fs/promises';
import type { Server } from 'http';

import { FetchZkConfigProvider } from '../index';

describe('Fetch ZK config Provider', () => {
  const resourceDir = `${process.cwd()}/src/test/resources`;

  let server: Server;
  let serverURL: string;

  beforeAll(async () => {
    const proverKey = await fs.readFile(`${resourceDir}/keys/set_topic.prover`);
    const verifierKey = await fs.readFile(`${resourceDir}/keys/set_topic.verifier`);
    const zkir = await fs.readFile(`${resourceDir}/zkir/set_topic.bzkir`).then((buffer) => buffer.toString('utf-8'));
    const app = express();
    app.get('/keys/set_topic.prover', (_, res) => {
      res.send(proverKey);
    });
    app.get('/keys/set_topic.verifier', (_, res) => {
      res.send(verifierKey);
    });
    app.get('/zkir/set_topic.bzkir', (_, res) => {
      res.send(zkir);
    });
    server = app.listen();
    const serverAddress = server.address();
    if (serverAddress === null) {
      throw new Error('Expected server address to be defined');
    } else if (typeof serverAddress === 'object') {
      serverURL = `http://localhost:${serverAddress.port}`;
    }
  });

  afterAll(() => {
    server.close();
  });

  const createHash = (binaryLike: BinaryLike): string => {
    return crypto.createHash('sha256').update(binaryLike).digest().toString('base64');
  };

  const PROVER_KEY_HASH = 'DnbPkv3mY0+nHwt3NGuaWlMRC+2QhtG+COdhjFd0xB8=';

  test('reads prover key correctly', async () => {
    const proverKey = await new FetchZkConfigProvider(serverURL).getProverKey('set_topic');
    expect(createHash(proverKey)).toEqual(PROVER_KEY_HASH);
  });

  const VERIFIER_KEY_HASH = 'sbTZdCx3Kz4RA5OUSaBg2+WZupNdCwd13XmQV9j4pd4=';

  test('reads verifier key correctly', async () => {
    const verifierKey = await new FetchZkConfigProvider(serverURL).getVerifierKey('set_topic');
    expect(createHash(verifierKey)).toEqual(VERIFIER_KEY_HASH);
  });

  const ZKIR_HASH = 'o4RX/Cgm/+GLJwptMkkbsrYYhX0z9DpQCaF0eaOVMU0=';

  test('reads ZKIR correctly', async () => {
    const zkProvider = await new FetchZkConfigProvider(serverURL).getZKIR('set_topic');
    expect(createHash(zkProvider)).toEqual(ZKIR_HASH);
  });

  test('throws on invalid url', () => {
    expect(() => new FetchZkConfigProvider('ws://localhost:5000')).toThrow(/^Invalid protocol scheme: 'ws:'/);
  });
});

================
File: packages/fetch-zk-config-provider/src/fetch-zk-config-provider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ProverKey, VerifierKey, ZKIR } from '@midnight-ntwrk/midnight-js-types';
import {
  createProverKey,
  createVerifierKey,
  createZKIR,
  InvalidProtocolSchemeError,
  ZKConfigProvider} from '@midnight-ntwrk/midnight-js-types';
import { fetch } from 'cross-fetch';

/**
 * The name of the path containing proving and verifying keys.
 */
const KEY_PATH = 'keys';
/**
 * File extension for proving keys.
 */
const PROVER_EXT = '.prover';
/**
 * File extension for verifying keys.
 */
const VERIFIER_EXT = '.verifier';
/**
 * The name of the path containing zkIRs.
 */
const ZKIR_PATH = 'zkir';
/**
 * File extension for zkIRs.
 */
const ZKIR_EXT = '.bzkir';

/**
 * Retrieves ZK artifacts from a remote source.
 */
export class FetchZkConfigProvider<K extends string> extends ZKConfigProvider<K> {
  /**
   * @param baseURL The endpoint to query for ZK artifacts.
   * @param fetchFunc The function to use to execute queries.
   */
  constructor(
    public readonly baseURL: string,
    private fetchFunc: typeof fetch = fetch
  ) {
    super();
    const urlObject = new URL(baseURL);
    if (urlObject.protocol !== 'http:' && urlObject.protocol !== 'https:') {
      throw new InvalidProtocolSchemeError(urlObject.protocol, ['http:', 'https:']);
    }
  }

  private async sendRequest<T extends 'text' | 'arraybuffer'>(
    url: typeof KEY_PATH | typeof ZKIR_PATH,
    circuitId: K,
    ext: typeof ZKIR_EXT | typeof PROVER_EXT | typeof VERIFIER_EXT,
    responseType: T
  ): Promise<T extends 'text' ? string : Uint8Array> {
    const response = await this.fetchFunc(`${this.baseURL}/${url}/${circuitId}${ext}`, {
      method: 'GET'
    });
    if (response.ok) {
      // The compiler can't infer that this return value is well-typed, so I cast to 'any'
      /* eslint-disable @typescript-eslint/no-explicit-any */
      return responseType === 'text'
        ? ((await response.text()) as any)
        : ((await response.arrayBuffer().then((arrayBuffer) => new Uint8Array(arrayBuffer))) as any);
      /* eslint-enable @typescript-eslint/no-explicit-any */
    }
    throw new Error(response.statusText);
  }

  getProverKey(circuitId: K): Promise<ProverKey> {
    return this.sendRequest(KEY_PATH, circuitId, PROVER_EXT, 'arraybuffer').then(createProverKey);
  }

  getVerifierKey(circuitId: K): Promise<VerifierKey> {
    return this.sendRequest(KEY_PATH, circuitId, VERIFIER_EXT, 'arraybuffer').then(createVerifierKey);
  }

  getZKIR(circuitId: K): Promise<ZKIR> {
    return this.sendRequest(ZKIR_PATH, circuitId, ZKIR_EXT, 'arraybuffer').then(createZKIR);
  }
}

================
File: packages/fetch-zk-config-provider/src/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { FetchZkConfigProvider } from './fetch-zk-config-provider';

================
File: packages/fetch-zk-config-provider/README.md
================
# What is this?
A `ZKConfigProvider` implementation that retrieves proving and verifying keys and ZK intermediate
representation, in a browser environment.  

This package was created for the [Midnight network](https://midnight.network).

Please visit the [Midnight Developer Hub](https://midnight.network/developer-hub) to learn more.

# Use only in Midnight test environments
Image exclusively for Midnight test environments use.  

# Agree to Terms
By downloading and using this image, you agree to [Midnights Terms and Conditions](https://midnight.network/static/terms.pdf), which includes the [Privacy Policy](https://midnight.network/static/privacy-policy.pdf).

# License
The software provided herein is licensed under the [Apache License V2.0](http://www.apache.org/licenses/LICENSE-2.0).

================
File: packages/fetch-zk-config-provider/rollup.config.mjs
================
import { createRollupConfig } from '../../build-tools/rollup.config.factory.mjs';
import packageJson from './package.json' with { type: 'json' };

export default createRollupConfig(packageJson);

================
File: packages/fetch-zk-config-provider/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": [
    "./src/test/**/*.ts"
  ]
}

================
File: packages/fetch-zk-config-provider/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": [
    "./src/**/*.ts"
  ]
}

================
File: packages/fetch-zk-config-provider/typedoc.json
================
{
  "extends": ["../../typedoc.base.json"],
  "readme": "none",
  "entryPoints": ["src/index.ts"]
}

================
File: packages/fetch-zk-config-provider/vitest.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// <reference types="vitest" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    include: ['**/test/**/*.test.ts'],
    exclude: ['node_modules', 'dist'],
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage'
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }]
    ]
  }
});

================
File: packages/http-client-proof-provider/src/test/resources/simple.compact
================
import CompactStandardLibrary;

export ledger round: Counter;

export circuit add(): [] {
  round.increment(1);
}

================
File: packages/http-client-proof-provider/src/test/commons.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

import {
  type ConstructorContext,
  emptyZswapLocalState
} from '@midnight-ntwrk/compact-runtime';
import {
  sampleCoinPublicKey,
  sampleContractAddress,
  sampleEncryptionPublicKey,
  type UnprovenTransaction,
  ZswapChainState
} from '@midnight-ntwrk/ledger-v6';
import { createUnprovenCallTxFromInitialStates } from '@midnight-ntwrk/midnight-js-contracts';
import { createProverKey, createVerifierKey, createZKIR } from '@midnight-ntwrk/midnight-js-types';
import fs from 'fs/promises';

const currentDir = dirname(fileURLToPath(import.meta.url));

export const resourceDir = `${currentDir}/resources`;

const CONTRACT = `simple`;
const CIRCUIT_ID = 'add';

export const getValidZKConfig = async () => ({
  circuitId: CIRCUIT_ID,
  proverKey: createProverKey(await fs.readFile(`${resourceDir}/managed/${CONTRACT}/keys/${CIRCUIT_ID}.prover`)),
  verifierKey: createVerifierKey(await fs.readFile(`${resourceDir}/managed/${CONTRACT}/keys/${CIRCUIT_ID}.verifier`)),
  zkir: createZKIR(await fs.readFile(`${resourceDir}/managed/${CONTRACT}/zkir/${CIRCUIT_ID}.bzkir`))
});

/**
 * Creates a valid UnprovenTransaction for testing using proper object construction
 * from the topic contract instead of binary data.
 */
export const getValidUnprovenTx = async (): Promise<UnprovenTransaction> => {
  const contractModule = await import(`${resourceDir}/managed/${CONTRACT}/contract/index.js`);
  const contract = new contractModule.Contract({});
  const coinPublicKey = sampleCoinPublicKey();

  const constructorResult = contract.initialState(
    {
      initialPrivateState: undefined,
      initialZswapLocalState: emptyZswapLocalState(coinPublicKey)
    } as ConstructorContext<undefined>
  );

  const initialContractState = constructorResult.currentContractState;

  const callOptions = {
    contract,
    circuitId: CIRCUIT_ID,
    contractAddress: sampleContractAddress(),
    coinPublicKey,
    initialContractState,
    initialZswapChainState: new ZswapChainState(),
    arguments: []
  };

  const result = createUnprovenCallTxFromInitialStates(
    callOptions,
    coinPublicKey,
    sampleEncryptionPublicKey()
  );

  return result.private.unprovenTx;
};

================
File: packages/http-client-proof-provider/src/test/http-client-proof-provider-spied.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable @typescript-eslint/no-explicit-any */
import { beforeEach,vi } from 'vitest';

import { getValidUnprovenTx } from './commons';

const mockFetch = vi.fn();

vi.mock('cross-fetch', () => ({
  default: mockFetch
}));

describe('Http Proof Server Proof Provider', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  test("'httpClientProofProvider' posts to valid 'url' not ending with a trailing '/'", async () => {
    // Arrange for the mock 'fetch' to return a 500 error.
    mockFetch.mockResolvedValue({
      ok: false,
      statusText: 'MOCK_ERROR',
      status: 500
    } as any);

    const { httpClientProofProvider } = await import('../http-client-proof-provider');
    const unprovenTx = await getValidUnprovenTx();
    const proofProvider = httpClientProofProvider('http://notvalidendpoint:8080');

    // Assert that the 'proveTx' call fails only with our arranged 500 error.
    await expect(() => proofProvider.proveTx(unprovenTx)).rejects.toThrow('MOCK_ERROR');

    // Assert that 'fetch' was used to POST to construct 'prove-tx' URL.
    expect(mockFetch).toHaveBeenCalledWith(
      expect.objectContaining({ href: 'http://notvalidendpoint:8080/prove-tx' }),
      expect.objectContaining({
        method: expect.stringMatching('POST')
      })
    );
  });

  test("'httpClientProofProvider' posts to valid 'url' ending with a trailing '/'", async () => {
    // Arrange for the mock 'fetch' to return a 500 error.
    mockFetch.mockResolvedValue({
      ok: false,
      statusText: 'MOCK_ERROR',
      status: 500
    } as any);

    const { httpClientProofProvider } = await import('../http-client-proof-provider');
    const unprovenTx = await getValidUnprovenTx();
    const proofProvider = httpClientProofProvider('http://notvalidendpoint:8080/');

    // Assert that the 'proveTx' call fails only with our arranged 500 error.
    await expect(() => proofProvider.proveTx(unprovenTx)).rejects.toThrow('MOCK_ERROR');

    // Assert that 'fetch' was used to POST to construct 'prove-tx' URL.
    expect(mockFetch).toHaveBeenCalledWith(
      expect.objectContaining({ href: 'http://notvalidendpoint:8080/prove-tx' }),
      expect.objectContaining({
        method: expect.stringMatching('POST')
      })
    );
  });
});

================
File: packages/http-client-proof-provider/src/test/http-client-proof-provider.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { BinaryLike } from 'crypto';
import crypto from 'crypto';

import { httpClientProofProvider, serializeTransactionPayload } from '../http-client-proof-provider';
import { getValidUnprovenTx, getValidZKConfig } from './commons';

const createHash = (binaryLike: BinaryLike): string => {
  return crypto.createHash('sha256').update(binaryLike).digest().toString('base64');
};

describe('Http Proof Server Proof Provider', () => {
  test("'httpProofServerProofProvider' throws when 'url' does not start with 'http:' or 'https:'", () => {
    expect(() => httpClientProofProvider('ws://localhost:8080')).toThrow(/Invalid protocol scheme: 'ws:'/);
  });

  test("'serializePayload' produces deterministic output", async () => {
    const zkConfig = await getValidZKConfig();
    const unprovenTx = await getValidUnprovenTx();
    const payload1 = serializeTransactionPayload(unprovenTx, zkConfig);
    const payload2 = serializeTransactionPayload(unprovenTx, zkConfig);
    expect(createHash(Buffer.from(payload1))).toEqual(createHash(Buffer.from(payload2)));
    expect(payload1.byteLength).toBeGreaterThan(0);
  });

  test('handles Uint8Array<ArrayBufferLike> correctly', async () => {
    const zkConfig = await getValidZKConfig();
    const unprovenTx = await getValidUnprovenTx();

    const result = serializeTransactionPayload(unprovenTx, zkConfig);

    expect(result).toBeInstanceOf(Uint8Array);
    expect(result.byteLength).toBeGreaterThan(0);
  });

  test('handles undefined zkConfig correctly', async () => {
    const unprovenTx = await getValidUnprovenTx();

    const result = serializeTransactionPayload(unprovenTx, undefined);

    expect(result).toBeInstanceOf(Uint8Array);
    expect(result.byteLength).toBeGreaterThan(0);
  });
});

================
File: packages/http-client-proof-provider/src/http-client-proof-provider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  createProvingTransactionPayload,
  type ProvingKeyMaterial,
  Transaction,
  type UnprovenTransaction
} from '@midnight-ntwrk/ledger-v6';
import type {
  ProofProvider,
  ProvenTransaction,
  ProveTxConfig,
  ZKConfig
} from '@midnight-ntwrk/midnight-js-types';
import { InvalidProtocolSchemeError } from '@midnight-ntwrk/midnight-js-types';
import fetch from 'cross-fetch';
import fetchBuilder from 'fetch-retry';
import _ from 'lodash';

/**
 * configure fetch-retry with fetch and http error 500 & 503 backoff strategy.
 */
const retryOptions = {
  retries: 3,
  retryDelay: (attempt: number) => 2 ** attempt * 1_000,
  retryOn: [500, 503]
};
const fetchRetry = fetchBuilder(fetch, retryOptions);

const deserializePayload = (arrayBuffer: ArrayBuffer): ProvenTransaction => {
  const bytes = new Uint8Array(arrayBuffer);
  const transaction = Transaction.deserialize('signature', 'proof', 'pre-binding', bytes);
  return transaction as ProvenTransaction;
};

const PROVE_TX_PATH = '/prove-tx';

/**
 * The default configuration for the proof server client.
 */
export const DEFAULT_CONFIG = {
  /**
   * The default timeout for prove requests.
   */
  timeout: 300000,
  /**
   * The default ZK configuration to use. It is overwritten with a proper ZK
   * configuration only if a call transaction is being proven.
   */
  zkConfig: undefined
};

const getKeyMaterial = <K extends string>(zkConfig?: ZKConfig<K>): ProvingKeyMaterial => {
  return {
    proverKey: zkConfig?.proverKey as Uint8Array,
    verifierKey: zkConfig?.verifierKey as Uint8Array,
    ir: zkConfig?.zkir as Uint8Array,
  };
}

export const serializeTransactionPayload = <K extends string>(unprovenTx: UnprovenTransaction, zkConfig?: ZKConfig<K>): Uint8Array => {
  const map = new Map();
  if(zkConfig) {
    map.set(zkConfig?.circuitId, getKeyMaterial(zkConfig));
  }
  return createProvingTransactionPayload(unprovenTx, map);
}

/**
 * Creates a {@link ProofProvider} by creating a client for a running proof server.
 * Allows for HTTP and HTTPS. The data passed to 'proveTx' are intended to be
 * secret, so usage of this function should be heavily scrutinized.
 *
 * @param url The url of a running proof server.
 */
export const httpClientProofProvider = <K extends string>(url: string): ProofProvider<K> => {
  // To validate the url, we use the URL constructor
  const urlObject = new URL(PROVE_TX_PATH, url);
  if (urlObject.protocol !== 'http:' && urlObject.protocol !== 'https:') {
    throw new InvalidProtocolSchemeError(urlObject.protocol, ['http:', 'https:']);
  }
  return {
    async proveTx(
      unprovenTx: UnprovenTransaction,
      partialProveTxConfig?: ProveTxConfig<K>
    ): Promise<ProvenTransaction> {
      const config = _.defaults(partialProveTxConfig, DEFAULT_CONFIG);
      const requestBody = serializeTransactionPayload(unprovenTx, config.zkConfig).buffer as ArrayBuffer;
      const response = await fetchRetry(urlObject, {
        method: 'POST',
        body: requestBody,
        signal: AbortSignal.timeout(config.timeout)
      });
      // TODO: More sophisticated error handling
      // TODO: Check that response is valid format (has arrayBuffer content-type)
      if (!response.ok) {
        throw new Error(
          `Failed Proof Server response: url="${response.url}", code="${response.status}", status="${response.statusText}"`
        );
      }
      return deserializePayload(await response.arrayBuffer());
    }
  };
};

================
File: packages/http-client-proof-provider/src/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export {
  DEFAULT_CONFIG,
  httpClientProofProvider,
  serializeTransactionPayload
} from './http-client-proof-provider';

================
File: packages/http-client-proof-provider/README.md
================
# What is this?
An implementation of a proof provider based on the Midnight ledger proof server.  

This package was created for the [Midnight network](https://midnight.network).

Please visit the [Midnight Developer Hub](https://midnight.network/developer-hub) to learn more.

# Use only in Midnight test environments
Image exclusively for Midnight test environments use.  

# Agree to Terms
By downloading and using this image, you agree to [Midnights Terms and Conditions](https://midnight.network/static/terms.pdf), which includes the [Privacy Policy](https://midnight.network/static/privacy-policy.pdf).

# License
The software provided herein is licensed under the [Apache License V2.0](http://www.apache.org/licenses/LICENSE-2.0).

================
File: packages/http-client-proof-provider/rollup.config.mjs
================
import { createRollupConfig } from '../../build-tools/rollup.config.factory.mjs';
import packageJson from './package.json' with { type: 'json' };

export default createRollupConfig(packageJson);

================
File: packages/http-client-proof-provider/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": [
    "./src/test/**/*.ts"
  ]
}

================
File: packages/http-client-proof-provider/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": [
    "./src/**/*.ts"
  ]
}

================
File: packages/http-client-proof-provider/typedoc.json
================
{
  "extends": ["../../typedoc.base.json"],
  "readme": "none",
  "entryPoints": ["src/index.ts"]
}

================
File: packages/http-client-proof-provider/vitest.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// <reference types="vitest" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    include: ['**/test/**/*.test.ts'],
    exclude: ['node_modules', 'dist'],
    testTimeout: 180000,
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage'
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }]
    ]
  },
  resolve: {
    alias: {
      '@midnight-ntwrk/onchain-runtime': '@midnight-ntwrk/onchain-runtime-cjs'
    }
  }
});

================
File: packages/indexer-public-data-provider/src/gen/fragment-masking.ts
================
/* eslint-disable */
import type { ResultOf, DocumentTypeDecoration, TypedDocumentNode } from '@graphql-typed-document-node/core';
import type { FragmentDefinitionNode } from 'graphql';
import type { Incremental } from './graphql';


export type FragmentType<TDocumentType extends DocumentTypeDecoration<any, any>> = TDocumentType extends DocumentTypeDecoration<
  infer TType,
  any
>
  ? [TType] extends [{ ' $fragmentName'?: infer TKey }]
    ? TKey extends string
      ? { ' $fragmentRefs'?: { [key in TKey]: TType } }
      : never
    : never
  : never;

// return non-nullable if `fragmentType` is non-nullable
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>>
): TType;
// return nullable if `fragmentType` is undefined
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>> | undefined
): TType | undefined;
// return nullable if `fragmentType` is nullable
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>> | null
): TType | null;
// return nullable if `fragmentType` is nullable or undefined
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>> | null | undefined
): TType | null | undefined;
// return array of non-nullable if `fragmentType` is array of non-nullable
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: Array<FragmentType<DocumentTypeDecoration<TType, any>>>
): Array<TType>;
// return array of nullable if `fragmentType` is array of nullable
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: Array<FragmentType<DocumentTypeDecoration<TType, any>>> | null | undefined
): Array<TType> | null | undefined;
// return readonly array of non-nullable if `fragmentType` is array of non-nullable
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: ReadonlyArray<FragmentType<DocumentTypeDecoration<TType, any>>>
): ReadonlyArray<TType>;
// return readonly array of nullable if `fragmentType` is array of nullable
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: ReadonlyArray<FragmentType<DocumentTypeDecoration<TType, any>>> | null | undefined
): ReadonlyArray<TType> | null | undefined;
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>> | Array<FragmentType<DocumentTypeDecoration<TType, any>>> | ReadonlyArray<FragmentType<DocumentTypeDecoration<TType, any>>> | null | undefined
): TType | Array<TType> | ReadonlyArray<TType> | null | undefined {
  return fragmentType as any;
}


export function makeFragmentData<
  F extends DocumentTypeDecoration<any, any>,
  FT extends ResultOf<F>
>(data: FT, _fragment: F): FragmentType<F> {
  return data as FragmentType<F>;
}
export function isFragmentReady<TQuery, TFrag>(
  queryNode: DocumentTypeDecoration<TQuery, any>,
  fragmentNode: TypedDocumentNode<TFrag>,
  data: FragmentType<TypedDocumentNode<Incremental<TFrag>, any>> | null | undefined
): data is FragmentType<typeof fragmentNode> {
  const deferredFields = (queryNode as { __meta__?: { deferredFields: Record<string, (keyof TFrag)[]> } }).__meta__
    ?.deferredFields;

  if (!deferredFields) return true;

  const fragDef = fragmentNode.definitions[0] as FragmentDefinitionNode | undefined;
  const fragName = fragDef?.name?.value;

  const fields = (fragName && deferredFields[fragName]) || [];
  return fields.length > 0 && fields.every(field => data && field in data);
}

================
File: packages/indexer-public-data-provider/src/gen/gql.ts
================
/* eslint-disable */
import * as types from './graphql';
import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 * Learn more about it here: https://the-guild.dev/graphql/codegen/plugins/presets/preset-client#reducing-bundle-size
 */
type Documents = {
    "\n  query BLOCK_HASH_QUERY($offset: BlockOffset) {\n    block(offset: $offset) {\n      height\n      hash\n    }\n  }": typeof types.BlockHashQueryDocument,
    "\n  query TX_ID_QUERY($offset: TransactionOffset!) {\n    transactions(offset: $offset) {\n      id\n      protocolVersion\n      raw\n      hash\n      unshieldedCreatedOutputs {\n        owner\n        intentHash\n        tokenType\n        value\n      }\n      unshieldedSpentOutputs {\n        owner\n        intentHash\n        tokenType\n        value\n      }\n      block {\n        height\n        hash\n        author\n        timestamp\n      }\n      ... on RegularTransaction {\n        identifiers\n        fees {\n          estimatedFees\n          paidFees\n        }\n        transactionResult {\n          status\n          segments {\n            id\n            success\n          }\n        }\n      }\n    }\n  }": typeof types.TxIdQueryDocument,
    "\n  query DEPLOY_TX_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      ... on ContractDeploy {\n        transaction {\n          id\n          protocolVersion\n\t        raw\n          hash\n          contractActions {\n            address\n          }\n          block {\n            height\n            hash\n            author\n            timestamp\n          }\n          unshieldedCreatedOutputs {\n            owner\n            intentHash\n            tokenType\n            value\n          }\n          unshieldedSpentOutputs {\n            owner\n            intentHash\n            tokenType\n            value\n          }\n          ... on RegularTransaction {\n            identifiers\n            fees {\n              estimatedFees\n              paidFees\n            }\n            transactionResult {\n              status\n              segments {\n                id\n                success\n              }\n            }\n          }\n        }\n      }\n      ... on ContractUpdate {\n        transaction {\n          id\n          protocolVersion\n\t        raw\n          hash\n          contractActions {\n            address\n          }\n          block {\n            height\n            hash\n            author\n            timestamp\n          }\n          unshieldedCreatedOutputs {\n            owner\n            intentHash\n            tokenType\n            value\n          }\n          unshieldedSpentOutputs {\n            owner\n            intentHash\n            tokenType\n            value\n          }\n          ... on RegularTransaction {\n            identifiers\n            fees {\n              estimatedFees\n              paidFees\n            }\n            transactionResult {\n              status\n              segments {\n                id\n                success\n              }\n            }\n          }\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          transaction {\n            id\n            protocolVersion\n\t          raw\n            hash\n            contractActions {\n              address\n            }\n            block {\n              height\n              hash\n              author\n              timestamp\n            }\n            unshieldedCreatedOutputs {\n              owner\n              intentHash\n              tokenType\n              value\n            }\n            unshieldedSpentOutputs {\n              owner\n              intentHash\n              tokenType\n              value\n            }\n            ... on RegularTransaction {\n              identifiers\n              fees {\n                estimatedFees\n                paidFees\n              }\n              transactionResult {\n                status\n                segments {\n                  id\n                  success\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }": typeof types.DeployTxQueryDocument,
    "\n  query DEPLOY_CONTRACT_STATE_TX_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      ... on ContractDeploy {\n        state\n      }\n      ... on ContractUpdate {\n        state\n      }\n      ... on ContractCall {\n        deploy {\n          transaction {\n            contractActions {\n              address\n              state\n            }\n          }\n        }\n      }\n    }\n  }": typeof types.DeployContractStateTxQueryDocument,
    "\n  query LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      transaction {\n        block {\n          height\n        }\n      }\n    }\n  }": typeof types.LatestContractTxBlockHeightQueryDocument,
    "\n  subscription TXS_FROM_BLOCK_SUB($offset: BlockOffset) {\n    blocks(offset: $offset) {\n      hash,\n      height,\n      transactions {\n        hash\n        contractActions {\n          state\n          address\n        }\n        ... on RegularTransaction {\n          identifiers\n        }\n      }\n    }\n  }": typeof types.TxsFromBlockSubDocument,
    "\n  query CONTRACT_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {\n    contractAction(address: $address, offset: $offset) {\n      state\n    }\n  }": typeof types.ContractStateQueryDocument,
    "\n  subscription CONTRACT_STATE_SUB($address: HexEncoded!, $offset: BlockOffset) {\n    contractActions(address: $address, offset: $offset) {\n      state\n    }\n  }": typeof types.ContractStateSubDocument,
    "\n  query BOTH_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {\n    contractAction(address: $address, offset: $offset) {\n      state\n      zswapState\n    }\n  }": typeof types.BothStateQueryDocument,
    "\n  query UNSHIELDED_BALANCE_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      ... on ContractDeploy {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractUpdate {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          unshieldedBalances {\n            tokenType\n            amount\n          }\n        }\n      }\n    }\n  }": typeof types.UnshieldedBalanceQueryDocument,
    "\n  query QUERY_UNSHIELDED_BALANCES_WITH_OFFSET($address: HexEncoded!, $offset: ContractActionOffset) {\n    contractAction(address: $address, offset: $offset) {\n      ... on ContractDeploy {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractUpdate {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          unshieldedBalances {\n            tokenType\n            amount\n          }\n        }\n      }\n    }\n  }": typeof types.QueryUnshieldedBalancesWithOffsetDocument,
    "\n  subscription UNSHIELDED_BALANCE_SUB($address: HexEncoded!, $offset: BlockOffset) {\n    contractActions(address: $address, offset: $offset) {\n      ... on ContractDeploy {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractUpdate {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          unshieldedBalances {\n            tokenType\n            amount\n          }\n        }\n      }\n    }\n  }": typeof types.UnshieldedBalanceSubDocument,
};
const documents: Documents = {
    "\n  query BLOCK_HASH_QUERY($offset: BlockOffset) {\n    block(offset: $offset) {\n      height\n      hash\n    }\n  }": types.BlockHashQueryDocument,
    "\n  query TX_ID_QUERY($offset: TransactionOffset!) {\n    transactions(offset: $offset) {\n      id\n      protocolVersion\n      raw\n      hash\n      unshieldedCreatedOutputs {\n        owner\n        intentHash\n        tokenType\n        value\n      }\n      unshieldedSpentOutputs {\n        owner\n        intentHash\n        tokenType\n        value\n      }\n      block {\n        height\n        hash\n        author\n        timestamp\n      }\n      ... on RegularTransaction {\n        identifiers\n        fees {\n          estimatedFees\n          paidFees\n        }\n        transactionResult {\n          status\n          segments {\n            id\n            success\n          }\n        }\n      }\n    }\n  }": types.TxIdQueryDocument,
    "\n  query DEPLOY_TX_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      ... on ContractDeploy {\n        transaction {\n          id\n          protocolVersion\n\t        raw\n          hash\n          contractActions {\n            address\n          }\n          block {\n            height\n            hash\n            author\n            timestamp\n          }\n          unshieldedCreatedOutputs {\n            owner\n            intentHash\n            tokenType\n            value\n          }\n          unshieldedSpentOutputs {\n            owner\n            intentHash\n            tokenType\n            value\n          }\n          ... on RegularTransaction {\n            identifiers\n            fees {\n              estimatedFees\n              paidFees\n            }\n            transactionResult {\n              status\n              segments {\n                id\n                success\n              }\n            }\n          }\n        }\n      }\n      ... on ContractUpdate {\n        transaction {\n          id\n          protocolVersion\n\t        raw\n          hash\n          contractActions {\n            address\n          }\n          block {\n            height\n            hash\n            author\n            timestamp\n          }\n          unshieldedCreatedOutputs {\n            owner\n            intentHash\n            tokenType\n            value\n          }\n          unshieldedSpentOutputs {\n            owner\n            intentHash\n            tokenType\n            value\n          }\n          ... on RegularTransaction {\n            identifiers\n            fees {\n              estimatedFees\n              paidFees\n            }\n            transactionResult {\n              status\n              segments {\n                id\n                success\n              }\n            }\n          }\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          transaction {\n            id\n            protocolVersion\n\t          raw\n            hash\n            contractActions {\n              address\n            }\n            block {\n              height\n              hash\n              author\n              timestamp\n            }\n            unshieldedCreatedOutputs {\n              owner\n              intentHash\n              tokenType\n              value\n            }\n            unshieldedSpentOutputs {\n              owner\n              intentHash\n              tokenType\n              value\n            }\n            ... on RegularTransaction {\n              identifiers\n              fees {\n                estimatedFees\n                paidFees\n              }\n              transactionResult {\n                status\n                segments {\n                  id\n                  success\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }": types.DeployTxQueryDocument,
    "\n  query DEPLOY_CONTRACT_STATE_TX_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      ... on ContractDeploy {\n        state\n      }\n      ... on ContractUpdate {\n        state\n      }\n      ... on ContractCall {\n        deploy {\n          transaction {\n            contractActions {\n              address\n              state\n            }\n          }\n        }\n      }\n    }\n  }": types.DeployContractStateTxQueryDocument,
    "\n  query LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      transaction {\n        block {\n          height\n        }\n      }\n    }\n  }": types.LatestContractTxBlockHeightQueryDocument,
    "\n  subscription TXS_FROM_BLOCK_SUB($offset: BlockOffset) {\n    blocks(offset: $offset) {\n      hash,\n      height,\n      transactions {\n        hash\n        contractActions {\n          state\n          address\n        }\n        ... on RegularTransaction {\n          identifiers\n        }\n      }\n    }\n  }": types.TxsFromBlockSubDocument,
    "\n  query CONTRACT_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {\n    contractAction(address: $address, offset: $offset) {\n      state\n    }\n  }": types.ContractStateQueryDocument,
    "\n  subscription CONTRACT_STATE_SUB($address: HexEncoded!, $offset: BlockOffset) {\n    contractActions(address: $address, offset: $offset) {\n      state\n    }\n  }": types.ContractStateSubDocument,
    "\n  query BOTH_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {\n    contractAction(address: $address, offset: $offset) {\n      state\n      zswapState\n    }\n  }": types.BothStateQueryDocument,
    "\n  query UNSHIELDED_BALANCE_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      ... on ContractDeploy {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractUpdate {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          unshieldedBalances {\n            tokenType\n            amount\n          }\n        }\n      }\n    }\n  }": types.UnshieldedBalanceQueryDocument,
    "\n  query QUERY_UNSHIELDED_BALANCES_WITH_OFFSET($address: HexEncoded!, $offset: ContractActionOffset) {\n    contractAction(address: $address, offset: $offset) {\n      ... on ContractDeploy {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractUpdate {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          unshieldedBalances {\n            tokenType\n            amount\n          }\n        }\n      }\n    }\n  }": types.QueryUnshieldedBalancesWithOffsetDocument,
    "\n  subscription UNSHIELDED_BALANCE_SUB($address: HexEncoded!, $offset: BlockOffset) {\n    contractActions(address: $address, offset: $offset) {\n      ... on ContractDeploy {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractUpdate {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          unshieldedBalances {\n            tokenType\n            amount\n          }\n        }\n      }\n    }\n  }": types.UnshieldedBalanceSubDocument,
};

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = gql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function gql(source: string): unknown;

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query BLOCK_HASH_QUERY($offset: BlockOffset) {\n    block(offset: $offset) {\n      height\n      hash\n    }\n  }"): (typeof documents)["\n  query BLOCK_HASH_QUERY($offset: BlockOffset) {\n    block(offset: $offset) {\n      height\n      hash\n    }\n  }"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query TX_ID_QUERY($offset: TransactionOffset!) {\n    transactions(offset: $offset) {\n      id\n      protocolVersion\n      raw\n      hash\n      unshieldedCreatedOutputs {\n        owner\n        intentHash\n        tokenType\n        value\n      }\n      unshieldedSpentOutputs {\n        owner\n        intentHash\n        tokenType\n        value\n      }\n      block {\n        height\n        hash\n        author\n        timestamp\n      }\n      ... on RegularTransaction {\n        identifiers\n        fees {\n          estimatedFees\n          paidFees\n        }\n        transactionResult {\n          status\n          segments {\n            id\n            success\n          }\n        }\n      }\n    }\n  }"): (typeof documents)["\n  query TX_ID_QUERY($offset: TransactionOffset!) {\n    transactions(offset: $offset) {\n      id\n      protocolVersion\n      raw\n      hash\n      unshieldedCreatedOutputs {\n        owner\n        intentHash\n        tokenType\n        value\n      }\n      unshieldedSpentOutputs {\n        owner\n        intentHash\n        tokenType\n        value\n      }\n      block {\n        height\n        hash\n        author\n        timestamp\n      }\n      ... on RegularTransaction {\n        identifiers\n        fees {\n          estimatedFees\n          paidFees\n        }\n        transactionResult {\n          status\n          segments {\n            id\n            success\n          }\n        }\n      }\n    }\n  }"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query DEPLOY_TX_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      ... on ContractDeploy {\n        transaction {\n          id\n          protocolVersion\n\t        raw\n          hash\n          contractActions {\n            address\n          }\n          block {\n            height\n            hash\n            author\n            timestamp\n          }\n          unshieldedCreatedOutputs {\n            owner\n            intentHash\n            tokenType\n            value\n          }\n          unshieldedSpentOutputs {\n            owner\n            intentHash\n            tokenType\n            value\n          }\n          ... on RegularTransaction {\n            identifiers\n            fees {\n              estimatedFees\n              paidFees\n            }\n            transactionResult {\n              status\n              segments {\n                id\n                success\n              }\n            }\n          }\n        }\n      }\n      ... on ContractUpdate {\n        transaction {\n          id\n          protocolVersion\n\t        raw\n          hash\n          contractActions {\n            address\n          }\n          block {\n            height\n            hash\n            author\n            timestamp\n          }\n          unshieldedCreatedOutputs {\n            owner\n            intentHash\n            tokenType\n            value\n          }\n          unshieldedSpentOutputs {\n            owner\n            intentHash\n            tokenType\n            value\n          }\n          ... on RegularTransaction {\n            identifiers\n            fees {\n              estimatedFees\n              paidFees\n            }\n            transactionResult {\n              status\n              segments {\n                id\n                success\n              }\n            }\n          }\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          transaction {\n            id\n            protocolVersion\n\t          raw\n            hash\n            contractActions {\n              address\n            }\n            block {\n              height\n              hash\n              author\n              timestamp\n            }\n            unshieldedCreatedOutputs {\n              owner\n              intentHash\n              tokenType\n              value\n            }\n            unshieldedSpentOutputs {\n              owner\n              intentHash\n              tokenType\n              value\n            }\n            ... on RegularTransaction {\n              identifiers\n              fees {\n                estimatedFees\n                paidFees\n              }\n              transactionResult {\n                status\n                segments {\n                  id\n                  success\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }"): (typeof documents)["\n  query DEPLOY_TX_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      ... on ContractDeploy {\n        transaction {\n          id\n          protocolVersion\n\t        raw\n          hash\n          contractActions {\n            address\n          }\n          block {\n            height\n            hash\n            author\n            timestamp\n          }\n          unshieldedCreatedOutputs {\n            owner\n            intentHash\n            tokenType\n            value\n          }\n          unshieldedSpentOutputs {\n            owner\n            intentHash\n            tokenType\n            value\n          }\n          ... on RegularTransaction {\n            identifiers\n            fees {\n              estimatedFees\n              paidFees\n            }\n            transactionResult {\n              status\n              segments {\n                id\n                success\n              }\n            }\n          }\n        }\n      }\n      ... on ContractUpdate {\n        transaction {\n          id\n          protocolVersion\n\t        raw\n          hash\n          contractActions {\n            address\n          }\n          block {\n            height\n            hash\n            author\n            timestamp\n          }\n          unshieldedCreatedOutputs {\n            owner\n            intentHash\n            tokenType\n            value\n          }\n          unshieldedSpentOutputs {\n            owner\n            intentHash\n            tokenType\n            value\n          }\n          ... on RegularTransaction {\n            identifiers\n            fees {\n              estimatedFees\n              paidFees\n            }\n            transactionResult {\n              status\n              segments {\n                id\n                success\n              }\n            }\n          }\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          transaction {\n            id\n            protocolVersion\n\t          raw\n            hash\n            contractActions {\n              address\n            }\n            block {\n              height\n              hash\n              author\n              timestamp\n            }\n            unshieldedCreatedOutputs {\n              owner\n              intentHash\n              tokenType\n              value\n            }\n            unshieldedSpentOutputs {\n              owner\n              intentHash\n              tokenType\n              value\n            }\n            ... on RegularTransaction {\n              identifiers\n              fees {\n                estimatedFees\n                paidFees\n              }\n              transactionResult {\n                status\n                segments {\n                  id\n                  success\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query DEPLOY_CONTRACT_STATE_TX_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      ... on ContractDeploy {\n        state\n      }\n      ... on ContractUpdate {\n        state\n      }\n      ... on ContractCall {\n        deploy {\n          transaction {\n            contractActions {\n              address\n              state\n            }\n          }\n        }\n      }\n    }\n  }"): (typeof documents)["\n  query DEPLOY_CONTRACT_STATE_TX_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      ... on ContractDeploy {\n        state\n      }\n      ... on ContractUpdate {\n        state\n      }\n      ... on ContractCall {\n        deploy {\n          transaction {\n            contractActions {\n              address\n              state\n            }\n          }\n        }\n      }\n    }\n  }"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      transaction {\n        block {\n          height\n        }\n      }\n    }\n  }"): (typeof documents)["\n  query LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      transaction {\n        block {\n          height\n        }\n      }\n    }\n  }"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  subscription TXS_FROM_BLOCK_SUB($offset: BlockOffset) {\n    blocks(offset: $offset) {\n      hash,\n      height,\n      transactions {\n        hash\n        contractActions {\n          state\n          address\n        }\n        ... on RegularTransaction {\n          identifiers\n        }\n      }\n    }\n  }"): (typeof documents)["\n  subscription TXS_FROM_BLOCK_SUB($offset: BlockOffset) {\n    blocks(offset: $offset) {\n      hash,\n      height,\n      transactions {\n        hash\n        contractActions {\n          state\n          address\n        }\n        ... on RegularTransaction {\n          identifiers\n        }\n      }\n    }\n  }"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query CONTRACT_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {\n    contractAction(address: $address, offset: $offset) {\n      state\n    }\n  }"): (typeof documents)["\n  query CONTRACT_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {\n    contractAction(address: $address, offset: $offset) {\n      state\n    }\n  }"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  subscription CONTRACT_STATE_SUB($address: HexEncoded!, $offset: BlockOffset) {\n    contractActions(address: $address, offset: $offset) {\n      state\n    }\n  }"): (typeof documents)["\n  subscription CONTRACT_STATE_SUB($address: HexEncoded!, $offset: BlockOffset) {\n    contractActions(address: $address, offset: $offset) {\n      state\n    }\n  }"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query BOTH_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {\n    contractAction(address: $address, offset: $offset) {\n      state\n      zswapState\n    }\n  }"): (typeof documents)["\n  query BOTH_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {\n    contractAction(address: $address, offset: $offset) {\n      state\n      zswapState\n    }\n  }"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query UNSHIELDED_BALANCE_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      ... on ContractDeploy {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractUpdate {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          unshieldedBalances {\n            tokenType\n            amount\n          }\n        }\n      }\n    }\n  }"): (typeof documents)["\n  query UNSHIELDED_BALANCE_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      ... on ContractDeploy {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractUpdate {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          unshieldedBalances {\n            tokenType\n            amount\n          }\n        }\n      }\n    }\n  }"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  query QUERY_UNSHIELDED_BALANCES_WITH_OFFSET($address: HexEncoded!, $offset: ContractActionOffset) {\n    contractAction(address: $address, offset: $offset) {\n      ... on ContractDeploy {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractUpdate {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          unshieldedBalances {\n            tokenType\n            amount\n          }\n        }\n      }\n    }\n  }"): (typeof documents)["\n  query QUERY_UNSHIELDED_BALANCES_WITH_OFFSET($address: HexEncoded!, $offset: ContractActionOffset) {\n    contractAction(address: $address, offset: $offset) {\n      ... on ContractDeploy {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractUpdate {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          unshieldedBalances {\n            tokenType\n            amount\n          }\n        }\n      }\n    }\n  }"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n  subscription UNSHIELDED_BALANCE_SUB($address: HexEncoded!, $offset: BlockOffset) {\n    contractActions(address: $address, offset: $offset) {\n      ... on ContractDeploy {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractUpdate {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          unshieldedBalances {\n            tokenType\n            amount\n          }\n        }\n      }\n    }\n  }"): (typeof documents)["\n  subscription UNSHIELDED_BALANCE_SUB($address: HexEncoded!, $offset: BlockOffset) {\n    contractActions(address: $address, offset: $offset) {\n      ... on ContractDeploy {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractUpdate {\n        unshieldedBalances {\n          tokenType\n          amount\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          unshieldedBalances {\n            tokenType\n            amount\n          }\n        }\n      }\n    }\n  }"];

export function gql(source: string) {
  return (documents as any)[source] ?? {};
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;

================
File: packages/indexer-public-data-provider/src/gen/index.ts
================
export * from "./fragment-masking";
export * from "./gql";

================
File: packages/indexer-public-data-provider/src/test/indexer-public-data-provider-spied.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { vi } from 'vitest';

// Dynamically load the package to be able to mock its dependencies.
const mockLinkHttp = await import('@apollo/client/link/http/http.cjs');
const mockGraphqlWS = await import('graphql-ws');
const mockApolloCore = await import('@apollo/client/core/core.cjs');

// Define the mocks.
const mockCreateHttpLink = vi.fn();
const mockFrom = vi.fn();
const mockCreateClient = vi.fn();

// Mock the dependencies.
vi.doMock('graphql-ws', () => ({
  __esModule: true,
  ...mockGraphqlWS,
  createClient: mockCreateClient
}));

vi.doMock('@apollo/client/link/http/http.cjs', () => ({
  __esModule: true,
  ...mockLinkHttp,
  createHttpLink: mockCreateHttpLink
}));

vi.doMock('@apollo/client/core/core.cjs', () => ({
  __esModule: true,
  ...mockApolloCore,
  from: mockFrom
}));

// TODO: Rework the following tests. They're currently failing and will require some rework. Essentially it
// looks like the mock HTTP link will have to return some data because the internals of Apollo is now
// reading it.
describe.skip('indexerPublicDataProvider', () => {
  // Define the URLs and origins.
  const queryURL = 'http://localhost:4000/api/v1/graphql';
  const subscriptionURL = 'ws://localhost:4000/api/v1/graphql/ws';
  const queryOrigin = 'http://localhost:4000';
  const subscriptionWithWs = 'ws://localhost:4000/ws'; // this is how dapp connector provides indexerWsUri

  test('indexerPublicDataProvider should create a PublicDataProvider instance using fully qualified urls', async () => {
    // Dynamically load the function so jest can mock its dependencies.
    const { indexerPublicDataProvider } = await import('../indexer-public-data-provider');
    const provider = indexerPublicDataProvider(queryURL, subscriptionURL);
    expect(mockCreateHttpLink).toHaveBeenCalledWith(expect.objectContaining({ uri: queryURL }));
    expect(mockCreateClient).toHaveBeenCalledWith(expect.objectContaining({ url: subscriptionURL }));
    expect(provider).toBeDefined();
  });

  test('indexerPublicDataProvider should create a PublicDataProvider instance using origin urls with ws', async () => {
    // Dynamically load the function so jest can mock its dependencies.
    const { indexerPublicDataProvider } = await import('../indexer-public-data-provider');
    const provider = indexerPublicDataProvider(queryOrigin, subscriptionWithWs);
    expect(mockCreateHttpLink).toHaveBeenCalledWith(expect.objectContaining({ uri: queryURL }));
    expect(mockCreateClient).toHaveBeenCalledWith(expect.objectContaining({ url: subscriptionURL }));
    expect(provider).toBeDefined();
  });
});

================
File: packages/indexer-public-data-provider/src/test/indexer-public-data-provider-unshielded-balances.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ContractAddress } from '@midnight-ntwrk/ledger-v6';
import type { ContractStateObservableConfig } from '@midnight-ntwrk/midnight-js-types';
import { describe, expect, test } from 'vitest';

import { indexerPublicDataProvider } from '../indexer-public-data-provider';

describe('Unshielded Balances Integration', () => {
  const queryURL = 'http://localhost:4000/api/v1/graphql';
  const subscriptionURL = 'ws://localhost:4000/api/v1/graphql/ws';
  const mockContractAddress = '1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef' as ContractAddress;

  describe('queryUnshieldedBalances', () => {
    test('should be a function that accepts contract address and optional config', () => {
      const provider = indexerPublicDataProvider(queryURL, subscriptionURL);

      expect(typeof provider.queryUnshieldedBalances).toBe('function');
      expect(provider.queryUnshieldedBalances.length).toBe(2); // expects 2 parameters
    });

    test('should return a Promise for unshielded balances', () => {
      const provider = indexerPublicDataProvider(queryURL, subscriptionURL);

      const result = provider.queryUnshieldedBalances(mockContractAddress);

      expect(result).toBeInstanceOf(Promise);

      // eslint-disable-next-line @typescript-eslint/no-empty-function
      result.catch(() => {});
    });

    test('should accept blockHeight configuration', () => {
      const provider = indexerPublicDataProvider(queryURL, subscriptionURL);
      const config = {
        type: 'blockHeight' as const,
        blockHeight: 1000
      };

      const result = provider.queryUnshieldedBalances(mockContractAddress, config);

      expect(result).toBeInstanceOf(Promise);

      // eslint-disable-next-line @typescript-eslint/no-empty-function
      result.catch(() => {});
    });

    test('should accept blockHash configuration', () => {
      const provider = indexerPublicDataProvider(queryURL, subscriptionURL);
      const config = {
        type: 'blockHash' as const,
        blockHash: '0x1234567890abcdef'
      };

      const result = provider.queryUnshieldedBalances(mockContractAddress, config);

      expect(result).toBeInstanceOf(Promise);

      // eslint-disable-next-line @typescript-eslint/no-empty-function
      result.catch(() => {});
    });

    test('should validate contract address format', () => {
      const provider = indexerPublicDataProvider(queryURL, subscriptionURL);
      const invalidAddress = 'invalid-address' as ContractAddress;

      expect(() => {
        provider.queryUnshieldedBalances(invalidAddress);
      }).toThrow();
    });
  });

  describe('watchForUnshieldedBalances', () => {
    test('should be a function that accepts contract address', () => {
      const provider = indexerPublicDataProvider(queryURL, subscriptionURL);

      expect(typeof provider.watchForUnshieldedBalances).toBe('function');
      expect(provider.watchForUnshieldedBalances.length).toBe(1); // expects 1 parameter
    });

    test('should return a Promise that eventually times out in test environment', () => {
      const provider = indexerPublicDataProvider(queryURL, subscriptionURL);

      const result = provider.watchForUnshieldedBalances(mockContractAddress);

      expect(result).toBeInstanceOf(Promise);

      // eslint-disable-next-line @typescript-eslint/no-empty-function
      result.catch(() => {});
    });
  });

  describe('unshieldedBalancesObservable', () => {
    test('should be a function that accepts contract address and config', () => {
      const provider = indexerPublicDataProvider(queryURL, subscriptionURL);

      expect(typeof provider.unshieldedBalancesObservable).toBe('function');
      expect(provider.unshieldedBalancesObservable.length).toBe(2); // expects 2 parameters
    });

    test('should throw error for txId configuration before address validation', () => {
      const provider = indexerPublicDataProvider(queryURL, subscriptionURL);
      const config: ContractStateObservableConfig = {
        type: 'txId',
        txId: 'test-tx-id'
      };

      expect(() => {
        provider.unshieldedBalancesObservable(mockContractAddress, config);
      }).toThrow('txId configuration not supported for unshielded balances observable');
    });

    test('should accept latest configuration', () => {
      const provider = indexerPublicDataProvider(queryURL, subscriptionURL);
      const config: ContractStateObservableConfig = { type: 'latest' };

      const result = provider.unshieldedBalancesObservable(mockContractAddress, config);

      expect(result).toBeDefined();
      expect(typeof result.subscribe).toBe('function');
    });

    test('should accept all configuration', () => {
      const provider = indexerPublicDataProvider(queryURL, subscriptionURL);
      const config: ContractStateObservableConfig = { type: 'all' };

      const result = provider.unshieldedBalancesObservable(mockContractAddress, config);

      expect(result).toBeDefined();
      expect(typeof result.subscribe).toBe('function');
    });

    test('should accept blockHeight configuration', () => {
      const provider = indexerPublicDataProvider(queryURL, subscriptionURL);
      const config: ContractStateObservableConfig = {
        type: 'blockHeight',
        blockHeight: 1000,
        inclusive: true
      };

      const result = provider.unshieldedBalancesObservable(mockContractAddress, config);

      expect(result).toBeDefined();
      expect(typeof result.subscribe).toBe('function');
    });

    test('should accept blockHash configuration', () => {
      const provider = indexerPublicDataProvider(queryURL, subscriptionURL);
      const config: ContractStateObservableConfig = {
        type: 'blockHash',
        blockHash: '0x1234567890abcdef',
        inclusive: false
      };

      const result = provider.unshieldedBalancesObservable(mockContractAddress, config);

      expect(result).toBeDefined();
      expect(typeof result.subscribe).toBe('function');
    });

    test('should use latest as default configuration', () => {
      const provider = indexerPublicDataProvider(queryURL, subscriptionURL);

      const result = provider.unshieldedBalancesObservable(mockContractAddress, {} as ContractStateObservableConfig);

      expect(result).toBeDefined();
      expect(typeof result.subscribe).toBe('function');
    });

    test('should validate contract address format', () => {
      const provider = indexerPublicDataProvider(queryURL, subscriptionURL);
      const invalidAddress = 'invalid-address' as ContractAddress;

      expect(() => {
        provider.unshieldedBalancesObservable(invalidAddress, {} as ContractStateObservableConfig);
      }).toThrow();
    });
  });
});

================
File: packages/indexer-public-data-provider/src/test/indexer-public-data-provider.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { indexerPublicDataProvider } from '../indexer-public-data-provider';

describe('indexerPublicDataProvider', () => {
  const queryURL = 'http://localhost:4000/api/v1/graphql';
  const subscriptionURL = 'ws://localhost:4000/api/v1/graphql/ws';
  const queryOrigin = 'http://localhost:4000';
  const subscriptionOriginWithWs = 'ws://localhost:4000/ws'; // this is how dapp connector provides indexerWsUri

  test('indexerPublicDataProvider should throw an error for invalid query URL', () => {
    expect(() => {
      indexerPublicDataProvider('invalid-url', subscriptionURL);
    }).toThrow('Invalid URL');
  });

  test('indexerPublicDataProvider should throw an error for invalid subscription URL', () => {
    expect(() => {
      indexerPublicDataProvider(queryURL, 'invalid-url');
    }).toThrow('Invalid URL');
  });

  test('indexerPublicDataProvider should throw an error for invalid query protocol', () => {
    expect(() => {
      indexerPublicDataProvider(subscriptionURL, subscriptionURL);
    }).toThrow("Invalid protocol scheme: 'ws:'. Allowable schemes are one of: http:,https:");
  });

  test('indexerPublicDataProvider should throw an error for invalid subscription protocol', () => {
    expect(() => {
      indexerPublicDataProvider(queryURL, queryURL);
    }).toThrow("Invalid protocol scheme: 'http:'. Allowable schemes are one of: ws:,wss:");
  });

  test('indexerPublicDataProvider should create a PublicDataProvider instance for subscriptionWithWs', () => {
    const provider = indexerPublicDataProvider(queryOrigin, subscriptionOriginWithWs);
    expect(provider).toBeDefined();
  });

  test('indexerPublicDataProvider should use the provided WebSocket implementation', () => {
    const provider = indexerPublicDataProvider(queryURL, subscriptionURL);
    expect(provider).toBeDefined();
  });
});

================
File: packages/indexer-public-data-provider/src/errors.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { GraphQLFormattedError } from 'graphql';

/**
 * An error describing the causes of error that occurred during server-side execution of
 * a query against the Indexer.
 */
export class IndexerFormattedError extends Error {
  /**
   * @param cause An array of GraphQL errors that occurred during the server-side execution.
   */
  constructor(public readonly cause: readonly GraphQLFormattedError[]) {
    super(`Indexer GraphQL error(s):\n${cause.reduce((acc, c, idx) => `${idx + 1}. ${c.message}:\n\t${acc}`, '')}`);
  }
}

================
File: packages/indexer-public-data-provider/src/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * from './errors';
export * from './indexer-public-data-provider';

================
File: packages/indexer-public-data-provider/src/query-definitions.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { gql } from './gen';

export const BLOCK_QUERY = gql(
  `
  query BLOCK_HASH_QUERY($offset: BlockOffset) {
    block(offset: $offset) {
      height
      hash
    }
  }`
);

export const TX_ID_QUERY = gql(
  `
  query TX_ID_QUERY($offset: TransactionOffset!) {
    transactions(offset: $offset) {
      id
      protocolVersion
      raw
      hash
      unshieldedCreatedOutputs {
        owner
        intentHash
        tokenType
        value
      }
      unshieldedSpentOutputs {
        owner
        intentHash
        tokenType
        value
      }
      block {
        height
        hash
        author
        timestamp
      }
      ... on RegularTransaction {
        identifiers
        fees {
          estimatedFees
          paidFees
        }
        transactionResult {
          status
          segments {
            id
            success
          }
        }
      }
    }
  }`
);

export const DEPLOY_TX_QUERY = gql(
  `
  query DEPLOY_TX_QUERY($address: HexEncoded!) {
    contractAction(address: $address) {
      ... on ContractDeploy {
        transaction {
          id
          protocolVersion
	        raw
          hash
          contractActions {
            address
          }
          block {
            height
            hash
            author
            timestamp
          }
          unshieldedCreatedOutputs {
            owner
            intentHash
            tokenType
            value
          }
          unshieldedSpentOutputs {
            owner
            intentHash
            tokenType
            value
          }
          ... on RegularTransaction {
            identifiers
            fees {
              estimatedFees
              paidFees
            }
            transactionResult {
              status
              segments {
                id
                success
              }
            }
          }
        }
      }
      ... on ContractUpdate {
        transaction {
          id
          protocolVersion
	        raw
          hash
          contractActions {
            address
          }
          block {
            height
            hash
            author
            timestamp
          }
          unshieldedCreatedOutputs {
            owner
            intentHash
            tokenType
            value
          }
          unshieldedSpentOutputs {
            owner
            intentHash
            tokenType
            value
          }
          ... on RegularTransaction {
            identifiers
            fees {
              estimatedFees
              paidFees
            }
            transactionResult {
              status
              segments {
                id
                success
              }
            }
          }
        }
      }
      ... on ContractCall {
        deploy {
          transaction {
            id
            protocolVersion
	          raw
            hash
            contractActions {
              address
            }
            block {
              height
              hash
              author
              timestamp
            }
            unshieldedCreatedOutputs {
              owner
              intentHash
              tokenType
              value
            }
            unshieldedSpentOutputs {
              owner
              intentHash
              tokenType
              value
            }
            ... on RegularTransaction {
              identifiers
              fees {
                estimatedFees
                paidFees
              }
              transactionResult {
                status
                segments {
                  id
                  success
                }
              }
            }
          }
        }
      }
    }
  }`
);

export const DEPLOY_CONTRACT_STATE_TX_QUERY = gql(
  `
  query DEPLOY_CONTRACT_STATE_TX_QUERY($address: HexEncoded!) {
    contractAction(address: $address) {
      ... on ContractDeploy {
        state
      }
      ... on ContractUpdate {
        state
      }
      ... on ContractCall {
        deploy {
          transaction {
            contractActions {
              address
              state
            }
          }
        }
      }
    }
  }`
);


export const LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY = gql(
  `
  query LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY($address: HexEncoded!) {
    contractAction(address: $address) {
      transaction {
        block {
          height
        }
      }
    }
  }`
);

export const TXS_FROM_BLOCK_SUB = gql(
  `
  subscription TXS_FROM_BLOCK_SUB($offset: BlockOffset) {
    blocks(offset: $offset) {
      hash,
      height,
      transactions {
        hash
        contractActions {
          state
          address
        }
        ... on RegularTransaction {
          identifiers
        }
      }
    }
  }`
);

export const CONTRACT_STATE_QUERY = gql(
  `
  query CONTRACT_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {
    contractAction(address: $address, offset: $offset) {
      state
    }
  }`
);

export const CONTRACT_STATE_SUB = gql(
  `
  subscription CONTRACT_STATE_SUB($address: HexEncoded!, $offset: BlockOffset) {
    contractActions(address: $address, offset: $offset) {
      state
    }
  }`
);

export const CONTRACT_AND_ZSWAP_STATE_QUERY = gql(
  `
  query BOTH_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {
    contractAction(address: $address, offset: $offset) {
      state
      zswapState
    }
  }`
);

export const UNSHIELDED_BALANCE_QUERY = gql(
  `
  query UNSHIELDED_BALANCE_QUERY($address: HexEncoded!) {
    contractAction(address: $address) {
      ... on ContractDeploy {
        unshieldedBalances {
          tokenType
          amount
        }
      }
      ... on ContractUpdate {
        unshieldedBalances {
          tokenType
          amount
        }
      }
      ... on ContractCall {
        deploy {
          unshieldedBalances {
            tokenType
            amount
          }
        }
      }
    }
  }`
);

export const QUERY_UNSHIELDED_BALANCES_WITH_OFFSET = gql(
  `
  query QUERY_UNSHIELDED_BALANCES_WITH_OFFSET($address: HexEncoded!, $offset: ContractActionOffset) {
    contractAction(address: $address, offset: $offset) {
      ... on ContractDeploy {
        unshieldedBalances {
          tokenType
          amount
        }
      }
      ... on ContractUpdate {
        unshieldedBalances {
          tokenType
          amount
        }
      }
      ... on ContractCall {
        deploy {
          unshieldedBalances {
            tokenType
            amount
          }
        }
      }
    }
  }`
);

export const UNSHIELDED_BALANCE_SUB = gql(
  `
  subscription UNSHIELDED_BALANCE_SUB($address: HexEncoded!, $offset: BlockOffset) {
    contractActions(address: $address, offset: $offset) {
      ... on ContractDeploy {
        unshieldedBalances {
          tokenType
          amount
        }
      }
      ... on ContractUpdate {
        unshieldedBalances {
          tokenType
          amount
        }
      }
      ... on ContractCall {
        deploy {
          unshieldedBalances {
            tokenType
            amount
          }
        }
      }
    }
  }`
);

================
File: packages/indexer-public-data-provider/codegen.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { CodegenConfig } from '@graphql-codegen/cli';

const config: CodegenConfig = {
  generates: {
    './src/gen/': {
      documents: ['./src/**/*.ts'],
      schema: './schema.graphql',
      preset: 'client',
      config: {
        avoidOptionals: true,
        skipTypename: true,
        skipTypeNameForRoot: true,
        enumsAsTypes: true,
        futureProofEnums: true,
        immutableTypes: true,
        useTypeImports: true,
        strictScalars: true,
        scalars: {
          BigInt: 'number',
          SessionId: 'string',
          WalletLocalState: 'string',
          Unit: 'null',
          Instant: 'number',
          HexEncoded: 'string',
          ViewingKey: 'string',
          UnshieldedAddress: 'string'
        },
        namingConvention: {
          transformUnderscore: true
        }
      },
      presetConfig: {
        gqlTagName: 'gql'
      },
      hooks: { afterAllFileWrite: ['prettier --write'] }
    }
  }
};

export default config;

================
File: packages/indexer-public-data-provider/README.md
================
# What is this?
An implementation of a public data provider based on the Midnight Pub-sub indexer.  

This package was created for the [Midnight network](https://midnight.network).

Please visit the [Midnight Developer Hub](https://midnight.network/developer-hub) to learn more.

# Use only in Midnight test environments
Image exclusively for Midnight test environments use.  

# Agree to Terms
By downloading and using this image, you agree to [Midnights Terms and Conditions](https://midnight.network/static/terms.pdf), which includes the [Privacy Policy](https://midnight.network/static/privacy-policy.pdf).

# License
The software provided herein is licensed under the [Apache License V2.0](http://www.apache.org/licenses/LICENSE-2.0).

================
File: packages/indexer-public-data-provider/rollup.config.mjs
================
import { createRollupConfig } from '../../build-tools/rollup.config.factory.mjs';
import packageJson from './package.json' with { type: 'json' };

export default createRollupConfig(packageJson);

================
File: packages/indexer-public-data-provider/schema.graphql
================
"""
A block with its relevant data.
"""
type Block {
  """
  The block hash.
  """
  hash: HexEncoded!
  """
  The block height.
  """
  height: Int!
  """
  The protocol version.
  """
  protocolVersion: Int!
  """
  The UNIX timestamp.
  """
  timestamp: Int!
  """
  The hex-encoded block author.
  """
  author: HexEncoded
  """
  The parent of this block.
  """
  parent: Block
  """
  The transactions within this block.
  """
  transactions: [Transaction!]!
  """
  The hex-encoded ledger parameters for this block.
  """
  ledgerParameters: HexEncoded!
}

"""
Either a block hash or a block height.
"""
input BlockOffset @oneOf {
  """
  A hex-encoded block hash.
  """
  hash: HexEncoded
  """
  A block height.
  """
  height: Int
}

type CollapsedMerkleTree {
  """
  The zswap state start index.
  """
  startIndex: Int!
  """
  The zswap state end index.
  """
  endIndex: Int!
  """
  The hex-encoded value.
  """
  update: HexEncoded!
  """
  The protocol version.
  """
  protocolVersion: Int!
}

"""
A contract action.
"""
interface ContractAction {
  address: HexEncoded!
  state: HexEncoded!
  zswapState: HexEncoded!
  transaction: Transaction!
  unshieldedBalances: [ContractBalance!]!
}

"""
Either a block offset or a transaction offset.
"""
input ContractActionOffset @oneOf {
  """
  Either a block hash or a block height.
  """
  blockOffset: BlockOffset
  """
  Either a transaction hash or a transaction identifier.
  """
  transactionOffset: TransactionOffset
}

"""
Represents a token balance held by a contract.
This type is exposed through the GraphQL API to allow clients to query
unshielded token balances for any contract action (Deploy, Call, Update).
"""
type ContractBalance {
  """
  Hex-encoded token type identifier.
  """
  tokenType: HexEncoded!
  """
  Balance amount as string to support larger integer values (up to 16 bytes).
  """
  amount: String!
}

"""
A contract call.
"""
type ContractCall implements ContractAction {
  """
  The hex-encoded serialized address.
  """
  address: HexEncoded!
  """
  The hex-encoded serialized state.
  """
  state: HexEncoded!
  """
  The hex-encoded serialized contract-specific zswap state.
  """
  zswapState: HexEncoded!
  """
  The entry point.
  """
  entryPoint: String!
  """
  Transaction for this contract call.
  """
  transaction: Transaction!
  """
  Contract deploy for this contract call.
  """
  deploy: ContractDeploy!
  """
  Unshielded token balances held by this contract.
  """
  unshieldedBalances: [ContractBalance!]!
}

"""
A contract deployment.
"""
type ContractDeploy implements ContractAction {
  """
  The hex-encoded serialized address.
  """
  address: HexEncoded!
  """
  The hex-encoded serialized state.
  """
  state: HexEncoded!
  """
  The hex-encoded serialized contract-specific zswap state.
  """
  zswapState: HexEncoded!
  """
  Transaction for this contract deploy.
  """
  transaction: Transaction!
  """
  Unshielded token balances held by this contract.
  """
  unshieldedBalances: [ContractBalance!]!
}

"""
A contract update.
"""
type ContractUpdate implements ContractAction {
  """
  The hex-encoded serialized address.
  """
  address: HexEncoded!
  """
  The hex-encoded serialized state.
  """
  state: HexEncoded!
  """
  The hex-encoded serialized contract-specific zswap state.
  """
  zswapState: HexEncoded!
  """
  Transaction for this contract update.
  """
  transaction: Transaction!
  """
  Unshielded token balances held by this contract after the update.
  """
  unshieldedBalances: [ContractBalance!]!
}

type DustGenerationDtimeUpdate implements DustLedgerEvent {
  """
  The ID of this dust ledger event.
  """
  id: Int!
  """
  The hex-encoded serialized event.
  """
  raw: HexEncoded!
  """
  The maximum ID of all dust ledger events.
  """
  maxId: Int!
}

"""
DUST generation status for a specific Cardano stake key.
"""
type DustGenerationStatus {
  """
  The hex-encoded Cardano stake key.
  """
  cardanoStakeKey: HexEncoded!
  """
  The hex-encoded associated DUST address if registered.
  """
  dustAddress: HexEncoded
  """
  Whether this stake key is registered.
  """
  registered: Boolean!
  """
  NIGHT balance backing generation.
  """
  nightBalance: String!
  """
  Generation rate in Specks per second.
  """
  generationRate: String!
  """
  Current DUST capacity.
  """
  currentCapacity: String!
}

type DustInitialUtxo implements DustLedgerEvent {
  """
  The ID of this dust ledger event.
  """
  id: Int!
  """
  The hex-encoded serialized event.
  """
  raw: HexEncoded!
  """
  The maximum ID of all dust ledger events.
  """
  maxId: Int!
  """
  The dust output.
  """
  output: DustOutput!
}

"""
A dust related ledger event.
"""
interface DustLedgerEvent {
  id: Int!
  raw: HexEncoded!
  maxId: Int!
}

"""
A dust output.
"""
type DustOutput {
  """
  The hex-encoded 32-byte nonce.
  """
  nonce: HexEncoded!
}

type DustSpendProcessed implements DustLedgerEvent {
  """
  The ID of this dust ledger event.
  """
  id: Int!
  """
  The hex-encoded serialized event.
  """
  raw: HexEncoded!
  """
  The maximum ID of all dust ledger events.
  """
  maxId: Int!
}

scalar HexEncoded

type Mutation {
  """
  Connect the wallet with the given viewing key and return a session ID.
  """
  connect(viewingKey: ViewingKey!): HexEncoded!
  """
  Disconnect the wallet with the given session ID.
  """
  disconnect(sessionId: HexEncoded!): Unit!
}

type ParamChange implements DustLedgerEvent {
  """
  The ID of this dust ledger event.
  """
  id: Int!
  """
  The hex-encoded serialized event.
  """
  raw: HexEncoded!
  """
  The maximum ID of all dust ledger events.
  """
  maxId: Int!
}

type Query {
  """
  Find a block for the given optional offset; if not present, the latest block is returned.
  """
  block(offset: BlockOffset): Block
  """
  Find transactions for the given offset.
  """
  transactions(offset: TransactionOffset!): [Transaction!]!
  """
  Find a contract action for the given address and optional offset.
  """
  contractAction(address: HexEncoded!, offset: ContractActionOffset): ContractAction
  """
  Get DUST generation status for specific Cardano stake keys.
  """
  dustGenerationStatus(cardanoStakeKeys: [HexEncoded!]!): [DustGenerationStatus!]!
}

"""
A regular Midnight transaction.
"""
type RegularTransaction implements Transaction {
  """
  The transaction ID.
  """
  id: Int!
  """
  The hex-encoded transaction hash.
  """
  hash: HexEncoded!
  """
  The protocol version.
  """
  protocolVersion: Int!
  """
  The hex-encoded serialized transaction content.
  """
  raw: HexEncoded!
  """
  The result of applying this transaction to the ledger state.
  """
  transactionResult: TransactionResult!
  """
  The hex-encoded serialized transaction identifiers.
  """
  identifiers: [HexEncoded!]!
  """
  The hex-encoded serialized merkle-tree root.
  """
  merkleTreeRoot: HexEncoded!
  """
  The zswap state start index.
  """
  startIndex: Int!
  """
  The zswap state end index.
  """
  endIndex: Int!
  """
  Fee information for this transaction.
  """
  fees: TransactionFees!
  """
  The block for this transaction.
  """
  block: Block!
  """
  The contract actions for this transaction.
  """
  contractActions: [ContractAction!]!
  """
  Unshielded UTXOs created by this transaction.
  """
  unshieldedCreatedOutputs: [UnshieldedUtxo!]!
  """
  Unshielded UTXOs spent (consumed) by this transaction.
  """
  unshieldedSpentOutputs: [UnshieldedUtxo!]!
  """
  Zswap ledger events of this transaction.
  """
  zswapLedgerEvents: [ZswapLedgerEvent!]!
  """
  Dust ledger events of this transaction.
  """
  dustLedgerEvents: [DustLedgerEvent!]!
}

"""
A transaction relevant for the subscribing wallet and an optional collapsed merkle tree.
"""
type RelevantTransaction {
  """
  A transaction relevant for the subscribing wallet.
  """
  transaction: RegularTransaction!
  """
  An optional collapsed merkle tree.
  """
  collapsedMerkleTree: CollapsedMerkleTree
}

"""
One of many segments for a partially successful transaction result showing success for some
segment.
"""
type Segment {
  """
  Segment ID.
  """
  id: Int!
  """
  Successful or not.
  """
  success: Boolean!
}

"""
An event of the shielded transactions subscription.
"""
union ShieldedTransactionsEvent = RelevantTransaction | ShieldedTransactionsProgress

"""
Information about the shielded transactions indexing progress.
"""
type ShieldedTransactionsProgress {
  """
  The highest zswap state end index (see `endIndex` of `Transaction`) of all transactions. It
  represents the known state of the blockchain. A value of zero (completely unlikely) means
  that no shielded transactions have been indexed yet.
  """
  highestEndIndex: Int!
  """
  The highest zswap state end index (see `endIndex` of `Transaction`) of all transactions
  checked for relevance. Initially less than and eventually (when some wallet has been fully
  indexed) equal to `highest_end_index`. A value of zero (very unlikely) means that no wallet
  has subscribed before and indexing for the subscribing wallet has not yet started.
  """
  highestCheckedEndIndex: Int!
  """
  The highest zswap state end index (see `endIndex` of `Transaction`) of all relevant
  transactions for the subscribing wallet. Usually less than `highest_checked_end_index`
  unless the latest checked transaction is relevant for the subscribing wallet. A value of
  zero means that no relevant transactions have been indexed for the subscribing wallet.
  """
  highestRelevantEndIndex: Int!
}

type Subscription {
  """
  Subscribe to blocks starting at the given offset or at the latest block if the offset is
  omitted.
  """
  blocks(offset: BlockOffset): Block!
  """
  Subscribe to contract actions with the given address starting at the given offset or at the
  latest block if the offset is omitted.
  """
  contractActions(address: HexEncoded!, offset: BlockOffset): ContractAction!
  """
  Subscribe to dust ledger events starting at the given ID or at the very start if omitted.
  """
  dustLedgerEvents(id: Int): DustLedgerEvent!
  """
  Subscribe to shielded transaction events for the given session ID starting at the given
  index or at zero if omitted.
  """
  shieldedTransactions(sessionId: HexEncoded!, index: Int): ShieldedTransactionsEvent!
  """
  Subscribe unshielded transaction events for the given address and the given transaction ID
  or zero if omitted.
  """
  unshieldedTransactions(address: UnshieldedAddress!, transactionId: Int): UnshieldedTransactionsEvent!
  """
  Subscribe to zswap ledger events starting at the given ID or at the very start if omitted.
  """
  zswapLedgerEvents(id: Int): ZswapLedgerEvent!
}

"""
A system Midnight transaction.
"""
type SystemTransaction implements Transaction {
  """
  The transaction ID.
  """
  id: Int!
  """
  The hex-encoded transaction hash.
  """
  hash: HexEncoded!
  """
  The protocol version.
  """
  protocolVersion: Int!
  """
  The hex-encoded serialized transaction content.
  """
  raw: HexEncoded!
  """
  The block for this transaction.
  """
  block: Block!
  """
  The contract actions for this transaction.
  """
  contractActions: [ContractAction!]!
  """
  Unshielded UTXOs created by this transaction.
  """
  unshieldedCreatedOutputs: [UnshieldedUtxo!]!
  """
  Unshielded UTXOs spent (consumed) by this transaction.
  """
  unshieldedSpentOutputs: [UnshieldedUtxo!]!
  """
  Zswap ledger events of this transaction.
  """
  zswapLedgerEvents: [ZswapLedgerEvent!]!
  """
  Dust ledger events of this transaction.
  """
  dustLedgerEvents: [DustLedgerEvent!]!
}

"""
A Midnight transaction.
"""
interface Transaction {
  id: Int!
  hash: HexEncoded!
  protocolVersion: Int!
  raw: HexEncoded!
  block: Block!
  contractActions: [ContractAction!]!
  unshieldedCreatedOutputs: [UnshieldedUtxo!]!
  unshieldedSpentOutputs: [UnshieldedUtxo!]!
  zswapLedgerEvents: [ZswapLedgerEvent!]!
  dustLedgerEvents: [DustLedgerEvent!]!
}

"""
Fees information for a transaction, including both paid and estimated fees.
"""
type TransactionFees {
  """
  The actual fees paid for this transaction in DUST.
  """
  paidFees: String!
  """
  The estimated fees that was calculated for this transaction in DUST.
  """
  estimatedFees: String!
}

"""
Either a transaction hash or a transaction identifier.
"""
input TransactionOffset @oneOf {
  """
  A hex-encoded transaction hash.
  """
  hash: HexEncoded
  """
  A hex-encoded transaction identifier.
  """
  identifier: HexEncoded
}

"""
The result of applying a transaction to the ledger state. In case of a partial success (status),
there will be segments.
"""
type TransactionResult {
  status: TransactionResultStatus!
  segments: [Segment!]
}

"""
The status of the transaction result: success, partial success or failure.
"""
enum TransactionResultStatus {
  SUCCESS
  PARTIAL_SUCCESS
  FAILURE
}

scalar Unit

scalar UnshieldedAddress

"""
A transaction that created and/or spent UTXOs alongside these and other information.
"""
type UnshieldedTransaction {
  """
  The transaction that created and/or spent UTXOs.
  """
  transaction: Transaction!
  """
  UTXOs created in the above transaction, possibly empty.
  """
  createdUtxos: [UnshieldedUtxo!]!
  """
  UTXOs spent in the above transaction, possibly empty.
  """
  spentUtxos: [UnshieldedUtxo!]!
}

"""
An event of the unshielded transactions subscription.
"""
union UnshieldedTransactionsEvent = UnshieldedTransaction | UnshieldedTransactionsProgress

"""
Information about the unshielded indexing progress.
"""
type UnshieldedTransactionsProgress {
  """
  The highest transaction ID of all currently known transactions for a subscribed address.
  """
  highestTransactionId: Int!
}

"""
Represents an unshielded UTXO.
"""
type UnshieldedUtxo {
  """
  Owner Bech32m-encoded address.
  """
  owner: UnshieldedAddress!
  """
  Token hex-encoded serialized token type.
  """
  tokenType: HexEncoded!
  """
  UTXO value (quantity) as a string to support u128.
  """
  value: String!
  """
  The hex-encoded serialized intent hash.
  """
  intentHash: HexEncoded!
  """
  Index of this output within its creating transaction.
  """
  outputIndex: Int!
  """
  The creation time in seconds.
  """
  ctime: Int
  """
  The hex-encoded initial nonce for DUST generation tracking.
  """
  initialNonce: HexEncoded!
  """
  Whether this UTXO is registered for DUST generation.
  """
  registeredForDustGeneration: Boolean!
  """
  Transaction that created this UTXO.
  """
  createdAtTransaction: Transaction!
  """
  Transaction that spent this UTXO.
  """
  spentAtTransaction: Transaction
}

scalar ViewingKey

"""
A zswap related ledger event.
"""
type ZswapLedgerEvent {
  """
  The ID of this zswap ledger event.
  """
  id: Int!
  """
  The hex-encoded serialized event.
  """
  raw: HexEncoded!
  """
  The maximum ID of all zswap ledger events.
  """
  maxId: Int!
}

"""
Directs the executor to include this field or fragment only when the `if` argument is true.
"""
directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
"""
Indicates that an Input Object is a OneOf Input Object (and thus requires exactly one of its field be provided)
"""
directive @oneOf on INPUT_OBJECT
"""
Directs the executor to skip this field or fragment when the `if` argument is true.
"""
directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

================
File: packages/indexer-public-data-provider/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": [
    "./src/test/**/*.ts"
  ]
}

================
File: packages/indexer-public-data-provider/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./dist",
    "types": ["vitest/globals"]
  },
  "include": [
    "./src/**/*.ts"
  ]
}

================
File: packages/indexer-public-data-provider/typedoc.json
================
{
  "extends": ["../../typedoc.base.json"],
  "readme": "none",
  "entryPoints": ["src/index.ts"]
}

================
File: packages/indexer-public-data-provider/vitest.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// <reference types="vitest" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    include: ['**/test/**/*.test.ts'],
    exclude: ['node_modules', 'dist'],
    testTimeout: 180000,
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage'
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }]
    ]
  },
  resolve: {
    alias: {
      '@midnight-ntwrk/onchain-runtime': '@midnight-ntwrk/onchain-runtime-cjs'
    }
  }
});

================
File: packages/level-private-state-provider/rollup.config.mjs
================
import { createRollupConfig } from '../../build-tools/rollup.config.factory.mjs';
import packageJson from './package.json' with { type: 'json' };

export default createRollupConfig(packageJson);

================
File: packages/level-private-state-provider/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": ["./src/test/**/*.ts"]
}

================
File: packages/level-private-state-provider/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": [
    "./src/**/*.ts"
  ]
}

================
File: packages/level-private-state-provider/typedoc.json
================
{
  "extends": ["../../typedoc.base.json"],
  "readme": "none",
  "entryPoints": ["src/index.ts"]
}

================
File: packages/level-private-state-provider/vitest.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// <reference types="vitest" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    include: ['**/test/**/*.test.ts'],
    exclude: ['node_modules', 'dist'],
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage'
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }]
    ]
  },
  resolve: {
    alias: {
      '@midnight-ntwrk/onchain-runtime': '@midnight-ntwrk/onchain-runtime-cjs'
    }
  }
});

================
File: packages/logger-provider/src/test/logger-provider.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { LogLevel } from '@midnight-ntwrk/midnight-js-types';
import pino from 'pino';
import pinoPretty from 'pino-pretty';
import { vi } from 'vitest';

import { LoggerProvider } from '../index';

// We do not need to mock pino, just provide a fake implementation.

describe('Logger Provider', () => {
  // define the test cases
  const testCases = [['info'], ['warn'], ['error'], ['debug'], ['trace'], ['fatal']];
  test.each(testCases)('loggerProvider.%s calls the underlying log function exactly once.', async (name) => {
    // For each test instantiate a new logger.
    const fakePino = {
      info: vi.fn(),
      warn: vi.fn(),
      error: vi.fn(),
      debug: vi.fn(),
      trace: vi.fn(),
      fatal: vi.fn(),
      isLevelEnabled: vi.fn()
    };
    // @ts-expect-error fakePino is not a full implementation of a pino logger.
    const logger = new LoggerProvider(fakePino);
    // @ts-expect-error fakePino is not a full implementation of a pino logger.
    logger[name]('Test');
    // @ts-expect-error fakePino is not a full implementation of a pino logger.
    expect(fakePino[name]).toHaveBeenCalledTimes(1);
  });

  test("'loggerProvider' returns true for enabled log level", async () => {
    // Set up a typical pino logger.
    const pretty: pinoPretty.PrettyStream = pinoPretty({
      colorize: true,
      sync: true
    });
    const level = 'debug' as const;
    const pinoLogger = pino(
      {
        level,
        depthLimit: 20
      },
      pino.multistream([
        { stream: pretty, level: 'info' },
        { stream: pretty, level: 'debug' }
      ])
    );
    const logger = new LoggerProvider(pinoLogger);
    expect(logger.isLevelEnabled(LogLevel.DEBUG)).toBe(true);
    expect(logger.isLevelEnabled(LogLevel.TRACE)).toBe(false);
  });
});

================
File: packages/logger-provider/src/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { LoggerProvider } from './logger-provider';

================
File: packages/logger-provider/src/logger-provider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { LogLevel } from '@midnight-ntwrk/midnight-js-types';
import type { LogFn,Logger } from 'pino';

/**
 * Implementation of {@link LoggerProvider} that returns a {@link Logger} instance.
 */
export class LoggerProvider {
  private instance: Logger;

  // Private constructor to prevent direct instantiation. Require a logger instance that conforms to the 'pino' logger interface.
  constructor(logger: Logger) {
    this.instance = logger;
  }

  // Wrapper methods for logging
  public info: LogFn = (...args: unknown[]): void => {
    this.instance.info(args);
  };
  public error: LogFn = (...args: unknown[]): void => {
    this.instance.error(args);
  };
  public warn: LogFn = (...args: unknown[]): void => {
    this.instance.warn(args);
  };
  public debug: LogFn = (...args: unknown[]): void => {
    this.instance.debug(args);
  };
  public trace: LogFn = (...args: unknown[]): void => {
    this.instance.trace(args);
  };
  public fatal: LogFn = (...args: unknown[]): void => {
    this.instance.fatal(args);
  };
  public isLevelEnabled = (level: LogLevel): boolean => {
    return this.instance.isLevelEnabled(level);
  };
}

================
File: packages/logger-provider/README.md
================
# What is this?
This enables DApp developers to provide an implementation specific [pino](https://getpino.io/#/) logger Midnight.js will use for reporting low level diagnostics. The provided logger must not use custom levels. If no logger is provided, Midnight.js will run silently.

Log messages will be done as follows:
- `debug`: External calls to APIs.
- `trace`: Internal diagnostics.


This package was created for the [Midnight network](https://midnight.network).


Please visit the [Midnight Developer Hub](https://midnight.network/developer-hub) to learn more.

# Use only in Midnight test environments
Image exclusively for Midnight test environments use.  

# Agree to Terms
By downloading and using this image, you agree to [Midnights Terms and Conditions](https://midnight.network/static/terms.pdf), which includes the [Privacy Policy](https://midnight.network/static/privacy-policy.pdf).

# License
The software provided herein is licensed under the [Apache License V2.0](http://www.apache.org/licenses/LICENSE-2.0).

================
File: packages/logger-provider/rollup.config.mjs
================
import { createRollupConfig } from '../../build-tools/rollup.config.factory.mjs';
import packageJson from './package.json' with { type: 'json' };

export default createRollupConfig(packageJson);

================
File: packages/logger-provider/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": [
    "./src/test/**/*.ts"
  ]
}

================
File: packages/logger-provider/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": [
    "./src/**/*.ts"
  ]
}

================
File: packages/logger-provider/typedoc.json
================
{
  "extends": ["../../typedoc.base.json"],
  "readme": "none",
  "entryPoints": ["src/index.ts"]
}

================
File: packages/logger-provider/vitest.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// <reference types="vitest" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    include: ['**/test/**/*.test.ts'],
    exclude: ['node_modules', 'dist'],
    testTimeout: 180000,
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage'
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }]
    ]
  }
});

================
File: packages/network-id/src/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type NetworkId } from './network-id';

// Module level state that will be preserved by the JavaScript module system.
let currentNetworkId: NetworkId = 'undeployed';

/**
 * Sets the global network identifier.
 *
 * @param id A valid {@link NetworkId} value.
 */
export const setNetworkId = (id: NetworkId): void => {
  currentNetworkId = id;
};

/**
 * Retrieves the currently set global network identifier.
 *
 * @returns The currently set {@link NetworkId}.
 */
export const getNetworkId = (): NetworkId => currentNetworkId;

export * from './network-id';

================
File: packages/network-id/src/network-id.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A valid named Midnight network identifier.
 */
export type NetworkId = string;

================
File: packages/network-id/README.md
================
# What is this?
A utility package for setting the network ID of runtime and ledger WASM API.

This package was created for the [Midnight network](https://midnight.network).

Please visit the [Midnight Developer Hub](https://midnight.network/developer-hub) to learn more.

# Use only in Midnight test environments
Image exclusively for Midnight test environments use.  

# Agree to Terms
By downloading and using this image, you agree to [Midnights Terms and Conditions](https://midnight.network/static/terms.pdf), which includes the [Privacy Policy](https://midnight.network/static/privacy-policy.pdf).

# License
The software provided herein is licensed under the [Apache License V2.0](http://www.apache.org/licenses/LICENSE-2.0).

================
File: packages/network-id/rollup.config.mjs
================
import { createRollupConfig } from '../../build-tools/rollup.config.factory.mjs';
import packageJson from './package.json' with { type: 'json' };

export default createRollupConfig(packageJson);

================
File: packages/network-id/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": [
    "./src/test/**/*.ts"
  ]
}

================
File: packages/network-id/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./dist",
  },
  "include": [
    "./src/**/*.ts"
  ]
}

================
File: packages/network-id/typedoc.json
================
{
  "extends": ["../../typedoc.base.json"],
  "readme": "none",
  "entryPoints": ["src/index.ts"]
}

================
File: packages/network-id/vitest.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// <reference types="vitest" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    include: ['**/test/**/*.test.ts'],
    exclude: ['node_modules', 'dist'],
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage'
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }]
    ]
  },
  resolve: {
    alias: {
      '@midnight-ntwrk/onchain-runtime': '@midnight-ntwrk/onchain-runtime-cjs'
    }
  }
});

================
File: packages/node-zk-config-provider/src/test/node-zk-provider.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { BinaryLike } from 'crypto';
import * as crypto from 'crypto';

import { NodeZkConfigProvider } from '../index';

const createHash = (binaryLike: BinaryLike): string => {
  return crypto.createHash('sha256').update(binaryLike).digest().toString('base64');
};

describe('Node ZK config Provider', () => {
  const resourceDir = `${process.cwd()}/src/test/resources`;
  const PROVER_KEY_HASH = 'DnbPkv3mY0+nHwt3NGuaWlMRC+2QhtG+COdhjFd0xB8=';

  test('reads prover key correctly', async () => {
    const proverKey = await new NodeZkConfigProvider(resourceDir).getProverKey('set_topic');
    expect(createHash(proverKey)).toEqual(PROVER_KEY_HASH);
  });

  const VERIFIER_KEY_HASH = 'sbTZdCx3Kz4RA5OUSaBg2+WZupNdCwd13XmQV9j4pd4=';

  test('reads verifier key correctly', async () => {
    const verifierKey = await new NodeZkConfigProvider(resourceDir).getVerifierKey('set_topic');
    expect(createHash(verifierKey)).toEqual(VERIFIER_KEY_HASH);
  });

  const ZKIR_HASH = 'CW4hEb7fRkPiS85+l0/kvN+6IbISWJycOrwW5Jn+AI0=';

  test('reads ZKIR correctly', async () => {
    const zkProvider = await new NodeZkConfigProvider(resourceDir).getZKIR('set_topic');
    expect(createHash(zkProvider)).toEqual(ZKIR_HASH);
  });

  test('throws on relative path', async () => {
    await expect(async () => new NodeZkConfigProvider('.').getVerifierKey('set_topic')).rejects.toThrowError(
      "ENOENT: no such file or directory, open 'keys/set_topic.verifier'"
    );
  });
});

================
File: packages/node-zk-config-provider/src/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { NodeZkConfigProvider } from './node-zk-config-provider';

================
File: packages/node-zk-config-provider/src/node-zk-config-provider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ProverKey, VerifierKey, ZKIR } from '@midnight-ntwrk/midnight-js-types';
import { createProverKey, createVerifierKey, createZKIR, ZKConfigProvider } from '@midnight-ntwrk/midnight-js-types';
import * as fs from 'fs/promises';
import * as path from 'path';

/**
 * The name of the directory containing proving and verifying keys.
 */
const KEY_DIR = 'keys';
/**
 * File extension for proving keys.
 */
const PROVER_EXT = '.prover';
/**
 * File extension for verifying keys.
 */
const VERIFIER_EXT = '.verifier';
/**
 * The name of the directory containing zkIRs.
 */
const ZKIR_DIR = 'zkir';
/**
 * File extension for zkIRs.
 */
const ZKIR_EXT = '.bzkir';

/**
 * Implementation of {@link ZKConfigProvider} that reads the keys and zkIR from the local filesystem.
 * @typeParam K - The type of the circuit ID used by the provider.
 */
export class NodeZkConfigProvider<K extends string> extends ZKConfigProvider<K> {
  /**
   * @param directory The path to the base directory containing the key and ZKIR subdirectories.
   */
  constructor(readonly directory: string) {
    super();
  }

  /**
   * Reads a file from the local filesystem.
   * @param subDir The subdirectory of the base-directory to read from.
   * @param circuitId The circuit ID corresponding to the file to read.
   * @param ext The file extension of the file to read.
   * @private
   */
  private readFile(subDir: string, circuitId: K, ext: string): Promise<Buffer> {
    return fs.readFile(path.join(this.directory, subDir, circuitId + ext));
  }

  /**
   * {@link ZKConfigProvider.getProverKey}
   */
  getProverKey(circuitId: K): Promise<ProverKey> {
    return this.readFile(KEY_DIR, circuitId, PROVER_EXT).then(createProverKey);
  }

  /**
   * {@link ZKConfigProvider.getVerifierKey}
   */
  getVerifierKey(circuitId: K): Promise<VerifierKey> {
    return this.readFile(KEY_DIR, circuitId, VERIFIER_EXT).then(createVerifierKey);
  }

  /**
   * {@link ZKConfigProvider.getZKIR}
   */
  getZKIR(circuitId: K): Promise<ZKIR> {
    return this.readFile(ZKIR_DIR, circuitId, ZKIR_EXT).then(createZKIR);
  }
}

================
File: packages/node-zk-config-provider/README.md
================
# What is this?
A `ZKConfigProvider` implementation that reads proving and verifying keys and ZK intermediate
representation, in a Node.js environment.

This package was created for the [Midnight network](https://midnight.network). 

Please visit the [Midnight Developer Hub](https://midnight.network/developer-hub) to learn more.

# Use only in Midnight test environments
Image exclusively for Midnight test environments use.  

# Agree to Terms
By downloading and using this image, you agree to [Midnights Terms and Conditions](https://midnight.network/static/terms.pdf), which includes the [Privacy Policy](https://midnight.network/static/privacy-policy.pdf).

# License
The software provided herein is licensed under the [Apache License V2.0](http://www.apache.org/licenses/LICENSE-2.0).

================
File: packages/node-zk-config-provider/rollup.config.mjs
================
import { createRollupConfig } from '../../build-tools/rollup.config.factory.mjs';
import packageJson from './package.json' with { type: 'json' };

export default createRollupConfig(packageJson);

================
File: packages/node-zk-config-provider/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": ["./src/test/**/*.ts"]
}

================
File: packages/node-zk-config-provider/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": [
    "./src/**/*.ts"
  ]
}

================
File: packages/node-zk-config-provider/typedoc.json
================
{
  "extends": ["../../typedoc.base.json"],
  "readme": "none",
  "entryPoints": ["src/index.ts"]
}

================
File: packages/node-zk-config-provider/vitest.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// <reference types="vitest" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    include: ['**/test/**/*.test.ts'],
    exclude: ['node_modules', 'dist'],
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage'
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }]
    ]
  }
});

================
File: packages/types/src/contract.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type {
  CircuitContext,
  CircuitResults,
  ConstructorContext,
  ConstructorResult,
  WitnessContext} from '@midnight-ntwrk/compact-runtime';

/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * A circuit which affects the public state.
 *
 * @typeParam PS - The private state modified by the contract witnesses.
 */
export type ImpureCircuit<PS> = (context: CircuitContext<PS>, ...args: any[]) => CircuitResults<PS, any>;

/**
 * A collection of impure circuits defined in a contract.
 *
 * @typeParam PS - The private state modified by the contract witnesses.
 */
export type ImpureCircuits<PS> = Record<string, ImpureCircuit<PS>>;

/**
 * A type representing a witness in a contract.
 *
 * @typeParam PS - The private state modified by the witness.
 */
export type Witness<PS> = (context: WitnessContext<any, PS>, ...rest: any[]) => [PS, any];

/**
 * A type representing all of a contract's witnesses.
 *
 * @typeParam PS - The private state modified by the contract witnesses.
 */
export type Witnesses<PS = any> = Record<string, Witness<PS>>;

/**
 * Interface for a contract. The data types defined in this file are generic shapes for the artifacts
 * produced by the `compact` compiler. In other words, this `Contract` interface should match the shape
 * of any `Contract` class produced by `compact`. Midnight.js uses it for generic constraints.
 *
 * @typeParam PS - The private state modified by the contract witnesses.
 * @typeParam W - The contract witnesses type.
 */
export interface Contract<PS = any, W extends Witnesses<PS> = Witnesses<PS>> {
  /**
   * The private oracle of the contract.
   */
  readonly witnesses: W;
  /**
   * The impure circuits defined in a contract. These circuits can be used to create call transactions.
   */
  readonly impureCircuits: ImpureCircuits<PS>;

  /**
   * Constructs the initial public state of the public oracle of a contract. This is used during
   * deployment transaction construction.
   */
  initialState(context: ConstructorContext<PS>, ...args: any[]): ConstructorResult<PS>;
}

/**
 * A union over the impure circuit identifiers of a contract.
 *
 * @typeParam C The contract type for which we would like impure circuit IDs.
 */
export type ImpureCircuitId<C extends Contract = Contract> = keyof C['impureCircuits'] & string;

/**
 * Extracts the private state of a contract.
 *
 * @typeParam C The contract for which we would like the private state.
 */
export type PrivateState<C extends Contract> = C extends Contract<infer PS> ? PS : never;

/**
 * Typesafe version of `Object.keys(contract.impureCircuits)`.
 *
 * @param contract The contract having impure circuits for which we want ids.
 *
 * @typeParam C The contract type for which we would like impure circuit IDs.
 */
export const getImpureCircuitIds = <C extends Contract>(contract: C): ImpureCircuitId<C>[] =>
  Object.keys(contract.impureCircuits) as ImpureCircuitId<C>[];

/**
 * The parameter types of the circuits in a contract.
 */
export type CircuitParameters<C extends Contract, K extends ImpureCircuitId<C>> =
  Parameters<C['impureCircuits'][K]> extends [CircuitContext<any>, ...infer A] ? A : never;

/**
 * The return types of the circuits in a contract.
 */
export type CircuitReturnType<C extends Contract, K extends ImpureCircuitId<C>> =
  ReturnType<C['impureCircuits'][K]> extends CircuitResults<any, infer U> ? U : never;

/**
 * The parameter type of the public state constructor.
 */
export type InitialStateParameters<C extends Contract> =
  Parameters<C['initialState']> extends [ConstructorContext<any>, ...infer A] ? A : never;

================
File: packages/types/src/errors.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * An error describing an invalid protocol scheme.
 */
export class InvalidProtocolSchemeError extends Error {
  /**
   * @param invalidScheme The invalid scheme.
   * @param allowableSchemes The valid schemes that are allowed.
   */
  constructor(
    public readonly invalidScheme: string,
    public readonly allowableSchemes: string[]
  ) {
    super(`Invalid protocol scheme: '${invalidScheme}'. Allowable schemes are one of: ${allowableSchemes.join(',')}`);
  }
}

================
File: packages/types/src/logger-provider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { LogFn } from 'pino';

/**
 * A valid named log level.
 */
export enum LogLevel {
  /**
   * Log levels typically used by DAapp developers.
   */
  INFO = 'info',
  WARN = 'warn',
  ERROR = 'error',
  FATAL = 'fatal',
  /**
   * Log levels used by Midnight.JS to report internal state.
   */
  DEBUG = 'debug',
  TRACE = 'trace'
}

/**
 * A provider for logging functions.
 */
export interface LoggerProvider {
  info?: LogFn;
  warn?: LogFn;
  error?: LogFn;
  debug?: LogFn;
  fatal?: LogFn;
  isLevelEnabled(level: LogLevel): boolean;
}

================
File: packages/types/src/midnight-provider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { FinalizedTransaction, TransactionId } from '@midnight-ntwrk/ledger-v6';

/**
 * Interface for Midnight transaction submission logic. It could be implemented, e.g., by a wallet,
 * a third-party service, or a node itself.
 */
export interface MidnightProvider {
  /**
   * Submit a transaction to the network to be consensed upon.
   * @param tx The finalized transaction to submit.
   * @returns The transaction identifier of the submitted transaction.
   */
  submitTx(tx: FinalizedTransaction): Promise<TransactionId>;
}

================
File: packages/types/src/private-state-provider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ContractAddress,SigningKey } from '@midnight-ntwrk/compact-runtime';

/**
 * A type representing an ID used to store a contract's private state.
 */
export type PrivateStateId = string;

/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * Interface for a typed key-valued store containing contract private states.
 *
 * @typeParam PSI - Parameter indicating the private state ID, sometimes a union of string literals.
 * @typeParam PS - Parameter indicating the private state type stored, sometimes a union of private state types.
 */
export interface PrivateStateProvider<PSI extends PrivateStateId = PrivateStateId, PS = any> {
  /**
   * Store the given private state at the given private state ID.
   *
   * @param privateStateId The private state identifier.
   * @param state The private state to store.
   */
  set(privateStateId: PSI, state: PS): Promise<void>;

  /**
   * Retrieve the private state at the given private state ID.
   *
   * @param privateStateId The private state identifier.
   */
  get(privateStateId: PSI): Promise<PS | null>;

  /**
   * Remove the value at the given private state ID.
   *
   * @param privateStateId The private state identifier.
   */
  remove(privateStateId: PSI): Promise<void>;

  /**
   * Remove all contract private states.
   */
  clear(): Promise<void>;

  /**
   * Store the given signing key at the given address.
   *
   * @param address The address of the contract having the given signing key.
   * @param signingKey The signing key to store.
   */
  setSigningKey(address: ContractAddress, signingKey: SigningKey): Promise<void>;

  /**
   * Retrieve the signing key for a contract.
   *
   * @param address The address of the contract for which to get the signing key.
   */
  getSigningKey(address: ContractAddress): Promise<SigningKey | null>;

  /**
   * Remove the signing key for a contract.
   *
   * @param address The address of the contract for which to delete the signing key.
   */
  removeSigningKey(address: ContractAddress): Promise<void>;

  /**
   * Remove all contract signing keys.
   */
  clearSigningKeys(): Promise<void>;
}

================
File: packages/types/src/proof-provider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  type PreBinding,
  type Proof,
  type SignatureEnabled,
  type Transaction,
  type UnprovenTransaction
} from '@midnight-ntwrk/ledger-v6';

import type { ZKConfig } from './midnight-types';

export type ProvenTransaction = Transaction<SignatureEnabled, Proof, PreBinding>;

/**
 * The configuration for the proof request to the proof provider.
 */
export interface ProveTxConfig<K extends string> {
  /**
   * The timeout for the request.
   */
  readonly timeout?: number;
  /**
   * The zero-knowledge configuration for the circuit that was called in `tx`.
   * Undefined if `tx` is a deployment transaction.
   */
  readonly zkConfig?: ZKConfig<K>;
}

/**
 * Interface for a proof server running in a trusted environment.
 * @typeParam K - The type of the circuit ID used by the provider.
 */
export interface ProofProvider<K extends string> {
  /**
   * Creates call proofs for an unproven transaction. The resulting transaction is unbalanced and
   * must be balanced using the {@link WalletProvider} interface.
   *           contain a single contract call.
   * @param unprovenTx
   * @param proveTxConfig The configuration for the proof request to the proof provider. Empty in case
   *                      a deploy transaction is being proved with no user-defined timeout.
   */
  proveTx(unprovenTx: UnprovenTransaction, proveTxConfig?: ProveTxConfig<K>): Promise<ProvenTransaction>;
}

================
File: packages/types/src/providers.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type ImpureCircuitId } from './contract';
import type { LoggerProvider } from './logger-provider';
import type { MidnightProvider } from './midnight-provider';
import type { PrivateStateId, PrivateStateProvider } from './private-state-provider';
import type { ProofProvider } from './proof-provider';
import type { PublicDataProvider } from './public-data-provider';
import type { WalletProvider } from './wallet-provider';
import type { ZKConfigProvider } from './zk-config-provider';

/**
 * Set of providers needed for transaction construction and submission.
 *
 * @typeParam ICK - A union of string literal types representing the callable circuits.
 * @typeParam PSI - Parameter indicating the private state ID, sometimes a union of string literals.
 * @typeParam PS - Parameter indicating the private state type stored, sometimes a union of private state types.
 */
export interface MidnightProviders<
  ICK extends ImpureCircuitId = ImpureCircuitId,
  PSI extends PrivateStateId = PrivateStateId,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  PS = any
> {
  /**
   * Manages the private state of a contract.
   */
  readonly privateStateProvider: PrivateStateProvider<PSI, PS>;
  /**
   * Retrieves public data from the blockchain.
   */
  readonly publicDataProvider: PublicDataProvider;
  /**
   * Retrieves the ZK artifacts of a contract needed to create proofs.
   */
  readonly zkConfigProvider: ZKConfigProvider<ICK>;
  /**
   * Creates proven, unbalanced transactions.
   */
  readonly proofProvider: ProofProvider<ICK>;
  /**
   * Creates proven, balanced transactions.
   */
  readonly walletProvider: WalletProvider;
  /**
   * Submits proven, balanced transactions to the network.
   */
  readonly midnightProvider: MidnightProvider;
  /**
   * An optional logger that provides utilities for logging at given levels.
   */
  readonly loggerProvider?: LoggerProvider;
}

================
File: packages/types/src/zk-config-provider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ProverKey, VerifierKey, ZKConfig,ZKIR } from './midnight-types';

/**
 * A provider for zero-knowledge intermediate representations, prover keys, and verifier keys. All
 * three are used by the {@link ProofProvider} to create a proof for a call transaction. The implementation
 * of this provider depends on the runtime environment, since each environment has different conventions
 * for accessing static artifacts.
 * @typeParam K - The type of the circuit ID used by the provider.
 */
export abstract class ZKConfigProvider<K extends string> {
  /**
   * Retrieves the zero-knowledge intermediate representation produced by `compact` compiler for the given circuit.
   * @param circuitId The circuit ID of the ZKIR to retrieve.
   */
  abstract getZKIR(circuitId: K): Promise<ZKIR>;

  /**
   * Retrieves the prover key produced by `compact` compiler for the given circuit.
   * @param circuitId The circuit ID of the prover key to retrieve.
   */
  abstract getProverKey(circuitId: K): Promise<ProverKey>;

  /**
   * Retrieves the verifier key produced by `compact` compiler for the given circuit.
   * @param circuitId The circuit ID of the verifier key to retrieve.
   */
  abstract getVerifierKey(circuitId: K): Promise<VerifierKey>;

  /**
   * Retrieves the verifier keys produced by `compact` compiler for the given circuits.
   * @param circuitIds The circuit IDs of the verifier keys to retrieve.
   */
  async getVerifierKeys(circuitIds: K[]): Promise<[K, VerifierKey][]> {
    return Promise.all(
      circuitIds.map(async (id) => {
        const key = await this.getVerifierKey(id);
        return [id, key];
      })
    );
  }

  /**
   * Retrieves all zero-knowledge artifacts produced by `compact` compiler for the given circuit.
   * @param circuitId The circuit ID of the artifacts to retrieve.
   */
  async get(circuitId: K): Promise<ZKConfig<K>> {
    return {
      circuitId,
      proverKey: await this.getProverKey(circuitId),
      verifierKey: await this.getVerifierKey(circuitId),
      zkir: await this.getZKIR(circuitId)
    };
  }
}

================
File: packages/types/README.md
================
# What is this?
Provides shared data types and interfaces for all MidnightJS modules.

This package was created for the [Midnight network](https://midnight.network).

Please visit the [Midnight Developer Hub](https://midnight.network/developer-hub) to learn more.

# Use only in Midnight test environments
Image exclusively for Midnight test environments use.  

# Agree to Terms
By downloading and using this image, you agree to [Midnights Terms and Conditions](https://midnight.network/static/terms.pdf), which includes the [Privacy Policy](https://midnight.network/static/privacy-policy.pdf).

# License
The software provided herein is licensed under the [Apache License V2.0](http://www.apache.org/licenses/LICENSE-2.0).

================
File: packages/types/rollup.config.mjs
================
import { createRollupConfig } from '../../build-tools/rollup.config.factory.mjs';
import packageJson from './package.json' with { type: 'json' };

export default createRollupConfig(packageJson);

================
File: packages/types/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": [
    "./src/test/**/*.ts"
  ]
}

================
File: packages/types/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./dist",
  },
  "include": [
    "./src/**/*.ts"
  ]
}

================
File: packages/types/typedoc.json
================
{
  "extends": ["../../typedoc.base.json"],
  "readme": "none",
  "entryPoints": ["src/index.ts"]
}

================
File: packages/types/vitest.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// <reference types="vitest" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    include: ['**/test/**/*.test.ts'],
    exclude: ['node_modules', 'dist'],
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage'
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }]
    ]
  },
  resolve: {
    alias: {
      '@midnight-ntwrk/onchain-runtime': '@midnight-ntwrk/onchain-runtime-cjs'
    }
  }
});

================
File: packages/utils/src/test/hex-utils.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assertIsHex, isHex, parseCoinPublicKeyToHex, parseEncPublicKeyToHex } from '../hex-utils';

describe('Hex Utils', () => {
  describe('with valid strings', () => {
    const THREE_BYTE_STRING = 'FAB123';

    it.each([THREE_BYTE_STRING, `0x${THREE_BYTE_STRING}`])('return true for any byte length', (source) => {
      expect(isHex(source)).toBeTruthy();
      expect(() => assertIsHex(source)).not.toThrow();
    });

    it.each([
      [THREE_BYTE_STRING, 3],
      [`0x${THREE_BYTE_STRING}`, 3]
    ])('return true for expected byte length', (source, requiredByteLen) => {
      expect(isHex(source, requiredByteLen)).toBeTruthy();
      expect(() => assertIsHex(source, requiredByteLen)).not.toThrow();
    });

    it.each([THREE_BYTE_STRING, `0x${THREE_BYTE_STRING}`])('return false with a zero byte length', (source) => {
      expect(isHex(source, 0)).toBeFalsy();
      expect(() => assertIsHex(source, 0)).toThrow('Expected byte length must be greater than zero.');
    });

    it('return false when string is not of expected length', () => {
      const byteLength = 5;

      expect(isHex(THREE_BYTE_STRING, 5)).toBeFalsy();
      expect(() => assertIsHex(THREE_BYTE_STRING, 5)).toThrow(
        `Expected an input string with byte length of ${byteLength}, got ${THREE_BYTE_STRING.length / 2}.`
      );
    });
  });

  describe('with invalid strings', () => {
    const INVALID_BYTE_STRING = 'HELL01';
    const INCOMPLETE_BYTE_STRING = '1A2';

    it.each([
      [INVALID_BYTE_STRING, 0],
      [`0x${INVALID_BYTE_STRING}`, 2]
    ])('return false for invalid hexadecimal digit', (source, invalidPos) => {
      expect(isHex(source)).toBeFalsy();
      expect(() => assertIsHex(source)).toThrow(`Invalid hex-digit 'H' found in input string at index ${invalidPos}.`);
    });

    it.each([INCOMPLETE_BYTE_STRING, `0x${INCOMPLETE_BYTE_STRING}`])(
      'return false for incomplete strings',
      (source) => {
        expect(isHex(source)).toBeFalsy();
        expect(() => assertIsHex(source)).toThrow(`The last byte of input string '${source}' is incomplete.`);
      }
    );
  });

  describe('with empty strings', () => {
    const EMPTY_STRING = '';

    it.each([undefined, 2])('return false regardless of byte length', (byteLen) => {
      expect(isHex(EMPTY_STRING, byteLen)).toBeFalsy();
      expect(() => assertIsHex(EMPTY_STRING, byteLen)).toThrow('Input string must have non-zero length.');
    });

    it.each([undefined, 2])('return false regardless of byte length and prefix', (byteLen) => {
      const source = `0x${EMPTY_STRING}`;

      expect(isHex(source, byteLen)).toBeFalsy();
      expect(() => assertIsHex(source, byteLen)).toThrow(`Input string '${source}' is not a valid hex-string.`);
    });
  });

  // Note that we are not mocking the underlying use of @midnight-ntwrk/wallet-sdk-address-format
  describe('parseCoinPublicKeyToHex', () => {
    const mockNetworkId = 'undeployed';

    describe('with valid inputs', () => {
      it('should return the input if it is a valid hex string', () => {
        const validHex = 'abcdef1234567890';
        expect(parseCoinPublicKeyToHex(validHex, mockNetworkId)).toBe(validHex);
      });

      it('should parse a valid Bech32m-encoded public key and return its hex representation', () => {
        const bech32Input = 'mn_shield-cpk_undeployed1mjngjmnlutcq50trhcsk3hugvt9wyjnhq3c7prryd5nqmvtzva0sn7kq7h';
        const expectedHex = 'dca6896e7fe2f00a3d63be2168df8862cae24a770471e08c646d260db162675f';
        const result = parseCoinPublicKeyToHex(bech32Input, mockNetworkId);
        expect(result).toBe(expectedHex);
      });
    });

    describe('with invalid inputs', () => {
      it('should throw an error if the input is neither a valid hex string nor a valid Bech32m-encoded public key', () => {
        const invalidInput = 'invalidKey';
        expect(() => parseCoinPublicKeyToHex(invalidInput, mockNetworkId)).toThrow();
      });
    });
  });

  // Note that we are not mocking the underlying use of @midnight-ntwrk/wallet-sdk-address-format
  describe('parseEncPublicKeyToHex', () => {
    const mockNetworkId = 'test';

    describe('with valid inputs', () => {
      it('should return the input if it is a valid hex string', () => {
        const validHex = 'abcdef1234567890';
        expect(parseEncPublicKeyToHex(validHex, mockNetworkId)).toBe(validHex);
      });

      it('should parse a valid Bech32m-encoded public key and return its hex representation', () => {
        const bech32Input = 'mn_shield-epk_test1qvqpla2ttj8v49y52ayluya23spy3m6dgt3mxv9sp9cduuq8uw2lw0snz2sze';
        const expectedHex = '03001ff54b5c8eca94945749fe13aa8c0248ef4d42e3b330b00970de7007e395f73e';
        const result = parseEncPublicKeyToHex(bech32Input, mockNetworkId);
        expect(result).toBe(expectedHex);
      });
    });

    describe('with invalid inputs', () => {
      it('should throw an error if the input is neither a valid hex string nor a valid Bech32m-encoded public key', () => {
        const invalidInput = 'invalidKey';
        expect(() => parseEncPublicKeyToHex(invalidInput, mockNetworkId)).toThrow();
      });
    });
  });
});

================
File: packages/utils/src/assertion-utils.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Asserts that the given value is non-nullable.
 *
 * @param value The value to test for nullability.
 * @param message The error message to use if an error is thrown.
 *
 * @throws Error If the value is nullable.
 */
export function assertDefined<A>(value: A | null | undefined, message?: string): asserts value is NonNullable<A> {
  if (!value) {
    throw new Error(message ?? 'Expected value to be defined');
  }
}

/**
 * Asserts that the given value is null or undefined.
 *
 * @param value The value to test for nullability.
 * @param message The error message to use if an error is thrown.
 *
 * @throws Error If the value is not undefined or null
 */
export function assertUndefined<A>(value: A | null | undefined, message?: string): asserts value is undefined | null {
  if (value) {
    throw new Error(message ?? 'Expected value to be null or undefined');
  }
}

================
File: packages/utils/src/date-utils.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export const ttlOneHour = () => new Date(Date.now() + 60 * 60 * 1000);

================
File: packages/utils/src/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * from './assertion-utils';
export * from './date-utils';
export * from './hex-utils';
export * from './type-utils';

================
File: packages/utils/src/type-utils.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ContractAddress } from '@midnight-ntwrk/compact-runtime';

import { assertIsHex, parseHex } from './hex-utils';

/**
 * Asserts that a string represents a hex-encoded contract address.
 *
 * @param contractAddress The source string.
 *
 * @throws `TypeError`
 * `contractAddress` is not a correctly formatted {@link ContractAddress}.
 *
 * @internal
 */
export function assertIsContractAddress(contractAddress: string): asserts contractAddress is ContractAddress {
  const CONTRACT_ADDRESS_BYTE_LENGTH = 32;

  assertIsHex(contractAddress, CONTRACT_ADDRESS_BYTE_LENGTH);

  const parsedHex = parseHex(contractAddress);

  if (parsedHex.hasPrefix) {
    throw new TypeError(`Unexpected '0x' prefix in contract address '${contractAddress}'`);
  }
}

================
File: packages/utils/README.md
================
# What is this?
Provides shared utilities for all MidnightJS modules.  
This package was created for the [Midnight network](https://midnight.network).

Please visit the [Midnight Developer Hub](https://midnight.network/developer-hub) to learn more.

# Use only in Midnight test environments
Image exclusively for Midnight test environments use.  

# Agree to Terms
By downloading and using this image, you agree to [Midnights Terms and Conditions](https://midnight.network/static/terms.pdf), which includes the [Privacy Policy](https://midnight.network/static/privacy-policy.pdf).

# License
The software provided herein is licensed under the [Apache License V2.0](http://www.apache.org/licenses/LICENSE-2.0).

================
File: packages/utils/rollup.config.mjs
================
import { createRollupConfig } from '../../build-tools/rollup.config.factory.mjs';
import packageJson from './package.json' with { type: 'json' };

export default createRollupConfig(packageJson);

================
File: packages/utils/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": [
    "./src/test/**/*.ts"
  ]
}

================
File: packages/utils/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./dist",
  },
  "include": [
    "./src/**/*.ts"
  ]
}

================
File: packages/utils/typedoc.json
================
{
  "extends": ["../../typedoc.base.json"],
  "readme": "none",
  "entryPoints": ["src/index.ts"]
}

================
File: packages/utils/vitest.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// <reference types="vitest" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    include: ['**/test/**/*.test.ts'],
    exclude: ['node_modules', 'dist'],
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage'
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }]
    ]
  },
  resolve: {
    alias: {
      '@midnight-ntwrk/onchain-runtime': '@midnight-ntwrk/onchain-runtime-cjs'
    }
  }
});

================
File: platform-js/platform-js/src/effect/internal/hex.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as Brand from 'effect/Brand';
import * as Either from 'effect/Either';
import { NodeInspectSymbol } from 'effect/Inspectable';
import * as Option from 'effect/Option'

import type * as Hex from '../Hex.js';
import * as IntegerRange from '../IntegerRange.js';
import * as ParseError from '../ParseError.js';

const HEX_STRING_REGEXP = /^(?<prefix>(0x)?)(?<byteChars>([0-9A-Fa-f]{2})*)(?<incompleteChars>.*)$/;

/** @internal */
export const parseHex: (source: string) => Either.Either<Hex.ParsedHexString, ParseError.ParseError> =
  (source) => {
    if (!source) {
      return Either.left(ParseError.make('Source string must have non-zero length', source));
    }
    const match = source.match(HEX_STRING_REGEXP);
    if (!match || !match.groups) {
      return Either.left(ParseError.make(`Source string '${source}' is not a valid hex-string`, source));
    }
    const { prefix, byteChars, incompleteChars } = match.groups;
    const parsedHex: Hex.ParsedHexString = {
      hasPrefix: Boolean(prefix),
      byteChars: byteChars || '',
      incompleteChars: incompleteChars || '',
      toString: () => `${prefix}${byteChars}..[${incompleteChars ?? '<none>'}]`,
      toJSON: () => match.groups,
      [NodeInspectSymbol]: () => match.groups
    };
    if (parsedHex.incompleteChars) {
      if (parsedHex.incompleteChars.length % 2 > 0) {
        return Either.left(ParseError.make(`Last byte of source string '${source}' is incomplete`, source, parsedHex));
      }
      const invalidCharPos = parsedHex.byteChars.length + (parsedHex.hasPrefix ? 2 : 0);
      return Either.left(
        ParseError.make(
          `Invalid hex-digit '${source[invalidCharPos]}' found in source string at index ${invalidCharPos}`,
          source,
          parsedHex
        )
      );
    }
    if (!parsedHex.byteChars) {
      return Either.left(ParseError.make(`Source string '${source}' is not a valid hex-string`, source, parsedHex));
    }
    return Either.right(parsedHex);
  };

type HexConstraints = Hex.HexConstraints & {
  readonly requirePrefix? : boolean;
}

const defaultHexConstructionConstraints: HexConstraints = {
  requirePrefix: false
};

/** @internal */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const make: <T extends Brand.Branded<string, any>>(constraints?: HexConstraints) => Brand.Brand.Constructor<T> =
  <T extends Brand.Branded<string, any>>(options?: Hex.HexConstraints) => { // eslint-disable-line @typescript-eslint/no-explicit-any
    const mergedOptions = { ...defaultHexConstructionConstraints, ...options };
    return Brand.refined<T>(
      (source: string) => Either.match(parseHex(source), {
        onLeft: (error) => Option.some(Brand.error(error.message, error.meta)),
        onRight: (parsedHex) => {
          if (mergedOptions.requirePrefix && !parsedHex.hasPrefix) {
            return Option.some(Brand.error(`Source string '${source}' requires a '0x' prefix`));
          }
          if (!mergedOptions.requirePrefix && parsedHex.hasPrefix) {
            return Option.some(Brand.error(`Source string '${source}' has a '0x' prefix but prefixes are not allowed`));
          }
          if (mergedOptions.byteLength) {
            const byteLength = IntegerRange.isIntegerRange(mergedOptions.byteLength)
              ? mergedOptions.byteLength
              : IntegerRange.from(mergedOptions.byteLength);
            const actualByteLen = parsedHex.byteChars.length / 2;
            if (!IntegerRange.contains(byteLength, actualByteLen)) {
              return Option.some(Brand.error(`Source string '${source}' has a byte length of ${actualByteLen}, but expected ${byteLength.toString()}`));
            }
          }
          return Option.none();
        }
      }));
  };

================
File: platform-js/platform-js/src/effect/Configuration.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { identity } from 'effect';
import * as Config from 'effect/Config';
import { type ConfigError } from 'effect/ConfigError';
import * as ConfigProvider from 'effect/ConfigProvider';
import * as Context from 'effect/Context';
import * as Effect from 'effect/Effect';
import * as Layer from 'effect/Layer';
import * as Option from 'effect/Option';
import * as Schema from 'effect/Schema';

import * as CoinPublicKey from './CoinPublicKey.js';
import * as NetworkId from './NetworkId.js';
import * as NetworkIdMoniker from './NetworkIdMoniker.js';
import * as SigningKey from './SigningKey.js';

/**
 * Provides accessors for retrieving configured keys.
 *
 * @category services
 */
export class Keys extends Context.Tag('@midnight-ntwrk/platform-js/Configuration#Keys')<
  Keys,
  Configuration.Keys
>() {}

/**
 * Provides an accessor for retrieving the configured {@link NetworkId.NetworkId | NetworkId}.
 *
 * @category services
 */
export class Network extends Context.Tag('@midnight-ntwrk/platform-js/Configuration#Network')<
  Network,
  NetworkId.NetworkId
>() {}

export declare namespace Configuration {
  /**
   * Accessors for retrieving keys.
   */
  export interface Keys {
    /**
     * Gets the current user's Zswap public key.
     *
     * @category keys
     */
    readonly coinPublicKey: CoinPublicKey.CoinPublicKey;

    /**
     * Gets a signing key.
     *
     * @remarks
     * A signing key is required when creating Contract Maintenance Authority (CMA) instances when initializing
     * new contracts. If `Option.None` is returned, then a new singing key is sampled and used for the CMA
     * instead. Returning the same signing key is useful when that key is to be used to maintain multiple contracts.
     *
     * @category keys
     */
    getSigningKey(): Option.Option<SigningKey.SigningKey>;
  }
}

const KeysConfig = Config.all([
  Schema.Config(
    'coinPublic',
    Schema.Union(
      Schema.String.pipe(Schema.fromBrand(CoinPublicKey.Hex)),
      Schema.String.pipe(Schema.fromBrand(CoinPublicKey.Bech32m))
    )
  ),
  Config.option(Schema.Config('signing', Schema.String.pipe(Schema.fromBrand(SigningKey.SigningKey))))
]).pipe(Config.nested('keys'));

const NetworkIdConfig = Config.option(Schema.Config(
  'network',
  Schema.String.pipe(Schema.fromBrand(NetworkIdMoniker.NetworkIdMoniker))
));

const makeKeys: () => Layer.Layer<Keys, ConfigError>
  = () => Layer.effect(Keys, Effect.gen(function* () {
    const [coinPublic, signing] = yield* KeysConfig;

    return Keys.of({
      coinPublicKey: coinPublic,
      getSigningKey: () => signing
    });
  }));

const makeNetwork: () => Layer.Layer<Network, ConfigError>
  = () => Layer.effect(Network, Effect.gen(function* () {
    return Network.of(
        NetworkId.make(Option.match(yield* NetworkIdConfig, {
        onSome: identity,
        onNone: () => NetworkId.MainNet
      }))
    );
  }));

/**
 * Creates a platform independent configuration provider,
 *
 * @param json A JSON object from which configuration values can be read.
 * @returns A `ConfigProvider` that defaults to values present in `json`, but allows them to be overridden
 * via environment variables.
 * 
 * @category constructors
 */
export const configProvider: (json: unknown) => ConfigProvider.ConfigProvider
  = (json) => ConfigProvider.fromEnv({ pathDelim: '_'}).pipe(
    ConfigProvider.constantCase,
    ConfigProvider.orElse(() => ConfigProvider.fromJson(json))
  );

/**
 * A default layer that provides a collection of services that provide accessors, that in turn, access underlying
 * configured values.
 *
 * @see {@link Keys}
 * @see {@link Network}
 * 
 * @category layers
 */
export const layer = Layer.mergeAll(makeKeys(), makeNetwork());

================
File: platform-js/platform-js/src/effect/Hex.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type * as Brand from 'effect/Brand';
import type * as Either from 'effect/Either';
import { type Inspectable } from 'effect/Inspectable';

import type * as IntegerRange from './IntegerRange.js';
import * as internal from './internal/hex.js';
import type * as ParseError from './ParseError.js';

/**
 * A hex-encoded string, of some arbitrary byte length, that may or may not have a `'0x'` prefix.
 * 
 * @remarks
 * `Hex` is a 'branded' string type defining a sequence of hexadecimal characters, and represented either as a
 * {@link Hex.PrefixedHex | PrefixedHex} or {@link Hex.PlainHex | PlainHex} instance.
 * 
 * It is possible to create custom `Hex` constructors that represent hex-encoded strings with specific constraints
 * (such as byte lengths), by invoking {@link ConstrainedPrefixedHex} or
 * {@link ConstrainedPlainHex} with options described by {@link HexConstraints}.
 * 
 * @see {@link ConstrainedPrefixedHex}
 * @see {@link ConstrainedPlainHex}
 * @category models
 */
export type Hex = Hex.PlainHex | Hex.PrefixedHex;

export declare namespace Hex {
  /**
   * A hex-encoded string, of some arbitrary byte length, that has a `'0x'` prefix.
   * 
   * @category models
   */
  export type PrefixedHex = Brand.Branded<string, 'PrefixedHex'>;

  /**
   * A plain hex-encoded string, of some arbitrary byte length.
   * 
   * @category models
   */
  export type PlainHex = Brand.Branded<string, 'PlainHex'>;
}

/**
 * Creates a hex-encoded string, of some arbitrary byte length, that has a `'0x'` prefix.
 * 
 * @category constructors
 */
export const PrefixedHex: Brand.Brand.Constructor<Hex.PrefixedHex> =
  internal.make<Hex.PrefixedHex>({ requirePrefix: true });

/**
 * Creates a hex-encoded string, from some given constraints, that has a `'0x'` prefix.
 *
 * @param constraints The {@link HexConstraints} to apply when parsing a received hex-encoded string.
 * @returns A function that creates a {@link Hex.PrefixedHex | PrefixedHex} instance from a received string
 * ensuring that it meets `constraints`.
 * 
 * @category constructors
 */
export const ConstrainedPrefixedHex: (constraints: HexConstraints) => Brand.Brand.Constructor<Hex.PrefixedHex> =
  (constraints) => internal.make<Hex.PrefixedHex>({ requirePrefix: true, ...constraints });

/**
 * Creates a plain hex-encoded string, of some arbitrary byte length.
 * 
 * @category constructors
 */
export const PlainHex: Brand.Brand.Constructor<Hex.PlainHex> =
  internal.make<Hex.PlainHex>({ requirePrefix: false });

/**
 * Creates a plain hex-encoded string, from some given constraints.
 *
 * @param constraints The {@link HexConstraints} to apply when parsing a received hex-encoded string.
 * @returns A function that creates a {@link Hex.PlainHex | PlainHex} instance from a received string
 * ensuring that it meets `constraints`.
 * 
 * @category constructors
 */
export const ConstrainedPlainHex: (constraints: HexConstraints) => Brand.Brand.Constructor<Hex.PlainHex> =
  (constraints) => internal.make<Hex.PlainHex>({ requirePrefix: false, ...constraints });
  
/**
 * Describes constraints for creating {@link Hex} constructors that parse hex-encoded strings.
 *
 * @see {@link Hex}
 * @category models
 */
export interface HexConstraints {
  /**
   * An {@link IntegerRange.IntegerRangeInput | IntegerRangeInput} describing the minimum and maximum number
   * of bytes a hex-encoded string should represent.
   */
  readonly byteLength?: IntegerRange.IntegerRangeInput;
}

/**
 * The result of parsing a hex-encoded string.
 *
 * @see {@link parseHex}
 * @category models
 */
export interface ParsedHexString extends Inspectable {
  /**
   * A flag indicating if the hex-string has a `'0x'` prefix.
   */
  readonly hasPrefix: boolean;

  /**
   * The captured sequence of _whole_ bytes found in the source string.
   */
  readonly byteChars: string;

  /**
   * The remaining characters of incomplete bytes and/or the non hexadecimal characters found in the
   * source string.
   */
  readonly incompleteChars: string;
};

/**
 * Parses a hex-encoded string.
 *
 * @param source The source string to parse.
 * @returns An `Either` with a `Right` value of {@link ParsedHexString} describing the parsed elements of `source`,
 * or a `Left` value of {@link ParseError.ParseError | ParseError} if parsing fails.
 *
 * @category utilities
 */
export const parseHex: (source: string) => Either.Either<ParsedHexString, ParseError.ParseError> = internal.parseHex;

================
File: platform-js/platform-js/src/effect/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * as CoinPublicKey from './CoinPublicKey.js';
export * as Configuration from './Configuration.js';
export * as ContractAddress from './ContractAddress.js';
export * as DomainSeparator from './DomainSeparator.js';
export * as Hex from './Hex.js';
export * as IntegerRange from './IntegerRange.js';
export * as NetworkId from './NetworkId.js';
export * as NetworkIdMoniker from './NetworkIdMoniker.js';
export * as ParseError from './ParseError.js';
export * as SigningKey from './SigningKey.js';

================
File: platform-js/platform-js/src/effect/IntegerRange.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable @typescript-eslint/no-use-before-define */

import * as Equal from 'effect/Equal';
import * as equivalence from 'effect/Equivalence';
import { dual } from 'effect/Function';
import * as Hash from 'effect/Hash';
import { type Inspectable,NodeInspectSymbol } from 'effect/Inspectable';
import { type Pipeable,pipeArguments } from 'effect/Pipeable';
import { hasProperty, isNumber, isString } from 'effect/Predicate';

const TypeId: unique symbol = Symbol.for('platform-js/effect/IntegerRange');
export type TypeId = typeof TypeId;

/**
 * An integer range, bounded inclusively of its minimum value, and either inclusively or exclusively of
 * its maximum value.
 */
export interface IntegerRange extends Equal.Equal, Pipeable, Inspectable {
  readonly [TypeId]: TypeId;
  readonly value: IntegerRangeValue;
}

/**
 * Describes the internal structure of an {@link IntegerRange}.
 */
export type IntegerRangeValue =
  | { readonly _tag: 'Inclusive'; readonly min: number; readonly max: number }
  | { readonly _tag: 'Exclusive'; readonly min: number; readonly max: number };

/**
 * An input for constructing {@link IntegerRange} instances.
 * 
 * @remarks
 * The tuple form of {@link IntegerRangeInput}, when used with {@link from}, will create an
 * {@link IntegerRange} that is _exclusive_ of `max` ( i.e., `min <= x < max`). When used with {@link inclusive} or
 * {@link exclusive}, `max` will be _inclusive_ or _exclusive_ respectively.
 * 
 * The template string forms of {@link IntegerRangeInput} represent _inclusive_ or _exclusive_ ranges as follows:
 * - `'n..m'` will create a _exclusive_ range that contains all values `x` where `n <= x < m`, and
 * - `'n..=m'` will create an _inclusive_ range that contains all values `x` where `n <= x <= m`.
 */
export type IntegerRangeInput =
  | IntegerRange
  | readonly [min: number, max: number]
  | `${number}..${number}` // Exclusive.
  | `${number}..=${number}`; // Inclusive.

/**
 * Provides equivalence for {@link IntegerRange} instances.
 * 
 * @remarks
 * For two {@link IntegerRange} instances to be considered equal, both their minimum and maximum values
 * must be equal, and they should both have the same type of inclusion (i.e., inclusive or exclusive). This is
 * not _range equivalence_ which determines if two {@link IntegerRange} instances represent the same sequence
 * of values.
 *
 * @category equivalence
 */
export const Equivalence: equivalence.Equivalence<IntegerRange> =
  equivalence.struct({
    value: equivalence.struct({
      _tag: equivalence.string,
      min: equivalence.number,
      max: equivalence.number
    })
  });

/**
 * Determines if a value is an integer range.
 *
 * @param u The value to check.
 * @returns `true` if `u` is an {@link IntegerRange}; `false` otherwise.
 *
 * @category guards
 */
export const isIntegerRange = (u: unknown): u is IntegerRange => hasProperty(u, TypeId);

/**
 * Determines if an integer range will be _inclusive_ of its maximum value.
 *
 * @param self The {@link IntegerRange} to check.
 * @returns `true` if `self` is an inclusive {@link IntegerRange}; `false` otherwise.
 *
 * @category guards
 */
export const isInclusive = (self: IntegerRange): boolean => self.value._tag === 'Inclusive';

/**
 * Determines if an integer range will be _exclusive_ of its maximum value.
 *
 * @param self The {@link IntegerRange} to check.
 * @returns `true` if `self` is an exclusive {@link IntegerRange}; `false` otherwise.
 *
 * @category guards
 */
export const isExclusive = (self: IntegerRange): boolean => self.value._tag === 'Exclusive';

/**
 * Determines if two integer ranges are equal.
 *
 * @category predicates
 */
export const equals: {
  (that: IntegerRange): (self: IntegerRange) => boolean;
  (self: IntegerRange, that: IntegerRange): boolean;
} = dual(2, (self: IntegerRange, that: IntegerRange): boolean => Equivalence(self, that));

/**
 * Determines if an integer range is inclusive of a value.
 *
 * @category predicates
 */
export const contains: {
  (value: number): (self: IntegerRange) => boolean;
  (self: IntegerRange, value: number): boolean;
} = dual(2, (self: IntegerRange, value: number): boolean => {
  if (isInclusive(self)) {
    return contains(from([self.value.min, self.value.max + 1]), value);
  }
  const { min, max } = self.value;
  return value >= min && value < max;
});

/**
 * Creates _inclusive_ integer ranges.
 *
 * @category constructors
 */
export const inclusive: {
  /**
   * @param range A tuple defining the minimum and maximum values of the integer range.
   * @returns An {@link IntegerRange} that is _inclusive_ of its maximum value.
   */
  (range: readonly [min: number, max: number]): IntegerRange;
  /**
   * Creates an _inclusive_ integer range that is equivalent to a source {@link IntegerRange} with regards to
   * the values that it can contain.
   *
   * @param range The {@link IntegerRange} to use as a basis for an _inclusive_ integer range .
   * @returns `range`, if `range` is already an _inclusive_ integer range; otherwise, a new {@link IntegerRange} that
   * is an _inclusive_ version of `range`.
   */
  (range: IntegerRange): IntegerRange;
} = (range) => {
  if (isIntegerRange(range)) {
    return isInclusive(range)
      ? range // Already inclusive, return it.
      : make([range.value.min, range.value.max - 1], 'Inclusive');
  }
  return make(range, 'Inclusive');
};

/**
 * Creates _exclusive_ integer ranges.
 *
 * @category constructors
 */
export const exclusive: {
  /**
   * @param range A tuple defining the minimum and maximum values of the integer range.
   * @returns An {@link IntegerRange} that is _exclusive_ of its maximum value.
   */
  (range: readonly [min: number, max: number]): IntegerRange;
  /**
   * Creates an _exclusive_ integer range that is equivalent to a source {@link IntegerRange} with regards to
   * the values that it can contain.
   *
   * @param range The {@link IntegerRange} to use as a basis for an _exclusive_ integer range .
   * @returns `range`, if `range` is already an _exclusive_ integer range; otherwise, a new {@link IntegerRange} that
   * is an _exclusive_ version of `range`.
   */
  (range: IntegerRange): IntegerRange;
} = (range) => {
  if (isIntegerRange(range)) {
    return isExclusive(range)
      ? range // Already exclusive, return it.
      : make([range.value.min, range.value.max + 1], 'Exclusive');
  }
  return make(range, 'Exclusive');
};

/**
 * Creates an integer range.
 *
 * @param input The input to use when constructing the integer range.
 * @returns An {@link IntegerRange} derived from `input`.
 * 
 * @remarks
 * The tuple form of {@link IntegerRangeInput}, will create an {@link IntegerRange} that is _exclusive_
 * of `max` ( i.e., `min <= x < max`).
 *
 * @category constructors
 */
export const from: (input: IntegerRangeInput) => IntegerRange =
  (input) => make(input);

const RANGE_REGEXP = /(?<n>\d*)\.\.(?<inc>\=?)(?<x>\d*)/; // eslint-disable-line no-useless-escape
const DEFAULT_ARRAY_INPUT_MODE: IntegerRangeValue['_tag'] = 'Exclusive';

const IntegerRangeProto: Omit<IntegerRange, 'value'> = {
  [TypeId]: TypeId,
  [Hash.symbol](this: IntegerRange) {
    return Hash.cached(this, Hash.structure(this.value))
  },
  [Equal.symbol](this: IntegerRange, that: unknown) {
    return isIntegerRange(that) && equals(this, that)
  },
  toString(this: IntegerRange) {
    const { min, max, _tag } = this.value;
    const sep = _tag === 'Inclusive' ? '..=' : '..';
    return `${min}${sep}${max}`;
  },
  toJSON(this: IntegerRange) {
    return {
      _id: 'IntegerRange',
      ...this.value
    };
  },
  [NodeInspectSymbol](this: IntegerRange) {
    return this.toJSON()
  },
  pipe() {
    return pipeArguments(this, arguments); // eslint-disable-line prefer-rest-params
  }
}

const make = (input: IntegerRangeInput, arrayInputMode?: IntegerRangeValue['_tag']): IntegerRange => {
  const self = Object.create(IntegerRangeProto);
  if (isIntegerRange(input)) {
    self.value = input.value;
  }
  else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
    const [min, max] = input;
    self.value = {
      _tag: arrayInputMode ?? DEFAULT_ARRAY_INPUT_MODE,
      min,
      max
    };
  }
  else if (isString(input)) {
    const match = input.match(RANGE_REGEXP);
    if (!match || !match.groups) {
      throw new Error(`Invalid IntegerRange: ${input}`);
    }
    const { n, inc, x } = match.groups;
    const min = Number(n);
    const max = Number(x);
    if (!isNumber(min) || !isNumber(max)) {
      throw new TypeError(`Invalid IntegerRange: ${input}`);
    }
    self.value = {
      _tag: inc === '=' ? 'Inclusive' : 'Exclusive',
      min,
      max
    };
  }
  else {
    throw new Error('Invalid IntegerRange');
  }
  return self;
}

================
File: platform-js/platform-js/src/effect/NetworkId.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as Equal from 'effect/Equal';
import * as equivalence from 'effect/Equivalence';
import { dual } from 'effect/Function';
import { type Inspectable,NodeInspectSymbol } from 'effect/Inspectable';
import { hasProperty } from 'effect/Predicate';

import * as NetworkIdMoniker from './NetworkIdMoniker.js';

const MAINNET_MONIKER = NetworkIdMoniker.NetworkIdMoniker('main');

const TypeId: unique symbol = Symbol.for('platform-js/effect/NetworkId');
export type TypeId = typeof TypeId;

const MonikerSymbol: unique symbol = Symbol.for('platform-js/effect/NetworkId#NetworkMoniker');

/**
 * Represents a Midnight network identifier.
 * 
 * @remarks
 * A {@link NetworkId} can be constructed by calling {@link make} with a valid
 * {@link NetworkIdMoniker.NetworkIdMoniker | NetworkIdMoniker} identifying the network. Alternatively, in order
 * to use the Midnight MainNet, use the exported instance {@link MainNet}.
 * 
 * @see {@link NetworkIdInput}
 * @see {@link make}
 */
export interface NetworkId extends Equal.Equal, Inspectable {
  readonly [TypeId]: TypeId;
  readonly [MonikerSymbol]: NetworkIdMoniker.NetworkIdMoniker | true;
  /**
   * Determines if the network identifier represents the Midnight MainNet.
   *
   * @returns `true` if the {@link NetworkId} represents the Midnight MainNet; `false` otherwise.
   */
  readonly isMainNet: () => boolean;
}

/**
 * An input for constructing {@link NetworkId} instances.
 * 
 * @see {@link make}
 */
export type NetworkIdInput = NetworkIdMoniker.NetworkIdMoniker | NetworkId;

/**
 * Provides equivalence for {@link NetworkId} instances.
 *
 * @remarks
 * For two {@link NetworkId} instances to be considered equal, their underlying monikers must be equal.
 *
 * @category equivalence
 */
export const Equivalence: equivalence.Equivalence<NetworkId> =
  equivalence.mapInput(
    (a, b) => Equal.equals(a, b),
    (_) => _[MonikerSymbol]
  );

/**
 * Determines if a value is a network identifier.
 *
 * @param u The value to check.
 * @returns `true` if `u` is a {@link NetworkId}; `false` otherwise.
 *
 * @category guards
 */
export const isNetworkId = (u: unknown): u is NetworkId => hasProperty(u, TypeId);

/**
 * Determines if two network identifiers are equal.
 *
 * @category predicates
 */
export const equals: {
  (that: NetworkId): (self: NetworkId) => boolean;
  (self: NetworkId, that: NetworkId): boolean;
} = dual(2, (self: NetworkId, that: NetworkId): boolean => Equivalence(self, that));


const NetworkIdProto = (networkMoniker: string | true) => ({
  [TypeId]: TypeId,
  [Equal.symbol](this: NetworkId, that: unknown) {
    return isNetworkId(that) && equals(this, that)
  },
  toString(this: NetworkId) {
    return this[MonikerSymbol] === true
      ? MAINNET_MONIKER
      : this[MonikerSymbol];
  },
  toJSON(this: NetworkId) {
    return {
      _id: 'NetworkId',
      moniker: this.toString()
    };
  },
  [NodeInspectSymbol](this: NetworkId) {
    return this.toJSON()
  },
  [MonikerSymbol]: networkMoniker,
  isMainNet(this: NetworkId): boolean {
    return this[MonikerSymbol] === true;
  }
});

/**
 * A network identifier that represents the Midnight MainNet.
 */
export const MainNet: NetworkId = Object.create(NetworkIdProto(true));

/**
 * Creates a network identifier.
 *
 * @param input The input to use when constructing the network identifier.
 * @returns A {@link NetworkId} derived from `input`.
 *
 * @category constructors
 */
export const make: (input: NetworkIdInput) => NetworkId =
  (input) => Object.create(NetworkIdProto(isNetworkId(input) ? input[MonikerSymbol] : input));

================
File: platform-js/platform-js/src/effect/NetworkIdMoniker.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Brand, Option } from 'effect';

const NETWORK_ID_REGEXP = /^[a-zA-Z0-9-]+$/;

/**
 * A name, handle, or tag representing a familiar identifier given to an instance of a Midnight network.
 *
 * @category models
 */
export type NetworkIdMoniker = Brand.Branded<string, 'NetworkIdMoniker'>;

/**
 * @category constructors
 */
export const NetworkIdMoniker = Brand.refined<NetworkIdMoniker>(
  (source: string) => {
    return source.match(NETWORK_ID_REGEXP)
      ? Option.none()
      : Option.some(Brand.error(`Source string '${source}' is not a valid network identifier`));
  }
);

================
File: platform-js/platform-js/src/effect/ParseError.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as Error from '@effect/platform/Error';
import { type Inspectable } from 'effect/Inspectable';
import { hasProperty } from 'effect/Predicate';

const TypeId: unique symbol = Symbol.for('platform-js/effect/ParseError');
type TypeId = typeof TypeId;

/**
 * Error indicating a failure to parse some string value.
 *
 * @category errors
 */
export class ParseError extends Error.TypeIdError(TypeId, 'ParseError')<{
  /** A displayable message. */
  readonly message: string;

  /** The source string that failed to parse. */
  readonly source: string;

  /** Inspectable data about the parse operation.  */
  readonly meta?: Inspectable;

  /** The underlying cause of the failed parse operation.  */
  readonly cause?: unknown;
}> { }

/**
 * Determines if a value is a parse error.
 *
 * @param u The value to check.
 * @returns `true` if `u` is a {@link ParseError}; `false` otherwise.
 *
 * @category guards
 */
export const isParseError = (u: unknown): u is ParseError => hasProperty(u, TypeId);

/**
 * Creates a new `ParseError`.
 *
 * @category constructors
 */
export const make: {
  (message: string, source: string): ParseError;
  (message: string, source: string, meta: Inspectable): ParseError;
  (message: string, source: string, meta: Inspectable, cause: unknown): ParseError;
} = (message: string, source: string, meta?: Inspectable, cause?: unknown): ParseError =>
  new ParseError({
    message,
    source,
    meta,
    cause
  });

================
File: platform-js/platform-js/src/effect/SigningKey.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Brand } from 'effect';

import * as Hex from './Hex.js';

/**
 * A public BIP-340 signing key, 32 bytes in length, with an optional 3-byte version prefix.
 *
 * @remarks
 * A signing key is used to create a Contract Maintenance Authority (CMA) when initializing a new contract.
 * It is used to create a verifying key that is included in the contract deployment data that will
 * eventually be stored on the Midnight network.
 *
 * @category keys
 */
export type SigningKey = Brand.Branded<string, 'SigningKey'>;
export const SigningKey = Brand.all(
  Brand.nominal<SigningKey>(),
  Hex.ConstrainedPlainHex({ byteLength: '32..=35' })
);

================
File: platform-js/platform-js/src/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * from './effect/index.js';

================
File: platform-js/platform-js/test/effect/Arbitrary.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable @typescript-eslint/no-use-before-define */

import * as IntegerRange from '@midnight-ntwrk/platform-js/effect/IntegerRange';
import * as fc from 'effect/FastCheck';

export const makeNetworkIdArbitrary: () => fc.Arbitrary<string> =
  () => fc.stringMatching(/^(dev|test)-[0-9a-fA-F]{4,8}-0[1-9]$/);

export const makePlainHexArbitrary: (inputOrRange: IntegerRange.IntegerRangeInput | IntegerRange.IntegerRange) => fc.Arbitrary<string> =
  (inputOrRange) => fc.stringMatching(hexRegExp(inputOrRange));

export const makePrefixedHexArbitrary: (inputOrRange: IntegerRange.IntegerRangeInput | IntegerRange.IntegerRange) => fc.Arbitrary<string> =
  (inputOrRange) => fc.stringMatching(hexRegExp(inputOrRange, { includePrefix: true }));

export const makeHexArbitrary: (inputOrRange: IntegerRange.IntegerRangeInput | IntegerRange.IntegerRange) => fc.Arbitrary<string> =
  (inputOrRange) => fc.oneof(
    makePlainHexArbitrary(inputOrRange),
    makePrefixedHexArbitrary(inputOrRange)
  );

type HexRegExpOptions = {
  readonly includePrefix?: boolean;
}

const hexRegExp: (input: IntegerRange.IntegerRangeInput, options?: HexRegExpOptions) => RegExp =
  (input, options) => {
    const mergedOptions = { ...defaultHexRegExpOptions, ...options };
    const byteLength = IntegerRange.isIntegerRange(input)
      ? input
      : IntegerRange.from(input);
    const { min, max } = IntegerRange.inclusive(byteLength).value;
    return new RegExp(`^${mergedOptions.includePrefix ? '0x' : ''}([0-9a-fA-F]{2}){${min},${max}}$`);
  };

const defaultHexRegExpOptions: HexRegExpOptions = {
  includePrefix: false
}

================
File: platform-js/platform-js/test/effect/ContractAddress.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { describe, expect,it } from '@effect/vitest';
import * as ContractAddress from '@midnight-ntwrk/platform-js/effect/ContractAddress';
import * as fc from 'effect/FastCheck';

import * as Arbitrary from './Arbitrary.js';

describe('ContractAddress', () => {
    it('should parse plain addresses', () => fc.assert(
      fc.property(Arbitrary.makePlainHexArbitrary('32..=32'), (hex) => {
        expect(() => ContractAddress.ContractAddress(hex)).not.toThrowError();
      })
    ));

    it('should throw with short length plain addresses', () => fc.assert(
      fc.property(Arbitrary.makePlainHexArbitrary('2..32'), (hex) => {
        expect(() => ContractAddress.ContractAddress(hex)).toThrowError();
      })
    ));

    it('should throw with long length plain addresses', () => fc.assert(
      fc.property(Arbitrary.makePlainHexArbitrary('33..=50'), (hex) => {
        expect(() => ContractAddress.ContractAddress(hex)).toThrowError();
      })
    ));

    it('should throw with prefixed addresses', () => fc.assert(
      fc.property(Arbitrary.makePrefixedHexArbitrary('32..=32'), (hex) => {
        expect(() => ContractAddress.ContractAddress(hex)).toThrowError();
      })
    ));

    it('should throw with an invalid address', () => {
      expect(() => ContractAddress.ContractAddress('HOSKYA')).toThrowError();
    });
});

================
File: platform-js/platform-js/test/effect/Hex.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { describe, expect,it } from '@effect/vitest';
import * as Hex from '@midnight-ntwrk/platform-js/effect/Hex';
import * as ParseError from '@midnight-ntwrk/platform-js/effect/ParseError';
import { Effect } from 'effect';
import * as fc from 'effect/FastCheck';

import * as Arbitrary from './Arbitrary.js';

describe('Hex', () => {
  describe('parseHex', () => {
    it('should parse plain hex-encodings', () => fc.assert(
      fc.asyncProperty(Arbitrary.makePlainHexArbitrary('2..=10'), (hex) => Effect.gen(function* () {
        const result = yield* Hex.parseHex(hex);
        expect(result.hasPrefix).toBe(false);
        expect(result.byteChars).toEqual(hex);
        expect(result.incompleteChars.length).toBe(0);
      }).pipe(Effect.runPromise))
    ));

    it('should parse prefixed hex-encodings', () => fc.assert(
      fc.asyncProperty(Arbitrary.makePrefixedHexArbitrary('2..=10'), (hex) => Effect.gen(function* () {
        const result = yield* Hex.parseHex(hex);
        expect(result.hasPrefix).toBe(true);
        expect(result.byteChars).toEqual(hex.substring(2));
        expect(result.incompleteChars.length).toBe(0);
      }).pipe(Effect.runPromise))
    ));

    it.effect('should throw with an invalid hex-encoding', () => Effect.gen(function* () {
      const error = yield* Effect.flip(Hex.parseHex('HOSKYA'));
      expect(ParseError.isParseError(error)).toBeTruthy();
      expect(error).toMatchObject({
        message: 'Invalid hex-digit \'H\' found in source string at index 0'
      });
    }));
  });

  describe('PlainHex', () => {
    it('should parse plain hex-encodings', () => fc.assert(
      fc.property(Arbitrary.makePlainHexArbitrary('2..=10'), (hex) => {
        expect(() => Hex.PlainHex(hex)).not.toThrowError();
      })
    ));

    it('should throw with prefixed hex-encodings', () => fc.assert(
      fc.property(Arbitrary.makePrefixedHexArbitrary('2..=10'), (hex) => {
        expect(() => Hex.PlainHex(hex)).toThrowError();
      })
    ));
  });

  describe('PrefixedHex', () => {
    it('should parse prefixed hex-encodings', () => fc.assert(
      fc.property(Arbitrary.makePrefixedHexArbitrary('2..=10'), (hex) => {
        expect(() => Hex.PrefixedHex(hex)).not.toThrowError();
      })
    ));

    it('should throw with plain hex-encodings', () => fc.assert(
      fc.property(Arbitrary.makePlainHexArbitrary('2..=10'), (hex) => {
        expect(() => Hex.PrefixedHex(hex)).toThrowError();
      })
    ));
  });
});

================
File: platform-js/platform-js/test/effect/IntegerRange.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { describe, expect,it } from '@effect/vitest';
import * as IntegerRange from '@midnight-ntwrk/platform-js/effect/IntegerRange';

describe('IntegerRange', () => {
  describe('from', () => {
    it.each<IntegerRange.IntegerRangeInput>([
      [0, 10] as const,
      [10, 100] as const,
      '0..10',
      '10..100'
    ])('should create an exclusive range with exclusive input %o', (input: IntegerRange.IntegerRangeInput) => {
      const range = IntegerRange.from(input);

      expect(IntegerRange.isExclusive(range)).toBe(true);
      expect(IntegerRange.isInclusive(range)).toBe(false);
    });

    it.each<IntegerRange.IntegerRangeInput>([
      '0..=10',
      '10..=100'
    ])('should create an inclusive range with inclusive input %o', (input: IntegerRange.IntegerRangeInput) => {
      const range = IntegerRange.from(input);

      expect(IntegerRange.isExclusive(range)).toBe(false);
      expect(IntegerRange.isInclusive(range)).toBe(true);
    });
  });

  describe('equals', () => {
    it('should return true for two ranges equal by value', () => {
      const a = IntegerRange.from([0, 10]);
      const b = IntegerRange.exclusive([0, 10]);
      const c = IntegerRange.from('0..10');
      
      expect(IntegerRange.equals(a, b)).toBe(true);
      expect(IntegerRange.equals(a, c)).toBe(true);
    });

    it('should return false for two ranges different by value', () => {
      const a = IntegerRange.from([0, 10]);
      const b = IntegerRange.inclusive([0, 10]);
      const c = IntegerRange.from([0, 11]);
      
      expect(IntegerRange.equals(a, b)).toBe(false);
      expect(IntegerRange.equals(a, c)).toBe(false);
    });
  });

  describe('inclusive', () => {
    it('should create an inclusive range from component parts', () => {
      const range = IntegerRange.inclusive([0, 10]);

      expect(IntegerRange.isInclusive(range)).toBe(true);
      expect(IntegerRange.isExclusive(range)).toBe(false);
    });

    it('should return an already inclusive range', () => {
      const sourceRange = IntegerRange.from('0..=10');
      const range = IntegerRange.inclusive(sourceRange);

      expect(IntegerRange.isInclusive(range)).toBe(true);
      expect(IntegerRange.isExclusive(range)).toBe(false);
      expect(range).toBe(sourceRange);
      expect(IntegerRange.equals(sourceRange, range)).toBe(true);
    });

    it('should return an inclusive equivalent of an exclusive range', () => {
      const sourceRange = IntegerRange.from('0..10');
      const range = IntegerRange.inclusive(sourceRange);

      expect(IntegerRange.isInclusive(range)).toBe(true);
      expect(IntegerRange.isExclusive(range)).toBe(false);
      expect(range).not.toBe(sourceRange);
      expect(IntegerRange.equals(sourceRange, range)).not.toBe(true);
      // TODO: add rangeEquals
    });
  });

  describe('exclusive', () => {
    it('should create an inclusive range from component parts', () => {
      const range = IntegerRange.exclusive([0, 10]);

      expect(IntegerRange.isExclusive(range)).toBe(true);
      expect(IntegerRange.isInclusive(range)).toBe(false);
    });

    it('should return an already exclusive range', () => {
      const sourceRange = IntegerRange.from('0..10');
      const range = IntegerRange.exclusive(sourceRange);

      expect(IntegerRange.isExclusive(range)).toBe(true);
      expect(IntegerRange.isInclusive(range)).toBe(false);
      expect(range).toBe(sourceRange);
      expect(IntegerRange.equals(sourceRange, range)).toBe(true);
    });

    it('should return an exclusive equivalent of an inclusive range', () => {
      const sourceRange = IntegerRange.from('0..=10');
      const range = IntegerRange.exclusive(sourceRange);

      expect(IntegerRange.isExclusive(range)).toBe(true);
      expect(IntegerRange.isInclusive(range)).toBe(false);
      expect(range).not.toBe(sourceRange);
      expect(IntegerRange.equals(sourceRange, range)).not.toBe(true);
      // TODO: add rangeEquals
    });
  });

  describe('contains', () => {
    it('should return true for ranges inclusive of a given value', () => {
      const effectiveMax = 9;
      const a = IntegerRange.from([0, 10]);
      const b = IntegerRange.exclusive([0, 10]);
      const c = IntegerRange.inclusive([0, 9]);
      
      expect(IntegerRange.contains(a, effectiveMax)).toBe(true);
      expect(IntegerRange.contains(b, effectiveMax)).toBe(true);
      expect(IntegerRange.contains(c, effectiveMax)).toBe(true);
    });
  });
});

================
File: platform-js/platform-js/test/effect/NetworkId.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { describe, expect,it } from '@effect/vitest';
import * as NetworkId from '@midnight-ntwrk/platform-js/effect/NetworkId';
import * as fc from 'effect/FastCheck';

import * as Arbitrary from './Arbitrary.js';

describe('NetworkId', () => {
  describe('isMainNet', () => {
    it('should return true for MainNet', () => {
      expect(NetworkId.MainNet.isMainNet()).toBe(true);
    });
    
    it('should return false for any named network identifier', () => fc.assert(
      fc.property(Arbitrary.makeNetworkIdArbitrary(), (networkId) => {
        expect(NetworkId.make(networkId).isMainNet()).toBe(false);
      })
    ));
  });

  describe('equals', () => {
    it('should return true for two network identifiers equal by name', () => {
      const a = NetworkId.make('hosky-dev01');
      const b = NetworkId.make('hosky-dev01');

      expect(NetworkId.equals(a, b)).toBe(true);
    });

    it('should return false for two network identifiers that differ by name', () => {
      const a = NetworkId.make('hosky-dev01');
      const b = NetworkId.make('hosky-dev02');

      expect(NetworkId.equals(a, b)).toBe(false);
    });
  });
});

================
File: platform-js/platform-js/test/effect/NetworkIdMoniker.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { describe, expect,it } from '@effect/vitest';
import * as NetworkIdMoniker from '@midnight-ntwrk/platform-js/effect/NetworkIdMoniker';
import * as fc from 'effect/FastCheck';

import * as Arbitrary from './Arbitrary.js';

describe('NetworkIdMoniker', () => {
  it('should not throw for valid identifiers', () => fc.assert(
    fc.property(Arbitrary.makeNetworkIdArbitrary(), (networkId) => {
      expect(() => NetworkIdMoniker.NetworkIdMoniker(networkId)).not.toThrow();
    })
  ));

  it.each([
    'hosky!dev',
    'hosky_dev_01',
    '!@&^*'
  ])('should throw for invalid identifiers (%s)', (networkId) => {
    expect(() => NetworkIdMoniker.NetworkIdMoniker(networkId)).toThrow();
  });
});

================
File: platform-js/platform-js/LICENSE
================
Copyright 2025 Midnight Foundation

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

================
File: platform-js/platform-js/README.md
================
# Platform.js

## Introduction

Provides a set of core abstractions, utilities, and types for building services and libraries that work with the
Midnight blockchain.

================
File: platform-js/platform-js/tsconfig.build.json
================
{
  "extends": "./tsconfig.src.json",
  "compilerOptions": {
    "tsBuildInfoFile": ".tsbuildinfo/build.tsbuildinfo",
    "outDir": "build/esm",
    "declarationDir": "build/dts",
    "stripInternal": true
  }
}

================
File: platform-js/platform-js/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [
    { "path": "./tsconfig.src.json" },
    { "path": "./tsconfig.test.json" }
  ]
}

================
File: platform-js/platform-js/tsconfig.src.json
================
{
  "extends": "../../tsconfig.base.json",
  "include": ["src"],
  "compilerOptions": {
    "tsBuildInfoFile": ".tsbuildinfo/src.tsbuildinfo",
    "rootDir": "src",
    "outDir": "build/src"
  }
}

================
File: platform-js/platform-js/tsconfig.test.json
================
{
  "extends": "../../tsconfig.base.json",
  "include": ["test"],
  "references": [
    { "path": "tsconfig.src.json" },
  ],
  "compilerOptions": {
    "tsBuildInfoFile": ".tsbuildinfo/test.tsbuildinfo",
    "rootDir": "test",
    "noEmit": true
  }
}

================
File: platform-js/platform-js/vitest.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// <reference types="vitest" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    include: ['test/**/*.test.ts'],
    exclude: ['node_modules', 'dist'],
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage'
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }]
    ]
  }
});

================
File: platform-js/README.md
================
# Platform.js

## Introduction

Provides a set of core abstractions, utilities, and types for building services and libraries that work with the
Midnight blockchain.

================
File: testkit-js/testkit-js/src/client/faucet-client.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import axios from 'axios';
import type { Logger } from 'pino';

import { extractHostnameAndPort } from '@/utils';

/**
 * Client for interacting with the Midnight faucet service.
 * Provides functionality to request test tokens for wallet addresses.
 */
export class FaucetClient {
  readonly faucetUrl: string;
  private logger: Logger;

  /**
   * Creates a new FaucetClient instance.
   * @param {string} faucetUrl - The URL of the faucet service endpoint
   * @param {Logger} logger - Logger instance for recording operations
   */
  constructor(faucetUrl: string, logger: Logger) {
    this.faucetUrl = faucetUrl;
    this.logger = logger;
  }

  /**
   * Checks the health status of the faucet service.
   * Makes a GET request to the health endpoint of the faucet service.
   * @returns {Promise<AxiosResponse | void>} A promise that resolves to the response of the health check or logs an error if the request fails
   */
  async health() {
    const url = `https://${extractHostnameAndPort(this.faucetUrl)}/api/health`;
    return axios
      .get(url, { timeout: 1000 })
      .then((r) => {
        this.logger.info(`Connected to faucet ${url}: ${JSON.stringify(r.data)}`);
        return r;
      })
      .catch((error) => {
        this.logger.warn(`Failed to connect to faucet service at '${url}'`, error);
      });
  }

  /**
   * Requests test tokens from the faucet for a specified wallet address.
   * Makes a POST request to the faucet service with the wallet address.
   * @param {string} walletAddress - The address to receive the test tokens
   * @returns {Promise<void>} A promise that resolves when the request is complete
   * @throws Will log but not throw if the request fails
   */
  async requestTokens(walletAddress: string): Promise<void> {
    this.logger.info(`Requesting tokens from '${this.faucetUrl}' for address: '${walletAddress}'`);
    try {
      const response = await axios.post(
        this.faucetUrl,
        {
          address: walletAddress,
          captchaToken: 'XXXX.DUMMY.TOKEN.XXXX'
        },
        {
          headers: {
            'Content-Type': 'application/json',
            'x-turnstile-token': process.env.TURNSTILE_HEADER ?? ''
          }
        }
      );
      this.logger.info(`Faucet response: ${response.statusText}`);
    } catch (error) {
      if (error instanceof Error) {
        this.logger.error(`Error requesting tokens: ${error.message}`);
      } else {
        this.logger.error(`Error requesting tokens`);
      }
    }
  }
}

================
File: testkit-js/testkit-js/src/client/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * from './faucet-client';
export * from './indexer-client';
export * from './node-client';
export * from './proof-server-client';

================
File: testkit-js/testkit-js/src/client/indexer-client.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import axios from 'axios';
import type { Logger } from 'pino';

import { extractHostnameAndPort } from '@/utils';

export class IndexerClient {
  readonly indexerUrl: string;
  private logger: Logger;

  /**
   * Creates an instance of IndexerClient.
   * @param {string} indexerUrl - The URL of the indexer service.
   * @param {Logger} logger - The logger instance for logging information.
   */
  constructor(indexerUrl: string, logger: Logger) {
    this.indexerUrl = indexerUrl;
    this.logger = logger;
  }

  /**
   * Checks the health status of the indexer service.
   * Makes a GET request to the status endpoint of the indexer service.
   * @returns {Promise<AxiosResponse | void>} A promise that resolves to the response of the health check or logs an error if the request fails.
   */
  async health() {
    const url = `https://${extractHostnameAndPort(this.indexerUrl)}/ready`;
    return axios
      .get(url, { timeout: 1000 })
      .then((r) => {
        this.logger.info(`Connected to indexer ${url}: ${JSON.stringify(r.data)}`);
        return r;
      })
      .catch((error) => {
        this.logger.warn(`Failed to connect to indexer at '${url}'`, error);
      });
  }
}

================
File: testkit-js/testkit-js/src/client/node-client.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ContractAddress } from '@midnight-ntwrk/compact-runtime';
import { ContractState, LedgerState } from '@midnight-ntwrk/ledger-v6';
import { getNetworkId } from '@midnight-ntwrk/midnight-js-network-id';
import type { BlockHash } from '@midnight-ntwrk/midnight-js-types';
import axios, { type AxiosResponse } from 'axios';
import type { Logger } from 'pino';

import { extractHostnameAndPort } from '@/utils';

/**
 * Client for interacting with a Midnight node's JSON-RPC API
 */
export class NodeClient {
  readonly nodeURL: string;
  private logger: Logger;

  /**
   * Creates a new NodeClient instance
   * @param {string} nodeURL - URL of the Midnight node
   * @param {Logger} logger - Logger instance for recording operations
   */
  constructor(nodeURL: string, logger: Logger) {
    this.nodeURL = nodeURL;
    this.logger = logger;
  }

  /**
   * Checks the health status of the node.
   * Makes a GET request to the health endpoint of the node.
   * @returns {Promise<AxiosResponse | void>} A promise that resolves to the response of the health check or logs an error if the request fails.
   */
  async health() {
    const url = `https://${extractHostnameAndPort(this.nodeURL)}/health`;
    return axios
      .get(url, { timeout: 1000 })
      .then((r) => {
        this.logger.info(`Connected to node ${url}: ${JSON.stringify(r.data)}`);
        return r;
      })
      .catch((error) => {
        this.logger.warn(`Failed to connect to node at '${url}'`, error);
      });
  }

  /**
   * Validates response format and throws if unexpected
   * @param {AxiosResponse} response - Response from node API
   * @throws {Error} If response format is unexpected
   * @private
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private static throwOnUnexpected(response: AxiosResponse<any, any>): void {
    if (typeof response.data !== 'object' || !response.data.result || typeof response.data.result !== 'string') {
      throw new Error(`Unexpected response format: ${JSON.stringify(response.data)}`);
    }
  }

  /**
   * Makes a JSON-RPC request to the node
   * @param {string} method - RPC method name
   * @param {any[]} params - RPC method parameters
   * @returns {Promise<string>} Response result as string
   * @private
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private async jsonRPC(method: string, params: any[]): Promise<string> {
    const response = await axios.post(
      this.nodeURL,
      {
        id: 1,
        jsonrpc: '2.0',
        method,
        params
      },
      {
        headers: {
          'Content-Type': 'application/json'
        }
      }
    );
    this.logger.info(`Node response: ${response.statusText}`);
    NodeClient.throwOnUnexpected(response);
    return response.data.result;
  }

  /**
   * Fetches the state of a contract
   * @param {ContractAddress} contractAddress - Address of the contract
   * @returns {Promise<ContractState | null>} Contract state or null if not found
   */
  async contractState(contractAddress: ContractAddress): Promise<ContractState | null> {
    this.logger.info(`Fetching contract state for address '${contractAddress}'`);
    const result = await this.jsonRPC('midnight_contractState', [
      `${getNetworkId()}${contractAddress}`
    ]);
    return result === '' ? null : ContractState.deserialize(Buffer.from(result, 'hex'));
  }

  /**
   * Fetches the ledger state at a given block
   * @param {BlockHash} blockHash - Hash of the block
   * @returns {Promise<LedgerState>} Ledger state
   */
  async ledgerState(blockHash: BlockHash): Promise<LedgerState> {
    const blob = await this.ledgerStateBlob(blockHash);
    return LedgerState.deserialize(blob);
  }

  /**
   * Fetches the raw ledger state blob at a given block
   * @param {BlockHash} blockHash - Hash of the block
   * @returns {Promise<Uint8Array>} Raw ledger state data
   * @throws {Error} If no ledger state is found
   */
  async ledgerStateBlob(blockHash: BlockHash): Promise<Uint8Array> {
    this.logger.info(`Fetching ledger state at block hash '${blockHash}'`);
    const result = await this.jsonRPC('midnight_getLedgerState', []);
    if (result === '') {
      throw new Error(`No ledger state found at block hash '${blockHash}'`);
    }
    return Buffer.from(result.slice(4), 'hex');
  }

  /**
   * Fetches the ledger version at a given block
   * @param {BlockHash} blockHash - Hash of the block
   * @returns {Promise<string>} Ledger version
   * @throws {Error} If no ledger version is found
   */
  async ledgerVersion(blockHash: BlockHash): Promise<string> {
    this.logger.info(`Fetching ledger version at block hash '${blockHash}'`);
    const result = await this.jsonRPC('midnight_ledgerVersion', []);
    if (result === '') {
      throw new Error(`No ledger version found at block hash '${blockHash}'`);
    }
    return result;
  }
}

================
File: testkit-js/testkit-js/src/client/proof-server-client.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import axios, { type AxiosRequestConfig } from 'axios';
import type { Logger } from 'pino';

import { extractHostnameAndPort } from '@/utils';

export class ProofServerClient {
  readonly proofServer: string;
  private logger: Logger;

  /**
   * Creates an instance of ProofServerClient.
   * @param {string} proofServer - The URL of the proof server service.
   * @param {Logger} logger - The logger instance for logging information.
   */
  constructor(proofServer: string, logger: Logger) {
    this.proofServer = proofServer;
    this.logger = logger;
  }

  /**
   * Checks the health status of the indexer service.
   * Makes a GET request to the status endpoint of the indexer service.
   * @returns {Promise<AxiosResponse | void>} A promise that resolves to the response of the health check or logs an error if the request fails.
   */
  async health() {
    const url = `http://${extractHostnameAndPort(this.proofServer)}/health`;
    return axios
      .get(url, { timeout: 1000 })
      .then((r) => {
        this.logger.info(`Connected to proof server ${url}: ${JSON.stringify(r.data)}`);
        return r;
      })
      .catch((error) => {
        this.logger.warn(`Failed to connect to proof server at '${url}'`, error);
      });
  }

  /**
   * Proves a transaction by sending a POST request to the proof server.
   * @param data serialized transaction data
   * @param config Axios request configuration
   */
  async proveTx(
    data?: ArrayBuffer,
    config: AxiosRequestConfig = {
      timeout: 3 * 60_000
    }
  ) {
    const url = `http://${extractHostnameAndPort(this.proofServer)}/prove-tx`;
    return axios
      .post(url, data, config)
      .then((r) => {
        this.logger.info(`Received data from proof server ${url}`);
        return r;
      })
      .catch((error) => {
        this.logger.error(`Error in proof server at '${url}' ${error.toString()}`);
      });
  }
}

================
File: testkit-js/testkit-js/src/contract/contract-types.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Configuration interface for Midnight contracts.
 */
export interface ContractConfiguration {
  /**
   * Name of the store used for persisting private state data.
   * This is used as a base name - a signing key store will also be created with "-signing-keys" appended.
   */
  readonly privateStateStoreName: string;

  /**
   * File system path to the zero-knowledge proof configuration files.
   * This should point to the directory containing the circuit verification keys and other ZK artifacts.
   */
  readonly zkConfigPath: string;
}

================
File: testkit-js/testkit-js/src/contract/in-memory-private-state-provider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { SigningKey } from '@midnight-ntwrk/compact-runtime';
import type { ContractAddress } from '@midnight-ntwrk/ledger-v6';
import {
  type Contract,
  type PrivateState,
  type PrivateStateId,
  type PrivateStateProvider} from '@midnight-ntwrk/midnight-js-types';

/**
 * A simple in-memory implementation of private state provider. Makes it easy to capture and rewrite private state from deploy.
 * @template PSI - Type of the private state identifier.
 * @template PS - Type of the private state.
 * @returns {PrivateStateProvider<PSI, PS>} An in-memory private state provider.
 */
export const inMemoryPrivateStateProvider = <
  PSI extends PrivateStateId,
  PS extends PrivateState<Contract>
>(): PrivateStateProvider<PSI, PS> => {
  const record = new Map<PSI, PS>();
  const signingKeys = {} as Record<ContractAddress, SigningKey>;

  return {
    /**
     * Sets the private state for a given key.
     * @param {PSI} key - The key for the private state.
     * @param {PS} state - The private state to set.
     * @returns {Promise<void>} A promise that resolves when the state is set.
     */
    set(key: PSI, state: PS): Promise<void> {
      record.set(key, state);
      return Promise.resolve();
    },
    /**
     * Gets the private state for a given key.
     * @param {PSI} key - The key for the private state.
     * @returns {Promise<PS | null>} A promise that resolves to the private state or null if not found.
     */
    get(key: PSI): Promise<PS | null> {
      const value = record.get(key) ?? null;
      return Promise.resolve(value);
    },
    /**
     * Removes the private state for a given key.
     * @param {PSI} key - The key for the private state.
     * @returns {Promise<void>} A promise that resolves when the state is removed.
     */
    remove(key: PSI): Promise<void> {
      record.delete(key);
      return Promise.resolve();
    },
    /**
     * Clears all private states.
     * @returns {Promise<void>} A promise that resolves when all states are cleared.
     */
    clear(): Promise<void> {
      record.clear();
      return Promise.resolve();
    },
    /**
     * Sets the signing key for a given contract address.
     * @param {ContractAddress} contractAddress - The contract address.
     * @param {SigningKey} signingKey - The signing key to set.
     * @returns {Promise<void>} A promise that resolves when the signing key is set.
     */
    setSigningKey(contractAddress: ContractAddress, signingKey: SigningKey): Promise<void> {
      signingKeys[contractAddress] = signingKey;
      return Promise.resolve();
    },
    /**
     * Gets the signing key for a given contract address.
     * @param {ContractAddress} contractAddress - The contract address.
     * @returns {Promise<SigningKey | null>} A promise that resolves to the signing key or null if not found.
     */
    getSigningKey(contractAddress: ContractAddress): Promise<SigningKey | null> {
      const value = signingKeys[contractAddress] ?? null;
      return Promise.resolve(value);
    },
    /**
     * Removes the signing key for a given contract address.
     * @param {ContractAddress} contractAddress - The contract address.
     * @returns {Promise<void>} A promise that resolves when the signing key is removed.
     */
    removeSigningKey(contractAddress: ContractAddress): Promise<void> {
      delete signingKeys[contractAddress];
      return Promise.resolve();
    },
    /**
     * Clears all signing keys.
     * @returns {Promise<void>} A promise that resolves when all signing keys are cleared.
     */
    clearSigningKeys(): Promise<void> {
      Object.keys(signingKeys).forEach((contractAddress) => {
        delete signingKeys[contractAddress];
      });
      return Promise.resolve();
    }
  };
};

================
File: testkit-js/testkit-js/src/contract/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * from './contract-types';
export * from './in-memory-private-state-provider';
export * from './providers';

================
File: testkit-js/testkit-js/src/contract/providers.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { httpClientProofProvider } from '@midnight-ntwrk/midnight-js-http-client-proof-provider';
import { indexerPublicDataProvider } from '@midnight-ntwrk/midnight-js-indexer-public-data-provider';
import { levelPrivateStateProvider } from '@midnight-ntwrk/midnight-js-level-private-state-provider';
import { NodeZkConfigProvider } from '@midnight-ntwrk/midnight-js-node-zk-config-provider';
import { type MidnightProviders, type PrivateStateId } from '@midnight-ntwrk/midnight-js-types';

import { type EnvironmentConfiguration } from '@/test-environment';
import { type MidnightWalletProvider } from '@/wallet';

import { type ContractConfiguration } from './contract-types';

/**
 * Configures and returns the required providers for a Midnight contract.
 *
 * @template ICK - Type parameter for the input circuit key string
 * @template PS - Type parameter for the private state
 *
 * @param {MidnightWalletProvider} midnightWalletProvider - The midnightWalletProvider provider instance to use for transactions
 * @param {EnvironmentConfiguration} environmentConfiguration - Configuration for the environment including indexer and proof server details
 * @param {ContractConfiguration} contractConfiguration - Configuration specific to the contract including storage names and ZK config path
 *
 * @returns {MidnightProviders} An object containing all configured providers:
 *   - privateStateProvider: For managing private contract state
 *   - publicDataProvider: For accessing public blockchain data
 *   - zkConfigProvider: For zero-knowledge proof configurations
 *   - proofProvider: For generating and verifying proofs
 *   - walletProvider: For midnightWalletProvider operations
 *   - midnightProvider: For Midnight-specific operations
 */
export const initializeMidnightProviders = <ICK extends string, PS>(
  midnightWalletProvider: MidnightWalletProvider,
  environmentConfiguration: EnvironmentConfiguration,
  contractConfiguration: ContractConfiguration
): MidnightProviders<ICK, PrivateStateId, PS> => {
  return {
    privateStateProvider: levelPrivateStateProvider<PrivateStateId, PS>({
      privateStateStoreName: contractConfiguration.privateStateStoreName,
      signingKeyStoreName: `${contractConfiguration.privateStateStoreName}-signing-keys`
    }),
    publicDataProvider: indexerPublicDataProvider(environmentConfiguration.indexer, environmentConfiguration.indexerWS),
    zkConfigProvider: new NodeZkConfigProvider<ICK>(contractConfiguration.zkConfigPath),
    proofProvider: httpClientProofProvider(environmentConfiguration.proofServer),
    walletProvider: midnightWalletProvider,
    midnightProvider: midnightWalletProvider
  };
};

================
File: testkit-js/testkit-js/src/test-environment/test-environments/env-var-remote-test-environment.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';

import {
  MN_TEST_FAUCET,
  MN_TEST_INDEXER,
  MN_TEST_INDEXER_WS,
  MN_TEST_NETWORK_ID,
  MN_TEST_NODE,
  MN_TEST_NODE_WS,
  MN_TEST_WALLET_NETWORK_ID
} from '@/env-vars';
import { MissingEnvironmentVariable } from '@/errors';
import type { EnvironmentConfiguration } from '@/test-environment';

import { RemoteTestEnvironment } from './remote-test-environment';

/**
 * List of required environment variables that must be set for this test environment
 */
const MN_REQUIRED_ENVIRONMENT_VARIABLES = ['MN_TEST_INDEXER', 'MN_TEST_INDEXER_WS', 'MN_TEST_NODE', 'MN_TEST_NODE_WS', 'MN_TEST_NETWORK_ID'];

/**
 * Test environment that configures services using environment variables.
 * Allows specifying custom endpoints through environment variables.
 */
export class EnvVarRemoteTestEnvironment extends RemoteTestEnvironment {
  /**
   * Returns the configuration for environment services based on environment variables.
   * Required environment variables:
   * - MN_TEST_NETWORK_ID: Network identifier (e.g., 'testnet', 'devnet')
   * - MN_TEST_INDEXER: GraphQL API endpoint for the indexer
   * - MN_TEST_INDEXER_WS: WebSocket endpoint for the indexer
   * - MN_TEST_NODE: RPC endpoint for the blockchain node
   * Optional environment variables:
   * - MN_TEST_FAUCET: API endpoint for requesting test tokens
   * @returns {EnvironmentConfiguration} Object containing service URLs from environment variables
   * @throws {MissingEnvironmentVariable} If any required environment variable is not set
   */
  getEnvironmentConfiguration(): EnvironmentConfiguration {
    // Throw is any of the required MN_* environment variables are missing.
    MN_REQUIRED_ENVIRONMENT_VARIABLES.forEach((envVar) => {
      if (!process.env[envVar]) {
        throw new MissingEnvironmentVariable(envVar);
      }
    });
    return {
      walletNetworkId: MN_TEST_WALLET_NETWORK_ID as NetworkId.NetworkId,
      networkId: MN_TEST_NETWORK_ID as string,
      indexer: MN_TEST_INDEXER as string,
      indexerWS: MN_TEST_INDEXER_WS as string,
      node: MN_TEST_NODE as string,
      nodeWS: MN_TEST_NODE_WS as string,
      faucet: MN_TEST_FAUCET,
      proofServer: this.proofServerContainer?.getUrl()
    };
  }
}

================
File: testkit-js/testkit-js/src/test-environment/test-environments/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * from './env-var-remote-test-environment';
export * from './local-test-environment';
export * from './qanet-test-environment';
export * from './remote-test-environment';
export * from './test-environment';
export * from './testnet2-test-environment';

================
File: testkit-js/testkit-js/src/test-environment/test-environments/local-test-environment.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { getNetworkId } from '@midnight-ntwrk/midnight-js-network-id';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import type { Logger } from 'pino';
import { DockerComposeEnvironment, type StartedDockerComposeEnvironment } from 'testcontainers';

import { getContainersConfiguration } from '@/configuration';
import type { StandaloneContainersConfiguration } from '@/configuration-types';
import { getEnvVarWalletSeeds } from '@/env-vars';
import type { ProofServerContainer } from '@/proof-server-container';
import type { EnvironmentConfiguration } from '@/test-environment';
import { MidnightWalletProvider } from '@/wallet';

import { TestEnvironment } from './test-environment';

/**
 * Configuration for component ports in the local test environment
 */
export type ComponentPortsConfiguration = {
  indexer: number;
  node: number;
  proofServer: number;
}

/**
 * Configuration class for local test environment implementing EnvironmentConfiguration
 */
export class LocalTestConfiguration implements EnvironmentConfiguration {
  readonly walletNetworkId: NetworkId.NetworkId;
  readonly networkId: string;
  readonly indexer: string;
  readonly indexerWS: string;
  readonly node: string;
  readonly nodeWS: string;
  readonly proofServer: string;
  readonly faucet: string | undefined;

  /**
   * Creates a new LocalTestConfiguration instance
   * @param {ComponentPortsConfiguration} ports - Object containing port numbers for each component
   */
  constructor({ indexer, node, proofServer }: ComponentPortsConfiguration) {
    this.walletNetworkId = NetworkId.NetworkId.Undeployed;
    this.networkId = 'undeployed';
    this.indexer = `http://127.0.0.1:${indexer}/api/v3/graphql`;
    this.indexerWS = `ws://127.0.0.1:${indexer}/api/v3/graphql/ws`;
    this.node = `http://127.0.0.1:${node}`;
    this.nodeWS = `ws://127.0.0.1:${node}`;
    this.proofServer = `http://127.0.0.1:${proofServer}`;
    this.faucet = undefined;
  }
}

/**
 * Test environment for local development using Docker containers
 * Manages containers for node, indexer and proof server components
 */
export class LocalTestEnvironment extends TestEnvironment {
  static readonly MAX_NUMBER_OF_WALLETS = 4;
  readonly genesisMintWalletSeed = [
    '0000000000000000000000000000000000000000000000000000000000000002',
    '0000000000000000000000000000000000000000000000000000000000000001',
    '0000000000000000000000000000000000000000000000000000000000000003',
    '0000000000000000000000000000000000000000000000000000000000000004'
  ];

  private config: StandaloneContainersConfiguration;
  private environmentConfiguration: EnvironmentConfiguration;
  public dockerEnv: StartedDockerComposeEnvironment;
  private walletProviders: MidnightWalletProvider[];

  /**
   * Creates a new LocalTestEnvironment instance
   * @param {Logger} logger - Logger instance for recording operations
   */
  constructor(logger: Logger) {
    super(logger);
    this.config = getContainersConfiguration().standalone;
  }

  /**
   * Returns the configuration for the testnet environment services.
   * @returns {EnvironmentConfiguration} Object containing URLs for testnet services:
   * - indexer: GraphQL API endpoint for the indexer
   * - indexerWS: WebSocket endpoint for the indexer
   * - node: RPC endpoint for the blockchain node
   * - faucet: API endpoint for requesting test tokens
   * - proofServer: URL for the proof generation server
   */
  getEnvironmentConfiguration(): EnvironmentConfiguration {
    return {
      walletNetworkId: this.environmentConfiguration?.walletNetworkId,
      networkId: this.environmentConfiguration?.networkId,
      indexer: this.environmentConfiguration?.indexer,
      indexerWS: this.environmentConfiguration?.indexerWS,
      node: this.environmentConfiguration?.node,
      nodeWS: this.environmentConfiguration?.nodeWS,
      faucet: this.environmentConfiguration?.faucet,
      proofServer: this.environmentConfiguration?.proofServer
    };
  }

  /**
   * Gets the mapped ports for all containers in the environment
   * @returns {ComponentPortsConfiguration} Object containing mapped port numbers
   * @private
   */
  private getMappedPorts = (): { indexer: number; node: number; proofServer: number } => ({
    indexer: this.dockerEnv
      .getContainer(`${this.config.container.indexer.name}_${this.uid}`)
      .getMappedPort(this.config.container.indexer.port),
    node: this.dockerEnv
      .getContainer(`${this.config.container.node.name}_${this.uid}`)
      .getMappedPort(this.config.container.node.port),
    proofServer: this.dockerEnv
      .getContainer(`${this.config.container.proofServer.name}_${this.uid}`)
      .getMappedPort(this.config.container.proofServer.port)
  });

  /**
   * Instead of starting the test environment by building the docker containers
   * from the default configuration files in this package, start the test environment
   * by passing an existing {@link StartedDockerComposeEnvironment} along with the
   * ports for the containers in the environment.
   *
   * @param {StartedDockerComposeEnvironment} dockerEnv - A started docker compose environment
   * @param {ComponentPortsConfiguration} ports - The ports of the containers in the given environment
   * @returns {Promise<EnvironmentConfiguration>} The environment configuration
   */
  startWithInjectedEnvironment = async (
    dockerEnv: StartedDockerComposeEnvironment,
    ports: ComponentPortsConfiguration
  ): Promise<EnvironmentConfiguration> => {
    this.logger.info(`Starting test environment...`);
    this.dockerEnv = dockerEnv;
    this.environmentConfiguration = new LocalTestConfiguration(ports);
    this.logger.info(`Test environment configuration: ${JSON.stringify(this.environmentConfiguration)}`);
    return this.environmentConfiguration;
  };

  /**
   * Starts the test environment by creating and configuring Docker containers
   * @param {ProofServerContainer} maybeProofServerContainer - Optional proof server container
   * @returns {Promise<EnvironmentConfiguration>} The environment configuration
   * @throws {Error} If trying to inject proof server container when starting new environment
   */
  start = async (maybeProofServerContainer?: ProofServerContainer) => {
    this.logger.info(
      `Starting test environment... path=${this.config.path}, file=${this.config.fileName}, uid=${this.uid}`
    );
    if (maybeProofServerContainer) {
      throw new Error(
        'Invalid usage, trying to inject proof server container instance when starting new test environment with another proof server...'
      );
    }
    this.dockerEnv = await new DockerComposeEnvironment(this.config.path, this.config.fileName)
      .withWaitStrategy(
        `${this.config.container.proofServer.name}_${this.uid}`,
        this.config.container.proofServer.waitStrategy
      )
      .withWaitStrategy(`${this.config.container.node.name}_${this.uid}`, this.config.container.node.waitStrategy)
      .withWaitStrategy(`${this.config.container.indexer.name}_${this.uid}`, this.config.container.indexer.waitStrategy)
      .withEnvironment({
        TESTCONTAINERS_UID: this.uid,
        NETWORK_ID: getNetworkId()
      })
      .up();
    this.environmentConfiguration = new LocalTestConfiguration(this.getMappedPorts());
    this.logger.info(`Test environment configuration: ${JSON.stringify(this.environmentConfiguration)}`);
    return this.environmentConfiguration;
  };

  /**
   * Shuts down the test environment, closing walletProviders and stopping containers
   * @returns {Promise<void>}
   */
  shutdown = async (saveWalletState?: boolean) => {
    this.logger.info(`Shutting down test environment...`);
    if (this.walletProviders) {
      if (saveWalletState) {
        this.logger.warn('Skipping wallet save state as it is obsolete in this context...');
      }
      await Promise.all(this.walletProviders.map((wallet) => wallet.stop()));
    }
    if (this.dockerEnv) {
      await this.dockerEnv.down({ timeout: 10000, removeVolumes: true });
    }
  };

  /**
   * Creates and starts the specified number of wallet providers
   * @throws {Error} If requested amount exceeds maximum supported walletProviders
   * @returns {Promise<MidnightWalletProvider[]>} A promise that resolves to an array of started wallets
   */
  startMidnightWalletProviders = async (
    amount = 1,
    seeds: string[] | undefined = getEnvVarWalletSeeds()
  ): Promise<MidnightWalletProvider[]> => {
    this.logger.info(`Getting ${amount} wallets...`);
    if (seeds) {
      this.logger.warn('Provided seeds will be ignored, using genesis mint wallet seeds');
    }
    if (amount > LocalTestEnvironment.MAX_NUMBER_OF_WALLETS) {
      throw new Error(
        `Maximum supported number of wallets for this environment reached: ${LocalTestEnvironment.MAX_NUMBER_OF_WALLETS}`
      );
    }
    this.walletProviders = await Promise.all(
      Array.from({ length: amount }).map((_elem, index) =>
        MidnightWalletProvider.build(this.logger, this.environmentConfiguration, this.genesisMintWalletSeed[index])
      )
    );
    await Promise.all(this.walletProviders.map((wallet) => wallet.start()));
    return this.walletProviders;
  };
}

================
File: testkit-js/testkit-js/src/test-environment/test-environments/qanet-test-environment.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';

import type { EnvironmentConfiguration } from '@/test-environment';

import { RemoteTestEnvironment } from './remote-test-environment';

/**
 * Test environment configuration for the Midnight QA network.
 * Provides URLs and endpoints for QA network services.
 */
export class QanetTestEnvironment extends RemoteTestEnvironment {
  /**
   * Returns the configuration for the QA network environment services.
   * @returns {EnvironmentConfiguration} Object containing URLs for QA network services:
   * - indexer: GraphQL API endpoint for the indexer
   * - indexerWS: WebSocket endpoint for the indexer
   * - node: RPC endpoint for the blockchain node
   * - faucet: API endpoint for requesting test tokens
   * - proofServer: URL for the proof generation server
   */
  getEnvironmentConfiguration(): EnvironmentConfiguration {
    return {
      walletNetworkId: NetworkId.NetworkId.DevNet,
      networkId: 'devnet',
      indexer: 'https://indexer.qanet.dev.midnight.network/api/v3/graphql',
      indexerWS: 'wss://indexer.qanet.dev.midnight.network/api/v3/graphql/ws',
      node: 'https://rpc.qanet.dev.midnight.network',
      nodeWS: 'wss://rpc.qanet.dev.midnight.network',
      faucet: 'https://faucet.qanet.dev.midnight.network/api/request-tokens',
      proofServer: this.proofServerContainer?.getUrl()
    };
  }
}

================
File: testkit-js/testkit-js/src/test-environment/test-environments/remote-test-environment.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { FaucetClient, NodeClient } from '@/client';
import { IndexerClient } from '@/client';
import { ProofServerClient } from '@/client';
import { getEnvVarWalletSeeds } from '@/env-vars';
import { logger } from '@/logger';
import type { ProofServerContainer } from '@/proof-server-container';
import { DynamicProofServerContainer } from '@/proof-server-container';
import type { EnvironmentConfiguration } from '@/test-environment';
import { MidnightWalletProvider, WalletSaveStateProvider } from '@/wallet';

import { TestEnvironment } from './test-environment';

/**
 * Base class for remote test environments that connect to external network services.
 * Provides functionality for managing walletProviders and a proof server container.
 */
export abstract class RemoteTestEnvironment extends TestEnvironment {
  protected proofServerContainer: ProofServerContainer;
  private environmentConfiguration: EnvironmentConfiguration;
  private walletProviders: MidnightWalletProvider[] | undefined = undefined;

  /**
   * Abstract method that must be implemented by subclasses to provide environment configuration.
   * @returns {EnvironmentConfiguration} Configuration object containing service URLs and endpoints
   */
  abstract getEnvironmentConfiguration(): EnvironmentConfiguration;

  /**
   * Creates and starts the specified number of wallet providers.
   * @returns {Promise<MidnightWalletProvider[]>} Array of started wallet providers
   */
  startMidnightWalletProviders = async (
    amount = 1,
    seeds: string[] | undefined = getEnvVarWalletSeeds()
  ): Promise<MidnightWalletProvider[]> => {
    if (amount > 1 && seeds && seeds.length !== amount) {
      throw new Error(
        `Number of seeds provided (${seeds.length}) does not match the amount of wallets requested (${amount})`
      );
    }
    this.logger.info(`Getting ${amount} wallets...`);
    const buildWallet = (seed?: string) =>
      MidnightWalletProvider.build(this.logger, this.environmentConfiguration, seed);
    const seeds2 = seeds || Array(amount).fill(undefined);
    this.walletProviders = await Promise.all(seeds2.map(buildWallet));
    await Promise.all(this.walletProviders.map((wallet) => wallet.start()));
    return this.walletProviders;
  };

  /**
   * Shuts down the test environment by closing all walletProviders and stopping the proof server.
   */
  shutdown = async (saveWalletState?: boolean) => {
    this.logger.info(`Shutting down test environment...`);
    if (this.walletProviders) {
      if (saveWalletState) {
        await Promise.all(
          this.walletProviders.map((midnightWallet) =>
            new WalletSaveStateProvider(logger, midnightWallet.zswapSecretKeys.coinPublicKey).save(midnightWallet.wallet.shielded)
          )
        );
      }
      await Promise.all(this.walletProviders.map((wallet) => wallet.stop()));
    }
    if (this.proofServerContainer) {
      await this.proofServerContainer.stop();
    }
  };

  /**
   * Performs a health check for the environment.
   * Checks the health of the node, indexer, and optionally the faucet services.
   * @returns {Promise<void>} A promise that resolves when the health check is complete.
   */
  healthCheck = async () => {
    this.logger.info('Performing env health check');
    await new NodeClient(this.environmentConfiguration.node, this.logger).health();
    await new IndexerClient(this.environmentConfiguration.indexer, this.logger).health();
    await new ProofServerClient(this.environmentConfiguration.proofServer, this.logger).health();
    if (this.environmentConfiguration.faucet) {
      await new FaucetClient(this.environmentConfiguration.faucet, this.logger).health();
    }
  };

  /**
   * Starts the test environment by initializing the proof server and environment configuration.
   * @param {ProofServerContainer} maybeProofServerContainer Optional proof server container to use instead of creating a new one
   * @returns {Promise<EnvironmentConfiguration>} The environment configuration
   */
  start = async (maybeProofServerContainer?: ProofServerContainer) => {
    this.logger.info(`Starting test environment... `);
    this.proofServerContainer =
      maybeProofServerContainer ?? (await DynamicProofServerContainer.start(this.logger, this.uid));
    this.environmentConfiguration = this.getEnvironmentConfiguration();
    this.logger.info(`Test environment configuration: ${JSON.stringify(this.environmentConfiguration)}`);
    await this.healthCheck();
    return this.environmentConfiguration;
  };
}

================
File: testkit-js/testkit-js/src/test-environment/test-environments/test-environment.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { Logger } from 'pino';

import type { ProofServerContainer } from '@/proof-server-container';
import type { MidnightWalletProvider } from '@/wallet';

import type { EnvironmentConfiguration } from '../environment-configuration';

/**
 * Abstract base class for test environments.
 * Provides common functionality for managing test wallets and environments.
 */
export abstract class TestEnvironment {
  /** Logger instance for recording operations */
  protected readonly logger: Logger;
  /** Unique identifier for this test environment instance */
  protected readonly uid: string;

  protected readonly envConfiguration: EnvironmentConfiguration;
  /**
   * Creates a new TestEnvironment instance.
   * @param {Logger} logger - Logger instance for recording operations
   */
  constructor(logger: Logger) {
    this.logger = logger;
    this.uid = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString();
  }

  /**
   * Starts a single wallet instance.
   * @returns {Promise<MidnightWalletProvider>} A promise that resolves to the started wallet
   * @throws {Error} If no wallet could be started
   */
  getMidnightWalletProvider = async () => {
    const [walletProvider] = await this.startMidnightWalletProviders();
    if (!walletProvider) {
      throw Error('Undefined walletProvider found, but expected to have one');
    }
    return walletProvider;
  };

  /**
   * Shuts down the test environment and cleans up resources.
   * @param {boolean} [saveWalletState] - Optional flag to save the wallet state before shutdown
   * @returns {Promise<void>} A promise that resolves when shutdown is complete
   */
  abstract shutdown(saveWalletState?: boolean): Promise<void>;
  /**
   * Start the test environment.
   *
   * @param maybeProofServerContainer If defined, a container representing an already
   *                                  running proof server. If undefined, a proof server
   *                                  will be started automatically.
   * @returns {Promise<EnvironmentConfiguration>} A promise that resolves to the environment configuration
   */
  abstract start(maybeProofServerContainer?: ProofServerContainer): Promise<EnvironmentConfiguration>;

  /**
   * Starts multiple wallet instances.
   * @param {number} [amount] - Optional number of wallet instances to start
   * @param {string[]} [seeds] - Optional array of seeds for the wallets
   * @returns {Promise<MidnightWalletProvider[]>} A promise that resolves to an array of started wallets
   */
  abstract startMidnightWalletProviders(amount?: number, seeds?: string[]): Promise<MidnightWalletProvider[]>;

  abstract getEnvironmentConfiguration(): EnvironmentConfiguration;
}

================
File: testkit-js/testkit-js/src/test-environment/test-environments/testnet2-test-environment.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';

import type { EnvironmentConfiguration } from '@/test-environment';

import { RemoteTestEnvironment } from './remote-test-environment';

/**
 * Test environment configuration for the Midnight testnet network.
 * Provides URLs and endpoints for testnet services.
 */
export class Testnet2TestEnvironment extends RemoteTestEnvironment {
  /**
   * Returns the configuration for the testnet environment services.
   * @returns {EnvironmentConfiguration} Object containing URLs for testnet services:
   * - indexer: GraphQL API endpoint for the indexer
   * - indexerWS: WebSocket endpoint for the indexer
   * - node: RPC endpoint for the blockchain node
   * - faucet: API endpoint for requesting test tokens
   * - proofServer: URL for the proof generation server
   */
  getEnvironmentConfiguration(): EnvironmentConfiguration {
    return {
      walletNetworkId: NetworkId.NetworkId.TestNet,
      networkId: 'testnet-02',
      indexer: 'https://indexer.testnet-02.midnight.network/api/v3/graphql',
      indexerWS: 'wss://indexer.testnet-02.midnight.network/api/v3/graphql/ws',
      node: 'https://rpc.testnet-02.midnight.network',
      nodeWS: 'wss://rpc.testnet-02.midnight.network',
      faucet: 'https://faucet.testnet-02.midnight.network/api/request-tokens',
      proofServer: this.proofServerContainer?.getUrl()
    };
  }
}

================
File: testkit-js/testkit-js/src/test-environment/environment-configuration.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';

/**
 * Configuration interface for the test environment services
 */
export interface EnvironmentConfiguration {
  /** Wallet Network identifier */
  readonly walletNetworkId: NetworkId.NetworkId;
  /** Network identifier */
  readonly networkId: string;
  /** URL of the indexer HTTP endpoint */
  readonly indexer: string;
  /** WebSocket URL for the indexer service */
  readonly indexerWS: string;
  /** URL of the blockchain node */
  readonly node: string;
  /** WebSocket URL for the blockchain node */
  readonly nodeWS: string;
  /** URL of the proof generation server */
  readonly proofServer: string;
  /** Optional URL for the faucet service to obtain test tokens */
  readonly faucet: string | undefined;
}

================
File: testkit-js/testkit-js/src/test-environment/environment-provider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { setNetworkId } from '@midnight-ntwrk/midnight-js-network-id';
import type { Logger } from 'pino';

import { getEnvVarEnvironment } from '@/env-vars';
import { type TestEnvironment } from '@/test-environment/test-environments/test-environment';

import {
  EnvVarRemoteTestEnvironment,
  LocalTestEnvironment,
  QanetTestEnvironment,
  Testnet2TestEnvironment,
} from './test-environments';

/**
 * Returns the appropriate test environment based on the MN_TEST_ENVIRONMENT variable.
 * @param {Logger} logger - The logger instance to be used by the test environment.
 * @returns { TestEnvironment} The selected test environment instance.
 */
export const getTestEnvironment = (logger: Logger): TestEnvironment => {
  const testEnv = getEnvVarEnvironment().toLowerCase();
  let env;
  switch (testEnv) {
    case 'testnet':
    case 'testnet-02':
      env = new Testnet2TestEnvironment(logger);
      setNetworkId('test');
      break;
    case 'qanet':
      env = new QanetTestEnvironment(logger);
      setNetworkId('dev');
      break;
    case 'env-var-remote':
      env = new EnvVarRemoteTestEnvironment(logger);
      setNetworkId(env.getEnvironmentConfiguration().networkId);
      break;
    default:
      env = new LocalTestEnvironment(logger);
      setNetworkId('undeployed');
  }
  return env;
};

================
File: testkit-js/testkit-js/src/test-environment/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * from './environment-configuration';
export * from './environment-provider';
export * from './test-environments';

================
File: testkit-js/testkit-js/src/wallet/gzip-file.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { createGunzip, createGzip } from 'node:zlib';

import { createReadStream, createWriteStream } from 'fs';

/**
 * A class for compressing and decompressing files using gzip.
 */
class GzipFile {
  /** The path to the input file */
  inputFile: string;
  /** The path to the output file */
  outputFile: string;

  /**
   * Creates a new GzipFile instance.
   * @param inputFile - The path to the input file to compress/decompress
   * @param outputFile - The path where the compressed file will be saved
   */
  constructor(inputFile: string, outputFile: string) {
    this.inputFile = inputFile;
    this.outputFile = outputFile;
  }

  /**
   * Compresses the input file using gzip compression.
   * @returns A promise that resolves when compression is complete
   * @throws If there is an error during compression
   */
  compress = () => {
    const gzip = createGzip();
    const source = createReadStream(this.inputFile);
    const destination = createWriteStream(this.outputFile);
    return new Promise<void>((resolve, reject) => {
      source
        .pipe(gzip)
        .pipe(destination)
        .on('finish', () => {
          resolve();
        })
        .on('error', (err) => {
          reject(err);
        });
    });
  };

  /**
   * Decompresses the input gzip file and returns its contents as a string.
   * @returns A promise that resolves with the decompressed file contents as a string
   * @throws If there is an error during decompression
   */
  decompress = () => {
    const gunzip = createGunzip();
    const source = createReadStream(this.inputFile);
    return new Promise<string>((resolve, reject) => {
      let data = '';
      source
        .pipe(gunzip)
        .on('data', (chunk) => {
          data += chunk.toString();
        })
        .on('end', () => {
          resolve(data);
        })
        .on('error', (err) => {
          reject(err);
        });
    });
  };
}

export { GzipFile };

================
File: testkit-js/testkit-js/src/wallet/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * from './gzip-file';
export * from './midnight-wallet-provider';
export * from './wallet-builder';
export * from './wallet-state-provider';
export * from './wallet-utils';

================
File: testkit-js/testkit-js/src/wallet/wallet-configuration-mapper.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type LedgerParameters } from '@midnight-ntwrk/ledger-v6';
import { type DefaultV1Configuration } from '@midnight-ntwrk/wallet-sdk-shielded/v1';

import { type EnvironmentConfiguration } from '@/test-environment';

export interface MapperOptions {
  readonly networkId?: string;
  readonly additionalFeeOverhead?: bigint;
  readonly ledgerParams?: LedgerParameters;
}

export function mapEnvironmentToConfiguration(
  env: EnvironmentConfiguration,
): DefaultV1Configuration {
  return {
    indexerClientConnection: {
      indexerHttpUrl: env.indexer,
      indexerWsUrl: env.indexerWS,
    },
    provingServerUrl: new URL(env.proofServer),
    relayURL: new URL(env.nodeWS),
    networkId: env.walletNetworkId,
  };
}

================
File: testkit-js/testkit-js/src/wallet/wallet-seed-utils.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { HDWallet, Roles } from '@midnight-ntwrk/wallet-sdk-hd';

export const getShieldedSeed = (seed: string): Uint8Array => {
  const seedBuffer = Buffer.from(seed, 'hex');
  const hdWalletResult = HDWallet.fromSeed(seedBuffer);

  const { hdWallet } = hdWalletResult as {
    type: 'seedOk';
    hdWallet: HDWallet;
  };

  const derivationResult = hdWallet.selectAccount(0).selectRole(Roles.Zswap).deriveKeyAt(0);

  if (derivationResult.type === 'keyOutOfBounds') {
    throw new Error('Key derivation out of bounds');
  }

  return Buffer.from(derivationResult.key);
};

export const getUnshieldedSeed = (seed: string): Uint8Array<ArrayBufferLike> => {
  const seedBuffer = Buffer.from(seed, 'hex');
  const hdWalletResult = HDWallet.fromSeed(seedBuffer);

  const { hdWallet } = hdWalletResult as {
    type: 'seedOk';
    hdWallet: HDWallet;
  };

  const derivationResult = hdWallet.selectAccount(0).selectRole(Roles.NightExternal).deriveKeyAt(0);

  if (derivationResult.type === 'keyOutOfBounds') {
    throw new Error('Key derivation out of bounds');
  }

  return derivationResult.key;
};


export const getDustSeed = (seed: string): Uint8Array<ArrayBufferLike> => {
  const seedBuffer = Buffer.from(seed, 'hex');
  const hdWalletResult = HDWallet.fromSeed(seedBuffer);

  const { hdWallet } = hdWalletResult as {
    type: 'seedOk';
    hdWallet: HDWallet;
  };

  const derivationResult = hdWallet.selectAccount(0).selectRole(Roles.Dust).deriveKeyAt(0);

  if (derivationResult.type === 'keyOutOfBounds') {
    throw new Error('Key derivation out of bounds');
  }

  return derivationResult.key;
};

================
File: testkit-js/testkit-js/src/wallet/wallet-state-provider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import fs from 'node:fs';

import { type ShieldedWallet } from '@midnight-ntwrk/wallet-sdk-shielded';
import { type UnshieldedWallet } from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';
import { type Logger } from 'pino';

import { getEnvVarEnvironment } from '@/env-vars';

import { GzipFile } from './gzip-file';

/** Default directory path for storing wallet state files */
export const DEFAULT_WALLET_STATE_DIRECTORY = `./.states`;


/**
 * Generates a filename for the wallet state file based on environment and optional seed
 * @returns {string} Generated filename for the wallet state
 * @param seed
 */
export const getWalletStateFilename = (seed: string | undefined) => {
  if (seed === undefined) {
    return `wallet.${getEnvVarEnvironment()}.state.gz`;
  }
  return `wallet.${getEnvVarEnvironment()}.${seed}.state.gz`;
};

/**
 * Provider class for saving and loading wallet state to/from compressed files
 */
export class WalletSaveStateProvider {
  /** Logger instance for recording operations */
  logger: Logger;
  /** Absolute path to the directory containing wallet state files */
  directoryPath: string;
  /** Full path including filename for the wallet state file */
  filePath: string;

  /**
   * Creates a new WalletSaveStateProvider instance
   * @param {Logger} logger - Logger instance for recording operations
   * @param seed
   * @param {string} [directoryPath=DEFAULT_WALLET_STATE_DIRECTORY] - Directory path for wallet state files
   * @param {string} [filename] - Filename for the wallet state file
   */
  constructor(
    logger: Logger,
    seed: string,
    directoryPath: string = DEFAULT_WALLET_STATE_DIRECTORY,
    filename: string = getWalletStateFilename(seed)
  ) {
    this.logger = logger;
    if (!directoryPath.startsWith('/')) {
      this.directoryPath = `${process.cwd()}/${directoryPath}`;
    } else {
      this.directoryPath = directoryPath;
    }
    this.filePath = `${this.directoryPath}/${filename}`;
  }

  /**
   * Saves the wallet state to a compressed file
   * @param {ShieldedWallet | UnshieldedWallet} wallet - The wallet instance to save state from
   * @returns {Promise<void>} A promise that resolves when the save is complete
   */
  async save(wallet: ShieldedWallet | UnshieldedWallet): Promise<void> {
    this.logger.info(`Saving state in ${this.filePath}`);
    try {
      fs.mkdirSync(this.directoryPath, { recursive: true });
      const serializedState = await wallet.serializeState();
      try {
        const tempFile = `${this.filePath.replaceAll('.gz', '')}`;
        fs.writeFileSync(tempFile, serializedState);
        this.logger.info(`File '${tempFile}' written successfully.`);
        await new GzipFile(tempFile, `${this.filePath.replaceAll('.gz', '')}.gz`).compress();
        fs.rmSync(tempFile);
        this.logger.info(`File '${this.filePath}' written successfully.`);
      } catch (err) {
        this.logger.error(`Error writing file '${this.filePath}': ${err instanceof Error ? err.message : String(err)}`);
      }
    } catch (e) {
      this.logger.warn(e instanceof Error ? e.message : String(e));
    }
  }

  /**
   * Loads and decompresses the wallet state from a file
   * @returns {Promise<string>} A promise that resolves with the decompressed wallet state as a string
   * @throws {Error} If there is an error reading or decompressing the file
   */
  async load(): Promise<string> {
    this.logger.info(`Loading state from ${this.filePath}`);
    try {
      return await new GzipFile(this.filePath, `${this.filePath.replaceAll('.gz', '')}.gz`).decompress();
    } catch (error: unknown) {
      this.logger.error(error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
}

================
File: testkit-js/testkit-js/src/wallet/wallet-utils.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { shieldedToken, type TokenType } from '@midnight-ntwrk/ledger-v6';
import { type WalletFacade } from '@midnight-ntwrk/wallet-sdk-facade';
import { ShieldedWallet } from '@midnight-ntwrk/wallet-sdk-shielded';
import { type UnshieldedWallet } from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';
import * as Rx from 'rxjs';

import { FaucetClient } from '@/client';
import { type EnvironmentConfiguration } from '@/index';
import { logger } from '@/logger';

export const getInitialState = async (wallet: ShieldedWallet | UnshieldedWallet) => {
  if (wallet instanceof ShieldedWallet) {
    return Rx.firstValueFrom((wallet as ShieldedWallet).state);
  } else {
    return Rx.firstValueFrom((wallet as UnshieldedWallet).state());
  }
};

export const getInitialShieldedState = async (wallet: ShieldedWallet) => {
  logger.info('Getting initial state of wallet...');
  return Rx.firstValueFrom(wallet.state);
};

export const getInitialUnshieldedState = async (wallet: UnshieldedWallet) => {
  logger.info('Getting initial state of wallet...');
  return Rx.firstValueFrom(wallet.state());
};

export const syncWallet = (wallet: WalletFacade, throttleTime = 2_000, timeout = 90_000) => {
  logger.info('Syncing wallet...');

  return Rx.firstValueFrom(
    wallet.state().pipe(
      Rx.tap((state) => {
        logger.info(
          `Wallet synced state emission: { shielded=${state.shielded.state.progress.isStrictlyComplete()}, unshielded=${state.unshielded.syncProgress?.synced}, dust=${state.dust.state.progress.isStrictlyComplete()} }`
        );
      }),
      Rx.throttleTime(throttleTime),
      Rx.tap((state) => {
        const isSynced =
            state.shielded.state.progress.isStrictlyComplete() &&
            state.dust.state.progress.isStrictlyComplete() &&
            state.unshielded.syncProgress?.synced === true;

        logger.info(
          `Wallet synced state emission (synced=${isSynced}): { shielded=${state.shielded.state.progress.isStrictlyComplete()}, unshielded=${state.unshielded.syncProgress?.synced}, dust=${state.dust.state.progress.isStrictlyComplete()} }`
        );
      }),
      Rx.filter(
        (state) =>
          state.shielded.state.progress.isStrictlyComplete() &&
          state.dust.state.progress.isStrictlyComplete() &&
          state.unshielded.syncProgress?.synced === true,
      ),
      Rx.tap(() => logger.info('Sync complete')),
      Rx.tap((state) => {
        const shieldedBalances = state.shielded.balances || {};
        const unshieldedBalances = state.unshielded.balances || {};
        const dustBalances = state.dust.walletBalance(new Date(Date.now())) || {};

        logger.info(`Wallet balances after sync - Shielded: ${JSON.stringify(shieldedBalances)}, Unshielded: ${JSON.stringify(Object.fromEntries(unshieldedBalances))}, Dust: ${dustBalances}`);
      }),
      Rx.timeout({
        each: timeout,
        with: () => Rx.throwError(() => new Error(`Wallet sync timeout after ${timeout}ms`))
      })
    )
  );
};

export const waitForFunds = async (
  wallet: WalletFacade,
  env: EnvironmentConfiguration,
  tokenType: TokenType = shieldedToken(),
  fundFromFaucet = false
) => {
  const initialState = await getInitialShieldedState(wallet.shielded);
  logger.info(`Your wallet address is: ${initialState.address.coinPublicKeyString()}, waiting for funds...`);
  if (fundFromFaucet && env.faucet) {
    logger.info('Requesting tokens from faucet...');
    await new FaucetClient(env.faucet, logger).requestTokens(initialState.address.coinPublicKeyString());
  }
  const initialBalance = initialState.balances[tokenType.tag];
  if (initialBalance === undefined || initialBalance === 0n) {
    logger.info(`Your wallet balance is: 0`);
    logger.info(`Waiting to receive tokens...`);
    return syncWallet(wallet);
  }
  return initialBalance;
};

================
File: testkit-js/testkit-js/src/assertions.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { StateValue } from '@midnight-ntwrk/compact-runtime';
import type { Bindingish, Proofish, Signaturish, Transaction } from '@midnight-ntwrk/ledger-v6';
import type {
  CallTxOptions,
  DeployContractOptions,
  DeployTxOptions,
  FinalizedCallTxData,
  FinalizedDeployTxData,
  FinalizedDeployTxDataBase
} from '@midnight-ntwrk/midnight-js-contracts';
import {
  type Contract,
  type FinalizedTxData,
  type ImpureCircuitId,
  type MidnightProviders,
  type PrivateState,
  type PrivateStateId,
  SucceedEntirely
} from '@midnight-ntwrk/midnight-js-types';

export const stateValueEqual = (a: StateValue, b: StateValue): boolean => {
  return a.toString(false) === b.toString(false);
};

export const txsEqual = <S extends Signaturish, P extends Proofish, B extends Bindingish>(a: Transaction<S, P, B>, b: Transaction<S, P, B>): boolean => {
  return a.toString(false) === b.toString(false);
};

export const expectFoundAndDeployedTxPublicDataEqual = <C extends Contract>(
  deployTxData: FinalizedDeployTxData<C>,
  foundDeployTxData: FinalizedDeployTxDataBase<C>
): void => {
  expect(
    stateValueEqual(deployTxData.public.initialContractState.data.state, foundDeployTxData.public.initialContractState.data.state)
  ).toBeTruthy();
  expect(deployTxData.public.contractAddress).toEqual(foundDeployTxData.public.contractAddress);
  expect(deployTxData.public.blockHash).toEqual(foundDeployTxData.public.blockHash);
  expect(deployTxData.public.blockHeight).toEqual(foundDeployTxData.public.blockHeight);
  expect(deployTxData.public.txHash).toEqual(foundDeployTxData.public.txHash);
  expect(deployTxData.public.identifiers).toEqual(foundDeployTxData.public.identifiers);
  expect(deployTxData.public.status).toEqual(foundDeployTxData.public.status);
  expect(txsEqual(deployTxData.public.tx, foundDeployTxData.public.tx)).toBeTruthy();
};

export const expectFoundAndDeployedTxPrivateDataEqual = <C extends Contract>(
  deployTxData: FinalizedDeployTxData<C>,
  foundDeployTxData: FinalizedDeployTxDataBase<C>
): void => {
  // For our purposes, we always find with the same private state that the contract is deployed with
  // so this comparison is justified.
  expect(deployTxData.private.initialPrivateState).toEqual(foundDeployTxData.private.initialPrivateState);
};

export const expectFoundAndDeployedTxDataEqual = <C extends Contract>(
  deployTxData: FinalizedDeployTxData<C>,
  foundDeployTxData: FinalizedDeployTxDataBase<C>
): void => {
  expectFoundAndDeployedTxPublicDataEqual(deployTxData, foundDeployTxData);
  expectFoundAndDeployedTxPrivateDataEqual(deployTxData, foundDeployTxData);
};

export const expectFoundAndDeployedStatesEqual = async <C extends Contract>(
  providers: MidnightProviders<ImpureCircuitId<C>, PrivateStateId, PrivateState<C> | unknown>,
  deployTxData: FinalizedDeployTxData<C>,
  foundDeployTxData: FinalizedDeployTxDataBase<C>,
  privateStateId?: PrivateStateId,
  initialPrivateState?: PrivateState<C>
): Promise<void> => {
  const deployedLedgerState = await providers.publicDataProvider.queryContractState(
    deployTxData.public.contractAddress
  );
  expect(deployedLedgerState).toBeDefined();
  expect(stateValueEqual(deployedLedgerState!.data.state, foundDeployTxData.public.initialContractState.data.state)).toBeTruthy();
  if (privateStateId) {
    const privateState = await providers.privateStateProvider.get(privateStateId);
    expect(privateState).toEqual(foundDeployTxData.private.initialPrivateState);
    if (initialPrivateState !== undefined) {
      expect(privateState).toEqual(initialPrivateState);
    }
  }
};

export const expectSuccessfulTxData = (finalizedTxData: FinalizedTxData): void => {
  expect(finalizedTxData.status).toEqual(SucceedEntirely);
  expect(finalizedTxData.tx).toBeTruthy();
  expect(finalizedTxData.txId).toBeTruthy();
  expect(finalizedTxData.txHash).toBeTruthy();
  expect(finalizedTxData.blockHeight).toBeTruthy();
  expect(finalizedTxData.blockHash).toBeTruthy();
};

export const expectSuccessfulDeployTx = async <C extends Contract>(
  providers: MidnightProviders<ImpureCircuitId<C>, PrivateStateId, PrivateState<C> | unknown>,
  deployTxData: FinalizedDeployTxData<C>,
  deployTxOptions?: DeployContractOptions<C> | DeployTxOptions<C>
): Promise<void> => {
  expectSuccessfulTxData(deployTxData.public);
  expect(deployTxData.public.contractAddress).toBeTruthy();
  const deployedLedgerState = await providers.publicDataProvider.queryContractState(
    deployTxData.public.contractAddress
  );
  expect(stateValueEqual(deployTxData.public.initialContractState.data.state, deployedLedgerState!.data.state));
  expect(deployTxData.public.initialContractState).toBeTruthy();

  // Checks that the signing key and private state passed in the deploy configuration
  // were stored correctly.
  if (deployTxOptions) {
    if (deployTxOptions.signingKey) {
      expect(deployTxData.private.signingKey).toEqual(deployTxOptions.signingKey);
      const storedSigningKey = await providers.privateStateProvider.getSigningKey(deployTxData.public.contractAddress);
      expect(storedSigningKey).toBeDefined();
      expect(storedSigningKey).toEqual(deployTxOptions.signingKey);
    }
    // We only test contracts that pass 'initialPrivateState' through the contract constructor unchanged
    // so this equality comparison is justified.
    if ('privateStateId' in deployTxOptions && 'initialPrivateState' in deployTxOptions) {
      expect(deployTxData.private.initialPrivateState).toEqual(deployTxOptions.initialPrivateState);
      const storedPrivateState = await providers.privateStateProvider.get(deployTxOptions.privateStateId);
      expect(storedPrivateState).toBeDefined();
      expect(storedPrivateState).toEqual(deployTxOptions.initialPrivateState);
    }
  }
};

export const expectSuccessfulCallTx = async <C extends Contract, ICK extends ImpureCircuitId<C>>(
  providers: MidnightProviders<ImpureCircuitId<C>, PrivateStateId, PrivateState<C> | unknown>,
  callTxData: FinalizedCallTxData<C, ICK>,
  callTxOptions?: CallTxOptions<C, ICK>,
  nextPrivateState?: PrivateState<C>
): Promise<void> => {
  expectSuccessfulTxData(callTxData.public);
  expect(callTxData.public.nextContractState).toBeTruthy();
  expect(callTxData.private.nextZswapLocalState);
  if (callTxOptions) {
    if ('privateStateId' in callTxOptions) {
      const storedPrivateState = await providers.privateStateProvider.get(callTxOptions.privateStateId);
      expect(storedPrivateState).toBeDefined();
      expect(storedPrivateState).toEqual(callTxData.private.nextPrivateState);
      if (nextPrivateState) {
        expect(nextPrivateState).toEqual(callTxData.private.nextPrivateState);
      }
    }
  }
};

================
File: testkit-js/testkit-js/src/configuration-types.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type WaitStrategy } from 'testcontainers';

/**
 * Configuration for a proof server container instance
 */
export interface ProofServerContainerConfiguration {
  /** Directory path where container configuration is located */
  path: string;
  /** Name of the container configuration file */
  fileName: string;
  /** Network endpoint configuration for the container */
  container: ContainerEndpoints;
}

/**
 * Network endpoint configuration for a container
 */
export interface ContainerEndpoints {
  /** Name of the container */
  name: string;
  /** Port number the container listens on */
  port: number;
  /** TestContainers WaitStrategy to use for container start */
  waitStrategy: WaitStrategy;
}

/**
 * Container endpoint configurations for standalone mode services
 */
export interface StandaloneContainerNames {
  /** Proof server container configuration */
  proofServer: ContainerEndpoints;
  /** Blockchain node container configuration */
  node: ContainerEndpoints;
  /** Indexer service container configuration */
  indexer: ContainerEndpoints;
}

/**
 * Configuration for standalone mode containers
 */
export interface StandaloneContainersConfiguration {
  /** Directory path where container configuration is located */
  path: string;
  /** Name of the container configuration file */
  fileName: string;
  /** Container endpoint configurations */
  container: StandaloneContainerNames;
}

/**
 * Configuration for test logging
 */
export interface LogConfiguration {
  /** Directory path where log files will be written */
  path: string;
  /** Name of the log file */
  fileName: string;
  /** Log level (e.g. 'info', 'debug', etc) */
  level: string;
}

/**
 * Top-level configuration for all test containers
 */
export interface ContainersConfiguration {
  /** Proof server container configuration */
  proofServer: ProofServerContainerConfiguration;
  /** Standalone mode containers configuration */
  standalone: StandaloneContainersConfiguration;
  /** Logging configuration */
  log: LogConfiguration;
}

================
File: testkit-js/testkit-js/src/errors.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * An error representing a required, but missing, environment variable.
 */
export class MissingEnvironmentVariable extends Error {
  /**
   * @param environmentVariable The name of the missing environment variable.
   */
  constructor(public readonly environmentVariable: string) {
    super(`Environment variable '${environmentVariable}' is required`);
  }
}

================
File: testkit-js/testkit-js/src/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * from './assertions';
export * from './client';
export * from './configuration';
export * from './configuration-types';
export * from './contract';
export * from './logger';
export * from './proof-server-container';
export * from './test-environment';
export * from './utils';
export * from './wallet';

================
File: testkit-js/testkit-js/src/logger.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as path from 'node:path';

import pino from 'pino';
import pinoPretty from 'pino-pretty';

import { getContainersConfiguration } from './configuration';

const { level } = getContainersConfiguration().log;

export function createLogger(fileName: string, dir: string = getContainersConfiguration().log.path) {
  let logPath = path.resolve(fileName);
  if (!fileName.includes('/')) {
    logPath = path.resolve(dir, fileName);
  }
  const prettyStream: pinoPretty.PrettyStream = pinoPretty({
    colorize: true,
    sync: true
  });
  const prettyFileStream: pinoPretty.PrettyStream = pinoPretty({
    mkdir: true,
    colorize: false,
    sync: true,
    append: true,
    destination: logPath
  });
  return pino(
    {
      level,
      depthLimit: 20
    },
    pino.multistream([
      { stream: prettyStream, level },
      { stream: prettyFileStream, level }
    ])
  );
}

export function createDefaultTestLogger() {
  return createLogger(getContainersConfiguration().log.fileName, getContainersConfiguration().log.path);
}

export const logger = createDefaultTestLogger();

================
File: testkit-js/testkit-js/src/proof-server-container.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { Logger } from 'pino';
import { DockerComposeEnvironment, type StartedDockerComposeEnvironment } from 'testcontainers';

import { getContainersConfiguration } from './configuration';
import type { ProofServerContainerConfiguration } from './configuration-types';

/**
 * Interface representing a proof server container that can be started and stopped.
 */
export interface ProofServerContainer {
  /**
   * Stops the proof server container.
   * @returns {Promise<void>} A promise that resolves when the container is stopped
   */
  stop(): Promise<void>;

  /**
   * Gets the URL where the proof server can be accessed.
   * @returns {string} The URL of the proof server
   */
  getUrl(): string;
}

/**
 * A proof server container that is started and stopped dynamically by the test
 * suite on random port.
 */
export class DynamicProofServerContainer implements ProofServerContainer {
  /** The Docker Compose environment running the container */
  public dockerEnv: StartedDockerComposeEnvironment;
  /** Unique identifier for the container instance */
  private uid: string;
  /** Configuration for the proof server container */
  private config: ProofServerContainerConfiguration;

  /**
   * Creates a new DynamicProofServerContainer instance.
   * @param {StartedDockerComposeEnvironment} dockerEnv - The started Docker Compose environment
   * @param {string} uid - Unique identifier for the container
   * @private
   */
  private constructor(dockerEnv: StartedDockerComposeEnvironment, uid: string) {
    this.dockerEnv = dockerEnv;
    this.uid = uid;
    this.config = getContainersConfiguration().proofServer;
  }

  /**
   * Starts a new proof server container.
   * @param {Logger} logger - Logger instance for recording operations
   * @param {string} [maybeUID] - Optional unique identifier for the container
   * @param {string} [maybeNetworkId] - Optional network ID for the container
   * @returns {Promise<DynamicProofServerContainer>} A promise that resolves to the new container instance
   */
  static async start(logger: Logger, maybeUID?: string, maybeNetworkId?: string): Promise<DynamicProofServerContainer> {
    const config = getContainersConfiguration().proofServer;
    const uid = maybeUID ?? Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString();
    const networkId = maybeNetworkId;
    logger.info(
      `Starting proof server: path='${config.path}', file=${config.fileName}, networkId=${networkId}, uid=${uid}`
    );
    const dockerEnv = await new DockerComposeEnvironment(config.path, config.fileName)
      .withWaitStrategy(`${config.container.name}_${uid}`, config.container.waitStrategy)
      .withEnvironment({
        TESTCONTAINERS_UID: uid,
        NETWORK_ID: networkId ?? 'undeployed'
      })
      .up();
    return new DynamicProofServerContainer(dockerEnv, uid);
  }

  /**
   * Stops the proof server container.
   * @returns {Promise<void>} A promise that resolves when the container is stopped
   */
  async stop(): Promise<void> {
    await this.dockerEnv.stop();
  }

  /**
   * Gets the mapped port number for the container.
   * @returns {number} The mapped port number
   */
  getMappedPort(): number {
    return this.dockerEnv
      .getContainer(`${this.config.container.name}_${this.uid}`)
      .getMappedPort(this.config.container.port);
  }

  /**
   * Gets the URL where the proof server can be accessed.
   * @returns {string} The URL of the proof server
   */
  getUrl(): string {
    return `http://localhost:${this.getMappedPort()}`;
  }
}

/**
 * A proof server that is currently running on a specific port.
 * Used for connecting to an existing proof server instance.
 */
export class StaticProofServerContainer implements ProofServerContainer {
  /** The port number where the proof server is running */
  port: number;

  /**
   * Creates a new StaticProofServerContainer instance.
   * @param {number} port - The port number where the proof server is running (default: 6300)
   */
  constructor(port = 6300) {
    this.port = port;
  }

  /**
   * Gets the URL where the proof server can be accessed.
   * @returns {string} The URL of the proof server
   */
  getUrl(): string {
    return `http://localhost:${this.port}`;
  }

  /**
   * No-op stop method since this represents an external proof server.
   * @returns {Promise<void>} A resolved promise
   */

  stop(): Promise<void> {
    return Promise.resolve(undefined);
  }
}

================
File: testkit-js/testkit-js/src/utils.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { rm } from 'node:fs/promises';

import path from 'path';

import { logger } from './logger';

export const MINUTE = 60_000;

/**
 * Creates a Promise that resolves after a specified delay.
 * @param ms The delay duration in milliseconds.
 * @returns A Promise that resolves after the specified delay.
 * @example
 * // Wait for 1 second
 * await delay(1000);
 */
export const delay = (ms: number) => {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
};

/**
 * Deletes a directory and its contents recursively.
 * @param {string} dirPath - The path to the directory to delete
 * @returns {Promise<void>} A promise that resolves when the directory is deleted
 * @private
 */
export const deleteDirectory = async (dirPath: string) => {
  try {
    const resolvedPath = path.resolve(dirPath);
    await rm(resolvedPath, { recursive: true, force: true });
    logger.info(`Directory ${resolvedPath} deleted successfully.`);
  } catch (error) {
    if (error instanceof Error) {
      logger.error(`Error deleting directory: ${error.message}`);
    } else {
      logger.error('Unknown error occurred');
    }
  }
};

export const extractHostnameAndPort = (url: string): string => {
  const { hostname, port } = new URL(url);
  if (port !== '') {
    return `${hostname}:${port}`;
  }
  return hostname;
};

================
File: testkit-js/testkit-js/test/env-vars.ut.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import path from 'path';
import { WebSocket } from 'ws';

import { getEnvVarWalletSeeds } from '@/env-vars';
import { createLogger } from '@/logger';

const logger = createLogger(
  path.resolve(`${process.cwd()}`, 'logs', 'tests', `ut_${new Date().toISOString().replace(/:/g, '-')}.log`)
);

// @ts-expect-error: It's needed to enable WebSocket usage through apollo
globalThis.WebSocket = WebSocket;

describe.concurrent('[Unit tests] EnvVars Testing API', () => {
  beforeEach(() => {
    logger.info(`Starting test... ${expect.getState().currentTestName}`);
  });

  it('should return wallet seeds from MN_TEST_WALLET_SEED', () => {
    process.env.MN_TEST_WALLET_SEED = '111,222';
    expect(getEnvVarWalletSeeds()).toEqual(['111', '222']);
    delete process.env.MN_TEST_WALLET_SEED;
  });

  it('should return wallet seeds from TEST_WALLET_SEED', () => {
    process.env.TEST_WALLET_SEED = '333';
    expect(getEnvVarWalletSeeds()).toEqual(['333']);
    delete process.env.TEST_WALLET_SEED;
  });

  it('should return undefined when no wallet seeds are set', () => {
    expect(getEnvVarWalletSeeds()).toEqual(undefined);
  });
});

================
File: testkit-js/testkit-js/test/testing-api.e2e.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import path from 'path';
import * as Rx from 'rxjs';
import { WebSocket } from 'ws';

import { createLogger } from '@/logger';
import { getTestEnvironment } from '@/test-environment';

const logger = createLogger(
  path.resolve(`${process.cwd()}`, 'logs', 'tests', `e2e_${new Date().toISOString().replace(/:/g, '-')}.log`)
);

// @ts-expect-error: It's needed to enable WebSocket usage through apollo
globalThis.WebSocket = WebSocket;

describe.concurrent('[E2E] Testing API', () => {
  beforeEach(() => {
    logger.info(`Starting test... ${expect.getState().currentTestName}`);
  });

  it.each([
    ['devnet environment', 'devnet'],
    ['qanet environment', 'qanet']
  ])(
    'test environment should start multiple wallets on %s [@slow]',
    async (_, envVar) => {
      if (process.env.RUN_E2E_TESTS === 'true') {
        process.env.MN_TEST_ENVIRONMENT = envVar;
        const testEnvironment = getTestEnvironment(logger);
        await testEnvironment.start();
        const wallets = await testEnvironment.startMidnightWalletProviders(2);
        await testEnvironment.shutdown();

        expect(wallets).toHaveLength(2);

        const promises = wallets.map(async (walletProvider) => {
          expect(walletProvider.zswapSecretKeys.coinPublicKey).not.toBeUndefined();
          const initialState = await Rx.firstValueFrom(walletProvider.wallet.state());
          const initialBalance = initialState.shielded.balances[0];
          expect(initialBalance).toBeGreaterThan(0);
        });

        await Promise.all(promises);
      }
    },
    10 * 60_000
  );
});

================
File: testkit-js/testkit-js/test/testing-api.it.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import path from 'path';
import { WebSocket } from 'ws';

import { ProofServerClient } from '@/client';
import {
  defaultContainersConfiguration,
  getContainersConfiguration,
  setContainersConfiguration
} from '@/configuration';
import type { ContainersConfiguration } from '@/configuration-types';
import { createLogger } from '@/logger';
import { DynamicProofServerContainer } from '@/proof-server-container';
import { getTestEnvironment } from '@/test-environment';
import { LocalTestEnvironment } from '@/test-environment/test-environments';

const logger = createLogger(
  path.resolve(`${process.cwd()}`, 'logs', 'tests', `it_${new Date().toISOString().replace(/:/g, '-')}.log`)
);

// @ts-expect-error: It's needed to enable WebSocket usage through apollo
globalThis.WebSocket = WebSocket;

describe.concurrent('[Integration tests] Testing API', () => {
  beforeEach(() => {
    logger.info(`Starting test... ${expect.getState().currentTestName}`);
  });

  it.each([
    ['local environment configuration', undefined],
    ['testnet-02 environment configuration', 'testnet-02'],
    ['qanet environment configuration', 'qanet']
  ])(
    'test environment should start and stop %s',
    async (_, envVar) => {
      process.env.MN_TEST_ENVIRONMENT = envVar;
      const testEnvironment = getTestEnvironment(logger);
      const configuration = await testEnvironment.start();
      await testEnvironment.shutdown();

      if (testEnvironment instanceof LocalTestEnvironment) {
        expect(configuration.faucet).toBeUndefined();
      } else {
        expect(configuration.faucet).not.toBeUndefined();
      }
      expect(configuration.indexer).not.toBeUndefined();
      expect(configuration.indexerWS).not.toBeUndefined();
      expect(configuration.node).not.toBeUndefined();
    },
    2 * 60_000
  );

  it(
    'test environment should retrieve a wallet with tokens on local environment configuration',
    async () => {
      process.env.MN_TEST_ENVIRONMENT = undefined;
      const testEnvironment = getTestEnvironment(logger);
      await testEnvironment.start();
      const wallet = await testEnvironment.getMidnightWalletProvider();
      await testEnvironment.shutdown();

      expect(wallet.zswapSecretKeys.coinPublicKey).not.toBeUndefined();
    },
    2 * 60_000
  );

  it(
    'test environment should retrieve multiple wallets on local environment configuration',
    async () => {
      process.env.MN_TEST_ENVIRONMENT = undefined;
      const testEnvironment = getTestEnvironment(logger);
      await testEnvironment.start();
      await testEnvironment.startMidnightWalletProviders(2);
      await testEnvironment.shutdown();
    },
    3 * 60_000
  );

  it(
    'test environment should retrieve not get more wallets than allowed',
    async () => {
      process.env.MN_TEST_ENVIRONMENT = undefined;
      const testEnvironment = getTestEnvironment(logger);
      await testEnvironment.start();
      await expect(testEnvironment.startMidnightWalletProviders(5)).rejects.toThrow(
        `Maximum supported number of wallets for this environment reached: ${LocalTestEnvironment.MAX_NUMBER_OF_WALLETS}`
      );
      await testEnvironment.shutdown();
    },
    2 * 60_000
  );

  it('proof server - should fail on wrong configuration set', async () => {
    const oldConfig = getContainersConfiguration();
    try {
      const broken: ContainersConfiguration = {
        ...defaultContainersConfiguration,
        proofServer: {
          ...defaultContainersConfiguration.proofServer,
          fileName: 'proof-server-invalid.yml'
        }
      };
      setContainersConfiguration(broken);
      await expect(DynamicProofServerContainer.start(logger)).rejects.toThrow('no such file or directory');
    } finally {
      setContainersConfiguration(oldConfig);
    }
  });

  it('proof server - should get health check', async () => {
    let server;
    try {
      server = await DynamicProofServerContainer.start(logger);
      const client = new ProofServerClient(server.getUrl(), logger);
      await client.health();
    } finally {
      await server?.stop();
    }
  });

  it('proof server - should prove some buffer', async () => {
    let server;
    try {
      server = await DynamicProofServerContainer.start(logger);
      const client = new ProofServerClient(server.getUrl(), logger);
      await client.proveTx(Buffer.from('test').buffer);
    } finally {
      await server?.stop();
    }
  });
});

================
File: testkit-js/testkit-js/test/testing-api.ut.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import path from 'path';
import { WebSocket } from 'ws';

import { createLogger } from '@/logger';
import {
  getTestEnvironment
} from '@/test-environment';
import {
  EnvVarRemoteTestEnvironment,
  LocalTestEnvironment,
  QanetTestEnvironment,
  Testnet2TestEnvironment} from '@/test-environment/test-environments';

const logger = createLogger(
  path.resolve(`${process.cwd()}`, 'logs', 'tests', `ut_${new Date().toISOString().replace(/:/g, '-')}.log`)
);

// @ts-expect-error: It's needed to enable WebSocket usage through apollo
globalThis.WebSocket = WebSocket;

describe('[Unit tests] Testing API', () => {
  beforeEach(() => {
    logger.info(`Starting test... ${expect.getState().currentTestName}`);
  });

  it.each([
    ['local environment reference', undefined, LocalTestEnvironment],
    ['qanet environment reference', 'qanet', QanetTestEnvironment],
    ['testnet2 environment reference', 'testnet-02', Testnet2TestEnvironment]
  ])('test environment should return %s', async (_, envVar, expectedInstance) => {
    process.env.MN_TEST_ENVIRONMENT = envVar;
    expect(getTestEnvironment(logger)).toBeInstanceOf(expectedInstance);
  });

  it('test environment should return env var remote test environment reference', () => {
    process.env.MN_TEST_ENVIRONMENT = 'env-var-remote';
    process.env.MN_TEST_INDEXER = 'https://test.url';
    process.env.MN_TEST_INDEXER_WS = 'wss://test.url';
    process.env.MN_TEST_NODE = 'http://test.url';
    process.env.MN_TEST_NODE_WS = 'ws://test.url';
    process.env.MN_TEST_NETWORK_ID = 'TestNet';
    expect(getTestEnvironment(logger)).toBeInstanceOf(EnvVarRemoteTestEnvironment);
  });

  it('should fail on wrong MN_TEST_NETWORK_ID for env var remote test environment', () => {
    process.env.MN_TEST_ENVIRONMENT = 'env-var-remote';
    delete process.env.MN_TEST_NETWORK_ID;
    expect(() => getTestEnvironment(logger)).toThrow(`Environment variable 'MN_TEST_NETWORK_ID' is required`);
  });
});

================
File: testkit-js/testkit-js/.npmignore
================
src/e2e/
test/

================
File: testkit-js/testkit-js/rollup.config.mjs
================
import { createRollupConfig } from '../../build-tools/rollup.config.factory.mjs';
import packageJson from './package.json' with { type: 'json' };

export default createRollupConfig(packageJson);

================
File: testkit-js/testkit-js/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": [
    "./src/test/**/*.ts"
  ]
}

================
File: testkit-js/testkit-js/tsconfig.docs.json
================
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./dist",
    "esModuleInterop": true,
    "strictPropertyInitialization": false,
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "./src/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "test",
    "**/*.test.ts",
    "**/*.spec.ts",
    "vitest*.ts"
  ]
}

================
File: testkit-js/testkit-js/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./dist",
    "esModuleInterop": true,
    "strictPropertyInitialization": false,
    "types": ["vitest/globals"],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "./test/**/*.ts",
    "./src/**/*.ts",
    "*.ts"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}

================
File: testkit-js/testkit-js/typedoc.json
================
{
  "extends": ["../../typedoc.base.json"],
  "readme": "README.md",
  "entryPoints": ["src/index.ts"],
  "out": "../../docs/api/testkit-js",
  "tsconfig": "tsconfig.docs.json"
}

================
File: testkit-js/testkit-js/vitest.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import tsconfigPaths from 'vite-tsconfig-paths';
import { defineConfig } from 'vitest/config';

export default defineConfig({
  plugins: [tsconfigPaths()],
  test: {
    globals: true,
    environment: 'node',
    include: ['**/test/**/*.{test,spec}.ts'],
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage'
    },
    hookTimeout: 30_000,
    testTimeout: 30_000,
    reporters: [
      'default',
      ['junit', { outputFile: './reports/test-report.xml' }],
      ['html', { outputFile: './reports/html/index.html' }],
      ['@d2t/vitest-ctrf-json-reporter', { outputDir: './reports/', outputFile: 'ctrf-report.json' }]
    ],
    setupFiles: []
  },
  resolve: {
    extensions: ['.ts', '.js'],
  }
});

================
File: testkit-js/testkit-js/vitest.package.it.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { defineConfig } from 'vitest/config';

import * as baseConfig from './vitest.config';

export default defineConfig({
  ...baseConfig.default,
  test: {
    ...baseConfig.default.test,
    include: ['**/test/**/*.it.test.{js,ts,jsx,tsx}']
  }
});

================
File: testkit-js/testkit-js/vitest.package.ut.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { defineConfig } from 'vitest/config';

import * as baseConfig from './vitest.config';

export default defineConfig({
  ...baseConfig.default,
  test: {
    ...baseConfig.default.test,
    include: ['**/test/**/*.ut.test.{js,ts,jsx,tsx}']
  }
});

================
File: testkit-js/testkit-js-e2e/src/contract/block-time.compact
================
import CompactStandardLibrary;

export circuit testBlockTimeLt(time: Uint<64>): [] {
  return assert(blockTimeLt(disclose(time)), "Block time is >= time");
}

export circuit testBlockTimeGte(time: Uint<64>): [] {
  return assert(blockTimeGte(disclose(time)), "Block time is < time");
}

export circuit testBlockTimeGt(time: Uint<64>): [] {
  return assert(blockTimeGt(disclose(time)), "Block time is <= time");
}

export circuit testBlockTimeLte(time: Uint<64>): [] {
  return assert(blockTimeLte(disclose(time)), "Block time is > time");
}

================
File: testkit-js/testkit-js-e2e/src/contract/counter-clone.compact
================
import CompactStandardLibrary;

export ledger round: Counter;

witness privateIncrement(): [];

export circuit increment(): [] {
  round.increment(2);
  privateIncrement();
}

export circuit decrement(amount: Uint<16>): [] {
  round.decrement(disclose(amount));
  privateIncrement();
}

export circuit reset(): [] {
  round.resetToDefault();
  privateIncrement();
}

================
File: testkit-js/testkit-js-e2e/src/contract/counter.compact
================
import CompactStandardLibrary;

export ledger round: Counter;

witness privateIncrement(): [];

export circuit increment(): [] {
  round.increment(1);
  privateIncrement();
}

export circuit decrement(amount: Uint<16>): [] {
  round.decrement(disclose(amount));
  privateIncrement();
}

export circuit reset(): [] {
  round.resetToDefault();
  privateIncrement();
}

================
File: testkit-js/testkit-js-e2e/src/contract/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * as CompilerBlockTime from './managed/block-time/contract/index.js';
export * as CompiledCounter from './managed/counter/contract/index.js';
export * as CompiledCounterClone from './managed/counter-clone/contract/index.js';
export * as CompiledSimple from './managed/simple/contract/index.js';
export * as CompiledUnshielded from './managed/unshielded/contract/index.js';
export * from './witnesses.js';

================
File: testkit-js/testkit-js-e2e/src/contract/simple.compact
================
import CompactStandardLibrary;

export ledger round: Counter;

export circuit noop(): [] {
  round.increment(1);
}

================
File: testkit-js/testkit-js-e2e/src/contract/witnesses.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { WitnessContext } from '@midnight-ntwrk/compact-runtime';

import type { Ledger } from './managed/counter/contract/index.js';

export type CounterPrivateState = {
  privateCounter: number;
}

export const createPrivateState = (privateCounter: number): CounterPrivateState => ({
  privateCounter
});

export const createInitialPrivateState = (privateCounter: number) => createPrivateState(privateCounter);

export const witnesses = {
  privateIncrement: ({ privateState }: WitnessContext<Ledger, CounterPrivateState>): [CounterPrivateState, []] => [
    { privateCounter: privateState.privateCounter + 1 },
    []
  ]
};

================
File: testkit-js/testkit-js-e2e/src/node/counter.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  defaultContainersConfiguration,
  type EnvironmentConfiguration,
  getTestEnvironment,
  initializeMidnightProviders,
  logger,
  type MidnightWalletProvider,
  setContainersConfiguration,
  type TestEnvironment
} from '@midnight-ntwrk/testkit-js';
import { type ContractConfiguration } from '@midnight-ntwrk/testkit-js';
import path from 'path';

import { CounterPrivateStateId, type CounterProviders, currentDir, privateStateZero } from '@/index';

import * as api from '../counter-api';

export class CounterConfiguration implements ContractConfiguration {
  readonly privateStateStoreName;
  readonly zkConfigPath;
  constructor(privateStateStoreName?: string, zkConfigPath?: string) {
    this.privateStateStoreName = privateStateStoreName || 'counter-private-state';
    this.zkConfigPath = zkConfigPath || path.resolve(currentDir, '..', 'dist', 'contract', 'managed', 'counter');
  }
}

async function counter() {
  let providers: CounterProviders;
  let testEnvironment: TestEnvironment;
  let environmentConfiguration: EnvironmentConfiguration;
  let wallet: MidnightWalletProvider;
  let contractConfiguration: CounterConfiguration;

  logger.info('Starting counter...');
  try {
    const dir = path.resolve('./../');
    const containersConfiguration = {
      ...defaultContainersConfiguration,
      standalone: {
        ...defaultContainersConfiguration.standalone,
        path: dir,
      },
      proofServer: {
        ...defaultContainersConfiguration.proofServer,
        path: dir
      }
    };
    setContainersConfiguration(containersConfiguration);

    testEnvironment = getTestEnvironment(logger);
    environmentConfiguration = await testEnvironment.start();
    contractConfiguration = new CounterConfiguration();
    api.setLogger(logger);
    wallet = await testEnvironment.getMidnightWalletProvider();
    providers = initializeMidnightProviders(wallet, environmentConfiguration, contractConfiguration);

    // Deploy the contract and call its methods
    const deployedCounterContract = await api.deploy(providers, privateStateZero);
    await api.increment(deployedCounterContract);
    await api.getCounterLedgerState(providers, deployedCounterContract.deployTxData.public.contractAddress);
    await api.getCounterPrivateState(providers, CounterPrivateStateId);
  } finally {
    await testEnvironment!.shutdown();
  }
}

counter()
  .then(() => logger.info('Counter test completed'))
  .catch((error) => {
    logger.error('Counter test failed:', error);
    process.exit(1);
  });

================
File: testkit-js/testkit-js-e2e/src/block-time-api.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { deployContract } from '@midnight-ntwrk/midnight-js-contracts';
import type { FinalizedTxData } from '@midnight-ntwrk/midnight-js-types';
import { type ContractConfiguration } from '@midnight-ntwrk/testkit-js';
import path from 'path';
import type { Logger } from 'pino';
import { WebSocket } from 'ws';

import type {
  BlockTimeContract,
  BlockTimeProviders,
  DeployedBlockTimeContract
} from '@/block-time-types';

import { CompilerBlockTime } from './contract';

export const currentDir = path.resolve(new URL(import.meta.url).pathname, '..');

// @ts-expect-error: It's needed to enable WebSocket usage through apollo
globalThis.WebSocket = WebSocket;

// TODO: create class accepting logger

let logger: Logger;

export const setLogger = (_logger: Logger) => {
  logger = _logger;
};

export class BlockTimeConfiguration implements ContractConfiguration {
  readonly privateStateStoreName;
  readonly zkConfigPath;
  constructor(privateStateStoreName?: string, zkConfigPath?: string) {
    this.privateStateStoreName = privateStateStoreName || 'block-time-private-state';
    this.zkConfigPath = zkConfigPath || path.resolve(currentDir, '..', 'dist', 'contract', 'managed', 'block-time');
  }
}

export const CIRCUIT_ID_TEST_BLOCK_TIME_LT = 'testBlockTimeLt' as const;
export const CIRCUIT_ID_TEST_BLOCK_TIME_GTE = 'testBlockTimeGte' as const;
export const CIRCUIT_ID_TEST_BLOCK_TIME_LTE = 'testBlockTimeLte' as const;

export const blockTimeContractInstance: BlockTimeContract = new CompilerBlockTime.Contract({});

export const deploy = async (
  providers: BlockTimeProviders
): Promise<DeployedBlockTimeContract> => {
  logger.info('Deploying block time contract...');
  const blockTimeContract = await deployContract(providers, {
    contract: blockTimeContractInstance
  });
  logger.info(`Deployed contract at address: ${blockTimeContract.deployTxData.public.contractAddress}`);
  return blockTimeContract;
};

export const testBlockTimeLt = async (blockTimeContract: DeployedBlockTimeContract, time: bigint): Promise<FinalizedTxData> => {
  logger.info('Testing block time less than...');
  const finalizedTxData = await blockTimeContract.callTx.testBlockTimeLt(time);
  logger.info(`Transaction ${finalizedTxData.public.txId} added in block ${finalizedTxData.public.blockHeight}`);
  return finalizedTxData.public;
};

export const testBlockTimeGte = async (blockTimeContract: DeployedBlockTimeContract, time: bigint): Promise<FinalizedTxData> => {
  logger.info('Testing block time greater than or equal...');
  const finalizedTxData = await blockTimeContract.callTx.testBlockTimeGte(time);
  logger.info(`Transaction ${finalizedTxData.public.txId} added in block ${finalizedTxData.public.blockHeight}`);
  return finalizedTxData.public;
};

export const testBlockTimeGt = async (blockTimeContract: DeployedBlockTimeContract, time: bigint): Promise<FinalizedTxData> => {
  logger.info('Testing block time greater than...');
  const finalizedTxData = await blockTimeContract.callTx.testBlockTimeGt(time);
  logger.info(`Transaction ${finalizedTxData.public.txId} added in block ${finalizedTxData.public.blockHeight}`);
  return finalizedTxData.public;
};

export const testBlockTimeLte = async (blockTimeContract: DeployedBlockTimeContract, time: bigint): Promise<FinalizedTxData> => {
  logger.info('Testing block time less than or equal...');
  const finalizedTxData = await blockTimeContract.callTx.testBlockTimeLte(time);
  logger.info(`Transaction ${finalizedTxData.public.txId} added in block ${finalizedTxData.public.blockHeight}`);
  return finalizedTxData.public;
};

================
File: testkit-js/testkit-js-e2e/src/block-time-types.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { DeployedContract } from '@midnight-ntwrk/midnight-js-contracts';
import type { ImpureCircuitId, MidnightProviders } from '@midnight-ntwrk/midnight-js-types';

import type { CompilerBlockTime } from './contract';

export type BlockTimeContract = CompilerBlockTime.Contract<undefined>;

export type BlockTimeCircuits = ImpureCircuitId<BlockTimeContract> & string;

export type BlockTimeProviders = MidnightProviders<BlockTimeCircuits, string, undefined>;

export type DeployedBlockTimeContract = DeployedContract<BlockTimeContract>;

================
File: testkit-js/testkit-js-e2e/src/constants.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { sampleContractAddress } from '@midnight-ntwrk/compact-runtime';

export const MINUTE = 60_000;
export const SLOW_TEST_TIMEOUT = 6 * MINUTE;
export const VERY_SLOW_TEST_TIMEOUT = 10 * MINUTE;

export const UNDEPLOYED_CONTRACT_ADDRESS = sampleContractAddress();
export const INVALID_CONTRACT_ADDRESS_TOO_LONG = `00${sampleContractAddress()}`;
export const INVALID_CONTRACT_ADDRESS_HEX_FORMAT = `${sampleContractAddress()}z`;

================
File: testkit-js/testkit-js-e2e/src/counter-api.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ContractAddress } from '@midnight-ntwrk/ledger-v6';
import { deployContract } from '@midnight-ntwrk/midnight-js-contracts';
import type { FinalizedTxData } from '@midnight-ntwrk/midnight-js-types';
import { assertIsContractAddress } from '@midnight-ntwrk/midnight-js-utils';
import {
  type ContractConfiguration,
  type EnvironmentConfiguration,
  initializeMidnightProviders,
  type MidnightWalletProvider
} from '@midnight-ntwrk/testkit-js';
import path from 'path';
import type { Logger } from 'pino';
import { WebSocket } from 'ws';

import {
  CompiledCounter,
  type CounterPrivateState,
  createInitialPrivateState
} from './contract';
import { type CounterCloneContract,createCounterCloneContractInstance } from './counter-clone-types';
import {
  type CounterContract,
  CounterPrivateStateId,
  type CounterProviders,
  createCounterContractInstance,
  type DeployedCounterContract
} from './counter-types';
import { createSimpleContractInstance, type SimpleContract } from './simple-types';

export const currentDir = path.resolve(new URL(import.meta.url).pathname, '..');

// @ts-expect-error: It's needed to enable WebSocket usage through apollo
globalThis.WebSocket = WebSocket;

// TODO: create class accepting logger

let logger: Logger;

export const setLogger = (_logger: Logger) => {
  logger = _logger;
};

export const CIRCUIT_ID_RESET = 'reset';
export const CIRCUIT_ID_INCREMENT = 'increment';
export const CIRCUIT_ID_DECREMENT = 'decrement';
export const CONTRACT_CIRCUITS = ['decrement', 'increment', 'reset'];

export class CounterConfiguration implements ContractConfiguration {
  readonly privateStateStoreName;
  readonly zkConfigPath;
  constructor(privateStateStoreName?: string, zkConfigPath?: string) {
    this.privateStateStoreName = privateStateStoreName || 'counter-private-state';
    this.zkConfigPath = zkConfigPath || path.resolve(currentDir, '..', 'dist', 'contract', 'managed', 'counter');
  }
}

export class CounterCloneConfiguration implements ContractConfiguration {
  readonly privateStateStoreName;
  readonly zkConfigPath;
  constructor(privateStateStoreName?: string, zkConfigPath?: string) {
    this.privateStateStoreName = privateStateStoreName || 'counter-clone-private-state';
    this.zkConfigPath =
      zkConfigPath || path.resolve(currentDir, '..', 'dist', 'contract', 'managed', 'counter-clone');
  }
}

export class SimpleConfiguration implements ContractConfiguration {
  readonly privateStateStoreName;
  readonly zkConfigPath;
  constructor(privateStateStoreName?: string, zkConfigPath?: string) {
    this.privateStateStoreName = privateStateStoreName || 'simple-private-state';
    this.zkConfigPath = zkConfigPath || path.resolve(currentDir, '..', 'dist', 'contract', 'managed', 'simple');
  }
}

export const getCounterPrivateState = async (
  providers: CounterProviders,
  privateStateId: typeof CounterPrivateStateId
): Promise<CounterPrivateState | null> => {
  logger.info('Checking contract private state...');
  const privateState = await providers.privateStateProvider.get(privateStateId);
  logger.info(`Private state: ${privateState?.privateCounter}`);
  return privateState;
};

export const getCounterLedgerState = async (
  providers: CounterProviders,
  contractAddress: ContractAddress
): Promise<bigint | null> => {
  assertIsContractAddress(contractAddress);
  logger.info('Checking contract ledger state...');
  const state = await providers.publicDataProvider
    .queryContractState(contractAddress)
    .then((contractState) => (contractState != null ? CompiledCounter.ledger(contractState.data).round : null));
  logger.info(`Ledger state: ${state}`);
  return state;
};

export const simpleContractInstance: SimpleContract = createSimpleContractInstance();

export const counterContractInstance: CounterContract = createCounterContractInstance();

export const cloneContractInstance: CounterCloneContract = createCounterCloneContractInstance();

export const deploy = async (
  providers: CounterProviders,
  privateState: CounterPrivateState
): Promise<DeployedCounterContract> => {
  logger.info('Deploying counter contract...');
  const counterContract = await deployContract(providers, {
    contract: counterContractInstance,
    privateStateId: CounterPrivateStateId,
    initialPrivateState: privateState
  });
  logger.info(`Deployed contract at address: ${counterContract.deployTxData.public.contractAddress}`);
  return counterContract;
};

export const increment = async (counterContract: DeployedCounterContract): Promise<FinalizedTxData> => {
  logger.info('Incrementing...');
  const finalizedTxData = await counterContract.callTx.increment();
  logger.info(`Transaction ${finalizedTxData.public.txId} added in block ${finalizedTxData.public.blockHeight}`);
  return finalizedTxData.public;
};

export const randomCircuitId = (length = 32) =>
  Array.from({ length }, () => 'abcdefghijklmnopqrstuvwxyz'.charAt(Math.floor(Math.random() * 26))).join('');

const getConfigurationWithEmptyPrivateStore = () => {
  return new CounterConfiguration(`counter-private-store-${Date.now()}`);
};

export const deployCounterContract = async (
  wallet: MidnightWalletProvider,
  environmentConfiguration: EnvironmentConfiguration
) => {
  logger.info(`Deploying new contract`);
  const privateState = createInitialPrivateState(0);
  logger.info(`Private state: ${JSON.stringify(privateState)}`);
  const counterProviders: CounterProviders = initializeMidnightProviders(
    wallet,
    environmentConfiguration,
    getConfigurationWithEmptyPrivateStore()
  );
  const deployedCounterContract: DeployedCounterContract = await deploy(counterProviders, privateState);
  const { contractAddress } = deployedCounterContract.deployTxData.public;
  logger.info(`Contract deployed`);
  return { counterProviders, deployedCounterContract, contractAddress, privateState };
};

================
File: testkit-js/testkit-js-e2e/src/counter-clone-types.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ImpureCircuitId } from '@midnight-ntwrk/midnight-js-types';

import { CompiledCounterClone, type CounterPrivateState, witnesses } from './contract';

export type CounterCloneContract = CompiledCounterClone.Contract<CounterPrivateState>;

export type CounterCloneCircuits = ImpureCircuitId<CounterCloneContract>;

export const CounterClonePrivateStateId = 'counterClonePrivateState';

export const createCounterCloneContractInstance = (): CounterCloneContract => new CompiledCounterClone.Contract(witnesses);

================
File: testkit-js/testkit-js-e2e/src/counter-types.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { DeployedContract } from '@midnight-ntwrk/midnight-js-contracts';
import type { ImpureCircuitId, MidnightProviders } from '@midnight-ntwrk/midnight-js-types';

import { CompiledCounter, type CounterPrivateState, createInitialPrivateState, witnesses } from './contract';

export type CounterContract = CompiledCounter.Contract<CounterPrivateState>;

export type DeployedCounterContract = DeployedContract<CounterContract>;

export type CounterCircuits = ImpureCircuitId<CounterContract> & string;

export const CounterPrivateStateId = 'counterPrivateState';

export type CounterProviders = MidnightProviders<CounterCircuits, typeof CounterPrivateStateId, CounterPrivateState>;

export const privateStateZero = createInitialPrivateState(0);

export const createCounterContractInstance = (): CounterContract => new CompiledCounter.Contract(witnesses);

================
File: testkit-js/testkit-js-e2e/src/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * from './constants';
export * from './counter-api';
export * from './counter-clone-types';
export * from './counter-types';
export * from './simple-types';

================
File: testkit-js/testkit-js-e2e/src/simple-types.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ImpureCircuitId, MidnightProviders } from '@midnight-ntwrk/midnight-js-types';

import { CompiledSimple } from './contract';

export type SimpleContract = CompiledSimple.Contract<undefined>;

export type SimpleCircuits = ImpureCircuitId<SimpleContract>;

export type SimpleProviders = MidnightProviders<SimpleCircuits>;

export const createSimpleContractInstance = (): SimpleContract => new CompiledSimple.Contract({});

================
File: testkit-js/testkit-js-e2e/src/unshielded-types.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import type { ImpureCircuitId, MidnightProviders } from '@midnight-ntwrk/midnight-js-types';

import { CompiledUnshielded } from './contract';

export type UnshieldedContract = CompiledUnshielded.Contract<undefined>;

export type UnshieldedContractCircuits = ImpureCircuitId<UnshieldedContract>;

export type UnshieldedContractProviders = MidnightProviders<UnshieldedContractCircuits>;

export const createUnshieldedContract = () : UnshieldedContract => new CompiledUnshielded.Contract({});

================
File: testkit-js/testkit-js-e2e/test/contracts.blocktime.it.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type ContractAddress } from '@midnight-ntwrk/ledger-v6';
import {
  createUnprovenCallTx,
  type FinalizedDeployTxData,
  submitTx
} from '@midnight-ntwrk/midnight-js-contracts';
import { FailEntirely, SucceedEntirely } from '@midnight-ntwrk/midnight-js-types';
import type {
  EnvironmentConfiguration,
  MidnightWalletProvider,
  TestEnvironment
} from '@midnight-ntwrk/testkit-js';
import {
  createLogger,
  getTestEnvironment,
  initializeMidnightProviders
} from '@midnight-ntwrk/testkit-js';
import path from 'path';

import * as api from '@/block-time-api';
import { BlockTimeConfiguration } from '@/block-time-api';
import {
  type BlockTimeContract,
  type BlockTimeProviders,
  type DeployedBlockTimeContract
} from '@/block-time-types';

const logger = createLogger(
  path.resolve(`${process.cwd()}`, 'logs', 'tests', `block_time_${new Date().toISOString()}.log`)
);

const currentTimeSeconds = () => BigInt(Math.floor(Date.now() / 1_000));

// We don't want to use vitest virtual time because we want time to proceed relatively
// uniformly on the node and the local device for testing and advancing local device time
// without advancing time on node container risks them being unintentionally inconsistent.
const sleep = (ms: number): Promise<void> =>
  new Promise((resolve) => setTimeout(resolve, ms));

describe('Block Time Contract Tests', () => {
  const SLOW_TEST_TIMEOUT = 240_000;
  const BLOCK_TIME_FUTURE_BUFFER = 60n;
  const BLOCK_TIME_PAST_BUFFER = 60n;

  let providers: BlockTimeProviders;
  let finalizedDeployTxData: FinalizedDeployTxData<BlockTimeContract>;
  let deployedContract: DeployedBlockTimeContract;
  let contractAddress: ContractAddress;
  let testEnvironment: TestEnvironment;
  let wallet: MidnightWalletProvider;
  let environmentConfiguration: EnvironmentConfiguration;
  let contractConfiguration: BlockTimeConfiguration;

  beforeEach(() => {
    logger.info(`Running test: ${expect.getState().currentTestName}`);
  });

  beforeAll(async () => {
    testEnvironment = getTestEnvironment(logger);
    environmentConfiguration = await testEnvironment.start();
    contractConfiguration = new BlockTimeConfiguration();
    api.setLogger(logger);
    wallet = await testEnvironment.getMidnightWalletProvider();
    providers = initializeMidnightProviders(wallet, environmentConfiguration, contractConfiguration);
    deployedContract = await api.deploy(providers);
    finalizedDeployTxData = deployedContract.deployTxData;
    contractAddress = finalizedDeployTxData.public.contractAddress;
    logger.info(`Contract deployed at address: ${contractAddress}`);
  }, SLOW_TEST_TIMEOUT);

  afterAll(async () => {
    await testEnvironment.shutdown();
  });

  describe('blockTimeLt tests', () => {
    it('should succeed when both device time and node time are less than future time', async () => {
      const futureTime = currentTimeSeconds() + BLOCK_TIME_FUTURE_BUFFER;
      const finalizedTx = await api.testBlockTimeLt(deployedContract, futureTime);
      expect(finalizedTx.status).toEqual(SucceedEntirely);
    }, SLOW_TEST_TIMEOUT);

    it('should fail immediately on device when device time is already past the check time', async () => {
      const pastTime = currentTimeSeconds() - 10n;
      await expect(() => api.testBlockTimeLt(deployedContract, pastTime)).rejects.toThrow('Block time is >= time');
    });

    // TODO: Uncomment once PM-19372 is resolved
    it.skip('should succeed on device but fail on node when submission is delayed', async () => {
      const futureTime = currentTimeSeconds() + 3n; // Only 3 seconds in future
      const unprovenCallTxOptions = {
        contract: api.blockTimeContractInstance,
        circuitId: api.CIRCUIT_ID_TEST_BLOCK_TIME_LT,
        contractAddress,
        args: [futureTime] as [bigint]
      };
      const unprovenCallTx = await createUnprovenCallTx(providers, unprovenCallTxOptions);
      // Delay submission so node time exceeds futureTime
      await sleep(4000);
      // Should fail because node time > futureTime
      const finalizedCallTx = await submitTx(providers, {
        unprovenTx: unprovenCallTx.private.unprovenTx,
        newCoins: unprovenCallTx.private.newCoins,
        circuitId: unprovenCallTxOptions.circuitId
      });
      expect(finalizedCallTx.status).toEqual(FailEntirely);
    }, SLOW_TEST_TIMEOUT);

    it('should succeed when both device time and node time are greater than past time', async () => {
      const pastTime = currentTimeSeconds() - BLOCK_TIME_PAST_BUFFER;
      const finalizedTx = await api.testBlockTimeGte(deployedContract, pastTime);
      expect(finalizedTx.status).toEqual(SucceedEntirely);
    }, SLOW_TEST_TIMEOUT);

    it('should fail immediately on device when device time is less than check time', async () => {
      const futureTime = currentTimeSeconds() + BLOCK_TIME_FUTURE_BUFFER;
      await expect(() => api.testBlockTimeGte(deployedContract, futureTime)).rejects.toThrow('Block time is < time');
    });

    it('should succeed even with submission delay when checking past time', async () => {
      const pastTime = currentTimeSeconds() - 30n;
      const unprovenCallTxOptions = {
        contract: api.blockTimeContractInstance,
        circuitId: api.CIRCUIT_ID_TEST_BLOCK_TIME_GTE,
        contractAddress,
        args: [pastTime] as [bigint]
      };
      const unprovenCallTx = await createUnprovenCallTx(providers, unprovenCallTxOptions);
      // Delay submission
      await sleep(3000);
      // Should still succeed because node time is still >= pastTime
      const finalizedCallTx = await submitTx(providers, {
        unprovenTx: unprovenCallTx.private.unprovenTx,
        newCoins: unprovenCallTx.private.newCoins,
        circuitId: unprovenCallTxOptions.circuitId
      });
      expect(finalizedCallTx.status).toEqual(SucceedEntirely);
    }, SLOW_TEST_TIMEOUT);

    it('should succeed when both device time and node time are greater than past time', async () => {
      const pastTime = currentTimeSeconds() - BLOCK_TIME_PAST_BUFFER;
      const finalizedTx = await api.testBlockTimeGt(deployedContract, pastTime);
      expect(finalizedTx.status).toEqual(SucceedEntirely);
    }, SLOW_TEST_TIMEOUT);

    it('should fail when device time is not greater than check time', async () => {
      const futureTime = currentTimeSeconds() + BLOCK_TIME_FUTURE_BUFFER;
      await expect(() => api.testBlockTimeGt(deployedContract, futureTime)).rejects.toThrow('Block time is <= time');
    });

    it('should succeed when both device time and node time are less than or equal to future time', async () => {
      const futureTime = currentTimeSeconds() + BLOCK_TIME_FUTURE_BUFFER;
      const finalizedTx = await api.testBlockTimeLte(deployedContract, futureTime);
      expect(finalizedTx.status).toEqual(SucceedEntirely);
    }, SLOW_TEST_TIMEOUT);

    it('should fail immediately on device when device time exceeds check time', async () => {
      const pastTime = currentTimeSeconds() - BLOCK_TIME_PAST_BUFFER;
      await expect(() => api.testBlockTimeLte(deployedContract, pastTime)).rejects.toThrow('Block time is > time');
    });

    // TODO: Uncomment once PM-19372 is resolved
    it.skip('should succeed on device but fail on node when submission delay causes time to exceed threshold', async () => {
      const futureTime = currentTimeSeconds() + 2n; // Only 2 seconds in future
      const unprovenCallTxOptions = {
        contract: api.blockTimeContractInstance,
        circuitId: api.CIRCUIT_ID_TEST_BLOCK_TIME_LTE,
        contractAddress,
        args: [futureTime] as [bigint]
      };
      const unprovenCallTx = await createUnprovenCallTx(providers, unprovenCallTxOptions);
      // Delay so node time exceeds futureTime
      await sleep(4000);
      const finalizedCallTx = await submitTx(providers, {
        unprovenTx: unprovenCallTx.private.unprovenTx,
        newCoins: unprovenCallTx.private.newCoins,
        circuitId: unprovenCallTxOptions.circuitId
      });
      expect(finalizedCallTx.status).toEqual(FailEntirely);
    }, SLOW_TEST_TIMEOUT);

    describe('should demonstrate different failure points for Lt check', async () => {
      it(
        'Immediate past time - fails on device',
        async () => {
          const pastTime = currentTimeSeconds() - 5n;
          await expect(() => api.testBlockTimeLt(deployedContract, pastTime)).rejects.toThrow('Block time is >= time');
        },
        SLOW_TEST_TIMEOUT
      );

      // TODO: Uncomment once PM-19372 is resolved
      it.skip(
        'Near future time with delay - succeeds on device, fails on node',
        async () => {
          const nearFutureTime = currentTimeSeconds() + 2n;
          const unprovenCallTxOptions = {
            contract: api.blockTimeContractInstance,
            circuitId: api.CIRCUIT_ID_TEST_BLOCK_TIME_LT,
            contractAddress,
            args: [nearFutureTime] as [bigint]
          };
          const unprovenCallTx = await createUnprovenCallTx(providers, unprovenCallTxOptions);
          await sleep(3000);
          const finalizedCallTx = await submitTx(providers, {
            unprovenTx: unprovenCallTx.private.unprovenTx,
            newCoins: unprovenCallTx.private.newCoins,
            circuitId: unprovenCallTxOptions.circuitId
          });
          expect(finalizedCallTx.status).toEqual(FailEntirely);
        },
        SLOW_TEST_TIMEOUT
      );

      it(
        'Far future time - succeeds on both device and node',
        async () => {
          const farFutureTime = currentTimeSeconds() + 120n;
          const finalizedTx = await api.testBlockTimeLt(deployedContract, farFutureTime);
          expect(finalizedTx.status).toEqual(SucceedEntirely);
        },
        SLOW_TEST_TIMEOUT
      );
    });

    it('should handle maximum time values', async () => {
      const maxTime = 2n ** 63n - 1n; // Max value for Uint<64>
      // Lt should succeed with max time (current time is always less)
      const finalizedTx = await api.testBlockTimeLt(deployedContract, maxTime);
      expect(finalizedTx.status).toEqual(SucceedEntirely);
    }, SLOW_TEST_TIMEOUT);

    it('should handle zero time value', async () => {
      const zeroTime = 0n;
      // Lt with 0 should fail (block time is always >= 0)
      await expect(() => api.testBlockTimeLt(deployedContract, zeroTime)).rejects.toThrow('Block time is >= time');

      // Lte with 0 should fail (block time is always > 0)
      await expect(() => api.testBlockTimeLte(deployedContract, zeroTime)).rejects.toThrow('Block time is > time');

      // Gte with 0 should succeed (block time is always >= 0)
      const gteTx = await api.testBlockTimeGte(deployedContract, zeroTime);
      expect(gteTx.status).toEqual(SucceedEntirely);

      // Gt with 0 should succeed (block time is always > 0)
      const gtTx = await api.testBlockTimeGt(deployedContract, zeroTime);
      expect(gtTx.status).toEqual(SucceedEntirely);
    }, SLOW_TEST_TIMEOUT);
  });
});

================
File: testkit-js/testkit-js-e2e/test/contracts.snarkupgrade.it.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ContractAddress } from '@midnight-ntwrk/ledger-v6';
import {
  createCircuitCallTxInterface,
  createCircuitMaintenanceTxInterface,
  createCircuitMaintenanceTxInterfaces,
  submitRemoveVerifierKeyTx
} from '@midnight-ntwrk/midnight-js-contracts';
import { SucceedEntirely } from '@midnight-ntwrk/midnight-js-types';
import type {
  EnvironmentConfiguration,
  MidnightWalletProvider,
  TestEnvironment
} from '@midnight-ntwrk/testkit-js';
import { createLogger, getTestEnvironment } from '@midnight-ntwrk/testkit-js';
import path from 'path';

import * as api from '@/counter-api';
import { CIRCUIT_ID_RESET, counterContractInstance } from '@/counter-api';
import { type CounterProviders } from '@/counter-types';

const logger = createLogger(
  path.resolve(`${process.cwd()}`, 'logs', 'tests', `contracts_snark_upgrade_${new Date().toISOString()}.log`)
);

describe('Contracts API Snark Upgrade [dedicated contract] [@slow]', () => {
  let testEnvironment: TestEnvironment;
  let wallet: MidnightWalletProvider;
  let environmentConfiguration: EnvironmentConfiguration;
  let counterProviders: CounterProviders;
  let contractAddress: ContractAddress;

  beforeAll(async () => {
    testEnvironment = getTestEnvironment(logger);
    environmentConfiguration = await testEnvironment.start();
    api.setLogger(logger);
    wallet = await testEnvironment.getMidnightWalletProvider();
  });

  afterAll(async () => {
    await testEnvironment.shutdown();
  });

  beforeEach(async () => {
    logger.info(`Running test=${expect.getState().currentTestName}`);
    ({ counterProviders, contractAddress } = await api.deployCounterContract(wallet, environmentConfiguration));
  });

  /**
   * Test successful verifier key removal using submitRemoveVerifierKeyTx.
   *
   * @given A deployed counter contract with verifier keys
   * @and Valid counter providers and contract address
   * @when Submitting remove verifier key transaction for reset circuit
   * @then Should successfully remove verifier key
   * @and Should return transaction with SucceedEntirely status
   */
  it('should successfully remove verifier key using submitRemoveVerifierKeyTx', async () => {
    const finalizedTxData = await submitRemoveVerifierKeyTx(counterProviders, contractAddress, CIRCUIT_ID_RESET);

    expect(finalizedTxData.status).toEqual(SucceedEntirely);
  });

  /**
   * Test successful verifier key removal using circuit maintenance interface.
   *
   * @given A deployed contract and circuit maintenance interface
   * @and Reset circuit identifier and contract address
   * @when Creating maintenance interface and removing verifier key
   * @then Should successfully remove verifier key
   * @and Should return transaction with SucceedEntirely status
   */
  it('should successfully remove verifier key using createContractMaintenanceTxInterface', async () => {
    const circuitMaintenanceTxInterface = createCircuitMaintenanceTxInterface(
      counterProviders,
      CIRCUIT_ID_RESET,
      contractAddress
    );
    const finalizedTxData = await circuitMaintenanceTxInterface.removeVerifierKey();

    expect(finalizedTxData.status).toEqual(SucceedEntirely);
  });

  /**
   * Test verifier key removal and contract interaction behavior.
   *
   * @given A deployed contract with multiple circuits
   * @and Circuit maintenance interfaces for all circuits
   * @when Removing verifier key for reset circuit
   * @and Attempting to interact with removed circuit
   * @then Should successfully remove verifier key
   * @and Should throw error when trying to use removed circuit operation
   */
  it('should successfully remove verifier key and disable circuit operation', async () => {
    const circuitMaintenanceTxInterfaces = createCircuitMaintenanceTxInterfaces(
      counterProviders,
      counterContractInstance,
      contractAddress
    );
    const finalizedTxData = await circuitMaintenanceTxInterfaces.reset.removeVerifierKey();
    expect(finalizedTxData.status).toEqual(SucceedEntirely);

    logger.info('Interact with contract');
    const contractCircuitsInterface = createCircuitCallTxInterface(
      counterProviders,
      counterContractInstance,
      contractAddress,
      'counterPrivateState'
    );

    await expect(() => contractCircuitsInterface.reset()).rejects.toThrow(
      "Operation 'reset' is undefined for contract state ContractState (Array(1) [\n" +
        '    <[-]: b8>,\n' +
        ']{\n' +
        '    increment: <verifier key>,\n' +
        '    decrement: <verifier key>,\n' +
        '}ContractState )'
    );
  });

  /**
   * Test verifier key insertion after removal.
   *
   * @given A deployed contract with existing verifier keys
   * @and Circuit maintenance interfaces and verifier key
   * @when Attempting to insert existing key (should fail)
   * @and Removing verifier key then inserting it back
   * @then Should fail on duplicate key insertion
   * @and Should succeed on insertion after removal with SucceedEntirely status
   */
  it('should succeed on verifier key insertion retry after removal', async () => {
    const vk = await counterProviders.zkConfigProvider.getVerifierKey(CIRCUIT_ID_RESET);
    const circuitMaintenanceTxInterfaces = createCircuitMaintenanceTxInterfaces(
      counterProviders,
      counterContractInstance,
      contractAddress
    );
    await expect(() => circuitMaintenanceTxInterfaces.reset.insertVerifierKey(vk)).rejects.toThrow(
      `Circuit 'reset' is already defined for contract at address '${contractAddress}'`
    );
    await circuitMaintenanceTxInterfaces.reset.removeVerifierKey();
    const finalizedTxData = await circuitMaintenanceTxInterfaces.reset.insertVerifierKey(vk);

    expect(finalizedTxData.status).toEqual(SucceedEntirely);
  });

  /**
   * Test verifier key insertion error handling for wrong circuit.
   *
   * @given A deployed contract with multiple circuits
   * @and Reset circuit verifier key and maintenance interfaces
   * @when Removing reset circuit verifier key
   * @and Attempting to insert reset key into increment circuit
   * @then Should fail with error about increment circuit already being defined
   * @and Should properly validate circuit-key correspondence
   */
  it('should fail when inserting verifier key for wrong circuit after removal', async () => {
    const vk = await counterProviders.zkConfigProvider.getVerifierKey(CIRCUIT_ID_RESET);
    const circuitMaintenanceTxInterfaces = createCircuitMaintenanceTxInterfaces(
      counterProviders,
      counterContractInstance,
      contractAddress
    );
    await circuitMaintenanceTxInterfaces.reset.removeVerifierKey();

    await expect(() => circuitMaintenanceTxInterfaces.increment.insertVerifierKey(vk)).rejects.toThrow(
      `Circuit 'increment' is already defined for contract at address '${contractAddress}'`
    );
  });
});

================
File: testkit-js/testkit-js-e2e/test/contracts.snarkupgrade.singlecontract.it.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { sampleSigningKey } from '@midnight-ntwrk/compact-runtime';
import type { ContractAddress } from '@midnight-ntwrk/ledger-v6';
import {
  createCircuitMaintenanceTxInterface,
  createCircuitMaintenanceTxInterfaces,
  createContractMaintenanceTxInterface,
  submitInsertVerifierKeyTx,
  submitRemoveVerifierKeyTx,
  submitReplaceAuthorityTx
} from '@midnight-ntwrk/midnight-js-contracts';
import { SucceedEntirely, type VerifierKey } from '@midnight-ntwrk/midnight-js-types';
import {
  createLogger,
  type EnvironmentConfiguration,
  getTestEnvironment,
  initializeMidnightProviders,
  type MidnightWalletProvider,
  type TestEnvironment} from '@midnight-ntwrk/testkit-js';
import path from 'path';

import { UNDEPLOYED_CONTRACT_ADDRESS } from '@/constants';
import * as api from '@/counter-api';
import {
  CIRCUIT_ID_DECREMENT,
  CIRCUIT_ID_RESET,
  CounterCloneConfiguration,
  counterContractInstance,
  SimpleConfiguration
} from '@/counter-api';
import { type CounterProviders, type DeployedCounterContract } from '@/counter-types';

const logger = createLogger(
  path.resolve(`${process.cwd()}`, 'logs', 'tests', `contracts_snark_upgrade_${new Date().toISOString()}.log`)
);

describe('Contracts API Snark Upgrade [single contract]', () => {
  let testEnvironment: TestEnvironment;
  let wallet: MidnightWalletProvider;
  let environmentConfiguration: EnvironmentConfiguration;
  let counterCloneContractProviders: CounterProviders;
  let simpleContractProviders: CounterProviders;
  let counterProviders: CounterProviders;
  let contractAddress: ContractAddress;
  let deployedCounterContract: DeployedCounterContract;

  beforeAll(async () => {
    testEnvironment = getTestEnvironment(logger);
    environmentConfiguration = await testEnvironment.start();
    api.setLogger(logger);
    wallet = await testEnvironment.getMidnightWalletProvider();
    counterCloneContractProviders = initializeMidnightProviders(
      wallet,
      environmentConfiguration,
      new CounterCloneConfiguration()
    );
    simpleContractProviders = initializeMidnightProviders(wallet, environmentConfiguration, new SimpleConfiguration());
    ({ counterProviders, deployedCounterContract, contractAddress } = await api.deployCounterContract(
      wallet,
      environmentConfiguration
    ));
  });

  afterAll(async () => {
    await testEnvironment.shutdown();
  });

  beforeEach(() => {
    logger.info(`Running test=${expect.getState().currentTestName}`);
  });

  it('submitReplaceAuthorityTx - successful replace authority with new key[@slow]', async () => {
    const newAuthority = sampleSigningKey();
    const finalizedTxData = await submitReplaceAuthorityTx(counterProviders, contractAddress)(newAuthority);

    expect(finalizedTxData.status).toEqual(SucceedEntirely);
  });

  it('submitReplaceAuthorityTx - successful replace authority with same key [@slow]', async () => {
    const authority = await counterProviders.privateStateProvider.getSigningKey(contractAddress);
    expect(authority).not.toBeNull();
    if (authority) {
      const finalizedTxData = await submitReplaceAuthorityTx(counterProviders, contractAddress)(authority);

      expect(finalizedTxData.status).toEqual(SucceedEntirely);
    }
  });

  it('submitReplaceAuthorityTx - should fail on replace contract that is not deployed to contract address', async () => {
    const authority = sampleSigningKey();

    await expect(submitReplaceAuthorityTx(counterProviders, UNDEPLOYED_CONTRACT_ADDRESS)(authority)).rejects.toThrow(
      `No contract state found on chain for contract address '${UNDEPLOYED_CONTRACT_ADDRESS}'`
    );
  });

  it('submitReplaceAuthorityTx - should fail when signing key for contract address does not exist', async () => {
    const authority = sampleSigningKey();

    await expect(submitReplaceAuthorityTx(counterCloneContractProviders, contractAddress)(authority)).rejects.toThrow(
      `Signing key for contract address '${contractAddress}' not found`
    );
  });

  it('submitInsertVerifierKeyTx - should fail on invalid verifier key', async () => {
    const vk = new Uint8Array(1) as VerifierKey;

    await expect(submitInsertVerifierKeyTx(counterProviders, contractAddress, CIRCUIT_ID_RESET, vk)).rejects.toThrow(
      `Circuit 'reset' is already defined for contract at address '${contractAddress}`
    );
  });

  it('submitInsertVerifierKeyTx - successful insert on not present circuitId [@slow]', async () => {
    const vk = await counterProviders.zkConfigProvider.getVerifierKey(CIRCUIT_ID_RESET);
    const finalizedTxData = await submitInsertVerifierKeyTx(
      counterProviders,
      contractAddress,
      api.randomCircuitId(),
      vk
    );

    expect(finalizedTxData.status).toEqual(SucceedEntirely);
  });

  it('submitInsertVerifierKeyTx - should fail on contract not present on contract address', async () => {
    const vk = await counterProviders.zkConfigProvider.getVerifierKey(CIRCUIT_ID_RESET);

    await expect(
      submitInsertVerifierKeyTx(counterProviders, UNDEPLOYED_CONTRACT_ADDRESS, CIRCUIT_ID_RESET, vk)
    ).rejects.toThrow(`No contract state found on chain for contract address '${UNDEPLOYED_CONTRACT_ADDRESS}'`);
  });

  it('submitInsertVerifierKeyTx - should fail on providers for different contract with different API', async () => {
    const vk = await counterProviders.zkConfigProvider.getVerifierKey(CIRCUIT_ID_RESET);

    await expect(
      submitInsertVerifierKeyTx(simpleContractProviders, UNDEPLOYED_CONTRACT_ADDRESS, CIRCUIT_ID_RESET, vk)
    ).rejects.toThrow(`No contract state found on chain for contract address '${UNDEPLOYED_CONTRACT_ADDRESS}'`);
  });

  it('submitRemoveVerifierKeyTx - should fail on not present circuitId', async () => {
    const circuitId = api.randomCircuitId();
    await expect(submitRemoveVerifierKeyTx(counterProviders, contractAddress, circuitId)).rejects.toThrow(
      `Circuit '${circuitId}' not found for contract at address '${contractAddress}'`
    );
  });

  it('submitRemoveVerifierKeyTx - should fail on contract not present on contract address', async () => {
    await expect(
      submitRemoveVerifierKeyTx(counterProviders, UNDEPLOYED_CONTRACT_ADDRESS, CIRCUIT_ID_RESET)
    ).rejects.toThrow(`No contract state found on chain for contract address '${UNDEPLOYED_CONTRACT_ADDRESS}'`);
  });

  it('submitRemoveVerifierKeyTx - should fail on providers for different contract with different API ', async () => {
    await expect(submitRemoveVerifierKeyTx(simpleContractProviders, contractAddress, CIRCUIT_ID_RESET)).rejects.toThrow(
      `Signing key for contract address '${contractAddress}' not found`
    );
  });

  it('createContractMaintenanceTxInterface - replaceAuthority - successful replace authority with the new one [@slow]', async () => {
    const authority = sampleSigningKey();
    // TODO: Remove extra log statements
    logger.info(`Signing key for 'Counter' is ${authority}`);
    const contractMaintenanceTxInterface = createContractMaintenanceTxInterface(counterProviders, contractAddress);
    const finalizedTxData = await contractMaintenanceTxInterface.replaceAuthority(authority);

    expect(finalizedTxData.status).toEqual(SucceedEntirely);

    logger.info('Remove key');
    const finalizedTxData1 = await submitRemoveVerifierKeyTx(counterProviders, contractAddress, CIRCUIT_ID_DECREMENT);

    expect(finalizedTxData1.status).toEqual(SucceedEntirely);
  });

  it('createContractMaintenanceTxInterface - replaceAuthority - successful replace authority with the same one [@slow]', async () => {
    const authority = await counterProviders.privateStateProvider.getSigningKey(contractAddress);
    logger.info(`Signing key for 'Counter' is ${authority}`);
    if (authority) {
      const contractMaintenanceTxInterface = createContractMaintenanceTxInterface(counterProviders, contractAddress);
      const finalizedTxData = await contractMaintenanceTxInterface.replaceAuthority(authority);

      expect(finalizedTxData.status).toEqual(SucceedEntirely);
    }
  });

  it('createContractMaintenanceTxInterface - replaceAuthority - should fail on contract not present on contract address', async () => {
    const authority = await counterProviders.privateStateProvider.getSigningKey(contractAddress);
    if (authority) {
      const contractMaintenanceTxInterface = createContractMaintenanceTxInterface(
        counterProviders,
        UNDEPLOYED_CONTRACT_ADDRESS
      );

      await expect(contractMaintenanceTxInterface.replaceAuthority(authority)).rejects.toThrow(
        `No contract state found on chain for contract address '${UNDEPLOYED_CONTRACT_ADDRESS}'`
      );
    }
  });

  it('createContractMaintenanceTxInterface - insertVerifierKey - fail when key is still present', async () => {
    const vk = await counterProviders.zkConfigProvider.getVerifierKey(CIRCUIT_ID_RESET);
    const circuitMaintenanceTxInterface = createCircuitMaintenanceTxInterface(
      counterProviders,
      CIRCUIT_ID_RESET,
      contractAddress
    );

    await expect(() => circuitMaintenanceTxInterface.insertVerifierKey(vk)).rejects.toThrow(
      `Circuit 'reset' is already defined for contract at address '${contractAddress}'`
    );
  });

  it('createContractMaintenanceTxInterface - insertVerifierKey - success when no key present [@slow]', async () => {
    const vk = await counterProviders.zkConfigProvider.getVerifierKey(CIRCUIT_ID_RESET);
    const circuitMaintenanceTxInterface = createCircuitMaintenanceTxInterface(
      counterProviders,
      CIRCUIT_ID_RESET,
      contractAddress
    );
    await circuitMaintenanceTxInterface.removeVerifierKey();
    const finalizedTxData = await circuitMaintenanceTxInterface.insertVerifierKey(vk);

    expect(finalizedTxData.status).toEqual(SucceedEntirely);
    await api.increment(deployedCounterContract);
  });

  it('createCircuitMaintenanceTxInterfaces - insertVerifierKey - fail when key is already present', async () => {
    const vk = await counterProviders.zkConfigProvider.getVerifierKey(CIRCUIT_ID_RESET);
    const circuitMaintenanceTxInterfaces = createCircuitMaintenanceTxInterfaces(
      counterProviders,
      counterContractInstance,
      contractAddress
    );

    await expect(() => circuitMaintenanceTxInterfaces.reset.insertVerifierKey(vk)).rejects.toThrow(
      `Circuit 'reset' is already defined for contract at address '${contractAddress}'`
    );
  });

  it('createCircuitMaintenanceTxInterfaces - insertVerifierKey - success when no key present [@slow]', async () => {
    const vk = await counterProviders.zkConfigProvider.getVerifierKey(CIRCUIT_ID_RESET);
    const circuitMaintenanceTxInterfaces = createCircuitMaintenanceTxInterfaces(
      counterProviders,
      counterContractInstance,
      contractAddress
    );
    await circuitMaintenanceTxInterfaces.reset.removeVerifierKey();
    const finalizedTxData = await circuitMaintenanceTxInterfaces.reset.insertVerifierKey(vk);

    expect(finalizedTxData.status).toEqual(SucceedEntirely);
    await api.increment(deployedCounterContract);
  });

  it('createCircuitMaintenanceTxInterfaces - removeVerifierKey - should fail on contract not present on contract address', async () => {
    const circuitMaintenanceTxInterfaces = createCircuitMaintenanceTxInterfaces(
      counterProviders,
      counterContractInstance,
      UNDEPLOYED_CONTRACT_ADDRESS
    );

    await expect(circuitMaintenanceTxInterfaces.reset.removeVerifierKey()).rejects.toThrow(
      `No contract state found on chain for contract address '${UNDEPLOYED_CONTRACT_ADDRESS}'`
    );
  });
});

================
File: testkit-js/testkit-js-e2e/test/contracts.snarkupgrade.smoke.it.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { sampleSigningKey } from '@midnight-ntwrk/compact-runtime';
import type { ContractAddress } from '@midnight-ntwrk/ledger-v6';
import {
  createCircuitMaintenanceTxInterfaces,
  findDeployedContract,
  submitRemoveVerifierKeyTx,
  submitReplaceAuthorityTx
} from '@midnight-ntwrk/midnight-js-contracts';
import { SucceedEntirely } from '@midnight-ntwrk/midnight-js-types';
import {
  createLogger,
  type EnvironmentConfiguration,
  getTestEnvironment,
  initializeMidnightProviders,
  type MidnightWalletProvider,
  type TestEnvironment} from '@midnight-ntwrk/testkit-js';
import path from 'path';

import { VERY_SLOW_TEST_TIMEOUT } from '@/constants';
import { type CounterPrivateState } from '@/contract';
import * as api from '@/counter-api';
import {
  CIRCUIT_ID_RESET,
  cloneContractInstance,
  CounterCloneConfiguration,
  counterContractInstance
} from '@/counter-api';
import { CounterClonePrivateStateId } from '@/counter-clone-types';
import { type CounterProviders } from '@/counter-types';

const logger = createLogger(
  path.resolve(`${process.cwd()}`, 'logs', 'tests', `contracts_snark_upgrade_${new Date().toISOString()}.log`)
);

describe('Contracts API Snark Upgrade [@slow][@smoke]', () => {
  let testEnvironment: TestEnvironment;
  let wallet: MidnightWalletProvider;
  let environmentConfiguration: EnvironmentConfiguration;
  let counterCloneContractProviders: CounterProviders;
  let counterProviders: CounterProviders;
  let contractAddress: ContractAddress;
  let privateState: CounterPrivateState;

  beforeAll(async () => {
    testEnvironment = getTestEnvironment(logger);
    environmentConfiguration = await testEnvironment.start();
    api.setLogger(logger);
    wallet = await testEnvironment.getMidnightWalletProvider();
    counterCloneContractProviders = initializeMidnightProviders(
      wallet,
      environmentConfiguration,
      new CounterCloneConfiguration()
    );
  });

  afterAll(async () => {
    await testEnvironment.shutdown();
  });

  beforeEach(async () => {
    logger.info(`Running test=${expect.getState().currentTestName}`);
    ({ counterProviders, contractAddress, privateState } = await api.deployCounterContract(
      wallet,
      environmentConfiguration
    ));
  });

  /**
   * Test updating verifier keys from one contract to another.
   *
   * @given A deployed counter contract with original verifier keys
   * @and Clone contract providers with different verifier keys
   * @when Removing all original verifier keys
   * @and Inserting new verifier keys from clone contract
   * @and Interacting with contract using new keys
   * @then Should successfully remove all original keys
   * @and Should successfully insert all new keys
   * @and Should enable contract operations with new verifier keys
   *
   * @smoke Test validates complete verifier key replacement workflow
   */
  it(
    'should update verifier keys from one contract to another [@smoke]',
    async () => {
      const circuitMaintenanceTxInterfaces = createCircuitMaintenanceTxInterfaces(
        counterProviders,
        counterContractInstance,
        contractAddress
      );

      logger.info('Remove keys');
      const finalizedTxDataReset = await circuitMaintenanceTxInterfaces.reset.removeVerifierKey();
      const finalizedTxDataIncrement = await circuitMaintenanceTxInterfaces.increment.removeVerifierKey();
      const finalizedTxDataDecrement = await circuitMaintenanceTxInterfaces.decrement.removeVerifierKey();

      expect(finalizedTxDataReset.status).toEqual(SucceedEntirely);
      expect(finalizedTxDataIncrement.status).toEqual(SucceedEntirely);
      expect(finalizedTxDataDecrement.status).toEqual(SucceedEntirely);

      logger.info('Insert keys');
      const vkReset = await counterCloneContractProviders.zkConfigProvider.getVerifierKey('reset');
      const vkIncrement = await counterCloneContractProviders.zkConfigProvider.getVerifierKey('increment');
      const vkDecrement = await counterCloneContractProviders.zkConfigProvider.getVerifierKey('decrement');

      const finalizedTxDataReset2 = await circuitMaintenanceTxInterfaces.reset.insertVerifierKey(vkReset);
      const finalizedTxDataIncrement2 = await circuitMaintenanceTxInterfaces.increment.insertVerifierKey(vkIncrement);
      const finalizedTxDataDecrement2 = await circuitMaintenanceTxInterfaces.decrement.insertVerifierKey(vkDecrement);

      expect(finalizedTxDataReset2.status).toEqual(SucceedEntirely);
      expect(finalizedTxDataIncrement2.status).toEqual(SucceedEntirely);
      expect(finalizedTxDataDecrement2.status).toEqual(SucceedEntirely);

      logger.info('Interact with contract');
      const contract = await findDeployedContract(counterCloneContractProviders, {
        contract: cloneContractInstance,
        contractAddress,
        privateStateId: CounterClonePrivateStateId,
        initialPrivateState: privateState
      });

      const finalizedTxDataIncrement3 = await contract.callTx.increment();
      const finalizedTxDataDecrement3 = await contract.callTx.decrement(1n);
      const finalizedTxDataReset3 = await contract.callTx.reset();

      expect(finalizedTxDataReset3.public.status).toEqual(SucceedEntirely);
      expect(finalizedTxDataIncrement3.public.status).toEqual(SucceedEntirely);
      expect(finalizedTxDataDecrement3.public.status).toEqual(SucceedEntirely);
    },
    VERY_SLOW_TEST_TIMEOUT
  );

  /**
   * Test authority replacement and access control validation.
   *
   * @given A deployed contract with original authority
   * @and Old authority signing key stored in private state provider
   * @when Replacing authority with new signing key
   * @and Attempting to use old authority for operations
   * @then Should successfully replace authority
   * @and Should fail when using old authority for maintenance operations
   */
  it(
    'should fail on operate with previous authority after replacement',
    async () => {
      const oldAuthority = await counterProviders.privateStateProvider.getSigningKey(contractAddress);
      expect(oldAuthority).not.toBeNull();

      if (oldAuthority) {
        const newAuthority = sampleSigningKey();
        const finalizedTxData = await submitReplaceAuthorityTx(counterProviders, contractAddress)(newAuthority);

        expect(finalizedTxData.status).toEqual(SucceedEntirely);

        await counterProviders.privateStateProvider.setSigningKey(contractAddress, oldAuthority);

        await expect(submitRemoveVerifierKeyTx(counterProviders, contractAddress, CIRCUIT_ID_RESET)).rejects.toThrow(
          'Transaction submission error: Transaction submission failed'
        );
      }
    },
    VERY_SLOW_TEST_TIMEOUT
  );
});

================
File: testkit-js/testkit-js-e2e/test/indexer-public-data-provider.observable1.it.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type ContractState } from '@midnight-ntwrk/compact-runtime';
import { type FinalizedTxData, type PublicDataProvider } from '@midnight-ntwrk/midnight-js-types';
import {
  createLogger,
  getTestEnvironment,
  initializeMidnightProviders,
  type TestEnvironment
} from '@midnight-ntwrk/testkit-js';
import path from 'path';
import { type Observable, toArray } from 'rxjs';

import { SLOW_TEST_TIMEOUT, VERY_SLOW_TEST_TIMEOUT } from '@/constants';
import { CompiledCounter } from '@/contract';
import * as api from '@/counter-api';
import { CONTRACT_CIRCUITS, CounterConfiguration } from '@/counter-api';
import { type CounterProviders, type DeployedCounterContract, privateStateZero } from '@/counter-types';

const logger = createLogger(
  path.resolve(`${process.cwd()}`, 'logs', 'tests', `indexer_${new Date().toISOString()}.log`)
);

const { ledger } = CompiledCounter;

describe('Indexer API', () => {
  let publicDataProvider: PublicDataProvider;
  let providers: CounterProviders;
  let testEnvironment: TestEnvironment;

  let deployedContractObserved: DeployedCounterContract;
  let incrementFinalizedTxData: FinalizedTxData;

  const expectObservedContractStatesToEqual = (observable$: Observable<ContractState>, expectedStates: bigint[]) => {
    observable$
      .pipe(toArray())
      .subscribe((states) => {
        const ledgerStates: bigint[] = [];
        states.forEach((state) => {
          expect(state).not.toBeNull();
          expect(state?.operations()).toEqual(CONTRACT_CIRCUITS);
          ledgerStates.push(ledger(state.data).round);
        });
        expect(ledgerStates).toEqual(expectedStates);
      })
      .unsubscribe();
  };

  beforeEach(async () => {
    logger.info(`Running test=${expect.getState().currentTestName}`);
    deployedContractObserved = await api.deploy(providers, privateStateZero);
    incrementFinalizedTxData = await api.increment(deployedContractObserved);
  });

  beforeAll(async () => {
    testEnvironment = getTestEnvironment(logger);
    const environmentConfiguration = await testEnvironment.start();
    api.setLogger(logger);
    logger.info(`Private state: ${JSON.stringify(privateStateZero)}`);
    const wallet = await testEnvironment.getMidnightWalletProvider();
    providers = initializeMidnightProviders(wallet, environmentConfiguration, new CounterConfiguration());
    publicDataProvider = providers.publicDataProvider;
  }, VERY_SLOW_TEST_TIMEOUT);

  afterAll(async () => {
    await testEnvironment.shutdown();
  });

  /**
   * Test contract state observable with block hash starting point.
   *
   * @given A deployed contract with incremented state
   * @and A specific block hash as starting point
   * @when Creating observable from defined block hash with inclusive/exclusive options
   * @and Executing additional increment operation
   * @then Should return correct state history based on inclusive flag
   * @and Should observe states in proper chronological order
   */
  it.each([
    [true, [1n, 2n]],
    [false, [2n]]
  ])(
    'should return the history of states starting from defined blockHash (inclusive:%s, expected:%s) [@slow]',
    async (inclusive, expectedStates) => {
      const observable$ = publicDataProvider.contractStateObservable(
        deployedContractObserved.deployTxData.public.contractAddress,
        {
          type: 'blockHash',
          blockHash: incrementFinalizedTxData.blockHash,
          inclusive
        }
      );
      await api.increment(deployedContractObserved);

      expectObservedContractStatesToEqual(observable$, expectedStates);
    },
    SLOW_TEST_TIMEOUT
  );

  /**
   * Test contract state observable with transaction ID starting point.
   *
   * @given A deployed contract with incremented state
   * @and A specific transaction ID as starting point
   * @when Creating observable from defined transaction ID with inclusive/exclusive options
   * @and Executing additional increment operation
   * @then Should return correct state history based on inclusive flag
   * @and Should observe states matching transaction-based filtering
   */
  it.each([
    [true, [1n, 2n]],
    [false, [2n]]
  ])(
    'should return the history of states starting from defined txId (inclusive:%s, expected states:%s) [@slow]',
    async (inclusive, expectedStates) => {
      const observable$ = publicDataProvider.contractStateObservable(
        deployedContractObserved.deployTxData.public.contractAddress,
        { type: 'txId', txId: incrementFinalizedTxData.txId, inclusive }
      );
      await api.increment(deployedContractObserved);

      expectObservedContractStatesToEqual(observable$, expectedStates);
    },
    SLOW_TEST_TIMEOUT
  );
});

================
File: testkit-js/testkit-js-e2e/test/indexer-public-data-provider.observable2.it.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type ContractState } from '@midnight-ntwrk/compact-runtime';
import {
  type All,
  type FinalizedTxData,
  type Latest,
  type PublicDataProvider
} from '@midnight-ntwrk/midnight-js-types';
import {
  createLogger,
  getTestEnvironment,
  initializeMidnightProviders,
  type TestEnvironment
} from '@midnight-ntwrk/testkit-js';
import path from 'path';
import { type Observable, toArray } from 'rxjs';

import { SLOW_TEST_TIMEOUT, VERY_SLOW_TEST_TIMEOUT } from '@/constants';
import { CompiledCounter } from '@/contract';
import * as api from '@/counter-api';
import { CONTRACT_CIRCUITS, CounterConfiguration } from '@/counter-api';
import { type CounterProviders, type DeployedCounterContract, privateStateZero } from '@/counter-types';

const logger = createLogger(
  path.resolve(`${process.cwd()}`, 'logs', 'tests', `indexer_${new Date().toISOString()}.log`)
);

const { ledger } = CompiledCounter;

describe('Indexer API', () => {
  let publicDataProvider: PublicDataProvider;
  let providers: CounterProviders;
  let testEnvironment: TestEnvironment;

  let deployedContractObserved: DeployedCounterContract;
  let incrementFinalizedTxData: FinalizedTxData;

  const expectObservedContractStatesToEqual = (observable$: Observable<ContractState>, expectedStates: bigint[]) => {
    observable$
      .pipe(toArray())
      .subscribe((states) => {
        const ledgerStates: bigint[] = [];
        states.forEach((state) => {
          expect(state).not.toBeNull();
          expect(state?.operations()).toEqual(CONTRACT_CIRCUITS);
          ledgerStates.push(ledger(state.data).round);
        });
        expect(ledgerStates).toEqual(expectedStates);
      })
      .unsubscribe();
  };

  beforeEach(async () => {
    logger.info(`Running test=${expect.getState().currentTestName}`);
    deployedContractObserved = await api.deploy(providers, privateStateZero);
    incrementFinalizedTxData = await api.increment(deployedContractObserved);
  });

  beforeAll(async () => {
    testEnvironment = getTestEnvironment(logger);
    const environmentConfiguration = await testEnvironment.start();
    api.setLogger(logger);
    logger.info(`Private state: ${JSON.stringify(privateStateZero)}`);
    const wallet = await testEnvironment.getMidnightWalletProvider();
    providers = initializeMidnightProviders(wallet, environmentConfiguration, new CounterConfiguration());
    publicDataProvider = providers.publicDataProvider;
  }, VERY_SLOW_TEST_TIMEOUT);

  afterAll(async () => {
    await testEnvironment.shutdown();
  });

  /**
   * Test contract state observable with block height starting point.
   *
   * @given A deployed contract with incremented state
   * @and A specific block height as starting point
   * @when Creating observable from defined block height with inclusive/exclusive options
   * @and Executing additional increment operation
   * @then Should return correct state history based on inclusive flag
   * @and Should observe states in proper chronological order from block height
   */
  it.each([
    [true, [1n, 2n]],
    [false, [2n]]
  ])(
    'should return the history of states starting from defined blockHeight (inclusive:%s, expected states:%s) [@slow]',
    async (inclusive, expectedStates) => {
      const observable$ = publicDataProvider.contractStateObservable(
        deployedContractObserved.deployTxData.public.contractAddress,
        {
          type: 'blockHeight',
          blockHeight: incrementFinalizedTxData.blockHeight,
          inclusive
        }
      );
      await api.increment(deployedContractObserved);

      expectObservedContractStatesToEqual(observable$, expectedStates);
    },
    SLOW_TEST_TIMEOUT
  );

  /**
   * Test contract state observable with different configuration types.
   *
   * @given A deployed contract with incremented state
   * @and Different observable configuration types (all, latest)
   * @when Creating observable with all states or latest states configuration
   * @and Executing additional increment operation
   * @then Should return complete history for 'all' configuration
   * @and Should return recent history for 'latest' configuration
   * @and Should observe states matching the configuration type requirements
   */
  it.each([
    [
      'should return the entire history of states of the contract with the given address',
      { type: 'all' } as All,
      [0n, 1n, 2n]
    ],
    [
      'should return the history of states of the contract with the given address, starting with the most recent state',
      { type: 'latest' } as Latest,
      [1n, 2n]
    ]
  ])(
    '%s (config:%s, expected states:%s) [@slow]',
    async (_, configType, expectedStates) => {
      const observable$ = publicDataProvider.contractStateObservable(
        deployedContractObserved.deployTxData.public.contractAddress,
        configType
      );
      await api.increment(deployedContractObserved);

      expectObservedContractStatesToEqual(observable$, expectedStates);
    },
    SLOW_TEST_TIMEOUT
  );
});

================
File: testkit-js/testkit-js-e2e/test/indexer-public-data-provider.singlecontract.it.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { FinalizedDeployTxData } from '@midnight-ntwrk/midnight-js-contracts';
import { type FinalizedTxData, type PublicDataProvider, SucceedEntirely } from '@midnight-ntwrk/midnight-js-types';
import {
  createLogger,
  getTestEnvironment,
  initializeMidnightProviders,
  type TestEnvironment
} from '@midnight-ntwrk/testkit-js';
import path from 'path';

import { UNDEPLOYED_CONTRACT_ADDRESS, VERY_SLOW_TEST_TIMEOUT } from '@/constants';
import { CompiledCounter } from '@/contract';
import * as api from '@/counter-api';
import { CounterConfiguration } from '@/counter-api';
import {
  type CounterContract,
  type CounterProviders,
  type DeployedCounterContract,
  privateStateZero
} from '@/counter-types';

const logger = createLogger(
  path.resolve(`${process.cwd()}`, 'logs', 'tests', `indexer_${new Date().toISOString()}.log`)
);

const { ledger } = CompiledCounter;

describe('Indexer API', () => {
  let publicDataProvider: PublicDataProvider;
  let providers: CounterProviders;
  let deployedContract: DeployedCounterContract;
  let finalizedDeployTxData: FinalizedDeployTxData<CounterContract>;
  let incrementedTxData: FinalizedTxData;
  let testEnvironment: TestEnvironment;

  beforeEach(() => {
    logger.info(`Running test=${expect.getState().currentTestName}`);
  });

  beforeAll(async () => {
    testEnvironment = getTestEnvironment(logger);
    const environmentConfiguration = await testEnvironment.start();
    api.setLogger(logger);
    logger.info(`Private state: ${JSON.stringify(privateStateZero)}`);
    const wallet = await testEnvironment.getMidnightWalletProvider();
    providers = initializeMidnightProviders(wallet, environmentConfiguration, new CounterConfiguration());
    publicDataProvider = providers.publicDataProvider;
    deployedContract = await api.deploy(providers, privateStateZero);
    finalizedDeployTxData = deployedContract.deployTxData;
    incrementedTxData = await api.increment(deployedContract);
    await api.increment(deployedContract);
  }, VERY_SLOW_TEST_TIMEOUT);

  afterAll(async () => {
    await testEnvironment.shutdown();
  });

  it('queryDeployContractState - should return a contract state equivalent to the initial contract state produced during deployment construction', async () => {
    const state = await publicDataProvider.queryDeployContractState(finalizedDeployTxData.public.contractAddress);

    expect(state).not.toBeNull();
    expect(state?.serialize()).toEqual(
      finalizedDeployTxData.public.initialContractState.serialize()
    );
    if (state) {
      expect(ledger(state.data)).toEqual(
        ledger(finalizedDeployTxData.public.initialContractState.data)
      );
    }
  });

  it('queryContractState - should return the current contract state of a deployed contract', async () => {
    const state = await publicDataProvider.queryContractState(finalizedDeployTxData.public.contractAddress);

    expect(state).not.toBeNull();
    expect(state?.operations()).toEqual(finalizedDeployTxData.public.initialContractState.operations());
    if (state) {
      expect(ledger(state?.data).round).toEqual(2n);
    }
  });

  it('queryContractState - should return the current contract state of a deployed contract at defined block height', async () => {
    const state = await publicDataProvider.queryContractState(finalizedDeployTxData.public.contractAddress, {
      type: 'blockHeight',
      blockHeight: incrementedTxData.blockHeight
    });

    expect(state).not.toBeNull();
    expect(state?.operations()).toEqual(finalizedDeployTxData.public.initialContractState.operations());
    if (state) {
      expect(ledger(state?.data).round).toEqual(1n);
    }
  });

  it('queryContractState - should return the current contract state of a deployed contract at defined block hash', async () => {
    const state = await publicDataProvider.queryContractState(finalizedDeployTxData.public.contractAddress, {
      type: 'blockHash',
      blockHash: incrementedTxData.blockHash
    });

    expect(state).not.toBeNull();
    expect(state?.operations()).toEqual(finalizedDeployTxData.public.initialContractState.operations());
    if (state) {
      expect(ledger(state?.data).round).toEqual(1n);
    }
  });

  it('queryContractState - should return null on no contract at contract address', async () => {
    await expect(publicDataProvider.queryContractState(UNDEPLOYED_CONTRACT_ADDRESS)).resolves.toBeNull();
  });

  it('queryZSwapAndContractState - should return the current ZSwap chain state and contract state of a deployed contract', async () => {
    const state = await publicDataProvider.queryZSwapAndContractState(finalizedDeployTxData.public.contractAddress);

    expect(state).not.toBeNull();
    if (state) {
      expect(state[0].firstFree).toEqual(ledger(finalizedDeployTxData.public.initialContractState.data).round);
      expect(state[1].operations()).toEqual(finalizedDeployTxData.public.initialContractState.operations());
      expect(ledger(state[1].data).round).toEqual(
        ledger(finalizedDeployTxData.public.initialContractState.data).round + 2n
      );
    }
  });

  it('queryZSwapAndContractState - should return null on no contract at contract address', async () => {
    await expect(publicDataProvider.queryZSwapAndContractState(UNDEPLOYED_CONTRACT_ADDRESS)).resolves.toBeNull();
  });

  it('watchForDeployTxData - should return the data of the transaction containing the deployment of the contract with the given address', async () => {
    const finalizedTxData = await publicDataProvider.watchForDeployTxData(finalizedDeployTxData.public.contractAddress);

    expect(finalizedTxData.status).toEqual(SucceedEntirely);
    expect(finalizedTxData.identifiers).toEqual(finalizedDeployTxData.public.identifiers);
    expect(finalizedTxData.txHash).toEqual(finalizedDeployTxData.public.txHash);
    expect(finalizedTxData.blockHash).toEqual(finalizedDeployTxData.public.blockHash);
    expect(finalizedTxData.blockHeight).toEqual(finalizedDeployTxData.public.blockHeight);
  });

  it('watchForTxData - should return the data of the transaction containing the contract call with the given transaction id', async () => {
    const finalizedTxData = await publicDataProvider.watchForTxData(incrementedTxData.txId);

    expect(finalizedTxData.status).toEqual(SucceedEntirely);
    expect(finalizedTxData.txId).toEqual(incrementedTxData.txId);
    expect(finalizedTxData.txHash).toEqual(incrementedTxData.txHash);
    expect(finalizedTxData.blockHash).toEqual(incrementedTxData.blockHash);
    expect(finalizedTxData.blockHeight).toEqual(incrementedTxData.blockHeight);

    expect(finalizedTxData.txId).not.toEqual(finalizedDeployTxData.public.txId);
    expect(finalizedTxData.txHash).not.toEqual(finalizedDeployTxData.public.txHash);
    expect(finalizedTxData.blockHash).not.toEqual(finalizedDeployTxData.public.blockHash);
    expect(finalizedTxData.blockHeight).not.toEqual(finalizedDeployTxData.public.blockHeight);
  });

  it('watchForContractState - should immediately return the current state of a deployed contract', async () => {
    const state = await publicDataProvider.watchForContractState(finalizedDeployTxData.public.contractAddress);

    expect(state).not.toBeNull();
    expect(state?.operations()).toEqual(finalizedDeployTxData.public.initialContractState.operations());
    if (state) {
      expect(ledger(state.data).round).toEqual(2n);
    }
  });
});

================
File: testkit-js/testkit-js-e2e/test/nodejs.it.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { spawn } from 'node:child_process';

import { logger } from '@midnight-ntwrk/testkit-js';
import path from 'path';

function runNodeAndExpectExitCode(scriptPath: string, expectedExitCode: number): Promise<void> {
  return new Promise((resolve, reject) => {
    const child = spawn('node', [
      scriptPath
    ], {
      cwd: process.cwd(),
      stdio: ['inherit', 'pipe', 'pipe']
    });

    let stdout = '';
    let stderr = '';

    child.stdout.on('data', (data) => {
      stdout += data.toString();
      process.stdout.write(data);
    });

    child.stderr.on('data', (data) => {
      stderr += data.toString();
      process.stderr.write(data);
    });

    child.on('error', (err: Error) => {
      logger.error(`Error spawning child process: ${err.message}`);
      reject(err);
    });

    child.on('close', (code: number | null) => {
      if (stdout) {
        logger.info(`Standard output: ${stdout}`);
      }
      if (stderr) {
        logger.warn(`Standard error: ${stderr}`);
      }

      try {
        expect(code).toBe(expectedExitCode);
        resolve();
      } catch (err) {
        reject(err instanceof Error ? err : new Error(String(err)));
      }
    });
  });
}

describe('Ledger API - NodeJS Integration Tests', () => {
  /**
   * Test ESM module execution in Node.js environment.
   *
   * @given A built ESM counter module
   * @and Node.js runtime environment
   * @when Executing the ESM module with expected exit code 0
   * @then Should run successfully without errors
   * @and Should complete with proper exit status
   */
  test('should run ESM module successfully', async () => {
    await runNodeAndExpectExitCode(path.resolve('./dist/counter.mjs'), 0);
  });

  /**
   * Test CJS module execution in Node.js environment.
   *
   * @given A built CJS counter module
   * @and Node.js runtime environment
   * @when Executing the CJS module with expected exit code 1
   * @then Should run and complete with expected error exit status
   * @and Should handle CJS module loading properly
   * @bug Expected exit code 1 indicates intentional failure behavior in test setup
   */
  test('should run CJS module with expected exit code', async () => {
    await runNodeAndExpectExitCode(path.resolve('./dist/counter.cjs'), 1);
  });
});

================
File: testkit-js/testkit-js-e2e/test/proof-server.it.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { sampleSigningKey } from '@midnight-ntwrk/compact-runtime';
import {
  ContractCall,
  ContractDeploy,
  LedgerState,
  type Proof,
  sampleCoinPublicKey,
  sampleEncryptionPublicKey,
  type UnprovenTransaction,
  WellFormedStrictness,
  ZswapChainState
} from '@midnight-ntwrk/ledger-v6';
import {
  createUnprovenCallTxFromInitialStates,
  createUnprovenDeployTxFromVerifierKeys
} from '@midnight-ntwrk/midnight-js-contracts';
import { DEFAULT_CONFIG, httpClientProofProvider } from '@midnight-ntwrk/midnight-js-http-client-proof-provider';
import { getNetworkId } from '@midnight-ntwrk/midnight-js-network-id';
import { NodeZkConfigProvider } from '@midnight-ntwrk/midnight-js-node-zk-config-provider';
import type { ProofProvider, ZKConfig } from '@midnight-ntwrk/midnight-js-types';
import { getImpureCircuitIds } from '@midnight-ntwrk/midnight-js-types';
import {
  createLogger,
  DynamicProofServerContainer,
  type ProofServerContainer
} from '@midnight-ntwrk/testkit-js';
import path from 'path';

import { createInitialPrivateState } from '@/contract';
import * as api from '@/counter-api';
import { CounterConfiguration, counterContractInstance } from '@/counter-api';
import type { CounterCircuits } from '@/counter-types';

const logger = createLogger(
  path.resolve(`${process.cwd()}`, 'logs', 'tests', `proof_server_${new Date().toISOString()}.log`)
);

describe('Proof server integration', () => {
  const circuitId = 'increment';
  const privateStateZero = createInitialPrivateState(0);

  let proofServerContainer: ProofServerContainer;
  let proofProvider: ProofProvider<CounterCircuits>;
  let unprovenDeployTx: UnprovenTransaction;
  let unprovenCallTx: UnprovenTransaction;
  let zkConfig: ZKConfig<CounterCircuits>;

  beforeEach(() => {
    logger.info(`Running test=${expect.getState().currentTestName}`);
  });

  beforeAll(async () => {
    proofServerContainer = await DynamicProofServerContainer.start(logger);
    proofProvider = httpClientProofProvider(proofServerContainer.getUrl());
    const zkConfigProvider = new NodeZkConfigProvider<CounterCircuits>(new CounterConfiguration().zkConfigPath);
    const coinPublicKey = sampleCoinPublicKey();
    const encryptionPublicKey = sampleEncryptionPublicKey();
    const signingKey = sampleSigningKey();
    const verifierKeys = await zkConfigProvider.getVerifierKeys(getImpureCircuitIds(counterContractInstance));
    const unprovenDeployTxResult = createUnprovenDeployTxFromVerifierKeys(
      verifierKeys,
      coinPublicKey,
      {
        contract: api.counterContractInstance,
        initialPrivateState: privateStateZero,
        signingKey
      },
      encryptionPublicKey
    );
    unprovenDeployTx = unprovenDeployTxResult.private.unprovenTx!;
    unprovenCallTx = createUnprovenCallTxFromInitialStates(
      {
        contract: api.counterContractInstance,
        circuitId,
        contractAddress: unprovenDeployTxResult.public.contractAddress,
        coinPublicKey,
        initialContractState: unprovenDeployTxResult.public.initialContractState,
        initialZswapChainState: new ZswapChainState(),
        initialPrivateState: unprovenDeployTxResult.private.initialPrivateState
      },
      coinPublicKey,
      encryptionPublicKey
    ).private.unprovenTx;
    zkConfig = await zkConfigProvider.get(circuitId);
  });

  afterAll(async () => {
    await proofServerContainer.stop();
  });

  /**
   * Test successful proof creation for deploy and call transactions.
   *
   * @given A proof server container and proof provider
   * @and Unproven deploy and call transactions with valid configuration
   * @when Creating proofs for both deploy and call transactions
   * @then Should successfully generate proofs for both transaction types
   * @and Should return valid ContractDeploy and ContractCall instances
   */
  test('should create proofs successfully for deploy and call transactions', async () => {
    const provenDeployTx = await proofProvider.proveTx(unprovenDeployTx);
    const contractActions = provenDeployTx.intents?.get(1)?.actions;
    expect(contractActions?.length).toEqual(1);
    if (contractActions) {
      expect(contractActions[0]).toBeInstanceOf(ContractDeploy);
    }
    const provenCallTx = await proofProvider.proveTx(unprovenCallTx, { zkConfig });
    const contractActionsCall = provenCallTx.intents?.get(1)?.actions;
    expect(contractActionsCall?.length).toEqual(1);
    if (contractActionsCall) {
      expect(contractActionsCall[0]).toBeInstanceOf(ContractCall);
      expect((contractActionsCall[0] as ContractCall<Proof>).entryPoint).toEqual(circuitId);
    }
  });

  test('should create proofs with transactions that has succesfull well-formedness', async () => {
    const zSwapChainState = new ZswapChainState();
    const ledgerState = new LedgerState(getNetworkId(), zSwapChainState);
    const strictness = new WellFormedStrictness();
    strictness.verifyContractProofs = false;
    strictness.enforceBalancing = false;
    strictness.verifyNativeProofs = false;

    const provenDeployTx = await proofProvider.proveTx(unprovenDeployTx);
    expect(() => provenDeployTx.wellFormed(ledgerState, strictness, new Date())).not.toThrow();

    const provenCallTx = await proofProvider.proveTx(unprovenCallTx, { zkConfig });
    expect(() => provenCallTx.wellFormed(ledgerState, strictness, new Date())).not.toThrow();
  });
  /**
   * Test error handling for invalid ZKConfig circuit ID.
   *
   * @given A proof provider and unproven call transaction
   * @and Invalid ZKConfig with wrong circuit ID
   * @when Attempting to prove transaction with invalid configuration
   * @then Should throw Bad Request error for invalid circuit ID
   */
  test('should throw error for invalid ZKConfig circuitId', async () => {
    const invalidZkConfig = { ...zkConfig, circuitId: 'invalid' as CounterCircuits };
    await expect(proofProvider.proveTx(unprovenCallTx, { zkConfig: invalidZkConfig })).rejects.toThrow('Bad Request');
  });

  /**
   * Test error handling for undefined ZKConfig.
   *
   * @given A proof provider and unproven call transaction
   * @and No ZKConfig provided
   * @when Attempting to prove transaction without configuration
   * @then Should throw Bad Request error for missing ZKConfig
   */
  test('should throw error for undefined ZKConfig', async () => {
    await expect(proofProvider.proveTx(unprovenCallTx)).rejects.toThrow('Bad Request');
  });

  const numTxsToProve = 5;
  const timeout = numTxsToProve * DEFAULT_CONFIG.timeout;

  /**
   * Test parallel proof generation for multiple transactions.
   *
   * @given A proof provider and multiple identical unproven transactions
   * @and Valid ZKConfig and extended timeout configuration
   * @when Executing multiple proveTx calls in parallel
   * @then Should successfully prove all transactions without errors
   * @and Should return valid ContractCall instances for all results
   */
  test(`should execute ${numTxsToProve} proveTx calls in parallel without errors`, async () => {
    const results = await Promise.all(
      [...Array(numTxsToProve)].map(() =>
        proofProvider.proveTx(unprovenCallTx, {
          timeout,
          zkConfig
        })
      )
    );
    expect(results).toHaveLength(numTxsToProve);
    results.forEach((result) => {
      expect(result).toBeDefined();
      const contractActions = result.intents?.get(1)?.actions;
      expect(contractActions).toBeDefined();
      if (contractActions) {
        expect(contractActions).toHaveLength(1);
        expect(contractActions[0]).toBeInstanceOf(ContractCall);
        const call = contractActions[0] as ContractCall<Proof>;
        expect(call.entryPoint).toEqual(circuitId);
      }
    });
  });
});

================
File: testkit-js/testkit-js-e2e/.npmignore
================
src/
test/
dist/counter.*
dist/contract/

================
File: testkit-js/testkit-js-e2e/README.md
================
# E2E Testing Strategy & Guidelines

End-to-End testing strategy for Midnight.JS applications, covering complete blockchain workflows and system interactions.

## Table of Contents

1. [Overview](#overview)
2. [Test Architecture](#test-architecture)
3. [Environment Configuration](#environment-configuration)
4. [Writing E2E Tests](#writing-e2e-tests)
5. [Test Execution](#test-execution)
6. [Debugging](#debugging)

---

## Overview

### What We Test

E2E tests validate complete user workflows across the blockchain stack:

- **Smart Contract Lifecycles**: Deployment, circuit execution, state management
- **Component Integration**: Wallet  Node  Indexer  Proof Server interactions  
- **Network Operations**: Real blockchain network interactions
- **Error Scenarios**: Invalid inputs, network failures, edge cases

### Core Principles

1. **Test Real Scenarios**: Focus on actual user workflows
2. **Environment Isolation**: Clean state per test
3. **Clear Documentation**: Self-documenting tests with Given-When-Then

---

## Test Architecture

### Components

```
Test Environment Manager
 Local (Docker Compose)
 Remote (Devnet/Testnet) 
 Custom (Environment Variables)

Infrastructure Components
 Wallet Management
 Proof Server Container
 Node/Indexer/Faucet Clients
 Contract Testing Framework
```

### Test Categories

#### 1. **Contract Tests**
- Contract deployment and validation
- Circuit execution
- State consistency (private and public)
- Transaction lifecycle

#### 2. **Infrastructure Tests** 
- Proof server integration
- Component communication
- Network reliability
- State synchronization

#### 3. **Error Handling Tests**
- Invalid input validation
- Network failure recovery
- Timeout scenarios
- Edge case handling

---

## Environment Configuration

### Environment Types

| Environment | Use Case | Infrastructure | Limitations |
|-------------|----------|----------------|-------------|
| `undeployed` | Development | Docker Compose | 4 wallets max |
| `devnet/testnet` | Integration | Live networks | Network dependent |
| `env-var-remote` | Custom | User-defined | Requires all env vars |

### Environment Variables

```bash
# Primary Configuration
MN_TEST_ENVIRONMENT=undeployed|devnet|testnet|env-var-remote
MN_TEST_WALLET_SEED="optional-seed-phrase"

# Custom Environment (when env-var-remote)
MN_TEST_NETWORK_ID="custom-network-id"
MN_TEST_INDEXER="http://custom-indexer:3085/api/"
MN_TEST_INDEXER_WS="ws://custom-indexer:3085/ws/"
MN_TEST_NODE="http://custom-node:3086"
MN_TEST_FAUCET="http://custom-faucet:3087"
```

### Usage Examples

```bash
# Local development
yarn e2e

# Testnet integration
MN_TEST_ENVIRONMENT=testnet yarn e2e

# Custom environment
MN_TEST_ENVIRONMENT=env-var-remote \
MN_TEST_INDEXER="http://localhost:3085/api/" \
yarn e2e
```

---

## Writing E2E Tests

### Test Template

```typescript
import { createLogger, getTestEnvironment, initializeMidnightProviders } from '@midnight-ntwrk/testkit-js';

const logger = createLogger(
  path.resolve(`${process.cwd()}`, 'logs', 'tests', `feature_${new Date().toISOString()}.log`)
);

describe('Feature Name', () => {
  let testEnvironment: TestEnvironment;
  let environmentConfiguration: EnvironmentConfiguration;
  let wallet: MidnightWalletProvider;
  let providers: YourProviders;

  beforeEach(() => {
    logger.info(`Running test=${expect.getState().currentTestName}`);
  });

  beforeAll(async () => {
    testEnvironment = getTestEnvironment(logger);
    environmentConfiguration = await testEnvironment.start();
    wallet = await testEnvironment.getMidnightWalletProvider();
    providers = initializeMidnightProviders(wallet, environmentConfiguration, configuration);
  });

  afterAll(async () => {
    await testEnvironment.shutdown();
  });

  /**
   * Test documentation with Given-When-Then structure
   *
   * @given Initial system state and preconditions
   * @when Action or operation being tested
   * @then Expected outcome and validation criteria
   */
  it('should perform expected behavior [@slow]', async () => {
    // Arrange
    const initialState = await getInitialState();
    
    // Act
    const result = await performOperation();
    
    // Assert
    expect(result).toBeDefined();
    await expectSuccessfulOperation(result);
  });
});
```

### Best Practices

#### Test Documentation
```typescript
/**
 * @given Deployed contract with initial state
 * @when Executing increment circuit
 * @then Should update both ledger and private state
 */
it('should execute increment circuit [@slow]', async () => {
  // Implementation
});
```

#### Error Testing
```typescript
await expect(invalidOperation()).rejects.toThrow('Expected error message');
```

#### State Validation
```typescript
const stateBefore = await getContractState();
await performOperation();
const stateAfter = await getContractState();
expect(stateAfter.value).toEqual(stateBefore.value + 1);
```

#### Annotations
- `[@slow]` - Tests > 30 seconds, uses extended timeout
- Gherkin comments - Clear test intent documentation

---

## Test Execution

### Commands

```bash
yarn e2e              # Run all E2E tests locally
yarn e2e-debug        # Run with debug output  
yarn e2e-testnet      # Run against testnet
yarn e2e-single       # Run single test file (requires MN_TEST_FILE environment variable)
```

### Configuration

#### Timeouts
```typescript
// config/vitest.e2e.config.ts
testTimeout: 60_000     // 1 minute default
hookTimeout: 2 * 60_000  // 2 minutes for setup/teardown

// For slow tests
const SLOW_TEST_TIMEOUT = 5 * 60_000; // 5 minutes
it('long operation [@slow]', async () => {}, SLOW_TEST_TIMEOUT);
```

#### Parallel Execution
Tests run safely in parallel with:
- Isolated test environments
- Unique resource naming (`counter-private-store-${Date.now()}`)
- Proper cleanup in afterAll hooks

### Reports

Generated reports:
- **JUnit XML**: `./reports/test-report.xml` (CI/CD integration)
- **HTML**: `./reports/html/index.html` (interactive results)
- **CTRF JSON**: `./reports/ctrf-report.json` (programmatic analysis)
- **Allure**: `./reports/allure-results/` (rich reporting with history)

---

## Debugging

### Logging

```typescript
// Test-specific logs
const logger = createLogger(
  path.resolve(`${process.cwd()}`, 'logs', 'tests', `feature_${new Date().toISOString()}.log`)
);

beforeEach(() => {
  logger.info(`Running test=${expect.getState().currentTestName}`);
});
```

### Debug Commands

```bash
# Enable container debugging
DEBUG='testcontainers:compose' yarn e2e
DEBUG='testcontainers:containers' yarn e2e-debug

# View logs
tail -f packages/testing/logs/tests/latest.log

# Check container status
docker compose -f compose.yml ps
docker compose -f compose.yml logs proof-server
```

### Common Issues

#### Test Timeouts
```typescript
// Use appropriate timeouts for slow operations
it('should complete operation [@slow]', async () => {
  // Implementation
}, SLOW_TEST_TIMEOUT);
```

#### Environment Setup
```bash
# Ensure Docker is running and pull latest images
docker compose -f compose.yml pull
yarn e2e
```

#### State Synchronization
```typescript
// Wait for state synchronization
await waitForFullSync(wallet);
const state = await getContractState();
expect(state).toBeDefined();
```

---

## Quick Reference

### Essential Commands
```bash
yarn e2e                    # Local E2E tests
yarn e2e-testnet           # Testnet integration
yarn e2e-debug             # Debug output
```

### Key Environment Variables  
```bash
MN_TEST_ENVIRONMENT        # Optional network id: undeployed|devnet|testnet|env-var-remote
MN_TEST_WALLET_SEED        # Optional wallet seed
```

### Test Annotations
- `[@slow]` - Extended timeout for long operations
- `@given/@when/@then` - Gherkin-style documentation

================
File: testkit-js/testkit-js-e2e/rollup.config.mjs
================
import resolve from '@rollup/plugin-node-resolve';
import typescript from '@rollup/plugin-typescript';
import commonjs from '@rollup/plugin-commonjs';
import dts from 'rollup-plugin-dts';
import packageJson from './package.json' with { type: 'json' };

export default [
  {
    input: 'src/index.ts',
    output: [
      {
        file: packageJson.module,
        format: 'esm',
        sourcemap: true
      },
      {
        file: packageJson.main,
        format: 'cjs',
        sourcemap: true
      }
    ],
    plugins: [
      resolve(),
      typescript({
        tsconfig: './tsconfig.build.json',
        declaration: false,
        composite: false
      }),
      commonjs()
    ],
    external: [
      /node_modules/,
      /^@midnight-ntwrk\/testkit-js$/,
      /^@midnight-ntwrk\/midnight-js-(.*)$/,
      /^@midnight-ntwrk\/(.*)$/
    ]
  },
  {
    input: 'src/index.ts',
    output: [
      { file: 'dist/index.d.mts', format: 'es' },
      { file: 'dist/index.d.cts', format: 'es' }
    ],
    plugins: [dts()],
    external: [
      /node_modules/,
      /^@midnight-ntwrk\/testkit-js$/,
      /^@midnight-ntwrk\/midnight-js-(.*)$/,
      /^@midnight-ntwrk\/(.*)$/
    ]
  },
  {
    input: 'src/node/counter.ts',
    output: [
      {
        file: './dist/counter.cjs',
        format: 'cjs',
        sourcemap: true
      },
      {
        file: './dist/counter.mjs',
        format: 'esm',
        sourcemap: true
      }
    ],
    plugins: [
      resolve(),
      typescript({
        tsconfig: './tsconfig.build.json',
        composite: false
      }),
      commonjs()
    ],
    external: [
      /node_modules/,
      /^@midnight-ntwrk\/testkit-js$/,
      /^@midnight-ntwrk\/midnight-js-(.*)$/,
      /^@midnight-ntwrk\/(.*)$/
    ]
  }
];

================
File: testkit-js/testkit-js-e2e/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": [
    "./src/test/**/*.ts"
  ]
}

================
File: testkit-js/testkit-js-e2e/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./dist",
    "esModuleInterop": true,
    "strictPropertyInitialization": false,
    "types": ["vitest/globals"],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "./test/**/*.ts",
    "./src/**/*.ts",
    "*.ts"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}

================
File: testkit-js/testkit-js-e2e/typedoc.json
================
{
  "extends": ["../../typedoc.base.json"],
  "readme": "README.md",
  "entryPoints": ["src/index.ts"]
}

================
File: testkit-js/testkit-js-e2e/vite.setup.mjs
================
import { beforeAll, vi } from 'vitest';
import {
  createLogger,
  deleteDirectory,
  defaultContainersConfiguration,
  setContainersConfiguration
} from '@midnight-ntwrk/testkit-js';
import path from 'path';

const logger = await createLogger('default.log');
globalThis.logger = logger;

const dir = path.resolve('./../');
const testKitContainersConfiguration = {
  ...defaultContainersConfiguration,
  standalone: {
    ...defaultContainersConfiguration.standalone,
    path: dir,
  },
  proofServer: {
    ...defaultContainersConfiguration.proofServer,
    path: dir
  }
};

beforeAll(async () => {
  logger.info(
    'Setting up container configuration to use pinned component versions'
  );
  setContainersConfiguration(testKitContainersConfiguration);
  await deleteDirectory('../midnight-level-db');
});

const MINUTE = 60 * 1000;
let timeout = 3 * MINUTE;
const envVar = import.meta.env.MN_TEST_ENVIRONMENT;
const localNetEnvVarValues = [undefined, '', 'undeployed'];

// live environments take longer to sync wallet
if (!localNetEnvVarValues.includes(envVar)) {
  timeout = 10 * MINUTE;
}
vi.setConfig({ testTimeout: timeout });
logger.info(
  `Setting test timeout to ${timeout / MINUTE} minutes for MN_TEST_ENVIRONMENT='${envVar}'`
);

================
File: testkit-js/testkit-js-e2e/vitest.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import tsconfigPaths from 'vite-tsconfig-paths';
import { defineConfig } from 'vitest/config';

export default defineConfig({
  plugins: [tsconfigPaths()],
  test: {
    globals: true,
    environment: 'node',
    include: ['**/test/**/*.{test,spec}.ts'],
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage'
    },
    testTimeout: 5 * 60_000,
    hookTimeout: 5 * 60_000,
    reporters: [
      'default',
      ['junit', { outputFile: './reports/test-report.xml' }],
      ['html', { outputFile: './reports/html/index.html' }],
      ['@d2t/vitest-ctrf-json-reporter', { outputDir: './reports/', outputFile: 'ctrf-report.json' }],
      ['allure-vitest/reporter', { resultsDir: './reports/allure-results' }]
    ],
    setupFiles: ['allure-vitest/setup', 'vite.setup.mjs']
  },
  resolve: {
    extensions: ['.ts', '.js'],
  }
});

================
File: testkit-js/testkit-js-e2e/vitest.single.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { defineConfig } from 'vitest/config';

import * as baseConfig from './vitest.config';

const testFile = process.env.MN_TEST_FILE;

if (!testFile) {
  throw new Error('Error: MN_TEST_FILE environment variable is required for single test execution.');
}

const testBaseName = testFile.replace(/\.test\.ts$/, '').replace(/^.*\//, '');

console.log(`Test file: ${testFile}`);
console.log(`Test base name: ${testBaseName}`);

export default defineConfig({
  ...baseConfig.default,
  test: {
    ...baseConfig.default.test,
    include: [`./test/${testFile}`],
    reporters: [
      'default',
      ['junit', { outputFile: `./reports/test-report-${testBaseName}.xml` }],
      ['@d2t/vitest-ctrf-json-reporter', { outputDir: './reports', outputFile: `ctrf-report-${testBaseName}.json` }],
      ['allure-vitest/reporter', { resultsDir: `./reports/allure-results-${testBaseName}` }]
    ]
  }
});

================
File: .gitignore
================
node_modules/
dist/
build/
.turbo
*.tsbuildinfo
.direnv/
.idea/
.env
*.log
coverage/
reports/
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions
managed/
midnight-level-db
logs
.states
.eslintcache
.rollup.cache
.DS_Store

================
File: .repomixignore
================
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

================
File: README.md
================
# Midnight.js

## Introduction

Midnight.js is a Typescript-based application development framework for the
Midnight blockchain. Similar to [Web3.js](https://web3js.org/) for Ethereum or
[polkadot.js](https://polkadot.js.org/) for Polkadot, it provides utilities for:

- Creating and submitting transactions
- Interacting with wallets
- Querying for block and contract state information
- Subscribing to chain events

Because of the privacy-preserving properties of the Midnight system, Midnight.js
also contains several unique utilities:

- Executing smart contracts locally
- Incorporating private state into contract execution
- Persisting, querying, and updating private state
- Creating and verifying zero-knowledge proofs

Midnight.js orchestrates all required interactions among the various Midnight
system APIs needed to create and submit a transaction to the Midnight
blockchain. These APIs include an indexer, a proof server, a private state
store, a Midnight node, a wallet, the ledger, the Compact contract runtime, and
a cryptographic artifact (proving key, verifying key, and ZKIR) repository. It
provides default implementations for each of the aforementioned APIs, e.g. a
GraphQL client for the indexer.

### Contracts

> This section assumes the reader has a working understanding of the Compact
> language.

When a user compiles a Compact smart contract with compactc, they obtain two
files:

1. A JavaScript file
2. A
   TypeScript [declaration file](https://www.typescriptlang.org/docs/handbook/2/type-declarations.html)

The JavaScript file contains:

- The execution logic for each circuit in the source contract
- Logic for constructing the contracts initial state
- Utilities for converting on-chain contract state into a JavaScript
  representation

Midnight.js uses this file at run time to execute circuits. The circuit
execution results are then used to create transactions.

> The term _runtime_ is often used to describe the JS executable for a
> contract. This is distinct from the package `@midnight-ntwrk/compact-runtime`,
> which provides the utilities each executable uses.

The TypeScript declaration file contains:

- A type definition for the contract, named `Contract`
- A type definition for any circuits defined within the contract
- A type definition for all required witnesses, named `Witnesses`
- A type definition for the contracts on-chain state, named `Ledger`

If the users Compact source code includes `witness` declarations, the
generated TypeScript declaration file defines a `Witnesses` type as a non-empty
object with a generic type parameter `PS`, representing the private state that
witnesses modify during circuit execution. The user must supply an
implementation of `Witnesses` to a `Contract` and execute a circuit.

Midnight.js uses the TS declaration file at compile time to ensure the contract
is consumed in a type-safe manner. For example, Midnight.js infers circuit
argument and return types from the TS declaration file then uses them as generic
constraints in various utility functions.

### Objectives and Requirements

This section lists a set of design considerations and requirements for
Midnight.js.

#### Type-Safety

* Should preserve a contract's circuit argument/return types and
  user defined types, e.g. `PS` and `Witnesses` types, throughout its
  data model, interfaces, and utility functions.
* Should attempt to infer types, e.g. `infer`, in its functions and data model
  instead of introducing additional generic parameters.
* Should use the least restrictive generic constraints necessary for type safety
  in its functions and data model.
* Should use `any` only for user-supplied types that are truly
  unconstrained. It should not use `any` merely to fix compilation issues.
* Should not require its users to manually specify concrete types for
  generic parameters in most scenarios.
* Should employ branded types to distinguish domain concepts that
  share the same in-code representation, e.g. `HexString` vs. `string`.

In general, these guidelines maximize compile-time checks and enable intuitive
autocompletion when using Midnight.js.

#### Modularity

* Should allow users to provide custom implementations of API
  clients to transaction construction utilities. This is currently accomplished
  via the "provider" pattern.
* Should collect commonly used types into a single package, e.g.
  `@midnight-ntwrk/midnight-js-types`, to standardize types across applications
  and promote programming to interfaces instead of concrete types.

#### Interoperability

* Should be as _isomorphic_ as possible. It should largely work in
  both browser and Node.js environments.
* Should allow dApps to run against different Midnight networks,
  e.g. TestNet vs MainNet.

### Reusability

* Should build high-level features, e.g. transaction construction,
  from low-level utility functions, and it should export both the high-level
  features and low-level functions. This allows users to assemble their own
  high-level features from the set of basic capabilities Midnight.js exposes.
* Should provide a default implementation of each API client needed
  to construct or submit a transaction.
* Should place each API client implementation in a separate package.
  This ensures users can select only the package they need for their
  application.

### Usability

* Should aim to minimize the boilerplate required to set up a dApp.
  This includes reducing the ceremony required to configure API clients.
* Should supply common sense default settings to avoid common application errors,
  e.g. subscribing to an indexer stream that causes the application to hang indefinitely.

### Security

* Should store and manipulate and store sensitive data, i.e.
  contract private states, securely.

> Midnight.js currently falls short of this goal; the default
> `PrivateStateProvider` based on `LevelDb` does not encrypt data at rest. To
> encrypt data, a password scheme would likely be necessary. But, requiring
> the user to input a password any time an application they're using needs to
> send a transaction would significantly degrade the UX. This issue should be
> prioritized and resolved.

# Architecture

## Structure

The following diagram is a Midnight.js-centric deployment diagram for the Midnight system.

![](./docs/image/deployment-diagram.png)

The elements of the diagram roughly correspond to these packages:

| Element              | Package                                                  |
|----------------------|----------------------------------------------------------|
| `Contracts`            | @midnight-ntwrk/midnight-js-contracts                    |
| `PublicDataProvider`   | @midnight-ntwrk/midnight-js-contracts                    |
| `PrivateStateProvider` | @midnight-ntwrk/midnight-js-level-private-state-provider |
| `ProofProvider`        | @midnight-ntwrk/midnight-js-http-client-proof-provider   |
| `ZKConfigProvider`     | @midnight-ntwrk/midnight-js-fetch-zk-config-provider     |
| `DappConnector`        | @midnight-ntwrk/dapp-connector-api                       |
| `Wallet`               | @midnight-ntwrk/wallet                                   |
| `Ledger`               | @midnight-ntwrk/ledger                                   |
| `Compact Runtime`      | @midnight-ntwrk/compact-runtime                          |
| `Impact VM`            | @midnight-ntwrk/onchain-runtime                          |

The `Contracts` element contains utilities that the web page uses to create and
submit transactions. Each of the clients in `Midnight.js` are concrete instances
of the provider interfaces defined in the `@midnight-ntwrk/midnight-js-types` package.

The dark arrow from `GUI` to `Web Page` indicates that the GUI for a given application may depend
on any of the packages in Midnight.js. The dashed arrow from `compactc` to `Contract` indicates
that the application developer has run `compactc` on a Compact source file `foo.compact` and produced an executable, `foo.js`.
The `Contracts` element uses the `foo.js` and `witnesses.js` programs stored on the web server to execute circuits and create unproven transactions,
and it uses the `Prover Keys`, `Verifier Keys`, and `ZKIRs` to prove those transactions. `Midnight.js` does not depend on `UI Components` because
UI components are created using Midnight.js.

There are two additional things to note about this diagram:

1. `Ledger` and `Compact Runtime` both depend on the `Impact VM` (on-chain runtime).
2. `Midnight.js` and `Substrate Node` both depend on the `Ledger`.

The first fact allows us to "rehearse" a circuit call (which involves running Impact VM) in
such a way that the execution can be replayed on the node. The second fact allows us to create
a transaction from the result of the circuit rehearsal that the node will accept.

Finally, note that `NodeProvider` depends on the `DappConnector`. This is because we used
the wallet to balance and submit transactions.

## Behavior

The following is a sequence diagram for the construction of a typical call transaction.

![](./docs/image/call-tx-build-sequence-diagram.png)

# Glossary

- Witness - A private computation performed only on the end user's device. The name
  and type signature of a witness is declared in Compact source. The application
  developer them provides a TypeScript implementation of that witness to use
  for circuit execution.
- Private state - The state updated by a witness and stored on the end user's device.

## Package structure

This is a yarn [workspaces](https://yarnpkg.com/features/workspaces/) project. All packages live in the [`packages`](packages) directory:

- `types` - Contains types and interfaces common to all other packages.
- `contracts` - Contains utilities for interacting with Midnight smart contracts.
- `indexer-public-data-provider` - Contains a cross-environment implementation of a Midnight indexer client.
- `node-zk-config-provider` - Contains a file system based Node.js utility for retrieving zero-knowledge artifacts.
- `fetch-zk-config-provider` - Contains a [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) based cross-environment utility for retrieving zero-knowledge artifacts.
- `network-id` - Contains utilities for setting the network id used by `ledger`, `zswap`, and `compact-runtime` dependencies.
- `http-client-proof-provider` - Contains a cross-environment implementation of a proof-server client.
- `level-private-state-provider` - Contains a cross-environment implementation of a persistent private state store based on [Level](https://github.com/Level/level).
- `utils` - General utilities used in Midnight.js

## Development setup

### 1. Nvm

To start developing, first install [nvm](https://https://github.com/nvm-sh/nvm). Then [direnv](https://direnv.net) is
optional, but strongly recommended.

If you're using `direnv`, only the first time you will need to do:
```shell
direnv allow
```
After that, `yarn` should be available in your path.

### Build

Remember to install the dependencies after cloning:
```shell
yarn install
```

Build:
```shell
yarn build
```

### Format code

```sh
yarn lint:fix 
```

### Tests

The following command runs the tests and generates code coverage report, which is available within `coverage` directory.
```sh
yarn test
```

## Contributing

All new features must branch off the default branch `main`.

It's recommended to enable automatic `eslint` formatting in your text editor
upon save, in order to avoid CI errors due to incorrect format.

### Commit Message Format

This project uses [Conventional Commits](https://www.conventionalcommits.org/). Please format your commit messages as:

```
<type>[optional scope]: <description>
```

**Types:** `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `chore`, `ci`, `build`, `revert`  
**Scopes:** `core`, `testkit`, `compact-js`, `platform-js`, `wallet`, `deps`, `config`

### Making Commits

```bash
# Interactive commit (recommended)
yarn commit

# Manual commit
git commit -m "feat(core): add new feature"
```

### Git Hooks

- `pre-commit`: Runs lint-staged
- `commit-msg`: Validates commit message format  
- `pre-push`: Runs full check suite

## Release a new version

### 1. Generate changelog
```bash
yarn changelog  # Updates CHANGELOG.md with new entries
```

### 2. Update versions
```bash
yarn workspaces foreach --all version $VERSION
```

### 3. Commit and tag
```bash
git add .
git commit -m "chore: release v$VERSION"
git tag v$VERSION
git push origin v$VERSION  # Triggers CD workflow
```

## Available Scripts

### Development
- `yarn commit` - Interactive conventional commit prompt
- `yarn build` - Build all packages
- `yarn test` - Run all tests
- `yarn lint` - Run ESLint
- `yarn lint:fix` - Fix linting issues

### Release
- `yarn changelog` - Generate/update CHANGELOG.md
- `yarn changelog:first` - Generate complete changelog from git history

After that, use the [Releases](https://github.com/input-output-hk/midnight-js/releases/new) feature
from GitHub to create a tag with a name following the pattern `vX.Y.Z`.

================
File: repomix.config.json
================
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "midnight-js.txt",
    "style": "plain",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "tokenCountTree": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false,
      "includeLogs": false,
      "includeLogsCount": 50
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/submitCallTxAsync.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / submitCallTxAsync

# Function: submitCallTxAsync()

> **submitCallTxAsync**\<`C`, `ICK`\>(`providers`, `options`): `Promise`\<[`SubmittedCallTx`](../type-aliases/SubmittedCallTx.md)\<`C`, `ICK`\>\>

Creates and submits a transaction for the invocation of a circuit on a given contract,
returning immediately after submission without waiting for finalization.

Unlike [submitCallTx](submitCallTx.md), this function does not wait for transaction finalization,
check transaction status, or update private state. The caller must handle these steps manually.

## Transaction Execution Phases

Midnight transactions execute in two phases:
1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success

## Manual Post-Submission Steps

After calling this function, you must manually:
1. Watch for transaction finalization using `providers.publicDataProvider.watchForTxData(txId)`
2. Check transaction status (compare against `SucceedEntirely`)
3. Handle failures appropriately (throw errors, log, etc.)
4. Update private state if transaction succeeded and `privateStateId` was provided

## Failure Behavior (Manual Handling Required)

**Guaranteed Phase Failure:**
- Transaction is rejected and not included in the blockchain
- `watchForTxData` may reject or return error status
- You must NOT store private state updates

**Fallible Phase Failure:**
- Transaction is recorded on-chain with non-`SucceedEntirely` status
- `watchForTxData` returns transaction data with failed status
- You must NOT store private state updates
- Transaction appears in blockchain history as partial success

## Type Parameters

### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

### ICK

`ICK` *extends* `string`

## Parameters

### providers

`SubmitCallTxProviders`\<`C`, `ICK`\>

The providers used to manage the invocation lifecycle.

### options

[`CallTxOptions`](../type-aliases/CallTxOptions.md)\<`C`, `ICK`\>

Configuration.

## Returns

`Promise`\<[`SubmittedCallTx`](../type-aliases/SubmittedCallTx.md)\<`C`, `ICK`\>\>

A `Promise` that resolves with the transaction ID and call transaction data immediately after submission;
        or rejects with an error if the submission fails.

## Example

```typescript
// 1. Submit
const { txId, callTxData } = await submitCallTxAsync(providers, options);

// 2. Watch (when ready)
const finalizedData = await providers.publicDataProvider.watchForTxData(txId);

// 3. Check status
if (finalizedData.status !== SucceedEntirely) {
  throw new CallTxFailedError(finalizedData, options.circuitId);
}

// 4. Update private state manually if needed
if (options.privateStateId) {
  await providers.privateStateProvider.set(
    privateStateId,
    callTxData.private.nextPrivateState
  );
}
```

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/submitTxAsync.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / submitTxAsync

# Function: submitTxAsync()

> **submitTxAsync**\<`C`, `ICK`\>(`providers`, `options`): `Promise`\<`string`\>

Proves, balances, and submits an unproven deployment or call transaction using
the given providers, according to the given options. Unlike [submitTx](submitTx.md),
this function returns immediately after submission without waiting for finalization.

## Type Parameters

### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

### ICK

`ICK` *extends* `string`

## Parameters

### providers

[`SubmitTxProviders`](../type-aliases/SubmitTxProviders.md)\<`C`, `ICK`\>

The providers used to manage the transaction lifecycle.

### options

[`SubmitTxOptions`](../type-aliases/SubmitTxOptions.md)\<`ICK`\>

Configuration.

## Returns

`Promise`\<`string`\>

A promise that resolves with the transaction ID immediately after submission,
         or rejects if an error occurs during preparation or submission.
         To watch for finalization, use providers.publicDataProvider.watchForTxData(txId).

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/SubmittedCallTx.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / SubmittedCallTx

# Type Alias: SubmittedCallTx\<C, ICK\>

> **SubmittedCallTx**\<`C`, `ICK`\> = `object`

Data returned from an asynchronous call transaction submission.
Contains the transaction ID and call transaction data without waiting for finalization.

## Type Parameters

### C

`C` *extends* `Contract`

### ICK

`ICK` *extends* `ImpureCircuitId`\<`C`\>

## Properties

### callTxData

> `readonly` **callTxData**: [`UnsubmittedCallTxData`](UnsubmittedCallTxData.md)\<`C`, `ICK`\>

The unproven call transaction data including private state.

***

### txId

> `readonly` **txId**: `string`

The transaction ID returned from submission.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-level-private-state-provider/classes/StorageEncryption.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-level-private-state-provider](../README.md) / StorageEncryption

# Class: StorageEncryption

## Constructors

### Constructor

> **new StorageEncryption**(`password`, `existingSalt?`): `StorageEncryption`

#### Parameters

##### password

`string`

##### existingSalt?

`Buffer`\<`ArrayBufferLike`\>

#### Returns

`StorageEncryption`

## Methods

### decrypt()

> **decrypt**(`encryptedData`): `string`

#### Parameters

##### encryptedData

`string`

#### Returns

`string`

***

### encrypt()

> **encrypt**(`data`): `string`

#### Parameters

##### data

`string`

#### Returns

`string`

***

### getSalt()

> **getSalt**(): `Buffer`

#### Returns

`Buffer`

***

### isEncrypted()

> `static` **isEncrypted**(`data`): `boolean`

#### Parameters

##### data

`string`

#### Returns

`boolean`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-level-private-state-provider/functions/getStoragePassword.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-level-private-state-provider](../README.md) / getStoragePassword

# Function: getStoragePassword()

> **getStoragePassword**(): `string`

## Returns

`string`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/BalancedProvingRecipe.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / BalancedProvingRecipe

# Type Alias: BalancedProvingRecipe

> **BalancedProvingRecipe** = [`ProvingRecipe`](ProvingRecipe.md)\<`UnprovenTransaction` \| `FinalizedTransaction`\>

================
File: packages/compact/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./dist",
    "esModuleInterop": true,
    "strictPropertyInitialization": false,
    "moduleResolution": "nodenext",
    "module": "NodeNext",
    "types": ["node"]
  },
  "include": [
    "./src/**/*.mts",
    "./src/**/*.ts"
  ]
}

================
File: packages/contracts/src/test/submit-call-tx.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { StateValue } from '@midnight-ntwrk/compact-runtime';
import { type AlignedValue, type ContractAddress, type PartitionedTranscript } from '@midnight-ntwrk/ledger-v6';
import {
  type Contract,
  FailEntirely,
  type FinalizedTxData,
  type ImpureCircuitId,
  type PrivateState,
  type PrivateStateId
} from '@midnight-ntwrk/midnight-js-types';
import { beforeEach, describe, expect, it, vi } from 'vitest';

import { CallTxFailedError, IncompleteCallTxPrivateStateConfig } from '../errors';
import { submitCallTx, submitCallTxAsync } from '../submit-call-tx';
import { submitTx, submitTxAsync } from '../submit-tx';
import type { FinalizedCallTxData, UnsubmittedCallTxData } from '../tx-model';
import { type CallTxOptions, createUnprovenCallTx } from '../unproven-call-tx';
import {
  createMockCoinInfo,
  createMockContract,
  createMockContractAddress,
  createMockFinalizedTxData,
  createMockPrivateStateId,
  createMockProviders,
  createMockUnprovenCallTxData,
  createMockUnprovenTx,
  createMockZswapLocalState
} from './test-mocks';

describe('submit-call-tx', () => {
  let mockContract: Contract<undefined>;
  let mockContractAddress: ReturnType<typeof createMockContractAddress>;
  let mockZswapLocalState: ReturnType<typeof createMockZswapLocalState>;
  let mockPrivateStateId: PrivateStateId;
  let mockProviders: ReturnType<typeof createMockProviders>;
  let mockUnprovenTx: ReturnType<typeof createMockUnprovenTx>;
  let mockCoinInfo: ReturnType<typeof createMockCoinInfo>;

  beforeEach(() => {
    vi.clearAllMocks();
    mockContract = createMockContract();
    mockContractAddress = createMockContractAddress();
    mockZswapLocalState = createMockZswapLocalState();
    mockPrivateStateId = createMockPrivateStateId();
    mockProviders = createMockProviders();
    mockUnprovenTx = createMockUnprovenTx();
    mockCoinInfo = createMockCoinInfo();

    vi.mock('../unproven-call-tx');
    vi.mock('../submit-tx');
  });

  const createBasicCallOptions = (overrides: Partial<CallTxOptions<Contract, ImpureCircuitId>> = {}) => ({
    contract: mockContract,
    contractAddress: mockContractAddress,
    circuitId: 'testCircuit' as ImpureCircuitId,
    args: ['arg1', 'arg2'],
    ...overrides
  });

  const setupSuccessfulMocks = () => {
    const mockUnprovenCallTxData = createMockUnprovenCallTxData();
    const mockFinalizedTxData = createMockFinalizedTxData();

    vi.mocked(createUnprovenCallTx).mockResolvedValue(mockUnprovenCallTxData);
    vi.mocked(submitTx).mockResolvedValue(mockFinalizedTxData);

    return { mockUnprovenCallTxData, mockFinalizedTxData };
  };

  const createFailedTxData = (): UnsubmittedCallTxData<Contract, ImpureCircuitId> => ({
    public: {
      nextContractState: StateValue.newNull(),
      publicTranscript: [],
      partitionedTranscript: {} as PartitionedTranscript
    },
    private: {
      input: {} as AlignedValue,
      output: {} as AlignedValue,
      unprovenTx: mockUnprovenTx,
      newCoins: [mockCoinInfo],
      nextPrivateState: { state: 'test' },
      nextZswapLocalState: mockZswapLocalState,
      privateTranscriptOutputs: [] as AlignedValue[],
      result: vi.fn()
    }
  });

  const verifySuccessfulCall = (
    mockUnprovenCallTxData: UnsubmittedCallTxData<Contract, ImpureCircuitId>,
    mockFinalizedTxData: FinalizedTxData,
    result: FinalizedCallTxData<Contract, ImpureCircuitId>,
    options: CallTxOptions<Contract, ImpureCircuitId>
  ) => {
    expect(createUnprovenCallTx).toHaveBeenCalledWith(mockProviders, options);
    expect(submitTx).toHaveBeenCalledWith(mockProviders, {
      unprovenTx: mockUnprovenCallTxData.private.unprovenTx,
      newCoins: mockUnprovenCallTxData.private.newCoins,
      circuitId: 'testCircuit'
    });
    expect(result).toEqual({
      private: mockUnprovenCallTxData.private,
      public: {
        ...mockUnprovenCallTxData.public,
        ...mockFinalizedTxData
      }
    });
  };

  describe('submitCallTx', () => {
    describe('successful call without private state ID', () => {
      it('should successfully submit call transaction', async () => {
        const options = createBasicCallOptions();
        const { mockUnprovenCallTxData, mockFinalizedTxData } = setupSuccessfulMocks();

        const result = await submitCallTx(mockProviders, options);

        verifySuccessfulCall(mockUnprovenCallTxData, mockFinalizedTxData, result, options);
        expect(mockProviders.privateStateProvider.set).not.toHaveBeenCalled();
      });
    });

    describe('successful call with private state ID', () => {
      it('should successfully submit call transaction and update private state', async () => {
        const nextPrivateState = { newState: 'updated' } as PrivateState<Contract>;
        const options = createBasicCallOptions({ privateStateId: mockPrivateStateId });
        const { mockFinalizedTxData } = setupSuccessfulMocks();

        const mockUnprovenCallTxData = createMockUnprovenCallTxData({
          private: {
            nextPrivateState,
            input: {} as AlignedValue,
            output: {} as AlignedValue,
            privateTranscriptOutputs: [] as AlignedValue[],
            result: vi.fn(),
            nextZswapLocalState: mockZswapLocalState,
            unprovenTx: mockUnprovenTx,
            newCoins: [mockCoinInfo]
          }
        });
        vi.mocked(createUnprovenCallTx).mockResolvedValue(mockUnprovenCallTxData);

        const result = await submitCallTx(mockProviders, options);

        expect(mockProviders.privateStateProvider.set).toHaveBeenCalledWith(mockPrivateStateId, nextPrivateState);
        verifySuccessfulCall(mockUnprovenCallTxData, mockFinalizedTxData, result, options);
      });
    });

    describe('configuration validation', () => {
      it('should throw IncompleteCallTxPrivateStateConfig when privateStateId provided without privateStateProvider', async () => {
        const providersWithoutPrivateState = { ...mockProviders };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        delete (providersWithoutPrivateState as any).privateStateProvider;
        const options = createBasicCallOptions({ privateStateId: mockPrivateStateId });

        await expect(submitCallTx(providersWithoutPrivateState, options)).rejects.toThrow(
          IncompleteCallTxPrivateStateConfig
        );

        expect(createUnprovenCallTx).not.toHaveBeenCalled();
        expect(submitTx).not.toHaveBeenCalled();
      });

      it('should accept privateStateProvider without privateStateId', async () => {
        const options = createBasicCallOptions();
        setupSuccessfulMocks();

        await submitCallTx(mockProviders, options);

        expect(mockProviders.privateStateProvider.set).not.toHaveBeenCalled();
      });
    });

    describe('failed call scenarios', () => {
      it('should throw CallTxFailedError when transaction fails with FailEntirely', async () => {
        const options = createBasicCallOptions();
        const mockUnprovenCallTxData = createFailedTxData();
        const mockFailedTxData = createMockFinalizedTxData(FailEntirely);

        vi.mocked(createUnprovenCallTx).mockResolvedValue(mockUnprovenCallTxData);
        vi.mocked(submitTx).mockResolvedValue(mockFailedTxData);

        await expect(submitCallTx(mockProviders, options)).rejects.toThrow(CallTxFailedError);
        expect(mockProviders.privateStateProvider.set).not.toHaveBeenCalled();
      });

      it('should include failure data and circuit ID in CallTxFailedError', async () => {
        const circuitId = 'testCircuit' as ImpureCircuitId<Contract>;
        const options = createBasicCallOptions({ circuitId });
        const mockUnprovenCallTxData = createFailedTxData();
        const mockFailedTxData = createMockFinalizedTxData(FailEntirely);

        vi.mocked(createUnprovenCallTx).mockResolvedValue(mockUnprovenCallTxData);
        vi.mocked(submitTx).mockResolvedValue(mockFailedTxData);

        try {
          await submitCallTx(mockProviders, options);
          expect.fail('Expected CallTxFailedError to be thrown');
        } catch (error) {
          expect(error).toBeInstanceOf(CallTxFailedError);
          expect((error as CallTxFailedError).finalizedTxData).toEqual(mockFailedTxData);
          expect((error as CallTxFailedError).circuitId).toEqual(circuitId);
        }
      });
    });

    describe('validation checks', () => {
      it('should validate contract address', async () => {
        const options = createBasicCallOptions({ contractAddress: 'invalid-address' as ContractAddress });

        await expect(submitCallTx(mockProviders, options)).rejects.toThrow();
      });

      it('should validate circuit exists in contract', async () => {
        const options = createBasicCallOptions({ circuitId: 'nonExistentCircuit' as ImpureCircuitId });

        await expect(submitCallTx(mockProviders, options)).rejects.toThrow("Circuit 'nonExistentCircuit' is undefined");
      });
    });

    describe('error propagation', () => {
      it('should propagate errors from createUnprovenCallTx', async () => {
        const options = createBasicCallOptions();
        const createError = new Error('Failed to create unproven call tx');
        vi.mocked(createUnprovenCallTx).mockRejectedValue(createError);

        await expect(submitCallTx(mockProviders, options)).rejects.toThrow('Failed to create unproven call tx');
        expect(submitTx).not.toHaveBeenCalled();
      });

      it('should propagate errors from submitTx', async () => {
        const options = createBasicCallOptions();
        const mockUnprovenCallTxData = createFailedTxData();
        const submitError = new Error('Network error during submission');

        vi.mocked(createUnprovenCallTx).mockResolvedValue(mockUnprovenCallTxData);
        vi.mocked(submitTx).mockRejectedValue(submitError);

        await expect(submitCallTx(mockProviders, options)).rejects.toThrow('Network error during submission');
      });

      it('should propagate errors from privateStateProvider.set', async () => {
        const options = createBasicCallOptions({ privateStateId: mockPrivateStateId });
        const stateError = new Error('Failed to set private state');

        const mockUnprovenCallTxData = createMockUnprovenCallTxData();
        const mockFinalizedTxData = createMockFinalizedTxData();

        vi.mocked(createUnprovenCallTx).mockResolvedValue(mockUnprovenCallTxData);
        vi.mocked(submitTx).mockResolvedValue(mockFinalizedTxData);
        mockProviders.privateStateProvider.set = vi.fn().mockRejectedValue(stateError);

        await expect(submitCallTx(mockProviders, options)).rejects.toThrow('Failed to set private state');
      });
    });

    describe('edge cases', () => {
      it('should handle empty new coins array', async () => {
        const options = createBasicCallOptions();
        const mockFinalizedTxData = createMockFinalizedTxData();

        const mockUnprovenCallTxData = createMockUnprovenCallTxData({
          private: {
            newCoins: [],
            input: {} as AlignedValue,
            output: {} as AlignedValue,
            privateTranscriptOutputs: [] as AlignedValue[],
            result: vi.fn(),
            nextZswapLocalState: mockZswapLocalState,
            nextPrivateState: { state: 'test' },
            unprovenTx: mockUnprovenTx
          }
        });
        vi.mocked(createUnprovenCallTx).mockResolvedValue(mockUnprovenCallTxData);
        vi.mocked(submitTx).mockResolvedValue(mockFinalizedTxData);

        const result = await submitCallTx(mockProviders, options);

        expect(submitTx).toHaveBeenCalledWith(mockProviders, {
          unprovenTx: mockUnprovenCallTxData.private.unprovenTx,
          newCoins: [],
          circuitId: 'testCircuit'
        });
        expect(result).toEqual({
          private: mockUnprovenCallTxData.private,
          public: { ...mockUnprovenCallTxData.public, ...mockFinalizedTxData }
        });
      });

      it('should handle undefined next private state with private state ID', async () => {
        const options = createBasicCallOptions({ privateStateId: mockPrivateStateId });

        const mockUnprovenCallTxData = createMockUnprovenCallTxData({
          private: {
            nextPrivateState: undefined,
            input: {} as AlignedValue,
            output: {} as AlignedValue,
            privateTranscriptOutputs: [] as AlignedValue[],
            result: vi.fn(),
            nextZswapLocalState: mockZswapLocalState,
            unprovenTx: mockUnprovenTx,
            newCoins: [mockCoinInfo]
          }
        });
        vi.mocked(createUnprovenCallTx).mockResolvedValue(mockUnprovenCallTxData);

        await submitCallTx(mockProviders, options);

        expect(mockProviders.privateStateProvider.set).toHaveBeenCalledWith(mockPrivateStateId, undefined);
      });

      it('should handle call without arguments', async () => {
        const options = createBasicCallOptions();
        const { mockUnprovenCallTxData, mockFinalizedTxData } = setupSuccessfulMocks();

        const result = await submitCallTx(mockProviders, options);

        expect(createUnprovenCallTx).toHaveBeenCalledWith(mockProviders, options);
        verifySuccessfulCall(mockUnprovenCallTxData, mockFinalizedTxData, result, options);
      });
    });
  });

  describe('submitCallTxAsync', () => {
    describe('successful async submission', () => {
      it('should submit transaction and return txId with call data without waiting', async () => {
        const options = createBasicCallOptions();
        const mockUnprovenCallTxData = createMockUnprovenCallTxData();
        const mockTxId = 'test-tx-id-123';

        vi.mocked(createUnprovenCallTx).mockResolvedValue(mockUnprovenCallTxData);
        vi.mocked(submitTxAsync).mockResolvedValue(mockTxId);

        const result = await submitCallTxAsync(mockProviders, options);

        expect(createUnprovenCallTx).toHaveBeenCalledWith(mockProviders, options);
        expect(submitTxAsync).toHaveBeenCalledWith(mockProviders, {
          unprovenTx: mockUnprovenCallTxData.private.unprovenTx,
          newCoins: mockUnprovenCallTxData.private.newCoins,
          circuitId: 'testCircuit'
        });
        expect(result).toEqual({
          txId: mockTxId,
          callTxData: mockUnprovenCallTxData
        });
      });

      it('should not update private state during async submission', async () => {
        const options = createBasicCallOptions({ privateStateId: mockPrivateStateId });
        const mockUnprovenCallTxData = createMockUnprovenCallTxData();
        const mockTxId = 'test-tx-id-456';

        vi.mocked(createUnprovenCallTx).mockResolvedValue(mockUnprovenCallTxData);
        vi.mocked(submitTxAsync).mockResolvedValue(mockTxId);

        await submitCallTxAsync(mockProviders, options);

        expect(mockProviders.privateStateProvider.set).not.toHaveBeenCalled();
      });
    });

    describe('configuration validation', () => {
      it('should throw IncompleteCallTxPrivateStateConfig when privateStateId provided without privateStateProvider', async () => {
        const providersWithoutPrivateState = { ...mockProviders };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        delete (providersWithoutPrivateState as any).privateStateProvider;
        const options = createBasicCallOptions({ privateStateId: mockPrivateStateId });

        await expect(submitCallTxAsync(providersWithoutPrivateState, options)).rejects.toThrow(
          IncompleteCallTxPrivateStateConfig
        );

        expect(createUnprovenCallTx).not.toHaveBeenCalled();
        expect(submitTxAsync).not.toHaveBeenCalled();
      });

      it('should accept privateStateProvider without privateStateId', async () => {
        const options = createBasicCallOptions();
        const mockUnprovenCallTxData = createMockUnprovenCallTxData();
        const mockTxId = 'test-tx-id-789';

        vi.mocked(createUnprovenCallTx).mockResolvedValue(mockUnprovenCallTxData);
        vi.mocked(submitTxAsync).mockResolvedValue(mockTxId);

        await submitCallTxAsync(mockProviders, options);

        expect(mockProviders.privateStateProvider.set).not.toHaveBeenCalled();
      });
    });

    describe('validation checks', () => {
      it('should validate contract address', async () => {
        const options = createBasicCallOptions({ contractAddress: 'invalid-address' as ContractAddress });

        await expect(submitCallTxAsync(mockProviders, options)).rejects.toThrow();
      });

      it('should validate circuit exists in contract', async () => {
        const options = createBasicCallOptions({ circuitId: 'nonExistentCircuit' as ImpureCircuitId });

        await expect(submitCallTxAsync(mockProviders, options)).rejects.toThrow("Circuit 'nonExistentCircuit' is undefined");
      });
    });

    describe('error propagation', () => {
      it('should propagate errors from createUnprovenCallTx', async () => {
        const options = createBasicCallOptions();
        const createError = new Error('Failed to create unproven call tx');
        vi.mocked(createUnprovenCallTx).mockRejectedValue(createError);

        await expect(submitCallTxAsync(mockProviders, options)).rejects.toThrow('Failed to create unproven call tx');
        expect(submitTxAsync).not.toHaveBeenCalled();
      });

      it('should propagate errors from submitTxAsync', async () => {
        const options = createBasicCallOptions();
        const mockUnprovenCallTxData = createMockUnprovenCallTxData();
        const submitError = new Error('Network error during submission');

        vi.mocked(createUnprovenCallTx).mockResolvedValue(mockUnprovenCallTxData);
        vi.mocked(submitTxAsync).mockRejectedValue(submitError);

        await expect(submitCallTxAsync(mockProviders, options)).rejects.toThrow('Network error during submission');
      });
    });

    describe('edge cases', () => {
      it('should handle empty new coins array', async () => {
        const options = createBasicCallOptions();
        const mockTxId = 'test-tx-id-empty-coins';

        const mockUnprovenCallTxData = createMockUnprovenCallTxData({
          private: {
            newCoins: [],
            input: {} as AlignedValue,
            output: {} as AlignedValue,
            privateTranscriptOutputs: [] as AlignedValue[],
            result: vi.fn(),
            nextZswapLocalState: mockZswapLocalState,
            nextPrivateState: { state: 'test' },
            unprovenTx: mockUnprovenTx
          }
        });
        vi.mocked(createUnprovenCallTx).mockResolvedValue(mockUnprovenCallTxData);
        vi.mocked(submitTxAsync).mockResolvedValue(mockTxId);

        const result = await submitCallTxAsync(mockProviders, options);

        expect(submitTxAsync).toHaveBeenCalledWith(mockProviders, {
          unprovenTx: mockUnprovenCallTxData.private.unprovenTx,
          newCoins: [],
          circuitId: 'testCircuit'
        });
        expect(result.txId).toBe(mockTxId);
        expect(result.callTxData).toEqual(mockUnprovenCallTxData);
      });

      it('should return callTxData with all private state information', async () => {
        const options = createBasicCallOptions({ privateStateId: mockPrivateStateId });
        const mockTxId = 'test-tx-id-full-data';
        const nextPrivateState = { complexState: 'data' } as PrivateState<Contract>;

        const mockUnprovenCallTxData = createMockUnprovenCallTxData({
          private: {
            nextPrivateState,
            input: {} as AlignedValue,
            output: {} as AlignedValue,
            privateTranscriptOutputs: [] as AlignedValue[],
            result: vi.fn(),
            nextZswapLocalState: mockZswapLocalState,
            unprovenTx: mockUnprovenTx,
            newCoins: [mockCoinInfo]
          }
        });
        vi.mocked(createUnprovenCallTx).mockResolvedValue(mockUnprovenCallTxData);
        vi.mocked(submitTxAsync).mockResolvedValue(mockTxId);

        const result = await submitCallTxAsync(mockProviders, options);

        expect(result.callTxData.private.nextPrivateState).toEqual(nextPrivateState);
        expect(result.callTxData).toEqual(mockUnprovenCallTxData);
      });
    });
  });
});

================
File: packages/contracts/src/test/submit-tx.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ImpureCircuitId } from '@midnight-ntwrk/midnight-js-types';
import { beforeEach, describe, expect, it, vi } from 'vitest';

import { submitTx, submitTxAsync, type SubmitTxOptions } from '../submit-tx';
import {
  createMockFinalizedTxData,
  createMockProvenTx,
  createMockProviders,
  createMockUnprovenTx
} from './test-mocks';

describe('submit-tx', () => {
  describe('submitTx', () => {
    let mockProviders: ReturnType<typeof createMockProviders>;
    let mockUnprovenTx: ReturnType<typeof createMockUnprovenTx>;
    let mockProvenTx: ReturnType<typeof createMockProvenTx>;

    beforeEach(() => {
      vi.clearAllMocks();

      mockProviders = createMockProviders();
      mockUnprovenTx = createMockUnprovenTx();
      mockProvenTx = createMockProvenTx();
    });

    describe('happy path', () => {
      it('should successfully submit transaction without circuit ID', async () => {
        const mockRecipe = { type: 'TransactionToProve' as const, transaction: mockProvenTx };
        const mockFinalizedTxData = createMockFinalizedTxData();

        mockProviders.walletProvider.balanceTx = vi.fn().mockResolvedValue(mockRecipe);
        mockProviders.proofProvider.proveTx = vi.fn().mockResolvedValue(mockProvenTx);
        mockProviders.midnightProvider.submitTx = vi.fn().mockResolvedValue('test-tx-id');
        mockProviders.publicDataProvider.watchForTxData = vi.fn().mockResolvedValue(mockFinalizedTxData);

        const options: SubmitTxOptions<ImpureCircuitId> = {
          unprovenTx: mockUnprovenTx,
        };

        const result = await submitTx(mockProviders, options);

        expect(mockProviders.walletProvider.balanceTx).toHaveBeenCalledWith(mockUnprovenTx, undefined);
        expect(mockProviders.proofProvider.proveTx).toHaveBeenCalledWith(mockProvenTx, undefined);
        expect(mockProviders.midnightProvider.submitTx).toHaveBeenCalled();
        expect(mockProviders.publicDataProvider.watchForTxData).toHaveBeenCalledWith('test-tx-id');
        expect(result).toBe(mockFinalizedTxData);
      });

      it('should successfully submit transaction with circuit ID', async () => {
        const circuitId = 'testCircuit' as ImpureCircuitId;
        const mockZkConfig = { zkConfig: 'test-config' };
        const mockRecipe = { type: 'TransactionToProve' as const, transaction: mockProvenTx };
        const mockFinalizedTxData = createMockFinalizedTxData();

        mockProviders.zkConfigProvider.get = vi.fn().mockResolvedValue(mockZkConfig);
        mockProviders.walletProvider.balanceTx = vi.fn().mockResolvedValue(mockRecipe);
        mockProviders.proofProvider.proveTx = vi.fn().mockResolvedValue(mockProvenTx);
        mockProviders.midnightProvider.submitTx = vi.fn().mockResolvedValue('test-tx-id');
        mockProviders.publicDataProvider.watchForTxData = vi.fn().mockResolvedValue(mockFinalizedTxData);

        const options: SubmitTxOptions<ImpureCircuitId> = {
          unprovenTx: mockUnprovenTx,
          circuitId
        };

        const result = await submitTx(mockProviders, options);

        expect(mockProviders.zkConfigProvider.get).toHaveBeenCalledWith(circuitId);
        expect(mockProviders.walletProvider.balanceTx).toHaveBeenCalledWith(mockUnprovenTx, undefined);
        expect(mockProviders.proofProvider.proveTx).toHaveBeenCalledWith(mockProvenTx, { zkConfig: mockZkConfig });
        expect(mockProviders.midnightProvider.submitTx).toHaveBeenCalled();
        expect(mockProviders.publicDataProvider.watchForTxData).toHaveBeenCalledWith('test-tx-id');
        expect(result).toBe(mockFinalizedTxData);
      });
    });
  });

  describe('submitTxAsync', () => {
    let mockProviders: ReturnType<typeof createMockProviders>;
    let mockUnprovenTx: ReturnType<typeof createMockUnprovenTx>;
    let mockProvenTx: ReturnType<typeof createMockProvenTx>;

    beforeEach(() => {
      vi.clearAllMocks();
      mockProviders = createMockProviders();
      mockUnprovenTx = createMockUnprovenTx();
      mockProvenTx = createMockProvenTx();
    });

    describe('successful submission', () => {
      it('should submit transaction and return txId without waiting for finalization', async () => {
        const mockRecipe = { type: 'TransactionToProve' as const, transaction: mockProvenTx };
        const expectedTxId = 'test-tx-id';

        mockProviders.walletProvider.balanceTx = vi.fn().mockResolvedValue(mockRecipe);
        mockProviders.proofProvider.proveTx = vi.fn().mockResolvedValue(mockProvenTx);
        mockProviders.midnightProvider.submitTx = vi.fn().mockResolvedValue(expectedTxId);

        const options: SubmitTxOptions<ImpureCircuitId> = {
          unprovenTx: mockUnprovenTx,
        };

        const result = await submitTxAsync(mockProviders, options);

        expect(mockProviders.walletProvider.balanceTx).toHaveBeenCalledWith(mockUnprovenTx, undefined);
        expect(mockProviders.proofProvider.proveTx).toHaveBeenCalledWith(mockProvenTx, undefined);
        expect(mockProviders.midnightProvider.submitTx).toHaveBeenCalled();
        expect(mockProviders.publicDataProvider.watchForTxData).not.toHaveBeenCalled();
        expect(result).toBe(expectedTxId);
      });

      it('should submit transaction with circuit ID and return txId', async () => {
        const circuitId = 'testCircuit' as ImpureCircuitId;
        const mockZkConfig = { zkConfig: 'test-config' };
        const mockRecipe = { type: 'TransactionToProve' as const, transaction: mockProvenTx };
        const expectedTxId = 'test-tx-id-with-circuit';

        mockProviders.zkConfigProvider.get = vi.fn().mockResolvedValue(mockZkConfig);
        mockProviders.walletProvider.balanceTx = vi.fn().mockResolvedValue(mockRecipe);
        mockProviders.proofProvider.proveTx = vi.fn().mockResolvedValue(mockProvenTx);
        mockProviders.midnightProvider.submitTx = vi.fn().mockResolvedValue(expectedTxId);

        const options: SubmitTxOptions<ImpureCircuitId> = {
          unprovenTx: mockUnprovenTx,
          circuitId
        };

        const result = await submitTxAsync(mockProviders, options);

        expect(mockProviders.zkConfigProvider.get).toHaveBeenCalledWith(circuitId);
        expect(mockProviders.walletProvider.balanceTx).toHaveBeenCalledWith(mockUnprovenTx, undefined);
        expect(mockProviders.proofProvider.proveTx).toHaveBeenCalledWith(mockProvenTx, { zkConfig: mockZkConfig });
        expect(mockProviders.midnightProvider.submitTx).toHaveBeenCalled();
        expect(mockProviders.publicDataProvider.watchForTxData).not.toHaveBeenCalled();
        expect(result).toBe(expectedTxId);
      });

      it('should handle newCoins parameter', async () => {
        const mockRecipe = { type: 'TransactionToProve' as const, transaction: mockProvenTx };
        const mockNewCoins = [{ coinId: 'coin1' }];
        const expectedTxId = 'test-tx-id-coins';

        mockProviders.walletProvider.balanceTx = vi.fn().mockResolvedValue(mockRecipe);
        mockProviders.proofProvider.proveTx = vi.fn().mockResolvedValue(mockProvenTx);
        mockProviders.midnightProvider.submitTx = vi.fn().mockResolvedValue(expectedTxId);

        const options: SubmitTxOptions<ImpureCircuitId> = {
          unprovenTx: mockUnprovenTx,
          newCoins: mockNewCoins as any
        };

        const result = await submitTxAsync(mockProviders, options);

        expect(mockProviders.walletProvider.balanceTx).toHaveBeenCalledWith(mockUnprovenTx, mockNewCoins);
        expect(result).toBe(expectedTxId);
      });
    });

    describe('error handling', () => {
      it('should propagate balanceTx errors', async () => {
        const balanceError = new Error('Balance transaction failed');
        mockProviders.walletProvider.balanceTx = vi.fn().mockRejectedValue(balanceError);

        const options: SubmitTxOptions<ImpureCircuitId> = {
          unprovenTx: mockUnprovenTx,
        };

        await expect(submitTxAsync(mockProviders, options)).rejects.toThrow('Balance transaction failed');
        expect(mockProviders.proofProvider.proveTx).not.toHaveBeenCalled();
        expect(mockProviders.midnightProvider.submitTx).not.toHaveBeenCalled();
      });

      it('should propagate proveTx errors', async () => {
        const mockRecipe = { type: 'TransactionToProve' as const, transaction: mockProvenTx };
        const proveError = new Error('Proof generation failed');

        mockProviders.walletProvider.balanceTx = vi.fn().mockResolvedValue(mockRecipe);
        mockProviders.proofProvider.proveTx = vi.fn().mockRejectedValue(proveError);

        const options: SubmitTxOptions<ImpureCircuitId> = {
          unprovenTx: mockUnprovenTx,
        };

        await expect(submitTxAsync(mockProviders, options)).rejects.toThrow('Proof generation failed');
        expect(mockProviders.midnightProvider.submitTx).not.toHaveBeenCalled();
      });

      it('should propagate submitTx errors', async () => {
        const mockRecipe = { type: 'TransactionToProve' as const, transaction: mockProvenTx };
        const submitError = new Error('Network submission failed');

        mockProviders.walletProvider.balanceTx = vi.fn().mockResolvedValue(mockRecipe);
        mockProviders.proofProvider.proveTx = vi.fn().mockResolvedValue(mockProvenTx);
        mockProviders.midnightProvider.submitTx = vi.fn().mockRejectedValue(submitError);

        const options: SubmitTxOptions<ImpureCircuitId> = {
          unprovenTx: mockUnprovenTx,
        };

        await expect(submitTxAsync(mockProviders, options)).rejects.toThrow('Network submission failed');
      });

      it('should propagate zkConfigProvider errors', async () => {
        const circuitId = 'testCircuit' as ImpureCircuitId;
        const configError = new Error('ZK config retrieval failed');

        mockProviders.zkConfigProvider.get = vi.fn().mockRejectedValue(configError);

        const options: SubmitTxOptions<ImpureCircuitId> = {
          unprovenTx: mockUnprovenTx,
          circuitId
        };

        await expect(submitTxAsync(mockProviders, options)).rejects.toThrow('ZK config retrieval failed');
        expect(mockProviders.walletProvider.balanceTx).not.toHaveBeenCalled();
      });
    });
  });
});

================
File: packages/contracts/src/test/test-mocks.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  ChargedState,
  type ContractState,
  type Op,
  sampleSigningKey,
  type SigningKey,
  StateValue,
  type ZswapLocalState
} from '@midnight-ntwrk/compact-runtime';
import {
  type AlignedValue,
  type Binding,
  type Bindingish,
  type CoinPublicKey,
  type CoinSecretKey,
  type DustSecretKey,
  type EncPublicKey,
  type EncryptionSecretKey,
  type PartitionedTranscript,
  type Proof,
  type Proofish,
  sampleCoinPublicKey,
  sampleContractAddress,
  sampleDustSecretKey,
  sampleEncryptionPublicKey,
  type ShieldedCoinInfo,
  type SignatureEnabled,
  type Signaturish,
  type TokenType,
  type Transaction,
  type UnprovenTransaction,
  type ZswapChainState,
  type ZswapSecretKeys
} from '@midnight-ntwrk/ledger-v6';
import {
  type Contract,
  type FinalizedTxData,
  type ImpureCircuitId,
  type PrivateState,
  type PrivateStateId,
  SucceedEntirely,
  type TxStatus,
  type VerifierKey,
  type Witnesses
} from '@midnight-ntwrk/midnight-js-types';
import { vi } from 'vitest';

import { type CallOptions, type CallOptionsWithPrivateState } from '../call';
import { type ContractConstructorResult } from '../call-constructor';
import type { ContractProviders } from '../contract-providers';
import { type UnsubmittedCallTxData, type UnsubmittedDeployTxData } from '../tx-model';

export const createMockContractAddress = () => sampleContractAddress();

export const createMockSigningKey = () => sampleSigningKey();

export const createMockCoinPublicKey = () => sampleCoinPublicKey();

export const createMockPrivateStateId = (): PrivateStateId => 'test-private-state-id' as PrivateStateId;

export const createMockEncryptionPublicKey = (): EncPublicKey => sampleEncryptionPublicKey();

export const createMockDustSecretKey = (): DustSecretKey => sampleDustSecretKey();

export const createMockZswapSecretKeys = (): ZswapSecretKeys => {
  return {
    coinPublicKey: createMockCoinPublicKey() as CoinPublicKey,
    coinSecretKey: {} as CoinSecretKey,
    encryptionPublicKey: createMockEncryptionPublicKey() as EncPublicKey,
    encryptionSecretKey: {} as EncryptionSecretKey,
    clear: vi.fn()
  };
};

export const createMockContractState = (signingKey?: SigningKey): ContractState => ({
  serialize: vi.fn().mockReturnValue(new Uint8Array(32)),
  data: new ChargedState(StateValue.newNull()),
  operation: vi.fn().mockImplementation((_circuitId: string) => ({
    verifierKey: new Uint8Array(32)
  })),
  query: vi.fn(),
  operations: vi.fn(),
  setOperation: vi.fn(),
  maintenanceAuthority: {
    threshold: 1,
    committee: [signingKey || createMockSigningKey()],
    counter: 1n,
    serialize: function (): Uint8Array {
      throw new Error('Function not implemented.');
    }
  },
  balance: {} as Map<TokenType, bigint>
});

export const createMockZswapLocalState = (): ZswapLocalState => ({
  currentIndex: 0n,
  coinPublicKey: createMockCoinPublicKey(),
  outputs: [],
  inputs: []
});

export const createMockContract = (): Contract<undefined> => ({
  initialState: vi.fn().mockReturnValue({
    currentContractState: createMockContractState(),
    currentPrivateState: { test: 'mock-private-state' },
    currentZswapLocalState: new Uint8Array(0)
  }),
  impureCircuits: {
    testCircuit: vi.fn()
  },
  witnesses: {} as Witnesses<undefined>
});

export const createMockUnprovenTx = (): UnprovenTransaction => ({
  eraseProofs: vi.fn(),
  identifiers: vi.fn(),
  merge: vi.fn(),
  serialize: vi.fn(),
  imbalances: vi.fn(),
  bind: vi.fn(),
  wellFormed: vi.fn(),
  transactionHash: vi.fn(),
  fees: vi.fn(),
  intents: undefined,
  fallibleOffer: undefined,
  guaranteedOffer: undefined,
  bindingRandomness: 0n,
  rewards: undefined,
  mockProve: vi.fn(),
  prove: vi.fn(),
  eraseSignatures: vi.fn(),
  cost: vi.fn(),
  feesWithMargin: vi.fn()
});

export const createMockProvenTx = (): Transaction<Signaturish, Proofish, Bindingish> => ({
  eraseProofs: vi.fn(),
  identifiers: vi.fn().mockReturnValue(['test-tx-id']),
  merge: vi.fn(),
  serialize: vi.fn(),
  imbalances: vi.fn(),
  bind: vi.fn().mockReturnValue(new Uint8Array(0)),
  wellFormed: vi.fn(),
  transactionHash: vi.fn(),
  fees: vi.fn(),
  intents: undefined,
  fallibleOffer: undefined,
  guaranteedOffer: undefined,
  bindingRandomness: 0n,
  rewards: undefined,
  eraseSignatures: vi.fn(),
  cost: vi.fn(),
  feesWithMargin: vi.fn(),
  mockProve: vi.fn(),
  prove: vi.fn()
});

export const createMockCoinInfo = (): ShieldedCoinInfo => ({
  type: 'shielded',
  nonce: 'nonce',
  value: 0n
});

export const createMockProviders = (): ContractProviders<Contract, CoinPublicKey, PrivateState<Contract>> => ({
  midnightProvider: {
    submitTx: vi.fn()
  },
  publicDataProvider: {
    watchForDeployTxData: vi.fn(),
    queryDeployContractState: vi.fn(),
    queryContractState: vi.fn(),
    queryZSwapAndContractState: vi.fn(),
    queryUnshieldedBalances: vi.fn(),
    watchForContractState: vi.fn(),
    watchForTxData: vi.fn(),
    contractStateObservable: vi.fn(),
    watchForUnshieldedBalances: vi.fn(),
    unshieldedBalancesObservable: vi.fn()
  },
  privateStateProvider: {
    get: vi.fn(),
    set: vi.fn(),
    getSigningKey: vi.fn(),
    setSigningKey: vi.fn(),
    remove: vi.fn(),
    clear: vi.fn(),
    clearSigningKeys: vi.fn(),
    removeSigningKey: vi.fn()
  },
  zkConfigProvider: {
    getVerifierKeys: vi.fn(),
    getZKIR: vi.fn(),
    getProverKey: vi.fn(),
    getVerifierKey: vi.fn(),
    get: vi.fn()
  },
  walletProvider: {
    balanceTx: vi.fn(),
    getCoinPublicKey: createMockCoinPublicKey,
    getEncryptionPublicKey: createMockEncryptionPublicKey,
  },
  proofProvider: {
    proveTx: vi.fn()
  }
});

export const createMockFinalizedTxData = (status: TxStatus = SucceedEntirely): FinalizedTxData => ({
  status: status,
  txId: 'test-tx-id',
  identifiers: ['test-tx-id-0', 'test-tx-id'],
  blockHeight: 100,
  tx: {} as Transaction<SignatureEnabled, Proof, Binding>,
  txHash: 'hash',
  blockHash: 'hash',
  segmentStatusMap: undefined,
  unshielded: {
    created: [],
    spent: []
  },
  blockTimestamp: 0,
  blockAuthor: null,
  indexerId: 0,
  protocolVersion: 0,
  fees: {
    paidFees: '',
    estimatedFees: ''
  }
});

export const createMockUnprovenDeployTxData = (overrides: Partial<UnsubmittedDeployTxData<Contract>> = {}): UnsubmittedDeployTxData<Contract> => ({
  public: {
    contractAddress: createMockContractAddress(),
    initialContractState: createMockContractState()
  },
  private: {
    unprovenTx: createMockUnprovenTx(),
    newCoins: [createMockCoinInfo()],
    signingKey: createMockSigningKey(),
    initialPrivateState: undefined,
    initialZswapState: createMockZswapLocalState()
  },
  ...overrides
});

export const createMockUnprovenCallTxData = (overrides: Partial<UnsubmittedCallTxData<Contract, ImpureCircuitId>> = {}): UnsubmittedCallTxData<Contract, ImpureCircuitId> => ({
    public: {
      nextContractState: StateValue.newNull(),
      publicTranscript: [
        { noop: { n: 1 } }
      ] as Op<AlignedValue>[],
      partitionedTranscript: {} as PartitionedTranscript,
      ...overrides.public
    },
    private: {
      unprovenTx: createMockUnprovenTx(),
      newCoins: [createMockCoinInfo()],
      nextPrivateState: { state: 'test' },
      input: {} as AlignedValue,
      output: {} as AlignedValue,
      privateTranscriptOutputs: [] as AlignedValue[],
      result: vi.fn(),
      nextZswapLocalState: createMockZswapLocalState(),
      ...overrides.private
    }
});

export const createMockCallOptions = (overrides: Partial<CallOptions<Contract, ImpureCircuitId>> = {}): CallOptions<Contract, ImpureCircuitId> => ({
  contract: createMockContract(),
  circuitId: 'testCircuit',
  args: [] as never[],
  contractAddress: createMockContractAddress(),
  coinPublicKey: createMockCoinPublicKey(),
  initialContractState: createMockContractState(),
  initialZswapChainState: {} as ZswapChainState,
  ...overrides
});

export const createMockCallOptionsWithPrivateState = (overrides: Partial<CallOptionsWithPrivateState<Contract, ImpureCircuitId>> = {}): CallOptionsWithPrivateState<Contract, ImpureCircuitId> => ({
  ...createMockCallOptions(),
  initialPrivateState: { test: 'private-state' },
  ...overrides
});

export const createMockConstructorResult = (): ContractConstructorResult<Contract> => ({
  nextContractState: createMockContractState(),
  nextPrivateState: { test: 'next-private-state' },
  nextZswapLocalState: createMockZswapLocalState(),
});

export const createMockVerifierKeys = (): [string, VerifierKey][] => [
  ['testCircuit', new Uint8Array(32) as VerifierKey]
];

================
File: packages/contracts/src/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export {
  call,
  CallOptions,
  CallOptionsBase,
  CallOptionsProviderDataDependencies,
  CallOptionsWithArguments,
  CallOptionsWithPrivateState,
  CallOptionsWithProviderDataDependencies,
  CallResult,
  CallResultPrivate,
  CallResultPublic
} from './call';
export {
  callContractConstructor,
  ContractConstructorOptions,
  ContractConstructorOptionsBase,
  ContractConstructorOptionsProviderDataDependencies,
  ContractConstructorOptionsWithArguments,
  ContractConstructorOptionsWithPrivateState,
  ContractConstructorOptionsWithProviderDataDependencies,
  ContractConstructorResult} from './call-constructor';
export { ContractProviders } from './contract-providers';
export {
  deployContract,
  DeployContractOptions,
  DeployContractOptionsBase,
  DeployContractOptionsWithPrivateState,
  DeployedContract
} from './deploy-contract';
export {
  CallTxFailedError,
  ContractTypeError,
  DeployTxFailedError,
  IncompleteCallTxPrivateStateConfig,
  IncompleteFindContractPrivateStateConfig,
  InsertVerifierKeyTxFailedError,
  RemoveVerifierKeyTxFailedError,
  ReplaceMaintenanceAuthorityTxFailedError,
  TxFailedError} from './errors';
export {
  findDeployedContract,
  FindDeployedContractOptions,
  FindDeployedContractOptionsBase,
  FindDeployedContractOptionsExistingPrivateState,
  FindDeployedContractOptionsStorePrivateState,
  FoundContract,
  verifierKeysEqual,
  verifyContractState} from './find-deployed-contract';
export { ContractStates,getPublicStates, getStates, PublicContractStates } from './get-states';
export { getUnshieldedBalances } from './get-unshielded-balances';
export { submitCallTx, submitCallTxAsync } from './submit-call-tx';
export { DeployTxOptions,submitDeployTx } from './submit-deploy-tx';
export { submitInsertVerifierKeyTx } from './submit-insert-vk-tx';
export { submitRemoveVerifierKeyTx } from './submit-remove-vk-tx';
export { submitReplaceAuthorityTx } from './submit-replace-authority-tx';
export { submitTx, submitTxAsync, SubmitTxOptions, SubmitTxProviders } from './submit-tx';
export {
  CircuitCallTxInterface,
  CircuitMaintenanceTxInterface,
  CircuitMaintenanceTxInterfaces,
  ContractMaintenanceTxInterface,
  createCallTxOptions,
  createCircuitCallTxInterface,
  createCircuitMaintenanceTxInterface,
  createCircuitMaintenanceTxInterfaces,
  createContractMaintenanceTxInterface} from './tx-interfaces';
export {
  FinalizedCallTxData,
  FinalizedDeployTxData,
  FinalizedDeployTxDataBase,
  SubmittedCallTx,
  UnsubmittedCallTxData,
  UnsubmittedDeployTxData,
  UnsubmittedDeployTxDataBase,
  UnsubmittedDeployTxPrivateData,
  UnsubmittedDeployTxPublicData,
  UnsubmittedTxData} from './tx-model';
export {
  CallTxOptions,
  CallTxOptionsBase,
  CallTxOptionsWithPrivateStateId,
  createUnprovenCallTx,
  createUnprovenCallTxFromInitialStates,
  UnprovenCallTxProvidersBase,
  UnprovenCallTxProvidersWithPrivateState
} from './unproven-call-tx';
export {
  createUnprovenDeployTx,
  createUnprovenDeployTxFromVerifierKeys,
  DeployTxOptionsBase,
  DeployTxOptionsWithPrivateState,
  DeployTxOptionsWithPrivateStateId,
  UnprovenDeployTxOptions,
  UnprovenDeployTxProviders} from './unproven-deploy-tx';

================
File: packages/contracts/src/submit-deploy-tx.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type Contract, type ImpureCircuitId,SucceedEntirely } from '@midnight-ntwrk/midnight-js-types';

import { type ContractProviders } from './contract-providers';
import { DeployTxFailedError } from './errors';
import { submitTx } from './submit-tx';
import type { FinalizedDeployTxData } from './tx-model';
import type { DeployTxOptionsBase, DeployTxOptionsWithPrivateStateId } from './unproven-deploy-tx';
import { createUnprovenDeployTx } from './unproven-deploy-tx';

/**
 * Providers necessary to submit a deployment transaction - all providers.
 */
export type SubmitDeployTxProviders<C extends Contract> =
  | ContractProviders<C, ImpureCircuitId<C>, unknown>
  | ContractProviders<C>;

/**
 * Configuration for creating deploy transactions.
 */
export type DeployTxOptions<C extends Contract> = DeployTxOptionsBase<C> | DeployTxOptionsWithPrivateStateId<C>;

 

export async function submitDeployTx<C extends Contract<undefined>>(
  providers: ContractProviders<C, ImpureCircuitId<C>, unknown>,
  options: DeployTxOptionsBase<C>
): Promise<FinalizedDeployTxData<C>>;

export async function submitDeployTx<C extends Contract>(
  providers: ContractProviders<C>,
  options: DeployTxOptionsWithPrivateStateId<C>
): Promise<FinalizedDeployTxData<C>>;

/**
 * Creates and submits a deploy transaction for the given contract.
 *
 * ## Transaction Execution Phases
 *
 * Midnight transactions execute in two phases:
 * 1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
 * 2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success
 *
 * ## Failure Behavior
 *
 * **Guaranteed Phase Failure:**
 * - Transaction is rejected and not included in the blockchain
 * - `DeployTxFailedError` is thrown with transaction data
 * - Private state (if `privateStateId` provided) is NOT stored
 * - Contract signing key is NOT stored in private state provider
 * - Contract is NOT deployed
 *
 * **Fallible Phase Failure:**
 * - Transaction is recorded on-chain with non-`SucceedEntirely` status
 * - `DeployTxFailedError` is thrown with transaction data
 * - Private state (if `privateStateId` provided) is NOT stored
 * - Contract signing key is NOT stored in private state provider
 * - Transaction appears in blockchain history as partial success
 * - Contract may be partially deployed but not functional
 *
 * @param providers The providers used to manage the deploy lifecycle.
 * @param options Configuration.
 *
 * @returns A `Promise` that resolves with the finalized deployment transaction data;
 *          or rejects with an error if the deployment fails.
 *
 * @throws {DeployTxFailedError} When transaction fails in either guaranteed or fallible phase.
 *         The error contains the finalized transaction data for debugging.
 */
export async function submitDeployTx<C extends Contract>(
  providers: SubmitDeployTxProviders<C>,
  options: DeployTxOptions<C>
): Promise<FinalizedDeployTxData<C>> {
  const unprovenDeployTxData = await createUnprovenDeployTx(providers, options);
  const finalizedTxData = await submitTx(providers, {
    unprovenTx: unprovenDeployTxData.private.unprovenTx,
    newCoins: unprovenDeployTxData.private.newCoins
  });
  if (finalizedTxData.status !== SucceedEntirely) {
    throw new DeployTxFailedError(finalizedTxData);
  }
  if ('privateStateId' in options) {
    await providers.privateStateProvider.set(options.privateStateId, unprovenDeployTxData.private.initialPrivateState);
  }
  await providers.privateStateProvider.setSigningKey(
    unprovenDeployTxData.public.contractAddress,
    unprovenDeployTxData.private.signingKey
  );
  return {
    private: unprovenDeployTxData.private,
    public: {
      ...finalizedTxData,
      ...unprovenDeployTxData.public
    }
  };
}

================
File: packages/contracts/src/submit-insert-vk-tx.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ContractAddress } from '@midnight-ntwrk/ledger-v6';
import {
  type FinalizedTxData,
  type ImpureCircuitId,
  SucceedEntirely,
  type VerifierKey} from '@midnight-ntwrk/midnight-js-types';
import { assertDefined, assertIsContractAddress, assertUndefined } from '@midnight-ntwrk/midnight-js-utils';

import { type ContractProviders } from './contract-providers';
import { InsertVerifierKeyTxFailedError } from './errors';
import { submitTx } from './submit-tx';
import { createUnprovenInsertVerifierKeyTx } from './utils';

/**
 * Constructs and submits a transaction that adds a new verifier key to the
 * blockchain for the given circuit ID at the given contract address.
 *
 * ## Transaction Execution Phases
 *
 * Midnight transactions execute in two phases:
 * 1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
 * 2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success
 *
 * ## Failure Behavior
 *
 * **Guaranteed Phase Failure:**
 * - Transaction is rejected and not included in the blockchain
 * - `InsertVerifierKeyTxFailedError` is thrown with transaction data
 * - Verifier key is NOT added to the contract
 * - No on-chain record of the failed transaction
 *
 * **Fallible Phase Failure:**
 * - Transaction is recorded on-chain with non-`SucceedEntirely` status
 * - `InsertVerifierKeyTxFailedError` is thrown with transaction data
 * - Verifier key may be partially added but not usable
 * - Transaction appears in blockchain history as partial success
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param contractAddress The address of the contract containing the circuit for which
 *                        the verifier key should be inserted.
 * @param circuitId The circuit for which the verifier key should be inserted.
 * @param newVk The new verifier key for the circuit.
 *
 * @returns A promise that resolves with the finalized transaction data, or rejects if
 *          an error occurs along the way.
 *
 * @throws {InsertVerifierKeyTxFailedError} When transaction fails in either guaranteed or fallible phase.
 *         The error contains the finalized transaction data for debugging.
 *
 * TODO: We'll likely want to modify ZKConfigProvider provider so that the verifier keys are
 *       automatically rotated in this function. This likely involves storing key versions
 *       along with keys in ZKConfigProvider. By default, artifacts for the latest version
 *       would be fetched to build transactions.
 */
export const submitInsertVerifierKeyTx = async (
  providers: ContractProviders,
  contractAddress: ContractAddress,
  circuitId: ImpureCircuitId,
  newVk: VerifierKey
): Promise<FinalizedTxData> => {
  assertIsContractAddress(contractAddress);
  const contractState = await providers.publicDataProvider.queryContractState(contractAddress);
  assertDefined(contractState, `No contract state found on chain for contract address '${contractAddress}'`);
  assertUndefined(
    contractState.operation(circuitId),
    `Circuit '${circuitId}' is already defined for contract at address '${contractAddress}'`
  );
  const signingKey = await providers.privateStateProvider.getSigningKey(contractAddress);
  assertDefined(signingKey, `Signing key for contract address '${contractAddress}' not found`);
  const unprovenTx = createUnprovenInsertVerifierKeyTx(contractAddress, circuitId, newVk, contractState, signingKey);
  const submitTxResult = await submitTx(providers, { unprovenTx });
  if (submitTxResult.status !== SucceedEntirely) {
    throw new InsertVerifierKeyTxFailedError(submitTxResult);
  }
  return submitTxResult;
};

================
File: packages/contracts/src/submit-remove-vk-tx.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ContractAddress } from '@midnight-ntwrk/ledger-v6';
import { type FinalizedTxData, type ImpureCircuitId,SucceedEntirely } from '@midnight-ntwrk/midnight-js-types';
import { assertDefined, assertIsContractAddress } from '@midnight-ntwrk/midnight-js-utils';

import { type ContractProviders } from './contract-providers';
import { RemoveVerifierKeyTxFailedError } from './errors';
import { submitTx } from './submit-tx';
import { createUnprovenRemoveVerifierKeyTx } from './utils';

/**
 * Constructs and submits a transaction that removes the current verifier key stored
 * on the blockchain for the given circuit ID at the given contract address.
 *
 * ## Transaction Execution Phases
 *
 * Midnight transactions execute in two phases:
 * 1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
 * 2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success
 *
 * ## Failure Behavior
 *
 * **Guaranteed Phase Failure:**
 * - Transaction is rejected and not included in the blockchain
 * - `RemoveVerifierKeyTxFailedError` is thrown with transaction data
 * - Verifier key remains on the contract (unchanged)
 * - No on-chain record of the failed transaction
 *
 * **Fallible Phase Failure:**
 * - Transaction is recorded on-chain with non-`SucceedEntirely` status
 * - `RemoveVerifierKeyTxFailedError` is thrown with transaction data
 * - Verifier key may be partially removed but contract state is inconsistent
 * - Transaction appears in blockchain history as partial success
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param contractAddress The address of the contract containing the circuit for which
 *                        the verifier key should be removed.
 * @param circuitId The circuit for which the verifier key should be removed.
 *
 * @returns A promise that resolves with the finalized transaction data, or rejects if
 *          an error occurs along the way.
 *
 * @throws {RemoveVerifierKeyTxFailedError} When transaction fails in either guaranteed or fallible phase.
 *         The error contains the finalized transaction data for debugging.
 *
 * TODO: We'll likely want to modify ZKConfigProvider provider so that the verifier keys are
 *       automatically rotated in this function. This likely involves storing key versions
 *       along with keys in ZKConfigProvider. By default, artifacts for the latest version
 *       would be fetched to build transactions.
 */
export const submitRemoveVerifierKeyTx = async (
  providers: ContractProviders,
  contractAddress: ContractAddress,
  circuitId: ImpureCircuitId
): Promise<FinalizedTxData> => {
  assertIsContractAddress(contractAddress);
  const contractState = await providers.publicDataProvider.queryContractState(contractAddress);
  assertDefined(contractState, `No contract state found on chain for contract address '${contractAddress}'`);
  assertDefined(
    contractState.operation(circuitId),
    `Circuit '${circuitId}' not found for contract at address '${contractAddress}'`
  );
  const signingKey = await providers.privateStateProvider.getSigningKey(contractAddress);
  assertDefined(signingKey, `Signing key for contract address '${contractAddress}' not found`);
  const unprovenTx = createUnprovenRemoveVerifierKeyTx(contractAddress, circuitId, contractState, signingKey);
  const submitTxResult = await submitTx(providers, { unprovenTx });
  if (submitTxResult.status !== SucceedEntirely) {
    throw new RemoveVerifierKeyTxFailedError(submitTxResult);
  }
  return submitTxResult;
};

================
File: packages/contracts/src/submit-replace-authority-tx.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ContractAddress, SigningKey } from '@midnight-ntwrk/ledger-v6';
import { type FinalizedTxData, SucceedEntirely } from '@midnight-ntwrk/midnight-js-types';
import { assertDefined, assertIsContractAddress } from '@midnight-ntwrk/midnight-js-utils';

import { type ContractProviders } from './contract-providers';
import { ReplaceMaintenanceAuthorityTxFailedError } from './errors';
import { submitTx } from './submit-tx';
import { createUnprovenReplaceAuthorityTx } from './utils';

/**
 * Constructs and submits a transaction that replaces the maintenance
 * authority stored on the blockchain for this contract. After the transaction is
 * finalized, the current signing key stored in the given private state provider
 * is overwritten with the given new authority key.
 *
 * ## Transaction Execution Phases
 *
 * Midnight transactions execute in two phases:
 * 1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
 * 2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success
 *
 * ## Failure Behavior
 *
 * **Guaranteed Phase Failure:**
 * - Transaction is rejected and not included in the blockchain
 * - `ReplaceMaintenanceAuthorityTxFailedError` is thrown with transaction data
 * - Signing key in private state provider is NOT updated (remains as current authority)
 * - Contract authority on-chain remains unchanged
 *
 * **Fallible Phase Failure:**
 * - Transaction is recorded on-chain with non-`SucceedEntirely` status
 * - `ReplaceMaintenanceAuthorityTxFailedError` is thrown with transaction data
 * - Signing key in private state provider is NOT updated (remains as current authority)
 * - Contract authority on-chain may be partially updated but inconsistent
 * - Transaction appears in blockchain history as partial success
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param contractAddress The address of the contract for which the maintenance
 *                        authority should be updated.
 *
 * TODO: There are at least three options we should support in the future:
 *       1. Replace authority and maintain key (current).
 *       2. Replace authority and do not maintain key.
 *       3. Add additional authorities and maintain original key.
 */
export const submitReplaceAuthorityTx =
  (providers: ContractProviders, contractAddress: ContractAddress) =>
  /**
   * @param newAuthority The signing key of the new contract maintenance authority.
   *
   * @returns A promise that resolves with the finalized transaction data, or rejects if
   *          an error occurs along the way.
   *
   * @throws {ReplaceMaintenanceAuthorityTxFailedError} When transaction fails in either guaranteed or fallible phase.
   *         The error contains the finalized transaction data for debugging.
   */
  async (newAuthority: SigningKey): Promise<FinalizedTxData> => {
    assertIsContractAddress(contractAddress);
    const contractState = await providers.publicDataProvider.queryContractState(contractAddress);
    assertDefined(contractState, `No contract state found on chain for contract address '${contractAddress}'`);
    const currentAuthority = await providers.privateStateProvider.getSigningKey(contractAddress);
    assertDefined(currentAuthority, `Signing key for contract address '${contractAddress}' not found`);
    const unprovenTx = createUnprovenReplaceAuthorityTx(contractAddress, newAuthority, contractState, currentAuthority);
    const submitTxResult = await submitTx(providers, { unprovenTx });
    if (submitTxResult.status !== SucceedEntirely) {
      throw new ReplaceMaintenanceAuthorityTxFailedError(submitTxResult);
    }
    // TODO: What if machine crashes right before the following set executes? How to recover?
    //       Likely will need a history of pending transactions.
    await providers.privateStateProvider.setSigningKey(contractAddress, newAuthority);
    return submitTxResult;
  };

================
File: packages/contracts/src/tx-model.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ContractAddress, ContractState, SigningKey,ZswapLocalState } from '@midnight-ntwrk/compact-runtime';
import { type ShieldedCoinInfo, type UnprovenTransaction } from '@midnight-ntwrk/ledger-v6';
import type {
  Contract,
  FinalizedTxData,
  ImpureCircuitId,
  PrivateState
} from '@midnight-ntwrk/midnight-js-types';

import type { CallResult } from './call';

/**
 * Data relevant to any unsubmitted transaction.
 */
export type UnsubmittedTxData = {
  /**
   * The unproven ledger transaction produced.
   */
  readonly unprovenTx: UnprovenTransaction;
  /**
   * New coins created during the construction of the transaction.
   */
  readonly newCoins: ShieldedCoinInfo[];
}

/**
 * Base type for public data relevant to an unsubmitted deployment transaction.
 */
export type UnsubmittedDeployTxPublicData = {
  /**
   * The ledger address of the contract that was deployed.
   */
  readonly contractAddress: ContractAddress;
  /**
   * The initial public state of the contract deployed to the blockchain.
   */
  readonly initialContractState: ContractState;
}

/**
 * Base type for private data relevant to an unsubmitted deployment transaction.
 */
export type UnsubmittedDeployTxPrivateData<C extends Contract> = {
  /**
   * The signing key that was added as the deployed contract's maintenance authority.
   */
  readonly signingKey: SigningKey;
  /**
   * The initial private state of the contract deployed to the blockchain. This
   * value is persisted if the transaction succeeds.
   */
  readonly initialPrivateState: PrivateState<C>;
}

/**
 * Base type for data relevant to an unsubmitted deployment transaction.
 */
export type UnsubmittedDeployTxDataBase<C extends Contract> = {
  /**
   * The public data (data that will be revealed upon tx submission) relevant to the deployment transaction.
   */
  readonly public: UnsubmittedDeployTxPublicData;
  /**
   * The private data (data that will not be revealed upon tx submission) relevant to the deployment transaction.
   */
  readonly private: UnsubmittedDeployTxPrivateData<C>;
}

/**
 * Data for an unsubmitted deployment transaction.
 */
export type UnsubmittedDeployTxData<C extends Contract> = UnsubmittedDeployTxDataBase<C> & {
  /**
   * The data of this transaction that is only visible on the user device.
   */
  readonly private: UnsubmittedTxData & {
    /**
     * The Zswap state produced as a result of running the contract constructor. Useful for when
     * inputs or outputs are created in the contract constructor.
     */
    readonly initialZswapState: ZswapLocalState;
  };
};

/**
 * Data for a finalized deploy transaction submitted in this process.
 */
export type FinalizedDeployTxDataBase<C extends Contract> = UnsubmittedDeployTxDataBase<C> & {
  /**
   * The data of this transaction that is visible on the blockchain.
   */
  readonly public: FinalizedTxData;
};

/**
 * Data for a finalized deploy transaction submitted in this process.
 */
export type FinalizedDeployTxData<C extends Contract> = UnsubmittedDeployTxData<C> & {
  /**
   * The data of this transaction that is visible on the blockchain.
   */
  readonly public: FinalizedTxData;
};

/**
 * Data for an unsubmitted call transaction.
 */
export type UnsubmittedCallTxData<C extends Contract, ICK extends ImpureCircuitId<C>> = CallResult<C, ICK> & {
  /**
   * Private data relevant to this call transaction.
   */
  readonly private: UnsubmittedTxData;
};

/**
 * Data for a submitted, finalized call transaction.
 */
export type FinalizedCallTxData<C extends Contract, ICK extends ImpureCircuitId<C>> = UnsubmittedCallTxData<C, ICK> & {
  /**
   * Public data relevant to this call transaction.
   */
  readonly public: FinalizedTxData;
};

/**
 * Data returned from an asynchronous call transaction submission.
 * Contains the transaction ID and call transaction data without waiting for finalization.
 */
export type SubmittedCallTx<C extends Contract, ICK extends ImpureCircuitId<C>> = {
  /**
   * The transaction ID returned from submission.
   */
  readonly txId: string;
  /**
   * The unproven call transaction data including private state.
   */
  readonly callTxData: UnsubmittedCallTxData<C, ICK>;
};

================
File: packages/contracts/src/unproven-call-tx.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { CoinPublicKey, ContractState } from '@midnight-ntwrk/compact-runtime';
import { type EncPublicKey,type ZswapChainState } from '@midnight-ntwrk/ledger-v6';
import { getNetworkId } from '@midnight-ntwrk/midnight-js-network-id';
import type { Contract, ImpureCircuitId, PrivateState, PrivateStateId } from '@midnight-ntwrk/midnight-js-types';
import { assertDefined, assertIsContractAddress, parseCoinPublicKeyToHex } from '@midnight-ntwrk/midnight-js-utils';

import type {
  CallOptions,
  CallOptionsWithArguments,
  CallOptionsWithPrivateState,
  CallOptionsWithProviderDataDependencies
} from './call';
import { call } from './call';
import { type ContractProviders } from './contract-providers';
import { IncompleteCallTxPrivateStateConfig } from './errors';
import { getPublicStates, getStates } from './get-states';
import type { UnsubmittedCallTxData } from './tx-model';
import { createUnprovenLedgerCallTx, encryptionPublicKeyForZswapState, zswapStateToNewCoins } from './utils';



export function createUnprovenCallTxFromInitialStates<C extends Contract<undefined>, ICK extends ImpureCircuitId<C>>(
  options: CallOptionsWithProviderDataDependencies<C, ICK>,
  walletCoinPublicKey: CoinPublicKey,
  walletEncryptionPublicKey: EncPublicKey
): UnsubmittedCallTxData<C, ICK>;

export function createUnprovenCallTxFromInitialStates<C extends Contract, ICK extends ImpureCircuitId<C>>(
  options: CallOptionsWithPrivateState<C, ICK>,
  walletCoinPublicKey: CoinPublicKey,
  walletEncryptionPublicKey: EncPublicKey
): UnsubmittedCallTxData<C, ICK>;

/**
 * Calls a circuit using the provided initial `states` and creates an unbalanced,
 * unproven, unsubmitted, call transaction.
 *
 * @param options Configuration.
 *
 * @param walletCoinPublicKey
 * @param walletEncryptionPublicKey
 * @returns Data produced by the circuit call and an unproven transaction assembled from the call result.
 */
export function createUnprovenCallTxFromInitialStates<C extends Contract, ICK extends ImpureCircuitId<C>>(
  options: CallOptions<C, ICK>,
  walletCoinPublicKey: CoinPublicKey,
  walletEncryptionPublicKey: EncPublicKey
): UnsubmittedCallTxData<C, ICK> {
  const { contract, circuitId, contractAddress, coinPublicKey, initialContractState, initialZswapChainState } = options;
  assertIsContractAddress(contractAddress);
  assertDefined(contract.impureCircuits[circuitId], `Circuit '${circuitId}' is undefined`);
  const callResult = call(options);
  return {
    public: {
      ...callResult.public
    },
    private: {
      ...callResult.private,
      unprovenTx: createUnprovenLedgerCallTx(
        circuitId,
        contractAddress,
        initialContractState,
        initialZswapChainState,
        callResult.public.partitionedTranscript,
        callResult.private.privateTranscriptOutputs,
        callResult.private.input,
        callResult.private.output,
        callResult.private.nextZswapLocalState,
        encryptionPublicKeyForZswapState(
          callResult.private.nextZswapLocalState,
          walletCoinPublicKey,
          walletEncryptionPublicKey
        )
      ),
      newCoins: zswapStateToNewCoins(
        parseCoinPublicKeyToHex(coinPublicKey, getNetworkId()),
        callResult.private.nextZswapLocalState
      )
    }
  };
}

/**
 * Base type for configuration for a call transaction; identical to {@link CallOptionsWithArguments}.
 */
export type CallTxOptionsBase<C extends Contract, ICK extends ImpureCircuitId<C>> = CallOptionsWithArguments<C, ICK>;

/**
 * Call transaction options with the private state ID to use to store the new private
 * state resulting from the circuit call. Since a private state should already be
 * stored at the given private state ID, we don't need an 'initialPrivateState' like
 * in {@link DeployTxOptionsWithPrivateState}.
 */
export type CallTxOptionsWithPrivateStateId<C extends Contract, ICK extends ImpureCircuitId<C>> = CallTxOptionsBase<
  C,
  ICK
> & {
  /**
   * The identifier for the private state of the contract.
   */
  readonly privateStateId: PrivateStateId;
};

/**
 * Call transaction configuration.
 */
export type CallTxOptions<C extends Contract, ICK extends ImpureCircuitId<C>> =
  | CallTxOptionsBase<C, ICK>
  | CallTxOptionsWithPrivateStateId<C, ICK>;

const createCallOptions = <C extends Contract, ICK extends ImpureCircuitId<C>>(
  callTxOptions: CallTxOptions<C, ICK>,
  coinPublicKey: CoinPublicKey,
  initialContractState: ContractState,
  initialZswapChainState: ZswapChainState,
  initialPrivateState?: PrivateState<C>
): CallOptions<C, ICK> => {
  const callOptionsBase = {
    contract: callTxOptions.contract,
    contractAddress: callTxOptions.contractAddress,
    circuitId: callTxOptions.circuitId
  };
  const callOptionsWithArguments =
    'args' in callTxOptions
      ? {
          ...callOptionsBase,
          args: callTxOptions.args
        }
      : callOptionsBase;
  const callOptionsBaseWithProviderDataDependencies = {
    ...callOptionsWithArguments,
    coinPublicKey: parseCoinPublicKeyToHex(coinPublicKey, getNetworkId()),
    initialContractState,
    initialZswapChainState
  };
  const callOptions = initialPrivateState
    ? { ...callOptionsBaseWithProviderDataDependencies, initialPrivateState }
    : callOptionsBaseWithProviderDataDependencies;
  return callOptions as CallOptions<C, ICK>;
};

/**
 * The minimum set of providers needed to create a call transaction, the ZK
 * artifact provider and a wallet. By defining this type, users can choose to
 * omit a private state provider if they're creating a call transaction for a
 * contract with no private state.
 */
export type UnprovenCallTxProvidersBase = Pick<ContractProviders, 'publicDataProvider' | 'walletProvider'>;

/**
 * Same providers as {@link UnprovenCallTxProvidersBase} with an additional private
 * state provider to store the new private state resulting from the circuit call -
 * only used when creating a call transaction for a contract with a private state.
 */
export type UnprovenCallTxProvidersWithPrivateState<C extends Contract> = UnprovenCallTxProvidersBase &
  Pick<ContractProviders<C>, 'privateStateProvider'>;

/**
 * Providers needed to create a call transaction.
 */
export type UnprovenCallTxProviders<C extends Contract> =
  | UnprovenCallTxProvidersBase
  | UnprovenCallTxProvidersWithPrivateState<C>;

export async function createUnprovenCallTx<C extends Contract<undefined>, ICK extends ImpureCircuitId<C>>(
  providers: UnprovenCallTxProvidersBase,
  options: CallTxOptionsBase<C, ICK>
): Promise<UnsubmittedCallTxData<C, ICK>>;

export async function createUnprovenCallTx<C extends Contract, ICK extends ImpureCircuitId<C>>(
  providers: UnprovenCallTxProvidersWithPrivateState<C>,
  options: CallTxOptionsWithPrivateStateId<C, ICK>
): Promise<UnsubmittedCallTxData<C, ICK>>;

/**
 * Calls a circuit using states fetched from the public data provider and private state
 * provider, then creates an unbalanced, unproven, unsubmitted, call transaction.
 *
 * @param providers The providers to use to create the call transaction.
 * @param options Configuration.
 *
 * @returns A promise that contains all data produced by the circuit call and an unproven
 *          transaction assembled from the call result.
 *
 * @throws IncompleteCallTxPrivateStateConfig If a `privateStateId` was given but a `privateStateProvider`
 *                                           was not. We assume that when a user gives a `privateStateId`,
 *                                           they want to update the private state store.
 */
export async function createUnprovenCallTx<C extends Contract, ICK extends ImpureCircuitId<C>>(
  providers: UnprovenCallTxProviders<C>,
  options: CallTxOptions<C, ICK>
): Promise<UnsubmittedCallTxData<C, ICK>> {
  assertIsContractAddress(options.contractAddress);
  assertDefined(options.contract.impureCircuits[options.circuitId], `Circuit '${options.circuitId}' is undefined`);

  const hasPrivateStateProvider = 'privateStateProvider' in providers;
  const hasPrivateStateId = 'privateStateId' in options;

  if (hasPrivateStateId && !hasPrivateStateProvider) {
    throw new IncompleteCallTxPrivateStateConfig();
  }

  if (hasPrivateStateId && hasPrivateStateProvider) {
    const { zswapChainState, contractState, privateState } = await getStates(
      providers.publicDataProvider,
      providers.privateStateProvider,
      options.contractAddress,
      options.privateStateId
    );
    return createUnprovenCallTxFromInitialStates(
      createCallOptions(
        options,
        parseCoinPublicKeyToHex(providers.walletProvider.getCoinPublicKey(), getNetworkId()),
        contractState,
        zswapChainState,
        privateState
      ),
      providers.walletProvider.getCoinPublicKey(),
      providers.walletProvider.getEncryptionPublicKey()
    );
  }

  const { zswapChainState, contractState } = await getPublicStates(
    providers.publicDataProvider,
    options.contractAddress
  );
  return createUnprovenCallTxFromInitialStates(
    createCallOptions(
      options,
      parseCoinPublicKeyToHex(providers.walletProvider.getCoinPublicKey(), getNetworkId()),
      contractState,
      zswapChainState
    ),
    providers.walletProvider.getCoinPublicKey(),
    providers.walletProvider.getEncryptionPublicKey()
  );
}

================
File: packages/contracts/src/unproven-deploy-tx.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { CoinPublicKey,SigningKey } from '@midnight-ntwrk/compact-runtime';
import type { EncPublicKey } from '@midnight-ntwrk/ledger-v6';
import { getNetworkId } from '@midnight-ntwrk/midnight-js-network-id';
import {
  type Contract,
  type ImpureCircuitId,
  type PrivateState,
  type PrivateStateId,
  type VerifierKey} from '@midnight-ntwrk/midnight-js-types';
import { getImpureCircuitIds } from '@midnight-ntwrk/midnight-js-types';
import { parseCoinPublicKeyToHex } from '@midnight-ntwrk/midnight-js-utils';

import type { ContractConstructorOptions, ContractConstructorOptionsWithArguments } from './call-constructor';
import { callContractConstructor } from './call-constructor';
import { type ContractProviders } from './contract-providers';
import { type DeployTxOptions } from './submit-deploy-tx';
import type { UnsubmittedDeployTxData } from './tx-model';
import { createUnprovenLedgerDeployTx, zswapStateToNewCoins } from './utils';

/**
 * Base type for deploy transaction configuration.
 */
export type DeployTxOptionsBase<C extends Contract> = ContractConstructorOptionsWithArguments<C> & {
  /**
   * The signing key to add as the to-be-deployed contract's maintenance authority.
   */
  readonly signingKey: SigningKey;
};

/**
 * Configuration for creating deploy transactions for contracts with private state. This
 * configuration used as a base type for the {@link DeployTxOptionsWithPrivateStateId} configuration.
 * It is also used directly as parameter to {@link createUnprovenDeployTx} which doesn't need
 * to save private state (and therefore doesn't need a private state ID) but does need to supply an
 * initial private state to run the contract constructor against.
 */
export type DeployTxOptionsWithPrivateState<C extends Contract> = DeployTxOptionsBase<C> & {
  /**
   * The private state to run the contract constructor against.
   */
  readonly initialPrivateState: PrivateState<C>;
};

/**
 * Configuration for creating deploy transactions for contracts with private state. This
 * configuration is used when a deployment transaction is created and an initial private
 * state needs to be stored, as is the case in {@link submitDeployTx}.
 */
export type DeployTxOptionsWithPrivateStateId<C extends Contract> = DeployTxOptionsWithPrivateState<C> & {
  /**
   * The identifier for the private state of the contract.
   */
  readonly privateStateId: PrivateStateId;
};

/**
 * Configuration for creating unproven deploy transactions.
 */
export type UnprovenDeployTxOptions<C extends Contract> = DeployTxOptionsBase<C> | DeployTxOptionsWithPrivateState<C>;

const createContractConstructorOptions = <C extends Contract>(
  deployTxOptions: DeployTxOptions<C>,
  coinPublicKey: CoinPublicKey
): ContractConstructorOptions<C> => {
  const constructorOptionsBase = {
    contract: deployTxOptions.contract
  };
  const constructorOptionsWithArguments =
    'args' in deployTxOptions
      ? {
          ...constructorOptionsBase,
          args: deployTxOptions.args
        }
      : constructorOptionsBase;
  const constructorOptionsWithProviderDataDependencies = {
    ...constructorOptionsWithArguments,
    coinPublicKey
  };
  const constructorOptions =
    'initialPrivateState' in deployTxOptions
      ? {
          ...constructorOptionsWithProviderDataDependencies,
          initialPrivateState: deployTxOptions.initialPrivateState
        }
      : constructorOptionsWithProviderDataDependencies;
  return constructorOptions as ContractConstructorOptions<C>;
};



export function createUnprovenDeployTxFromVerifierKeys<C extends Contract<undefined>>(
  verifierKeys: [ImpureCircuitId<C>, VerifierKey][],
  coinPublicKey: CoinPublicKey,
  options: DeployTxOptionsBase<C>,
  encryptionPublicKey: EncPublicKey
): UnsubmittedDeployTxData<C>;

export function createUnprovenDeployTxFromVerifierKeys<C extends Contract>(
  verifierKeys: [ImpureCircuitId<C>, VerifierKey][],
  coinPublicKey: CoinPublicKey,
  options: DeployTxOptionsWithPrivateState<C>,
  encryptionPublicKey: EncPublicKey
): UnsubmittedDeployTxData<C>;

/**
 * Calls a contract constructor and creates an unbalanced, unproven, unsubmitted, deploy transaction
 * from the constructor results.
 *
 * @param verifierKeys The verifier keys for the contract being deployed.
 * @param coinPublicKey The Zswap coin public key of the current user.
 * @param options Configuration.
 * @param encryptionPublicKey
 * @returns Data produced by the contract constructor call and an unproven deployment transaction
 *          assembled from the contract constructor result.
 */
export function createUnprovenDeployTxFromVerifierKeys<C extends Contract>(
  verifierKeys: [ImpureCircuitId<C>, VerifierKey][],
  coinPublicKey: CoinPublicKey,
  options: UnprovenDeployTxOptions<C>,
  encryptionPublicKey: EncPublicKey
): UnsubmittedDeployTxData<C> {
  const { nextContractState, nextPrivateState, nextZswapLocalState } = callContractConstructor(
    createContractConstructorOptions(options, coinPublicKey)
  );
  const [contractAddress, initialContractState, unprovenTx] = createUnprovenLedgerDeployTx(
    verifierKeys,
    options.signingKey,
    nextContractState,
    nextZswapLocalState,
    encryptionPublicKey
  );
  return {
    public: {
      contractAddress,
      initialContractState
    },
    private: {
      signingKey: options.signingKey,
      initialPrivateState: nextPrivateState,
      initialZswapState: nextZswapLocalState,
      unprovenTx,
      newCoins: zswapStateToNewCoins(coinPublicKey, nextZswapLocalState)
    }
  };
}

/**
 * Providers needed to create an unproven deployment transactions, just the ZK artifact
 * provider and a wallet.
 */
export type UnprovenDeployTxProviders<C extends Contract> = Pick<
  ContractProviders<C>,
  'zkConfigProvider' | 'walletProvider'
>;

export async function createUnprovenDeployTx<C extends Contract<undefined>>(
  providers: UnprovenDeployTxProviders<C>,
  options: DeployTxOptionsBase<C>
): Promise<UnsubmittedDeployTxData<C>>;

export async function createUnprovenDeployTx<C extends Contract>(
  providers: UnprovenDeployTxProviders<C>,
  options: DeployTxOptionsWithPrivateState<C>
): Promise<UnsubmittedDeployTxData<C>>;

/**
 * Calls a contract constructor and creates an unbalanced, unproven, unsubmitted, deploy transaction
 * from the constructor results.
 *
 * @param providers The providers to use to create the deploy transaction.
 * @param options Configuration.
 *
 * @returns A promise that contains all data produced by the constructor call and an unproven
 *          transaction assembled from the constructor result.
 */
export async function createUnprovenDeployTx<C extends Contract>(
  providers: UnprovenDeployTxProviders<C>,
  options: UnprovenDeployTxOptions<C>
): Promise<UnsubmittedDeployTxData<C>> {
  const verifierKeys = await providers.zkConfigProvider.getVerifierKeys(getImpureCircuitIds(options.contract));
  return createUnprovenDeployTxFromVerifierKeys(
    verifierKeys,
    parseCoinPublicKeyToHex(providers.walletProvider.getCoinPublicKey(), getNetworkId()),
    options,
    providers.walletProvider.getEncryptionPublicKey()
  );
}

================
File: packages/contracts/vitest.config.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// <reference types="vitest" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  define: {
    __DEBUG__: true,
  },
  test: {
    pool: 'threads',
    environment: 'node',
    testTimeout: 90_000,
    globals: true,
    include: ['**/test/**/*.test.ts'],
    exclude: ['node_modules', 'dist'],
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage'
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }]
    ]
  },
  resolve: {
    alias: {
      '@midnight-ntwrk/onchain-runtime': '@midnight-ntwrk/onchain-runtime-cjs'
    }
  }
});

================
File: packages/indexer-public-data-provider/src/gen/graphql.ts
================
/* eslint-disable */
import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = T | null | undefined;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  HexEncoded: { input: string; output: string; }
  Unit: { input: null; output: null; }
  UnshieldedAddress: { input: string; output: string; }
  ViewingKey: { input: string; output: string; }
};

/** A block with its relevant data. */
export type Block = {
  /** The hex-encoded block author. */
  readonly author: Maybe<Scalars['HexEncoded']['output']>;
  /** The block hash. */
  readonly hash: Scalars['HexEncoded']['output'];
  /** The block height. */
  readonly height: Scalars['Int']['output'];
  /** The hex-encoded ledger parameters for this block. */
  readonly ledgerParameters: Scalars['HexEncoded']['output'];
  /** The parent of this block. */
  readonly parent: Maybe<Block>;
  /** The protocol version. */
  readonly protocolVersion: Scalars['Int']['output'];
  /** The UNIX timestamp. */
  readonly timestamp: Scalars['Int']['output'];
  /** The transactions within this block. */
  readonly transactions: ReadonlyArray<Transaction>;
};

/** Either a block hash or a block height. */
export type BlockOffset =
  /** A hex-encoded block hash. */
  { readonly hash: Scalars['HexEncoded']['input']; readonly height?: never; }
  |  /** A block height. */
  { readonly hash?: never; readonly height: Scalars['Int']['input']; };

export type CollapsedMerkleTree = {
  /** The zswap state end index. */
  readonly endIndex: Scalars['Int']['output'];
  /** The protocol version. */
  readonly protocolVersion: Scalars['Int']['output'];
  /** The zswap state start index. */
  readonly startIndex: Scalars['Int']['output'];
  /** The hex-encoded value. */
  readonly update: Scalars['HexEncoded']['output'];
};

/** A contract action. */
export type ContractAction = {
  readonly address: Scalars['HexEncoded']['output'];
  readonly state: Scalars['HexEncoded']['output'];
  readonly transaction: Transaction;
  readonly unshieldedBalances: ReadonlyArray<ContractBalance>;
  readonly zswapState: Scalars['HexEncoded']['output'];
};

/** Either a block offset or a transaction offset. */
export type ContractActionOffset =
  /** Either a block hash or a block height. */
  { readonly blockOffset: BlockOffset; readonly transactionOffset?: never; }
  |  /** Either a transaction hash or a transaction identifier. */
  { readonly blockOffset?: never; readonly transactionOffset: TransactionOffset; };

/**
 * Represents a token balance held by a contract.
 * This type is exposed through the GraphQL API to allow clients to query
 * unshielded token balances for any contract action (Deploy, Call, Update).
 */
export type ContractBalance = {
  /** Balance amount as string to support larger integer values (up to 16 bytes). */
  readonly amount: Scalars['String']['output'];
  /** Hex-encoded token type identifier. */
  readonly tokenType: Scalars['HexEncoded']['output'];
};

/** A contract call. */
export type ContractCall = ContractAction & {
  /** The hex-encoded serialized address. */
  readonly address: Scalars['HexEncoded']['output'];
  /** Contract deploy for this contract call. */
  readonly deploy: ContractDeploy;
  /** The entry point. */
  readonly entryPoint: Scalars['String']['output'];
  /** The hex-encoded serialized state. */
  readonly state: Scalars['HexEncoded']['output'];
  /** Transaction for this contract call. */
  readonly transaction: Transaction;
  /** Unshielded token balances held by this contract. */
  readonly unshieldedBalances: ReadonlyArray<ContractBalance>;
  /** The hex-encoded serialized contract-specific zswap state. */
  readonly zswapState: Scalars['HexEncoded']['output'];
};

/** A contract deployment. */
export type ContractDeploy = ContractAction & {
  /** The hex-encoded serialized address. */
  readonly address: Scalars['HexEncoded']['output'];
  /** The hex-encoded serialized state. */
  readonly state: Scalars['HexEncoded']['output'];
  /** Transaction for this contract deploy. */
  readonly transaction: Transaction;
  /** Unshielded token balances held by this contract. */
  readonly unshieldedBalances: ReadonlyArray<ContractBalance>;
  /** The hex-encoded serialized contract-specific zswap state. */
  readonly zswapState: Scalars['HexEncoded']['output'];
};

/** A contract update. */
export type ContractUpdate = ContractAction & {
  /** The hex-encoded serialized address. */
  readonly address: Scalars['HexEncoded']['output'];
  /** The hex-encoded serialized state. */
  readonly state: Scalars['HexEncoded']['output'];
  /** Transaction for this contract update. */
  readonly transaction: Transaction;
  /** Unshielded token balances held by this contract after the update. */
  readonly unshieldedBalances: ReadonlyArray<ContractBalance>;
  /** The hex-encoded serialized contract-specific zswap state. */
  readonly zswapState: Scalars['HexEncoded']['output'];
};

export type DustGenerationDtimeUpdate = DustLedgerEvent & {
  /** The ID of this dust ledger event. */
  readonly id: Scalars['Int']['output'];
  /** The maximum ID of all dust ledger events. */
  readonly maxId: Scalars['Int']['output'];
  /** The hex-encoded serialized event. */
  readonly raw: Scalars['HexEncoded']['output'];
};

/** DUST generation status for a specific Cardano stake key. */
export type DustGenerationStatus = {
  /** The hex-encoded Cardano stake key. */
  readonly cardanoStakeKey: Scalars['HexEncoded']['output'];
  /** Current DUST capacity. */
  readonly currentCapacity: Scalars['String']['output'];
  /** The hex-encoded associated DUST address if registered. */
  readonly dustAddress: Maybe<Scalars['HexEncoded']['output']>;
  /** Generation rate in Specks per second. */
  readonly generationRate: Scalars['String']['output'];
  /** NIGHT balance backing generation. */
  readonly nightBalance: Scalars['String']['output'];
  /** Whether this stake key is registered. */
  readonly registered: Scalars['Boolean']['output'];
};

export type DustInitialUtxo = DustLedgerEvent & {
  /** The ID of this dust ledger event. */
  readonly id: Scalars['Int']['output'];
  /** The maximum ID of all dust ledger events. */
  readonly maxId: Scalars['Int']['output'];
  /** The dust output. */
  readonly output: DustOutput;
  /** The hex-encoded serialized event. */
  readonly raw: Scalars['HexEncoded']['output'];
};

/** A dust related ledger event. */
export type DustLedgerEvent = {
  readonly id: Scalars['Int']['output'];
  readonly maxId: Scalars['Int']['output'];
  readonly raw: Scalars['HexEncoded']['output'];
};

/** A dust output. */
export type DustOutput = {
  /** The hex-encoded 32-byte nonce. */
  readonly nonce: Scalars['HexEncoded']['output'];
};

export type DustSpendProcessed = DustLedgerEvent & {
  /** The ID of this dust ledger event. */
  readonly id: Scalars['Int']['output'];
  /** The maximum ID of all dust ledger events. */
  readonly maxId: Scalars['Int']['output'];
  /** The hex-encoded serialized event. */
  readonly raw: Scalars['HexEncoded']['output'];
};

export type Mutation = {
  /** Connect the wallet with the given viewing key and return a session ID. */
  readonly connect: Scalars['HexEncoded']['output'];
  /** Disconnect the wallet with the given session ID. */
  readonly disconnect: Scalars['Unit']['output'];
};


export type MutationConnectArgs = {
  viewingKey: Scalars['ViewingKey']['input'];
};


export type MutationDisconnectArgs = {
  sessionId: Scalars['HexEncoded']['input'];
};

export type ParamChange = DustLedgerEvent & {
  /** The ID of this dust ledger event. */
  readonly id: Scalars['Int']['output'];
  /** The maximum ID of all dust ledger events. */
  readonly maxId: Scalars['Int']['output'];
  /** The hex-encoded serialized event. */
  readonly raw: Scalars['HexEncoded']['output'];
};

export type Query = {
  /** Find a block for the given optional offset; if not present, the latest block is returned. */
  readonly block: Maybe<Block>;
  /** Find a contract action for the given address and optional offset. */
  readonly contractAction: Maybe<ContractAction>;
  /** Get DUST generation status for specific Cardano stake keys. */
  readonly dustGenerationStatus: ReadonlyArray<DustGenerationStatus>;
  /** Find transactions for the given offset. */
  readonly transactions: ReadonlyArray<Transaction>;
};


export type QueryBlockArgs = {
  offset: InputMaybe<BlockOffset>;
};


export type QueryContractActionArgs = {
  address: Scalars['HexEncoded']['input'];
  offset: InputMaybe<ContractActionOffset>;
};


export type QueryDustGenerationStatusArgs = {
  cardanoStakeKeys: ReadonlyArray<Scalars['HexEncoded']['input']>;
};


export type QueryTransactionsArgs = {
  offset: TransactionOffset;
};

/** A regular Midnight transaction. */
export type RegularTransaction = Transaction & {
  /** The block for this transaction. */
  readonly block: Block;
  /** The contract actions for this transaction. */
  readonly contractActions: ReadonlyArray<ContractAction>;
  /** Dust ledger events of this transaction. */
  readonly dustLedgerEvents: ReadonlyArray<DustLedgerEvent>;
  /** The zswap state end index. */
  readonly endIndex: Scalars['Int']['output'];
  /** Fee information for this transaction. */
  readonly fees: TransactionFees;
  /** The hex-encoded transaction hash. */
  readonly hash: Scalars['HexEncoded']['output'];
  /** The transaction ID. */
  readonly id: Scalars['Int']['output'];
  /** The hex-encoded serialized transaction identifiers. */
  readonly identifiers: ReadonlyArray<Scalars['HexEncoded']['output']>;
  /** The hex-encoded serialized merkle-tree root. */
  readonly merkleTreeRoot: Scalars['HexEncoded']['output'];
  /** The protocol version. */
  readonly protocolVersion: Scalars['Int']['output'];
  /** The hex-encoded serialized transaction content. */
  readonly raw: Scalars['HexEncoded']['output'];
  /** The zswap state start index. */
  readonly startIndex: Scalars['Int']['output'];
  /** The result of applying this transaction to the ledger state. */
  readonly transactionResult: TransactionResult;
  /** Unshielded UTXOs created by this transaction. */
  readonly unshieldedCreatedOutputs: ReadonlyArray<UnshieldedUtxo>;
  /** Unshielded UTXOs spent (consumed) by this transaction. */
  readonly unshieldedSpentOutputs: ReadonlyArray<UnshieldedUtxo>;
  /** Zswap ledger events of this transaction. */
  readonly zswapLedgerEvents: ReadonlyArray<ZswapLedgerEvent>;
};

/** A transaction relevant for the subscribing wallet and an optional collapsed merkle tree. */
export type RelevantTransaction = {
  /** An optional collapsed merkle tree. */
  readonly collapsedMerkleTree: Maybe<CollapsedMerkleTree>;
  /** A transaction relevant for the subscribing wallet. */
  readonly transaction: RegularTransaction;
};

/**
 * One of many segments for a partially successful transaction result showing success for some
 * segment.
 */
export type Segment = {
  /** Segment ID. */
  readonly id: Scalars['Int']['output'];
  /** Successful or not. */
  readonly success: Scalars['Boolean']['output'];
};

/** An event of the shielded transactions subscription. */
export type ShieldedTransactionsEvent = RelevantTransaction | ShieldedTransactionsProgress;

/** Information about the shielded transactions indexing progress. */
export type ShieldedTransactionsProgress = {
  /**
   * The highest zswap state end index (see `endIndex` of `Transaction`) of all transactions
   * checked for relevance. Initially less than and eventually (when some wallet has been fully
   * indexed) equal to `highest_end_index`. A value of zero (very unlikely) means that no wallet
   * has subscribed before and indexing for the subscribing wallet has not yet started.
   */
  readonly highestCheckedEndIndex: Scalars['Int']['output'];
  /**
   * The highest zswap state end index (see `endIndex` of `Transaction`) of all transactions. It
   * represents the known state of the blockchain. A value of zero (completely unlikely) means
   * that no shielded transactions have been indexed yet.
   */
  readonly highestEndIndex: Scalars['Int']['output'];
  /**
   * The highest zswap state end index (see `endIndex` of `Transaction`) of all relevant
   * transactions for the subscribing wallet. Usually less than `highest_checked_end_index`
   * unless the latest checked transaction is relevant for the subscribing wallet. A value of
   * zero means that no relevant transactions have been indexed for the subscribing wallet.
   */
  readonly highestRelevantEndIndex: Scalars['Int']['output'];
};

export type Subscription = {
  /**
   * Subscribe to blocks starting at the given offset or at the latest block if the offset is
   * omitted.
   */
  readonly blocks: Block;
  /**
   * Subscribe to contract actions with the given address starting at the given offset or at the
   * latest block if the offset is omitted.
   */
  readonly contractActions: ContractAction;
  /** Subscribe to dust ledger events starting at the given ID or at the very start if omitted. */
  readonly dustLedgerEvents: DustLedgerEvent;
  /**
   * Subscribe to shielded transaction events for the given session ID starting at the given
   * index or at zero if omitted.
   */
  readonly shieldedTransactions: ShieldedTransactionsEvent;
  /**
   * Subscribe unshielded transaction events for the given address and the given transaction ID
   * or zero if omitted.
   */
  readonly unshieldedTransactions: UnshieldedTransactionsEvent;
  /** Subscribe to zswap ledger events starting at the given ID or at the very start if omitted. */
  readonly zswapLedgerEvents: ZswapLedgerEvent;
};


export type SubscriptionBlocksArgs = {
  offset: InputMaybe<BlockOffset>;
};


export type SubscriptionContractActionsArgs = {
  address: Scalars['HexEncoded']['input'];
  offset: InputMaybe<BlockOffset>;
};


export type SubscriptionDustLedgerEventsArgs = {
  id: InputMaybe<Scalars['Int']['input']>;
};


export type SubscriptionShieldedTransactionsArgs = {
  index: InputMaybe<Scalars['Int']['input']>;
  sessionId: Scalars['HexEncoded']['input'];
};


export type SubscriptionUnshieldedTransactionsArgs = {
  address: Scalars['UnshieldedAddress']['input'];
  transactionId: InputMaybe<Scalars['Int']['input']>;
};


export type SubscriptionZswapLedgerEventsArgs = {
  id: InputMaybe<Scalars['Int']['input']>;
};

/** A system Midnight transaction. */
export type SystemTransaction = Transaction & {
  /** The block for this transaction. */
  readonly block: Block;
  /** The contract actions for this transaction. */
  readonly contractActions: ReadonlyArray<ContractAction>;
  /** Dust ledger events of this transaction. */
  readonly dustLedgerEvents: ReadonlyArray<DustLedgerEvent>;
  /** The hex-encoded transaction hash. */
  readonly hash: Scalars['HexEncoded']['output'];
  /** The transaction ID. */
  readonly id: Scalars['Int']['output'];
  /** The protocol version. */
  readonly protocolVersion: Scalars['Int']['output'];
  /** The hex-encoded serialized transaction content. */
  readonly raw: Scalars['HexEncoded']['output'];
  /** Unshielded UTXOs created by this transaction. */
  readonly unshieldedCreatedOutputs: ReadonlyArray<UnshieldedUtxo>;
  /** Unshielded UTXOs spent (consumed) by this transaction. */
  readonly unshieldedSpentOutputs: ReadonlyArray<UnshieldedUtxo>;
  /** Zswap ledger events of this transaction. */
  readonly zswapLedgerEvents: ReadonlyArray<ZswapLedgerEvent>;
};

/** A Midnight transaction. */
export type Transaction = {
  readonly block: Block;
  readonly contractActions: ReadonlyArray<ContractAction>;
  readonly dustLedgerEvents: ReadonlyArray<DustLedgerEvent>;
  readonly hash: Scalars['HexEncoded']['output'];
  readonly id: Scalars['Int']['output'];
  readonly protocolVersion: Scalars['Int']['output'];
  readonly raw: Scalars['HexEncoded']['output'];
  readonly unshieldedCreatedOutputs: ReadonlyArray<UnshieldedUtxo>;
  readonly unshieldedSpentOutputs: ReadonlyArray<UnshieldedUtxo>;
  readonly zswapLedgerEvents: ReadonlyArray<ZswapLedgerEvent>;
};

/** Fees information for a transaction, including both paid and estimated fees. */
export type TransactionFees = {
  /** The estimated fees that was calculated for this transaction in DUST. */
  readonly estimatedFees: Scalars['String']['output'];
  /** The actual fees paid for this transaction in DUST. */
  readonly paidFees: Scalars['String']['output'];
};

/** Either a transaction hash or a transaction identifier. */
export type TransactionOffset =
  /** A hex-encoded transaction hash. */
  { readonly hash: Scalars['HexEncoded']['input']; readonly identifier?: never; }
  |  /** A hex-encoded transaction identifier. */
  { readonly hash?: never; readonly identifier: Scalars['HexEncoded']['input']; };

/**
 * The result of applying a transaction to the ledger state. In case of a partial success (status),
 * there will be segments.
 */
export type TransactionResult = {
  readonly segments: Maybe<ReadonlyArray<Segment>>;
  readonly status: TransactionResultStatus;
};

/** The status of the transaction result: success, partial success or failure. */
export type TransactionResultStatus =
  | 'FAILURE'
  | 'PARTIAL_SUCCESS'
  | 'SUCCESS'
  | '%future added value';

/** A transaction that created and/or spent UTXOs alongside these and other information. */
export type UnshieldedTransaction = {
  /** UTXOs created in the above transaction, possibly empty. */
  readonly createdUtxos: ReadonlyArray<UnshieldedUtxo>;
  /** UTXOs spent in the above transaction, possibly empty. */
  readonly spentUtxos: ReadonlyArray<UnshieldedUtxo>;
  /** The transaction that created and/or spent UTXOs. */
  readonly transaction: Transaction;
};

/** An event of the unshielded transactions subscription. */
export type UnshieldedTransactionsEvent = UnshieldedTransaction | UnshieldedTransactionsProgress;

/** Information about the unshielded indexing progress. */
export type UnshieldedTransactionsProgress = {
  /** The highest transaction ID of all currently known transactions for a subscribed address. */
  readonly highestTransactionId: Scalars['Int']['output'];
};

/** Represents an unshielded UTXO. */
export type UnshieldedUtxo = {
  /** Transaction that created this UTXO. */
  readonly createdAtTransaction: Transaction;
  /** The creation time in seconds. */
  readonly ctime: Maybe<Scalars['Int']['output']>;
  /** The hex-encoded initial nonce for DUST generation tracking. */
  readonly initialNonce: Scalars['HexEncoded']['output'];
  /** The hex-encoded serialized intent hash. */
  readonly intentHash: Scalars['HexEncoded']['output'];
  /** Index of this output within its creating transaction. */
  readonly outputIndex: Scalars['Int']['output'];
  /** Owner Bech32m-encoded address. */
  readonly owner: Scalars['UnshieldedAddress']['output'];
  /** Whether this UTXO is registered for DUST generation. */
  readonly registeredForDustGeneration: Scalars['Boolean']['output'];
  /** Transaction that spent this UTXO. */
  readonly spentAtTransaction: Maybe<Transaction>;
  /** Token hex-encoded serialized token type. */
  readonly tokenType: Scalars['HexEncoded']['output'];
  /** UTXO value (quantity) as a string to support u128. */
  readonly value: Scalars['String']['output'];
};

/** A zswap related ledger event. */
export type ZswapLedgerEvent = {
  /** The ID of this zswap ledger event. */
  readonly id: Scalars['Int']['output'];
  /** The maximum ID of all zswap ledger events. */
  readonly maxId: Scalars['Int']['output'];
  /** The hex-encoded serialized event. */
  readonly raw: Scalars['HexEncoded']['output'];
};

export type BlockHashQueryQueryVariables = Exact<{
  offset: InputMaybe<BlockOffset>;
}>;


export type BlockHashQueryQuery = { readonly block: { readonly height: number, readonly hash: string } | null };

export type TxIdQueryQueryVariables = Exact<{
  offset: TransactionOffset;
}>;


export type TxIdQueryQuery = { readonly transactions: ReadonlyArray<
    | { readonly identifiers: ReadonlyArray<string>, readonly id: number, readonly protocolVersion: number, readonly raw: string, readonly hash: string, readonly fees: { readonly estimatedFees: string, readonly paidFees: string }, readonly transactionResult: { readonly status: TransactionResultStatus, readonly segments: ReadonlyArray<{ readonly id: number, readonly success: boolean }> | null }, readonly unshieldedCreatedOutputs: ReadonlyArray<{ readonly owner: string, readonly intentHash: string, readonly tokenType: string, readonly value: string }>, readonly unshieldedSpentOutputs: ReadonlyArray<{ readonly owner: string, readonly intentHash: string, readonly tokenType: string, readonly value: string }>, readonly block: { readonly height: number, readonly hash: string, readonly author: string | null, readonly timestamp: number } }
    | { readonly id: number, readonly protocolVersion: number, readonly raw: string, readonly hash: string, readonly unshieldedCreatedOutputs: ReadonlyArray<{ readonly owner: string, readonly intentHash: string, readonly tokenType: string, readonly value: string }>, readonly unshieldedSpentOutputs: ReadonlyArray<{ readonly owner: string, readonly intentHash: string, readonly tokenType: string, readonly value: string }>, readonly block: { readonly height: number, readonly hash: string, readonly author: string | null, readonly timestamp: number } }
  > };

export type DeployTxQueryQueryVariables = Exact<{
  address: Scalars['HexEncoded']['input'];
}>;


export type DeployTxQueryQuery = { readonly contractAction:
    | { readonly deploy: { readonly transaction:
          | { readonly identifiers: ReadonlyArray<string>, readonly id: number, readonly protocolVersion: number, readonly raw: string, readonly hash: string, readonly fees: { readonly estimatedFees: string, readonly paidFees: string }, readonly transactionResult: { readonly status: TransactionResultStatus, readonly segments: ReadonlyArray<{ readonly id: number, readonly success: boolean }> | null }, readonly contractActions: ReadonlyArray<
              | { readonly address: string }
              | { readonly address: string }
              | { readonly address: string }
            >, readonly block: { readonly height: number, readonly hash: string, readonly author: string | null, readonly timestamp: number }, readonly unshieldedCreatedOutputs: ReadonlyArray<{ readonly owner: string, readonly intentHash: string, readonly tokenType: string, readonly value: string }>, readonly unshieldedSpentOutputs: ReadonlyArray<{ readonly owner: string, readonly intentHash: string, readonly tokenType: string, readonly value: string }> }
          | { readonly id: number, readonly protocolVersion: number, readonly raw: string, readonly hash: string, readonly contractActions: ReadonlyArray<
              | { readonly address: string }
              | { readonly address: string }
              | { readonly address: string }
            >, readonly block: { readonly height: number, readonly hash: string, readonly author: string | null, readonly timestamp: number }, readonly unshieldedCreatedOutputs: ReadonlyArray<{ readonly owner: string, readonly intentHash: string, readonly tokenType: string, readonly value: string }>, readonly unshieldedSpentOutputs: ReadonlyArray<{ readonly owner: string, readonly intentHash: string, readonly tokenType: string, readonly value: string }> }
         } }
    | { readonly transaction:
        | { readonly identifiers: ReadonlyArray<string>, readonly id: number, readonly protocolVersion: number, readonly raw: string, readonly hash: string, readonly fees: { readonly estimatedFees: string, readonly paidFees: string }, readonly transactionResult: { readonly status: TransactionResultStatus, readonly segments: ReadonlyArray<{ readonly id: number, readonly success: boolean }> | null }, readonly contractActions: ReadonlyArray<
            | { readonly address: string }
            | { readonly address: string }
            | { readonly address: string }
          >, readonly block: { readonly height: number, readonly hash: string, readonly author: string | null, readonly timestamp: number }, readonly unshieldedCreatedOutputs: ReadonlyArray<{ readonly owner: string, readonly intentHash: string, readonly tokenType: string, readonly value: string }>, readonly unshieldedSpentOutputs: ReadonlyArray<{ readonly owner: string, readonly intentHash: string, readonly tokenType: string, readonly value: string }> }
        | { readonly id: number, readonly protocolVersion: number, readonly raw: string, readonly hash: string, readonly contractActions: ReadonlyArray<
            | { readonly address: string }
            | { readonly address: string }
            | { readonly address: string }
          >, readonly block: { readonly height: number, readonly hash: string, readonly author: string | null, readonly timestamp: number }, readonly unshieldedCreatedOutputs: ReadonlyArray<{ readonly owner: string, readonly intentHash: string, readonly tokenType: string, readonly value: string }>, readonly unshieldedSpentOutputs: ReadonlyArray<{ readonly owner: string, readonly intentHash: string, readonly tokenType: string, readonly value: string }> }
       }
    | { readonly transaction:
        | { readonly identifiers: ReadonlyArray<string>, readonly id: number, readonly protocolVersion: number, readonly raw: string, readonly hash: string, readonly fees: { readonly estimatedFees: string, readonly paidFees: string }, readonly transactionResult: { readonly status: TransactionResultStatus, readonly segments: ReadonlyArray<{ readonly id: number, readonly success: boolean }> | null }, readonly contractActions: ReadonlyArray<
            | { readonly address: string }
            | { readonly address: string }
            | { readonly address: string }
          >, readonly block: { readonly height: number, readonly hash: string, readonly author: string | null, readonly timestamp: number }, readonly unshieldedCreatedOutputs: ReadonlyArray<{ readonly owner: string, readonly intentHash: string, readonly tokenType: string, readonly value: string }>, readonly unshieldedSpentOutputs: ReadonlyArray<{ readonly owner: string, readonly intentHash: string, readonly tokenType: string, readonly value: string }> }
        | { readonly id: number, readonly protocolVersion: number, readonly raw: string, readonly hash: string, readonly contractActions: ReadonlyArray<
            | { readonly address: string }
            | { readonly address: string }
            | { readonly address: string }
          >, readonly block: { readonly height: number, readonly hash: string, readonly author: string | null, readonly timestamp: number }, readonly unshieldedCreatedOutputs: ReadonlyArray<{ readonly owner: string, readonly intentHash: string, readonly tokenType: string, readonly value: string }>, readonly unshieldedSpentOutputs: ReadonlyArray<{ readonly owner: string, readonly intentHash: string, readonly tokenType: string, readonly value: string }> }
       }
   | null };

export type DeployContractStateTxQueryQueryVariables = Exact<{
  address: Scalars['HexEncoded']['input'];
}>;


export type DeployContractStateTxQueryQuery = { readonly contractAction:
    | { readonly deploy: { readonly transaction:
          | { readonly contractActions: ReadonlyArray<
              | { readonly address: string, readonly state: string }
              | { readonly address: string, readonly state: string }
              | { readonly address: string, readonly state: string }
            > }
          | { readonly contractActions: ReadonlyArray<
              | { readonly address: string, readonly state: string }
              | { readonly address: string, readonly state: string }
              | { readonly address: string, readonly state: string }
            > }
         } }
    | { readonly state: string }
    | { readonly state: string }
   | null };

export type LatestContractTxBlockHeightQueryQueryVariables = Exact<{
  address: Scalars['HexEncoded']['input'];
}>;


export type LatestContractTxBlockHeightQueryQuery = { readonly contractAction:
    | { readonly transaction:
        | { readonly block: { readonly height: number } }
        | { readonly block: { readonly height: number } }
       }
    | { readonly transaction:
        | { readonly block: { readonly height: number } }
        | { readonly block: { readonly height: number } }
       }
    | { readonly transaction:
        | { readonly block: { readonly height: number } }
        | { readonly block: { readonly height: number } }
       }
   | null };

export type TxsFromBlockSubSubscriptionVariables = Exact<{
  offset: InputMaybe<BlockOffset>;
}>;


export type TxsFromBlockSubSubscription = { readonly blocks: { readonly hash: string, readonly height: number, readonly transactions: ReadonlyArray<
      | { readonly identifiers: ReadonlyArray<string>, readonly hash: string, readonly contractActions: ReadonlyArray<
          | { readonly state: string, readonly address: string }
          | { readonly state: string, readonly address: string }
          | { readonly state: string, readonly address: string }
        > }
      | { readonly hash: string, readonly contractActions: ReadonlyArray<
          | { readonly state: string, readonly address: string }
          | { readonly state: string, readonly address: string }
          | { readonly state: string, readonly address: string }
        > }
    > } };

export type ContractStateQueryQueryVariables = Exact<{
  address: Scalars['HexEncoded']['input'];
  offset: InputMaybe<ContractActionOffset>;
}>;


export type ContractStateQueryQuery = { readonly contractAction:
    | { readonly state: string }
    | { readonly state: string }
    | { readonly state: string }
   | null };

export type ContractStateSubSubscriptionVariables = Exact<{
  address: Scalars['HexEncoded']['input'];
  offset: InputMaybe<BlockOffset>;
}>;


export type ContractStateSubSubscription = { readonly contractActions:
    | { readonly state: string }
    | { readonly state: string }
    | { readonly state: string }
   };

export type BothStateQueryQueryVariables = Exact<{
  address: Scalars['HexEncoded']['input'];
  offset: InputMaybe<ContractActionOffset>;
}>;


export type BothStateQueryQuery = { readonly contractAction:
    | { readonly state: string, readonly zswapState: string }
    | { readonly state: string, readonly zswapState: string }
    | { readonly state: string, readonly zswapState: string }
   | null };

export type UnshieldedBalanceQueryQueryVariables = Exact<{
  address: Scalars['HexEncoded']['input'];
}>;


export type UnshieldedBalanceQueryQuery = { readonly contractAction:
    | { readonly deploy: { readonly unshieldedBalances: ReadonlyArray<{ readonly tokenType: string, readonly amount: string }> } }
    | { readonly unshieldedBalances: ReadonlyArray<{ readonly tokenType: string, readonly amount: string }> }
    | { readonly unshieldedBalances: ReadonlyArray<{ readonly tokenType: string, readonly amount: string }> }
   | null };

export type QueryUnshieldedBalancesWithOffsetQueryVariables = Exact<{
  address: Scalars['HexEncoded']['input'];
  offset: InputMaybe<ContractActionOffset>;
}>;


export type QueryUnshieldedBalancesWithOffsetQuery = { readonly contractAction:
    | { readonly deploy: { readonly unshieldedBalances: ReadonlyArray<{ readonly tokenType: string, readonly amount: string }> } }
    | { readonly unshieldedBalances: ReadonlyArray<{ readonly tokenType: string, readonly amount: string }> }
    | { readonly unshieldedBalances: ReadonlyArray<{ readonly tokenType: string, readonly amount: string }> }
   | null };

export type UnshieldedBalanceSubSubscriptionVariables = Exact<{
  address: Scalars['HexEncoded']['input'];
  offset: InputMaybe<BlockOffset>;
}>;


export type UnshieldedBalanceSubSubscription = { readonly contractActions:
    | { readonly deploy: { readonly unshieldedBalances: ReadonlyArray<{ readonly tokenType: string, readonly amount: string }> } }
    | { readonly unshieldedBalances: ReadonlyArray<{ readonly tokenType: string, readonly amount: string }> }
    | { readonly unshieldedBalances: ReadonlyArray<{ readonly tokenType: string, readonly amount: string }> }
   };


export const BlockHashQueryDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"BLOCK_HASH_QUERY"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"offset"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"BlockOffset"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"block"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"offset"},"value":{"kind":"Variable","name":{"kind":"Name","value":"offset"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"height"}},{"kind":"Field","name":{"kind":"Name","value":"hash"}}]}}]}}]} as unknown as DocumentNode<BlockHashQueryQuery, BlockHashQueryQueryVariables>;
export const TxIdQueryDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"TX_ID_QUERY"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"offset"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"TransactionOffset"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"transactions"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"offset"},"value":{"kind":"Variable","name":{"kind":"Name","value":"offset"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"protocolVersion"}},{"kind":"Field","name":{"kind":"Name","value":"raw"}},{"kind":"Field","name":{"kind":"Name","value":"hash"}},{"kind":"Field","name":{"kind":"Name","value":"unshieldedCreatedOutputs"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"owner"}},{"kind":"Field","name":{"kind":"Name","value":"intentHash"}},{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}},{"kind":"Field","name":{"kind":"Name","value":"unshieldedSpentOutputs"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"owner"}},{"kind":"Field","name":{"kind":"Name","value":"intentHash"}},{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}},{"kind":"Field","name":{"kind":"Name","value":"block"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"height"}},{"kind":"Field","name":{"kind":"Name","value":"hash"}},{"kind":"Field","name":{"kind":"Name","value":"author"}},{"kind":"Field","name":{"kind":"Name","value":"timestamp"}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"RegularTransaction"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"identifiers"}},{"kind":"Field","name":{"kind":"Name","value":"fees"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"estimatedFees"}},{"kind":"Field","name":{"kind":"Name","value":"paidFees"}}]}},{"kind":"Field","name":{"kind":"Name","value":"transactionResult"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"status"}},{"kind":"Field","name":{"kind":"Name","value":"segments"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"success"}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<TxIdQueryQuery, TxIdQueryQueryVariables>;
export const DeployTxQueryDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"DEPLOY_TX_QUERY"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"address"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"HexEncoded"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"contractAction"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"address"},"value":{"kind":"Variable","name":{"kind":"Name","value":"address"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ContractDeploy"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"transaction"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"protocolVersion"}},{"kind":"Field","name":{"kind":"Name","value":"raw"}},{"kind":"Field","name":{"kind":"Name","value":"hash"}},{"kind":"Field","name":{"kind":"Name","value":"contractActions"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"block"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"height"}},{"kind":"Field","name":{"kind":"Name","value":"hash"}},{"kind":"Field","name":{"kind":"Name","value":"author"}},{"kind":"Field","name":{"kind":"Name","value":"timestamp"}}]}},{"kind":"Field","name":{"kind":"Name","value":"unshieldedCreatedOutputs"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"owner"}},{"kind":"Field","name":{"kind":"Name","value":"intentHash"}},{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}},{"kind":"Field","name":{"kind":"Name","value":"unshieldedSpentOutputs"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"owner"}},{"kind":"Field","name":{"kind":"Name","value":"intentHash"}},{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"RegularTransaction"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"identifiers"}},{"kind":"Field","name":{"kind":"Name","value":"fees"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"estimatedFees"}},{"kind":"Field","name":{"kind":"Name","value":"paidFees"}}]}},{"kind":"Field","name":{"kind":"Name","value":"transactionResult"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"status"}},{"kind":"Field","name":{"kind":"Name","value":"segments"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"success"}}]}}]}}]}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ContractUpdate"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"transaction"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"protocolVersion"}},{"kind":"Field","name":{"kind":"Name","value":"raw"}},{"kind":"Field","name":{"kind":"Name","value":"hash"}},{"kind":"Field","name":{"kind":"Name","value":"contractActions"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"block"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"height"}},{"kind":"Field","name":{"kind":"Name","value":"hash"}},{"kind":"Field","name":{"kind":"Name","value":"author"}},{"kind":"Field","name":{"kind":"Name","value":"timestamp"}}]}},{"kind":"Field","name":{"kind":"Name","value":"unshieldedCreatedOutputs"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"owner"}},{"kind":"Field","name":{"kind":"Name","value":"intentHash"}},{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}},{"kind":"Field","name":{"kind":"Name","value":"unshieldedSpentOutputs"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"owner"}},{"kind":"Field","name":{"kind":"Name","value":"intentHash"}},{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"RegularTransaction"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"identifiers"}},{"kind":"Field","name":{"kind":"Name","value":"fees"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"estimatedFees"}},{"kind":"Field","name":{"kind":"Name","value":"paidFees"}}]}},{"kind":"Field","name":{"kind":"Name","value":"transactionResult"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"status"}},{"kind":"Field","name":{"kind":"Name","value":"segments"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"success"}}]}}]}}]}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ContractCall"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"deploy"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"transaction"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"protocolVersion"}},{"kind":"Field","name":{"kind":"Name","value":"raw"}},{"kind":"Field","name":{"kind":"Name","value":"hash"}},{"kind":"Field","name":{"kind":"Name","value":"contractActions"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"block"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"height"}},{"kind":"Field","name":{"kind":"Name","value":"hash"}},{"kind":"Field","name":{"kind":"Name","value":"author"}},{"kind":"Field","name":{"kind":"Name","value":"timestamp"}}]}},{"kind":"Field","name":{"kind":"Name","value":"unshieldedCreatedOutputs"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"owner"}},{"kind":"Field","name":{"kind":"Name","value":"intentHash"}},{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}},{"kind":"Field","name":{"kind":"Name","value":"unshieldedSpentOutputs"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"owner"}},{"kind":"Field","name":{"kind":"Name","value":"intentHash"}},{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"RegularTransaction"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"identifiers"}},{"kind":"Field","name":{"kind":"Name","value":"fees"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"estimatedFees"}},{"kind":"Field","name":{"kind":"Name","value":"paidFees"}}]}},{"kind":"Field","name":{"kind":"Name","value":"transactionResult"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"status"}},{"kind":"Field","name":{"kind":"Name","value":"segments"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"success"}}]}}]}}]}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<DeployTxQueryQuery, DeployTxQueryQueryVariables>;
export const DeployContractStateTxQueryDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"DEPLOY_CONTRACT_STATE_TX_QUERY"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"address"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"HexEncoded"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"contractAction"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"address"},"value":{"kind":"Variable","name":{"kind":"Name","value":"address"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ContractDeploy"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"state"}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ContractUpdate"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"state"}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ContractCall"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"deploy"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"transaction"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"contractActions"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"address"}},{"kind":"Field","name":{"kind":"Name","value":"state"}}]}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<DeployContractStateTxQueryQuery, DeployContractStateTxQueryQueryVariables>;
export const LatestContractTxBlockHeightQueryDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"address"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"HexEncoded"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"contractAction"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"address"},"value":{"kind":"Variable","name":{"kind":"Name","value":"address"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"transaction"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"block"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"height"}}]}}]}}]}}]}}]} as unknown as DocumentNode<LatestContractTxBlockHeightQueryQuery, LatestContractTxBlockHeightQueryQueryVariables>;
export const TxsFromBlockSubDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"subscription","name":{"kind":"Name","value":"TXS_FROM_BLOCK_SUB"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"offset"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"BlockOffset"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"blocks"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"offset"},"value":{"kind":"Variable","name":{"kind":"Name","value":"offset"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"hash"}},{"kind":"Field","name":{"kind":"Name","value":"height"}},{"kind":"Field","name":{"kind":"Name","value":"transactions"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"hash"}},{"kind":"Field","name":{"kind":"Name","value":"contractActions"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"state"}},{"kind":"Field","name":{"kind":"Name","value":"address"}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"RegularTransaction"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"identifiers"}}]}}]}}]}}]}}]} as unknown as DocumentNode<TxsFromBlockSubSubscription, TxsFromBlockSubSubscriptionVariables>;
export const ContractStateQueryDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"CONTRACT_STATE_QUERY"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"address"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"HexEncoded"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"offset"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"ContractActionOffset"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"contractAction"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"address"},"value":{"kind":"Variable","name":{"kind":"Name","value":"address"}}},{"kind":"Argument","name":{"kind":"Name","value":"offset"},"value":{"kind":"Variable","name":{"kind":"Name","value":"offset"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"state"}}]}}]}}]} as unknown as DocumentNode<ContractStateQueryQuery, ContractStateQueryQueryVariables>;
export const ContractStateSubDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"subscription","name":{"kind":"Name","value":"CONTRACT_STATE_SUB"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"address"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"HexEncoded"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"offset"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"BlockOffset"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"contractActions"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"address"},"value":{"kind":"Variable","name":{"kind":"Name","value":"address"}}},{"kind":"Argument","name":{"kind":"Name","value":"offset"},"value":{"kind":"Variable","name":{"kind":"Name","value":"offset"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"state"}}]}}]}}]} as unknown as DocumentNode<ContractStateSubSubscription, ContractStateSubSubscriptionVariables>;
export const BothStateQueryDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"BOTH_STATE_QUERY"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"address"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"HexEncoded"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"offset"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"ContractActionOffset"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"contractAction"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"address"},"value":{"kind":"Variable","name":{"kind":"Name","value":"address"}}},{"kind":"Argument","name":{"kind":"Name","value":"offset"},"value":{"kind":"Variable","name":{"kind":"Name","value":"offset"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"state"}},{"kind":"Field","name":{"kind":"Name","value":"zswapState"}}]}}]}}]} as unknown as DocumentNode<BothStateQueryQuery, BothStateQueryQueryVariables>;
export const UnshieldedBalanceQueryDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"UNSHIELDED_BALANCE_QUERY"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"address"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"HexEncoded"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"contractAction"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"address"},"value":{"kind":"Variable","name":{"kind":"Name","value":"address"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ContractDeploy"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"unshieldedBalances"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ContractUpdate"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"unshieldedBalances"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ContractCall"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"deploy"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"unshieldedBalances"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<UnshieldedBalanceQueryQuery, UnshieldedBalanceQueryQueryVariables>;
export const QueryUnshieldedBalancesWithOffsetDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"QUERY_UNSHIELDED_BALANCES_WITH_OFFSET"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"address"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"HexEncoded"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"offset"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"ContractActionOffset"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"contractAction"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"address"},"value":{"kind":"Variable","name":{"kind":"Name","value":"address"}}},{"kind":"Argument","name":{"kind":"Name","value":"offset"},"value":{"kind":"Variable","name":{"kind":"Name","value":"offset"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ContractDeploy"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"unshieldedBalances"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ContractUpdate"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"unshieldedBalances"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ContractCall"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"deploy"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"unshieldedBalances"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<QueryUnshieldedBalancesWithOffsetQuery, QueryUnshieldedBalancesWithOffsetQueryVariables>;
export const UnshieldedBalanceSubDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"subscription","name":{"kind":"Name","value":"UNSHIELDED_BALANCE_SUB"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"address"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"HexEncoded"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"offset"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"BlockOffset"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"contractActions"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"address"},"value":{"kind":"Variable","name":{"kind":"Name","value":"address"}}},{"kind":"Argument","name":{"kind":"Name","value":"offset"},"value":{"kind":"Variable","name":{"kind":"Name","value":"offset"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ContractDeploy"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"unshieldedBalances"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ContractUpdate"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"unshieldedBalances"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ContractCall"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"deploy"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"unshieldedBalances"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"amount"}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<UnshieldedBalanceSubSubscription, UnshieldedBalanceSubSubscriptionVariables>;

================
File: packages/indexer-public-data-provider/src/indexer-public-data-provider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { ApolloClient, InMemoryCache } from '@apollo/client/core/core.cjs';
import type { ApolloQueryResult, FetchResult, NormalizedCacheObject } from '@apollo/client/core/index.js';
import { from,split } from '@apollo/client/link/core/core.cjs';
import { createHttpLink } from '@apollo/client/link/http/http.cjs';
import { RetryLink } from '@apollo/client/link/retry/retry.cjs';
import { GraphQLWsLink } from '@apollo/client/link/subscriptions/subscriptions.cjs';
import { getMainDefinition } from '@apollo/client/utilities/utilities.cjs';
import { ContractState } from '@midnight-ntwrk/compact-runtime';
import {
  type Binding,
  type ContractAddress,
  type IntentHash,
  type Proof,
  type RawTokenType,
  type SignatureEnabled,
  type TransactionId
} from '@midnight-ntwrk/ledger-v6';
import { Transaction as LedgerTransaction, ZswapChainState } from '@midnight-ntwrk/ledger-v6';
import type {
  BlockHashConfig,
  BlockHeightConfig,
  ContractStateObservableConfig,
  FinalizedTxData,
  PublicDataProvider,
  SegmentStatus,
  TxStatus,
  UnshieldedBalances,
  UnshieldedUtxo,
  UnshieldedUtxos} from '@midnight-ntwrk/midnight-js-types';
import {
  FailEntirely,
  FailFallible,
  InvalidProtocolSchemeError,
  SegmentFail,
  SegmentSuccess,
  SucceedEntirely} from '@midnight-ntwrk/midnight-js-types';
import { assertIsContractAddress } from '@midnight-ntwrk/midnight-js-utils';
import { Buffer } from 'buffer';
import fetch from 'cross-fetch';
import { createClient } from 'graphql-ws';
import * as ws from 'isomorphic-ws';
import * as Rx from 'rxjs';
import type * as Zen from 'zen-observable-ts';

import { IndexerFormattedError } from './errors';
import {
  type BlockOffset,
  type ContractActionOffset,
  type ContractBalance,
  type DeployContractStateTxQueryQuery,
  type DeployTxQueryQuery,
  type InputMaybe,
  type LatestContractTxBlockHeightQueryQuery,
  type RegularTransaction,
  type Segment,
  type TransactionResult
} from './gen/graphql';
import {
  BLOCK_QUERY,
  CONTRACT_AND_ZSWAP_STATE_QUERY,
  CONTRACT_STATE_QUERY,
  CONTRACT_STATE_SUB,
  DEPLOY_CONTRACT_STATE_TX_QUERY,
  DEPLOY_TX_QUERY,
  LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY,
  QUERY_UNSHIELDED_BALANCES_WITH_OFFSET,
  TX_ID_QUERY,
  TXS_FROM_BLOCK_SUB,
  UNSHIELDED_BALANCE_QUERY,
  UNSHIELDED_BALANCE_SUB
} from './query-definitions';

type IsEmptyObject<T> = keyof T extends never ? true : false;
type ExcludeEmptyAndNull<T> = T extends null ? never : IsEmptyObject<T> extends true ? never : T;

const isRegularTransaction = (
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  tx: any
): tx is RegularTransaction & { hash: string; identifiers: string[] } => {
  return 'identifiers' in tx && 'hash' in tx && Array.isArray(tx.identifiers);
};

const maybeThrowGraphQLErrors = <A, R extends FetchResult<A> | ApolloQueryResult<A>>(result: R): R => {
  if (result.errors && result.errors.length > 0) {
    throw new IndexerFormattedError(result.errors);
  }
  return result;
};

const maybeThrowApolloError = <A>(result: ApolloQueryResult<A>): ApolloQueryResult<A> => {
  if (result.error) {
    throw new Error(result.error.message);
  }
  return result;
};

const maybeThrowErrors = <A>(queryResult: ApolloQueryResult<A>): ApolloQueryResult<A> => {
  maybeThrowApolloError(queryResult);
  return maybeThrowGraphQLErrors(queryResult);
};

const toByteArray = (s: string): Buffer => Buffer.from(s, 'hex');

const deserializeContractState = (s: string): ContractState =>
  ContractState.deserialize(toByteArray(s));

const deserializeZswapState = (s: string): ZswapChainState =>
  ZswapChainState.deserialize(toByteArray(s));

const deserializeTransaction = (s: string): LedgerTransaction<SignatureEnabled, Proof, Binding> =>
  LedgerTransaction.deserialize('signature', 'proof', 'binding', toByteArray(s));

const zenToRx = <T>(zenObservable: Zen.Observable<T>): Rx.Observable<T> =>
  new Rx.Observable((subscriber) => zenObservable.subscribe(subscriber));

/**
 * The default time (in milliseconds) to wait between queries when polling.
 */
const DEFAULT_POLL_INTERVAL = 1000;

type Block = {
  hash: string;
  height: number;
  transactions: {
    hash: string;
    identifiers: readonly string[];
    contractActions: readonly { state: string; address: string }[];
  }[];
}

// Assumes that the block exists.
const blockOffsetToBlock$ = (apolloClient: ApolloClient<NormalizedCacheObject>) => (offset: InputMaybe<BlockOffset>) =>
  zenToRx(
    apolloClient
      .subscribe({
        query: TXS_FROM_BLOCK_SUB,
        variables: {
          offset
        },
        fetchPolicy: 'no-cache'
      })
      .map(maybeThrowGraphQLErrors)
      .map((fetchResult) => {
        const blocks = fetchResult.data!.blocks!;
        return {
          hash: blocks.hash,
          height: blocks.height,
          transactions: blocks.transactions
            .filter((tx): tx is RegularTransaction & { hash: string; contractActions: { state: string; address: string }[] } =>
              'identifiers' in tx
            )
            .map(tx => ({
              hash: tx.hash,
              identifiers: tx.identifiers,
              contractActions: tx.contractActions
            }))
        };
      })
  );

const transactionIdToTransaction$ =
  (apolloClient: ApolloClient<NormalizedCacheObject>) => (identifier: TransactionId) =>
    zenToRx(
      apolloClient
        .watchQuery({
          query: TX_ID_QUERY,
          variables: {
            offset: { identifier }
          },
          pollInterval: DEFAULT_POLL_INTERVAL,
          fetchPolicy: 'no-cache',
          initialFetchPolicy: 'no-cache',
          nextFetchPolicy: 'no-cache'
        })
        .map(maybeThrowErrors)
        .filter((maybeQueryResult) => maybeQueryResult.data.transactions.length !== 0)
        .map((maybeQueryResult) => ({
          height: maybeQueryResult.data.transactions[0]!.block.height
        }))
    ).pipe(
      Rx.concatMap(blockOffsetToBlock$(apolloClient)),
      Rx.concatMap(({ transactions }) => Rx.from(transactions))
    );

type Transaction = {
  hash: string;
  identifiers: readonly string[];
  contractActions: readonly { state: string; address: string }[];
}

const transactionToContractState$ =
  (transactionId: TransactionId) =>
  ({ identifiers, contractActions }: Transaction) =>
    Rx.zip(identifiers, contractActions).pipe(
      Rx.skipWhile((pair) => pair[0] !== transactionId),
      Rx.map((pair) => deserializeContractState(pair[1].state))
    );

const toTxStatus = (transactionResult: TransactionResult): TxStatus => {
  const result = transactionResult.status;
  const map = {
    'FAILURE': FailEntirely,
    'PARTIAL_SUCCESS': FailFallible,
    'SUCCESS': SucceedEntirely
  } as const
  if (result === 'FAILURE' || result === 'PARTIAL_SUCCESS' || result === 'SUCCESS') {
    return map[result];
  }
  throw new Error(`Unexpected 'status' value ${result}`);
};

const toSegmentStatus = (success: boolean): SegmentStatus =>
  success ? SegmentSuccess : SegmentFail;

const toSegmentStatusMap = (transactionResult: TransactionResult): Map<number, SegmentStatus> | undefined => {
  if (transactionResult.status !== 'PARTIAL_SUCCESS') {
    return undefined;
  }

  if (!transactionResult.segments) {
    return undefined;
  }

  return new Map(
    transactionResult.segments.map((segment: Segment) => [segment.id, toSegmentStatus(segment.success)])
  );
}

export type IndexerUtxo = {
  owner: string,
  intentHash: string,
  tokenType: string,
  value: string
};

const transformIndexerUtxoToUnshieldedUtxo = (indexerUtxo: IndexerUtxo): UnshieldedUtxo => ({
  owner: indexerUtxo.owner as ContractAddress,
  intentHash: indexerUtxo.intentHash as IntentHash,
  tokenType: indexerUtxo.tokenType as RawTokenType,
  value: BigInt(indexerUtxo.value)
});

export const toUnshieldedUtxos = (createdUtxo: readonly IndexerUtxo[], spentUtxo: readonly IndexerUtxo[]): UnshieldedUtxos => ({
  created: createdUtxo.map(transformIndexerUtxoToUnshieldedUtxo),
  spent: spentUtxo.map(transformIndexerUtxoToUnshieldedUtxo)
});

const transformContractBalanceToUnshieldedBalance = (contractBalance: ContractBalance): UnshieldedBalances[0] => ({
  balance: BigInt(contractBalance.amount),
  tokenType: contractBalance.tokenType as RawTokenType
});

export const toUnshieldedBalances = (contractBalances: readonly ContractBalance[]): UnshieldedBalances =>
  contractBalances.map(transformContractBalanceToUnshieldedBalance);

const blockToContractState$ = (contractAddress: ContractAddress) => (block: Block) =>
  Rx.from(block.transactions).pipe(
    Rx.concatMap(({ contractActions }) => Rx.from(contractActions)),
    Rx.filter((call) => call.address === contractAddress),
    Rx.map((call) => deserializeContractState(call.state))
  );

const contractAddressToLatestBlockOffset$ =
  (apolloClient: ApolloClient<NormalizedCacheObject>) => (contractAddress: ContractAddress) =>
    zenToRx(
      apolloClient
        .watchQuery({
          query: LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY,
          variables: {
            address: contractAddress
          },
          pollInterval: DEFAULT_POLL_INTERVAL,
          fetchPolicy: 'no-cache',
          initialFetchPolicy: 'no-cache',
          nextFetchPolicy: 'no-cache'
        })
        .map(maybeThrowErrors)
        .filter((maybeQueryResult) => maybeQueryResult.data.contractAction !== null)
        .map((queryResult) => {
          const contract = queryResult.data.contractAction as ExcludeEmptyAndNull<
            LatestContractTxBlockHeightQueryQuery['contractAction']
          >;
          return contract.transaction.block.height;
        })
    ).pipe(
      Rx.take(1),
      Rx.map((height) => ({ height }))
    );

// Assumes block already exists
const blockOffsetToContractState$ =
  (apolloClient: ApolloClient<NormalizedCacheObject>) =>
  (contractAddress: ContractAddress) =>
  (offset: InputMaybe<BlockOffset>) =>
    zenToRx(
      apolloClient
        .subscribe({
          query: CONTRACT_STATE_SUB,
          variables: {
            address: contractAddress,
            offset
          },
          fetchPolicy: 'no-cache'
        })
        .map(maybeThrowGraphQLErrors)
        .map((queryResult) => queryResult.data!.contractActions!.state)
        .map(deserializeContractState)
    );

const waitForContractToAppear =
  (apolloClient: ApolloClient<NormalizedCacheObject>) =>
  (contractAddress: ContractAddress) =>
  (offset: InputMaybe<ContractActionOffset>) =>
    zenToRx(
      apolloClient
        .watchQuery({
          query: CONTRACT_STATE_QUERY,
          variables: {
            address: contractAddress,
            offset
          },
          pollInterval: DEFAULT_POLL_INTERVAL,
          fetchPolicy: 'no-cache',
          initialFetchPolicy: 'no-cache',
          nextFetchPolicy: 'no-cache'
        })
        .map(maybeThrowErrors)
        .filter((maybeQueryResult) => maybeQueryResult.data.contractAction !== null)
        .map((queryResult) => queryResult.data.contractAction!.state)
    ).pipe(Rx.take(1));

const waitForBlockToAppear = (apolloClient: ApolloClient<NormalizedCacheObject>) => (offset: InputMaybe<BlockOffset>) =>
  zenToRx(
    apolloClient
      .watchQuery({
        query: BLOCK_QUERY,
        variables: {
          offset
        },
        pollInterval: DEFAULT_POLL_INTERVAL,
        fetchPolicy: 'no-cache',
        initialFetchPolicy: 'no-cache',
        nextFetchPolicy: 'no-cache'
      })
      .map(maybeThrowErrors)
      .filter((fetchResult) => fetchResult.data.block !== null)
  ).pipe(Rx.take(1));

const waitForUnshieldedBalancesToAppear =
  (apolloClient: ApolloClient<NormalizedCacheObject>) => (contractAddress: ContractAddress) =>
    zenToRx(
      apolloClient
        .watchQuery({
          query: UNSHIELDED_BALANCE_QUERY,
          variables: {
            address: contractAddress
          },
          pollInterval: DEFAULT_POLL_INTERVAL,
          fetchPolicy: 'no-cache',
          initialFetchPolicy: 'no-cache',
          nextFetchPolicy: 'no-cache'
        })
        .map(maybeThrowErrors)
        .filter((maybeQueryResult) => maybeQueryResult.data.contractAction !== null)
        .map((queryResult) => {
          const contractAction = queryResult.data.contractAction!;
          if ('unshieldedBalances' in contractAction) {
            return contractAction.unshieldedBalances;
          }
          if ('deploy' in contractAction) {
            return contractAction.deploy.unshieldedBalances;
          }
          return [];
        })
    ).pipe(Rx.take(1));

const blockOffsetToUnshieldedBalances$ =
  (apolloClient: ApolloClient<NormalizedCacheObject>) =>
  (contractAddress: ContractAddress) =>
  (offset: InputMaybe<BlockOffset>) =>
    zenToRx(
      apolloClient
        .subscribe({
          query: UNSHIELDED_BALANCE_SUB,
          variables: {
            address: contractAddress,
            offset
          },
          fetchPolicy: 'no-cache'
        })
        .map(maybeThrowGraphQLErrors)
        .map((queryResult) => {
          const contractAction = queryResult.data!.contractActions!;
          if ('unshieldedBalances' in contractAction) {
            return contractAction.unshieldedBalances;
          }
          if ('deploy' in contractAction) {
            return contractAction.deploy.unshieldedBalances;
          }
          return [];
        })
        .map(toUnshieldedBalances)
    );

const indexerPublicDataProviderInternal = (
  queryURL: string,
  subscriptionURL: string,
  webSocketImpl: typeof ws.WebSocket = ws.WebSocket
): PublicDataProvider => {
  const queryURLObj = new URL(queryURL);

  if (queryURLObj.protocol !== 'http:' && queryURLObj.protocol !== 'https:') {
    throw new InvalidProtocolSchemeError(queryURLObj.protocol, ['http:', 'https:']);
  }
  const subscriptionURLObj = new URL(subscriptionURL);

  if (subscriptionURLObj.protocol !== 'ws:' && subscriptionURLObj.protocol !== 'wss:') {
    throw new InvalidProtocolSchemeError(subscriptionURLObj.protocol, ['ws:', 'wss:']);
  }
  // Construct the Apollo client.
  const link = createHttpLink({ fetch, uri: queryURL });
  // Retry link with exponential backoff.
  const retryLink = new RetryLink({
    delay: {
      initial: 1000,
      max: 10000,
      jitter: true
    },
    attempts: {
      max: 5
    }
  });
  // Combine the retry link with the HTTP link to form the final link.
  const apolloLink = from([retryLink, link]);
  const apolloClient = new ApolloClient({
    link: split(
      ({ query }) => {
        const definition = getMainDefinition(query);
        return definition.kind === 'OperationDefinition' && definition.operation === 'subscription';
      },
      new GraphQLWsLink(createClient({ url: subscriptionURL, webSocketImpl })),
      apolloLink
    ),
    cache: new InMemoryCache()
  });
  return {
    async queryContractState(
      address: ContractAddress,
      config?: BlockHeightConfig | BlockHashConfig
    ): Promise<ContractState | null> {
      let offset: InputMaybe<ContractActionOffset>;
      if (config) {
        offset = {
          blockOffset: config.type === 'blockHeight' ? { height: config.blockHeight } : { hash: config.blockHash }
        };
      } else {
        offset = null;
      }
      const maybeContractState = await apolloClient
        .query({
          query: CONTRACT_STATE_QUERY,
          variables: {
            address,
            offset
          },
          fetchPolicy: 'no-cache'
        })
        .then(maybeThrowErrors)
        .then((queryResult) => queryResult.data?.contractAction?.state ?? null);
      return maybeContractState ? deserializeContractState(maybeContractState) : null;
    },
    async queryZSwapAndContractState(
      address: ContractAddress,
      config?: BlockHeightConfig | BlockHashConfig
    ): Promise<[ZswapChainState, ContractState] | null> {
      let offset;
      if (config) {
        offset = {
          blockOffset: config.type === 'blockHeight' ? { height: config.blockHeight } : { hash: config.blockHash }
        };
      } else {
        offset = null;
      }
      const maybeContractStates = await apolloClient
        .query({
          query: CONTRACT_AND_ZSWAP_STATE_QUERY,
          variables: {
            address,
            offset
          },
          fetchPolicy: 'no-cache'
        })
        .then(maybeThrowErrors)
        .then((queryResult) => queryResult.data.contractAction);
      return maybeContractStates
        ? [deserializeZswapState(maybeContractStates.zswapState), deserializeContractState(maybeContractStates.state)]
        : null;
    },
    async queryUnshieldedBalances(
      address: ContractAddress,
      config?: BlockHeightConfig | BlockHashConfig
    ): Promise<UnshieldedBalances | null> {
      let offset: InputMaybe<ContractActionOffset>;
      if (config) {
        offset = {
          blockOffset: config.type === 'blockHeight' ? { height: config.blockHeight } : { hash: config.blockHash }
        };
      } else {
        offset = null;
      }
      const maybeUnshieldedBalances = await apolloClient
        .query({
          query: QUERY_UNSHIELDED_BALANCES_WITH_OFFSET,
          variables: {
            address,
            offset
          },
          fetchPolicy: 'no-cache'
        })
        .then(maybeThrowErrors)
        .then((queryResult) => {
          const contractAction = queryResult.data.contractAction;
          if (!contractAction) {
            return null;
          }
          if ('unshieldedBalances' in contractAction) {
            return contractAction.unshieldedBalances;
          }
          if ('deploy' in contractAction) {
            return contractAction.deploy.unshieldedBalances;
          }
          return [];
        });
      return maybeUnshieldedBalances ? toUnshieldedBalances(maybeUnshieldedBalances) : null;
    },
    async queryDeployContractState(contractAddress: ContractAddress): Promise<ContractState | null> {
      return apolloClient
        .query({
          query: DEPLOY_CONTRACT_STATE_TX_QUERY,
          variables: {
            address: contractAddress
          },
          fetchPolicy: 'no-cache'
        })
        .then((queryResult) => {
          if (queryResult.data.contractAction) {
            const contract = queryResult.data.contractAction as ExcludeEmptyAndNull<
              DeployContractStateTxQueryQuery['contractAction']
            >;
            return 'deploy' in contract
              ? contract.deploy.transaction.contractActions.find(({ address }) => address === contractAddress)!.state
              : contract.state;
          }
          return null;
        })
        .then((maybeContractState) => (maybeContractState ? deserializeContractState(maybeContractState) : null));
    },
    async watchForContractState(contractAddress: ContractAddress): Promise<ContractState> {
      return Rx.firstValueFrom(
        waitForContractToAppear(apolloClient)(contractAddress)(null).pipe(Rx.map(deserializeContractState))
      );
    },
    async watchForUnshieldedBalances(contractAddress: ContractAddress): Promise<UnshieldedBalances> {
      return Rx.firstValueFrom(
        waitForUnshieldedBalancesToAppear(apolloClient)(contractAddress).pipe(Rx.map(toUnshieldedBalances))
      );
    },
    async watchForDeployTxData(contractAddress: ContractAddress): Promise<FinalizedTxData> {
      return Rx.firstValueFrom(
        zenToRx(
          apolloClient
            .watchQuery({
              query: DEPLOY_TX_QUERY,
              variables: {
                address: contractAddress
              },
              pollInterval: DEFAULT_POLL_INTERVAL,
              fetchPolicy: 'no-cache',
              initialFetchPolicy: 'no-cache',
              nextFetchPolicy: 'no-cache'
            })
            .filter((maybeQueryResult) => maybeQueryResult.data.contractAction !== null)
            .map(maybeThrowErrors)
            .map((queryResults) => {
              const contract = queryResults.data.contractAction as ExcludeEmptyAndNull<
                DeployTxQueryQuery['contractAction']
              >;

              return 'deploy' in contract ? contract.deploy.transaction : contract.transaction;
            })
            .filter(isRegularTransaction)
            .map(
              (transaction: RegularTransaction): FinalizedTxData => ({
                tx: deserializeTransaction(transaction.raw),
                status: toTxStatus(transaction.transactionResult),
                txId: transaction.identifiers[
                  transaction.contractActions.findIndex(({ address }) => address === contractAddress)
                ]!,
                identifiers: transaction.identifiers,
                txHash: transaction.hash,
                blockHeight: transaction.block.height,
                blockHash: transaction.block.hash,
                blockTimestamp: transaction.block.timestamp,
                blockAuthor: transaction.block.author,
                segmentStatusMap: toSegmentStatusMap(transaction.transactionResult),
                unshielded: toUnshieldedUtxos(transaction.unshieldedCreatedOutputs, transaction.unshieldedSpentOutputs),
                indexerId: transaction.id,
                protocolVersion: transaction.protocolVersion,
                fees: {
                  estimatedFees: transaction.fees.estimatedFees,
                  paidFees: transaction.fees.paidFees
                },
              })
            )
        )
      );
    },
    async watchForTxData(txId: TransactionId): Promise<FinalizedTxData> {
      return Rx.firstValueFrom(
        zenToRx(
          apolloClient
            .watchQuery({
              query: TX_ID_QUERY,
              variables: { offset: { identifier: txId } },
              pollInterval: DEFAULT_POLL_INTERVAL,
              fetchPolicy: 'no-cache',
              initialFetchPolicy: 'no-cache',
              nextFetchPolicy: 'no-cache'
            })
            .map(maybeThrowErrors)
            .filter((maybeQueryResult) => maybeQueryResult.data.transactions.length !== 0)
            .map((queryResult) => queryResult.data.transactions[0]!)
            .filter(isRegularTransaction)
            .map(
              (transaction: RegularTransaction): FinalizedTxData => ({
                tx: deserializeTransaction(transaction.raw),
                status: toTxStatus(transaction.transactionResult),
                txId,
                txHash: transaction.hash,
                identifiers: transaction.identifiers,
                blockHeight: transaction.block.height,
                blockHash: transaction.block.hash,
                segmentStatusMap: toSegmentStatusMap(transaction.transactionResult),
                unshielded: toUnshieldedUtxos(transaction.unshieldedCreatedOutputs, transaction.unshieldedSpentOutputs),
                blockTimestamp: transaction.block.timestamp,
                blockAuthor: transaction.block.author,
                indexerId: transaction.id,
                protocolVersion: transaction.protocolVersion,
                fees: {
                  paidFees: transaction.fees.paidFees,
                  estimatedFees: transaction.fees.estimatedFees
                }
              })
            )
        )
      );
    },
    contractStateObservable(
      contractAddress: ContractAddress,
      config: ContractStateObservableConfig = { type: 'latest' }
    ): Rx.Observable<ContractState> {
      if (config.type === 'txId') {
        const contractStates = transactionIdToTransaction$(apolloClient)(config.txId).pipe(
          Rx.filter(isRegularTransaction),
          Rx.concatMap(transactionToContractState$(config.txId))
        );
        return (config.inclusive ?? true) ? contractStates : contractStates.pipe(Rx.skip(1));
      }
      if (config.type === 'latest') {
        return contractAddressToLatestBlockOffset$(apolloClient)(contractAddress).pipe(
          Rx.concatMap(blockOffsetToBlock$(apolloClient)),
          Rx.concatMap(blockToContractState$(contractAddress))
        );
      }
      if (config.type === 'all') {
        return waitForContractToAppear(apolloClient)(contractAddress)(null).pipe(
          Rx.concatMap(() => blockOffsetToContractState$(apolloClient)(contractAddress)(null))
        );
      }
      const offset = config.type === 'blockHash' ? { hash: config.blockHash } : { height: config.blockHeight };
      const blocks = waitForBlockToAppear(apolloClient)(offset).pipe(
        Rx.filter(isRegularTransaction),
        Rx.concatMap(() => blockOffsetToBlock$(apolloClient)(offset))
      );
      const maybeShortenedBlocks =
        config.type === 'blockHeight' || config.type === 'blockHash'
          ? Rx.iif(() => config.inclusive ?? true, blocks, blocks.pipe(Rx.skip(1)))
          : blocks;
      return maybeShortenedBlocks.pipe(Rx.concatMap(blockToContractState$(contractAddress)));
    },
    unshieldedBalancesObservable(
      contractAddress: ContractAddress,
      config: ContractStateObservableConfig = { type: 'latest' }
    ): Rx.Observable<UnshieldedBalances> {
      if (config.type === 'txId') {
        throw new Error('txId configuration not supported for unshielded balances observable');
      }
      if (config.type === 'latest') {
        return contractAddressToLatestBlockOffset$(apolloClient)(contractAddress).pipe(
          Rx.concatMap(blockOffsetToUnshieldedBalances$(apolloClient)(contractAddress))
        );
      }
      if (config.type === 'all') {
        return waitForUnshieldedBalancesToAppear(apolloClient)(contractAddress).pipe(
          Rx.concatMap(() => blockOffsetToUnshieldedBalances$(apolloClient)(contractAddress)(null))
        );
      }
      const offset = config.type === 'blockHash' ? { hash: config.blockHash } : { height: config.blockHeight };
      const balances = waitForBlockToAppear(apolloClient)(offset).pipe(
        Rx.concatMap(() => blockOffsetToUnshieldedBalances$(apolloClient)(contractAddress)(offset))
      );
      return config.type === 'blockHeight' || config.type === 'blockHash'
        ? Rx.iif(() => config.inclusive ?? true, balances, balances.pipe(Rx.skip(1)))
        : balances;
    }
  };
};

/**
 * Constructs a {@link PublicDataProvider} based on an {@link ApolloClient}.
 *
 * @param queryURL The URL of a GraphQL server query endpoint.
 * @param subscriptionURL The URL of a GraphQL server subscription (websocket) endpoint.
 * @param webSocketImpl An optional websocket implementation for the Apollo client to use.
 *
 * TODO: Re-examine caching when 'ContractCall' and 'ContractDeploy' have transaction identifiers included.
 */
export const indexerPublicDataProvider = (
  queryURL: string,
  subscriptionURL: string,
  webSocketImpl: typeof ws.WebSocket = ws.WebSocket
): PublicDataProvider => {
  /**
   * This current object is a wrapper around the real implementation of the indexer client constructed
   * below. This wrapper just asserts that the input contract addresses are valid, and prepends the hex
   * representation of the network ID to all input contract addresses to work around a discrepancy
   * as of ledger 3.0.0 between the contract address representation on the indexer (with network ID)
   * and the address representation in the ledger WASM API (without network ID).
   */
  const publicDataProvider = indexerPublicDataProviderInternal(queryURL, subscriptionURL, webSocketImpl);
  return {
    contractStateObservable(
      contractAddress: ContractAddress,
      config: ContractStateObservableConfig
    ): Rx.Observable<ContractState> {
      assertIsContractAddress(contractAddress);
      return publicDataProvider.contractStateObservable(contractAddress, config);
    },
    queryContractState(
      contractAddress: ContractAddress,
      config?: BlockHeightConfig | BlockHashConfig
    ): Promise<ContractState | null> {
      assertIsContractAddress(contractAddress);
      return publicDataProvider.queryContractState(contractAddress, config);
    },
    queryDeployContractState(contractAddress: ContractAddress): Promise<ContractState | null> {
      assertIsContractAddress(contractAddress);
      return publicDataProvider.queryDeployContractState(contractAddress);
    },
    queryZSwapAndContractState(
      contractAddress: ContractAddress,
      config?: BlockHeightConfig | BlockHashConfig
    ): Promise<[ZswapChainState, ContractState] | null> {
      assertIsContractAddress(contractAddress);
      return publicDataProvider.queryZSwapAndContractState(contractAddress, config);
    },
    queryUnshieldedBalances(
      contractAddress: ContractAddress,
      config?: BlockHeightConfig | BlockHashConfig
    ): Promise<UnshieldedBalances | null> {
      assertIsContractAddress(contractAddress);
      return publicDataProvider.queryUnshieldedBalances(contractAddress, config);
    },
    watchForContractState(contractAddress: ContractAddress): Promise<ContractState> {
      assertIsContractAddress(contractAddress);
      return publicDataProvider.watchForContractState(contractAddress);
    },
    watchForUnshieldedBalances(contractAddress: ContractAddress): Promise<UnshieldedBalances> {
      assertIsContractAddress(contractAddress);
      return publicDataProvider.watchForUnshieldedBalances(contractAddress);
    },
    watchForDeployTxData(contractAddress: ContractAddress): Promise<FinalizedTxData> {
      assertIsContractAddress(contractAddress);
      return publicDataProvider.watchForDeployTxData(contractAddress);
    },
    watchForTxData(txId: TransactionId): Promise<FinalizedTxData> {
      return publicDataProvider.watchForTxData(txId);
    },
    unshieldedBalancesObservable(
      contractAddress: ContractAddress,
      config: ContractStateObservableConfig
    ): Rx.Observable<UnshieldedBalances> {
      assertIsContractAddress(contractAddress);
      return publicDataProvider.unshieldedBalancesObservable(contractAddress, config);
    }
  };
};

================
File: packages/level-private-state-provider/src/test/level-private-state-provider.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as fs from 'node:fs/promises';
import * as path from 'node:path';

import { type ContractAddress, sampleSigningKey } from '@midnight-ntwrk/compact-runtime';
import * as crypto from 'crypto';

import { levelPrivateStateProvider } from '../index';

describe('Level Private State Provider', (): void => {
  beforeAll(() => {
    process.env.MIDNIGHT_STORAGE_PASSWORD = 'test-storage-password-for-unit-tests-only';
  });

  afterAll(async () => {
    await fs.rm(path.join('.', 'midnight-level-db'), { recursive: true, force: true });
    delete process.env.MIDNIGHT_STORAGE_PASSWORD;
  });

  // tests adapted from https://github.com/solydhq/typed-local-store

  const uint8Array0 = new Uint8Array(crypto.randomBytes(32));
  const uint8Array1 = new Uint8Array(crypto.randomBytes(32));
  const buffer0 = Buffer.from(crypto.randomBytes(32));
  const buffer1 = Buffer.from(crypto.randomBytes(32));

  const objectValue = {
    stringValue: 'innerValue',
    numberValue: 2,
    booleanValue: false,
    stringArrayValue: ['D', 'E', 'F'],
    numberArrayValue: [3, 4, 5],
    booleanArrayValue: [false, true, false],
    uint8ArrayValue: uint8Array0,
    uint8ArrayArrayValue: [uint8Array0, uint8Array1],
    bufferValue: buffer0,
    bufferArrayValue: [buffer0, buffer1]
  };

  const testStates = {
    stringValue: 'value',
    numberValue: 1,
    booleanValue: true,
    objectValue,
    uint8ArrayValue: uint8Array0,
    bufferValue: buffer0,
    stringArrayValue: ['A', 'B', 'C'],
    numberArrayValue: [0, 1, 2],
    booleanArrayValue: [true, false, true],
    objectValues: [objectValue, objectValue, objectValue],
    uint8ArrayArrayValue: [uint8Array0, uint8Array1],
    bufferArrayValue: [buffer0, buffer1]
  };

  type PID = keyof typeof testStates;
  type PS = (typeof testStates)[PID];

  test("'get' returns null if key does not exist", async () => {
    const db = levelPrivateStateProvider<PID, PS>();
    const value = await db.get('stringValue');
    expect(value).toBeNull();
  });

  test("'getSigningKey' returns null if the signing key does not exist", async () => {
    const db = levelPrivateStateProvider<PID, PS>();
    const value = await db.getSigningKey('booleanValue');
    expect(value).toBeNull();
  });

  async function testSetGet<K extends PID>(key: K): Promise<void> {
    const stateRepo = levelPrivateStateProvider<PID, PS>();
    await stateRepo.set(key, testStates[key]);
    const value = await stateRepo.get(key);
    expect(value).toEqual(testStates[key]);
  }

  test("'get' functions do not interfere", async () => {
    await testSetGet('booleanArrayValue');
    const db = levelPrivateStateProvider<PID, PS>();
    const value = await db.getSigningKey('booleanArrayValue');
    expect(value).toBeNull();
  });

  async function testSetGetSigningKey<K extends PID>(key: K): Promise<void> {
    const stateRepo = levelPrivateStateProvider<PID, PS>();
    const signingKey = sampleSigningKey();
    await stateRepo.setSigningKey(key, signingKey);
    const value = await stateRepo.getSigningKey(key);
    expect(value).toEqual(signingKey);
  }

  describe("LevelDB PrivateStateProvider 'get' then 'set' returns original value", () => {
    test('for booleans', () => {
      return testSetGet('booleanValue');
    });
    test('for boolean arrays', () => {
      return testSetGet('booleanArrayValue');
    });
    test('for strings', () => {
      return testSetGet('stringValue');
    });
    test('for string arrays', () => {
      return testSetGet('stringArrayValue');
    });
    test('for numbers', () => {
      return testSetGet('numberValue');
    });
    test('for number arrays', () => {
      return testSetGet('numberArrayValue');
    });
    test('for objects', () => {
      return testSetGet('objectValue');
    });
    test('for object arrays', async () => {
      return testSetGet('objectValues');
    });
    test('for Uint8 arrays', async () => {
      return testSetGet('uint8ArrayValue');
    });
    test('for Uint8 array arrays', async () => {
      return testSetGet('uint8ArrayArrayValue');
    });
    test('for buffers', async () => {
      return testSetGet('bufferValue');
    });
    test('for buffer arrays', async () => {
      return testSetGet('bufferArrayValue');
    });
    test('for signing keys', async () => {
      return testSetGetSigningKey('bufferArrayValue');
    });
  });

  test("'set' functions do not interfere", async () => {
    await testSetGet('booleanArrayValue');
    const db = levelPrivateStateProvider<PID, PS>();
    await db.setSigningKey('booleanArrayValue', sampleSigningKey());
    const value = await db.get('booleanValue');
    expect(value).toEqual(testStates.booleanValue);
  });

  test("'remove' deletes private states", async () => {
    await testSetGet('stringValue');
    const db = levelPrivateStateProvider<PID, PS>();
    await db.remove('stringValue');
    const value = await db.get('stringValue');
    expect(value).toBeNull();
  });

  test("'removeSigningKey' deletes signing keys", async () => {
    await testSetGetSigningKey('stringValue');
    const db = levelPrivateStateProvider<PID, PS>();
    await db.removeSigningKey('stringValue');
    const value = await db.getSigningKey('stringValue');
    expect(value).toBeNull();
  });

  test("'remove' functions do not interfere", async () => {
    await testSetGet('stringValue');
    await testSetGetSigningKey('stringValue');
    const db = levelPrivateStateProvider<PID, PS>();
    await db.removeSigningKey('stringValue');
    const value = await db.get('stringValue');
    expect(value).toEqual(testStates.stringValue);
  });

  test("'clear' deletes private states", async () => {
    await testSetGet('stringValue');
    await testSetGet('objectValue');
    const db = levelPrivateStateProvider<PID, PS>();
    await db.clear();
    const value0 = await db.get('stringValue');
    expect(value0).toBeNull();
    const value2 = await db.get('objectValue');
    expect(value2).toBeNull();
  });

  test("'clearSigningKeys' deletes signing keys", async () => {
    await testSetGetSigningKey('stringValue');
    await testSetGetSigningKey('bufferArrayValue');
    const db = levelPrivateStateProvider<PID, PS>();
    await db.clearSigningKeys();
    const value0 = await db.getSigningKey('stringValue');
    expect(value0).toBeNull();
    const value2 = await db.getSigningKey('bufferArrayValue');
    expect(value2).toBeNull();
  });

  test("'clear' functions do not interfere", async () => {
    await testSetGet('stringValue');
    await testSetGet('objectValue');
    await testSetGetSigningKey('stringValue');
    await testSetGetSigningKey('objectValue');
    const db = levelPrivateStateProvider<PID, PS>();
    await db.clearSigningKeys();
    const value0 = await db.get('stringValue');
    expect(value0).toEqual(testStates.stringValue);
    const value2 = await db.get('objectValue');
    expect(value2).toEqual(testStates.objectValue);
  });

  test("'get' throws error on non-'LEVEL_NOT_FOUND_ERROR' codes", () => {
    expect.assertions(1);
    return levelPrivateStateProvider<PID, PS>()
      .get(null as unknown as PID)
      .catch((e) => expect(e.code).toMatch('LEVEL_INVALID_KEY'));
  });

  test("'getSigningKey' throws error on non-'LEVEL_NOT_FOUND_ERROR' codes", () => {
    expect.assertions(1);
    return levelPrivateStateProvider<PID, PS>()
      .getSigningKey(null as unknown as ContractAddress)
      .catch((e) => expect(e.code).toMatch('LEVEL_INVALID_KEY'));
  });
});

================
File: packages/level-private-state-provider/src/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export {
  DEFAULT_CONFIG,
  levelPrivateStateProvider,
  LevelPrivateStateProviderConfig} from './level-private-state-provider';
export {
  getStoragePassword,
  StorageEncryption
} from './storage-encryption';

================
File: packages/level-private-state-provider/src/level-private-state-provider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ContractAddress, SigningKey } from '@midnight-ntwrk/compact-runtime';
import type { PrivateStateId,PrivateStateProvider } from '@midnight-ntwrk/midnight-js-types';
import { type AbstractSublevel } from 'abstract-level';
import { Buffer } from 'buffer';
import { Level } from 'level';
import _ from 'lodash';
import * as superjson from 'superjson';

import { getStoragePassword, StorageEncryption } from './storage-encryption';

/**
 * The default name of the indexedDB database for Midnight.
 */
export const MN_LDB_DEFAULT_DB_NAME = 'midnight-level-db';

/**
 * The default name of the private state store.
 */
export const MN_LDB_DEFAULT_PRIS_STORE_NAME = 'private-states';

/**
 * The default name of the signing key store.
 */
export const MN_LDB_DEFAULT_KEY_STORE_NAME = 'signing-keys';

/**
 * Optional properties for the indexedDB based private state provider configuration.
 */
export interface LevelPrivateStateProviderConfig {
  /**
   * The name of the LevelDB database used to store all Midnight related data.
   */
  readonly midnightDbName: string;
  /**
   * The name of the object store containing private states.
   */
  readonly privateStateStoreName: string;
  /**
   * The name of the object store containing signing keys.
   */
  readonly signingKeyStoreName: string;
}

/**
 * The default configuration for the level database.
 */
export const DEFAULT_CONFIG = {
  /**
   * The name of the database.
   */
  midnightDbName: MN_LDB_DEFAULT_DB_NAME,
  /**
   * The name of the "level" on which to store private state.
   */
  privateStateStoreName: MN_LDB_DEFAULT_PRIS_STORE_NAME,
  /**
   * The name of the "level" on which to store signing keys.
   */
  signingKeyStoreName: MN_LDB_DEFAULT_KEY_STORE_NAME
};

superjson.registerCustom<Buffer, string>(
  {
    isApplicable: (v): v is Buffer => v instanceof Buffer,
    serialize: (v) => v.toString('hex'),
    deserialize: (v) => Buffer.from(v, 'hex')
  },
  'buffer'
);

const withSubLevel = async <K, V, A>(
  dbName: string,
  levelName: string,
  thunk: (subLevel: AbstractSublevel<Level, string | Uint8Array | Buffer, K, V>) => Promise<A>
): Promise<A> => {
  const level = new Level(dbName, {
    createIfMissing: true
  });
  const subLevel = level.sublevel<K, V>(levelName, {
    valueEncoding: 'utf-8'
  });
  try {
    await level.open();
    await subLevel.open();
    return await thunk(subLevel);
  } finally {
    await subLevel.close();
    await level.close();
  }
};

const METADATA_KEY = '__midnight_encryption_metadata__';

const getOrCreateEncryption = async (dbName: string, levelName: string): Promise<StorageEncryption> => {
  const password = getStoragePassword();

  return withSubLevel<string, string, StorageEncryption>(dbName, levelName, async (subLevel) => {
    try {
      const metadataJson = await subLevel.get(METADATA_KEY);
      if (!metadataJson) {
        throw new Error('Metadata not found');
      }
      const metadata = JSON.parse(metadataJson);
      const salt = Buffer.from(metadata.salt, 'hex');
      return new StorageEncryption(password, salt);
    } catch {
      const encryption = new StorageEncryption(password);
      const metadata = {
        salt: encryption.getSalt().toString('hex'),
        version: 1
      };
      await subLevel.put(METADATA_KEY, JSON.stringify(metadata));
      return encryption;
    }
  });
};

const subLevelMaybeGet = async <K, V>(dbName: string, levelName: string, key: K): Promise<V | null> => {
  const encryption = await getOrCreateEncryption(dbName, levelName);

  return withSubLevel<K, string, V | null>(dbName, levelName, async (subLevel) => {
    try {
      const encryptedValue = await subLevel.get(key);

      if (encryptedValue === undefined) {
        return null;
      }

      let decryptedValue: string;

      if (StorageEncryption.isEncrypted(encryptedValue)) {
        decryptedValue = encryption.decrypt(encryptedValue);
      } else {
        decryptedValue = encryptedValue;
        const reEncrypted = encryption.encrypt(encryptedValue);
        await subLevel.put(key, reEncrypted);
      }

      const value = superjson.parse<V>(decryptedValue);

      if (value === undefined) {
        return null;
      }

      return value;
    } catch (error: unknown) {
      if (error && typeof error === 'object' && 'code' in error && error.code === 'LEVEL_NOT_FOUND') {
        return null;
      }
      throw error;
    }
  });
};

/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * Constructs an instance of {@link PrivateStateProvider} based on {@link Level} database.
 *
 * @param partialConfig Database configuration options.
 */
export const levelPrivateStateProvider = <PSI extends PrivateStateId, PS = any>(
  partialConfig: Partial<LevelPrivateStateProviderConfig> = {}
): PrivateStateProvider<PSI, PS> => {
  const config = _.defaults(partialConfig, DEFAULT_CONFIG);
  return {
    get(privateStateId: PSI): Promise<PS | null> {
      return subLevelMaybeGet<PSI, PS>(config.midnightDbName, config.privateStateStoreName, privateStateId);
    },
    remove(privateStateId: PSI): Promise<void> {
      return withSubLevel<PSI, string, void>(config.midnightDbName, config.privateStateStoreName, (subLevel) =>
        subLevel.del(privateStateId)
      );
    },
    async set(privateStateId: PSI, state: PS): Promise<void> {
      const encryption = await getOrCreateEncryption(config.midnightDbName, config.privateStateStoreName);
      const serialized = superjson.stringify(state);
      const encrypted = encryption.encrypt(serialized);

      return withSubLevel<PSI, string, void>(config.midnightDbName, config.privateStateStoreName, (subLevel) =>
        subLevel.put(privateStateId, encrypted)
      );
    },
    clear(): Promise<void> {
      return withSubLevel(config.midnightDbName, config.privateStateStoreName, (subLevel) => subLevel.clear());
    },
    getSigningKey(address: ContractAddress): Promise<SigningKey | null> {
      return subLevelMaybeGet<ContractAddress, SigningKey>(config.midnightDbName, config.signingKeyStoreName, address);
    },
    removeSigningKey(address: ContractAddress): Promise<void> {
      return withSubLevel<ContractAddress, string, void>(
        config.midnightDbName,
        config.signingKeyStoreName,
        (subLevel) => subLevel.del(address)
      );
    },
    async setSigningKey(address: ContractAddress, signingKey: SigningKey): Promise<void> {
      const encryption = await getOrCreateEncryption(config.midnightDbName, config.signingKeyStoreName);
      const serialized = superjson.stringify(signingKey);
      const encrypted = encryption.encrypt(serialized);

      return withSubLevel<ContractAddress, string, void>(
        config.midnightDbName,
        config.signingKeyStoreName,
        (subLevel) => subLevel.put(address, encrypted)
      );
    },
    clearSigningKeys(): Promise<void> {
      return withSubLevel(config.midnightDbName, config.signingKeyStoreName, (subLevel) => subLevel.clear());
    }
  };
};

================
File: packages/level-private-state-provider/src/storage-encryption.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Buffer } from 'buffer';
import { createCipheriv, createDecipheriv, pbkdf2Sync, randomBytes } from 'crypto';

const ALGORITHM = 'aes-256-gcm';
const KEY_LENGTH = 32;
const IV_LENGTH = 12;
const AUTH_TAG_LENGTH = 16;
const SALT_LENGTH = 32;
const PBKDF2_ITERATIONS = 100000;
const ENCRYPTION_VERSION = 1;

const VERSION_PREFIX_LENGTH = 1;
const HEADER_LENGTH = VERSION_PREFIX_LENGTH + SALT_LENGTH + IV_LENGTH + AUTH_TAG_LENGTH;

export interface EncryptionMetadata {
  salt: Buffer;
  version: number;
}

export class StorageEncryption {
  private readonly encryptionKey: Buffer;
  private readonly salt: Buffer;

  constructor(password: string, existingSalt?: Buffer) {
    this.salt = existingSalt ?? randomBytes(SALT_LENGTH);
    this.encryptionKey = this.deriveKey(password, this.salt);
  }

  private deriveKey(password: string, salt: Buffer): Buffer {
    return pbkdf2Sync(password, salt, PBKDF2_ITERATIONS, KEY_LENGTH, 'sha256');
  }

  encrypt(data: string): string {
    const plaintext = Buffer.from(data, 'utf-8');
    const iv = randomBytes(IV_LENGTH);
    const cipher = createCipheriv(ALGORITHM, this.encryptionKey, iv);

    const encrypted = Buffer.concat([cipher.update(plaintext), cipher.final()]);
    const authTag = cipher.getAuthTag();

    const version = Buffer.from([ENCRYPTION_VERSION]);
    const result = Buffer.concat([version, this.salt, iv, authTag, encrypted]);

    return result.toString('base64');
  }

  decrypt(encryptedData: string): string {
    const data = Buffer.from(encryptedData, 'base64');

    if (data.length < HEADER_LENGTH) {
      throw new Error('Invalid encrypted data: too short');
    }

    const version = data[0];
    if (version !== ENCRYPTION_VERSION) {
      throw new Error(`Unsupported encryption version: ${version}`);
    }

    const salt = data.subarray(VERSION_PREFIX_LENGTH, VERSION_PREFIX_LENGTH + SALT_LENGTH);
    const iv = data.subarray(VERSION_PREFIX_LENGTH + SALT_LENGTH, VERSION_PREFIX_LENGTH + SALT_LENGTH + IV_LENGTH);
    const authTag = data.subarray(
      VERSION_PREFIX_LENGTH + SALT_LENGTH + IV_LENGTH,
      VERSION_PREFIX_LENGTH + SALT_LENGTH + IV_LENGTH + AUTH_TAG_LENGTH
    );
    const encrypted = data.subarray(HEADER_LENGTH);

    if (!this.salt.equals(salt)) {
      throw new Error('Salt mismatch: data was encrypted with a different password');
    }

    const decipher = createDecipheriv(ALGORITHM, this.encryptionKey, iv);
    decipher.setAuthTag(authTag);

    const decrypted = Buffer.concat([decipher.update(encrypted), decipher.final()]);
    return decrypted.toString('utf-8');
  }

  static isEncrypted(data: string): boolean {
    try {
      const buffer = Buffer.from(data, 'base64');
      return buffer.length >= HEADER_LENGTH && buffer[0] === ENCRYPTION_VERSION;
    } catch {
      return false;
    }
  }

  getSalt(): Buffer {
    return this.salt;
  }
}

export const getStoragePassword = (): string => {
  const password = process.env.MIDNIGHT_STORAGE_PASSWORD;

  if (!password) {
    throw new Error(
      'MIDNIGHT_STORAGE_PASSWORD environment variable is required.\n' +
      'Please set it to a strong, unique password:\n' +
      '  export MIDNIGHT_STORAGE_PASSWORD="your-secure-password-here"\n\n' +
      'For production environments, use a cryptographically secure password:\n' +
      '  export MIDNIGHT_STORAGE_PASSWORD="$(openssl rand -base64 32)"'
    );
  }

  if (password.length < 16) {
    throw new Error(
      'MIDNIGHT_STORAGE_PASSWORD must be at least 16 characters long.\n' +
      'Use a strong, randomly generated password for production.'
    );
  }

  return password;
};

================
File: packages/level-private-state-provider/README.md
================
# What is this?
An implementation of a private state provider that works with LevelDB compatible data stores.

This package provides **encrypted storage** for private states and signing keys using AES-256-GCM encryption.

This package was created for the [Midnight network](https://midnight.network).

Please visit the [Midnight Developer Hub](https://midnight.network/developer-hub) to learn more.

## Security

### Encryption at Rest

**All data is encrypted by default** using AES-256-GCM with PBKDF2 key derivation.

The encryption password **MUST** be configured via the `MIDNIGHT_STORAGE_PASSWORD` environment variable.

###  CRITICAL: Password is REQUIRED

**The `MIDNIGHT_STORAGE_PASSWORD` environment variable is mandatory.**

Without this environment variable set, the application **will not start**.

**Minimum Requirements:**
- Minimum 16 characters
- Use cryptographically secure random password
- Never commit passwords to version control
- Rotate passwords periodically

### Password Setup

**Development:**
```bash
# Generate a secure random password
export MIDNIGHT_STORAGE_PASSWORD="$(openssl rand -base64 24)"
```

**Production (Environment Variable):**
```bash
# Use a strong, unique password
export MIDNIGHT_STORAGE_PASSWORD="$(openssl rand -base64 32)"
```

**Production (Secrets Manager):**
Use AWS Secrets Manager, HashiCorp Vault, or similar systems:
```typescript
import { getSecret } from './your-secrets-manager';

process.env.MIDNIGHT_STORAGE_PASSWORD = await getSecret('midnight-storage-password');
```

**Docker/Kubernetes:**
```yaml
# docker-compose.yml
environment:
  - MIDNIGHT_STORAGE_PASSWORD=${MIDNIGHT_STORAGE_PASSWORD}

# kubernetes secret
apiVersion: v1
kind: Secret
metadata:
  name: midnight-storage
type: Opaque
data:
  password: <base64-encoded-password>
```

### Security Features

- **AES-256-GCM**: Industry-standard authenticated encryption
- **PBKDF2**: 100,000 iterations with random salt per database
- **Mandatory Password**: No default password, environment variable required
- **Password Validation**: Minimum 16 character length enforced
- **Automatic Migration**: Existing unencrypted data is automatically encrypted on first access
- **Authentication**: Built-in protection against tampering (GCM mode)

### Data Protection

This provider encrypts:
-  Private contract states
-  Signing keys
-  All sensitive user data

### Migration from Unencrypted Storage

If you have existing unencrypted data:
1. Set `MIDNIGHT_STORAGE_PASSWORD` environment variable
2. Start your application
3. Unencrypted data will be automatically encrypted on first read
4. All new writes are encrypted immediately

**No data loss occurs during migration.**

### Error Handling

If the environment variable is not set, you will see:
```
Error: MIDNIGHT_STORAGE_PASSWORD environment variable is required.
Please set it to a strong, unique password:
  export MIDNIGHT_STORAGE_PASSWORD="your-secure-password-here"

For production environments, use a cryptographically secure password:
  export MIDNIGHT_STORAGE_PASSWORD="$(openssl rand -base64 32)"
```

If the password is too short (< 16 characters):
```
Error: MIDNIGHT_STORAGE_PASSWORD must be at least 16 characters long.
Use a strong, randomly generated password for production.
```

# Use only in Midnight test environments
Image exclusively for Midnight test environments use.  

# Agree to Terms
By downloading and using this image, you agree to [Midnight's Terms and Conditions](https://midnight.network/static/terms.pdf), which includes the [Privacy Policy](https://midnight.network/static/privacy-policy.pdf).

# License
The software provided herein is licensed under the [Apache License V2.0](http://www.apache.org/licenses/LICENSE-2.0).

================
File: packages/utils/src/test/type-utils.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { randomBytes } from 'crypto';

import { toHex } from '../hex-utils';
import { assertIsContractAddress } from '../type-utils';

const createHexString = (byteLen: number): string => toHex(randomBytes(byteLen));

const EXPECTED_CONTRACT_ADDRESS_BYTE_LENGTH = 32;

describe('Type Utils', () => {
  describe('assertIsContractAddress', () => {
    it('throws with zero length contract address', () => {
      expect(() => assertIsContractAddress('')).toThrow();
      expect(() => assertIsContractAddress('0x')).toThrow();
    });

    it('throws with malformed contract address', () => {
      expect(() => assertIsContractAddress(`X${createHexString(EXPECTED_CONTRACT_ADDRESS_BYTE_LENGTH).substring(1)}`)).toThrow();
    });

    it('passes with valid contract address', () => {
      expect(() => assertIsContractAddress(createHexString(EXPECTED_CONTRACT_ADDRESS_BYTE_LENGTH))).not.toThrow();
    });

    it('throws with prefixed but valid contract address', () => {
      expect(() => assertIsContractAddress(`0x${createHexString(EXPECTED_CONTRACT_ADDRESS_BYTE_LENGTH)}`)).toThrow(
        /Unexpected '0x' prefix in contract address/
      );
    });
  });
});

================
File: packages/utils/src/hex-utils.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type NetworkId } from '@midnight-ntwrk/midnight-js-network-id';
import {
  MidnightBech32m,
  ShieldedCoinPublicKey,
  ShieldedEncryptionPublicKey
} from '@midnight-ntwrk/wallet-sdk-address-format';
import { Buffer } from 'buffer';

/**
 * The result of parsing a string as a hex-encoded string.
 */
export type ParsedHexString = {
  /** A flag indicating if the hex-string has a `'0x'` prefix. */
  readonly hasPrefix: boolean;
  /** The captured sequence of _whole_ bytes found in the source string. */
  readonly byteChars: string;
  /** The remaining characters of incomplete bytes and/or the non hexadecimal characters found
   * in the source string. */
  readonly incompleteChars: string;
}

/**
 * A regular expression that captures a hex-encoded string.
 *
 * @remarks
 * The regular expression captures characters from the source string sequentially, and will build a
 * `RegExpExecArray` object with captured groups described by {@link ParsedHexString}. These
 * groups capture the running sequence of _whole_ bytes (i.e., two valid hexadecimal characters),
 * and then any remaining sequence of characters that are not valid hexadecimal characters, or
 * incomplete bytes.
 *
 * @internal
 */
const HEX_STRING_REGEXP = /^(?<prefix>(0x)?)(?<byteChars>([0-9A-Fa-f]{2})*)(?<incompleteChars>.*)$/;

/**
 * Parses a string as a hex-encoded string.
 *
 * @param source The source string to parse.
 * @returns A {@link ParsedHexString} describing the parsed elements of `source`.
 *
 * @example
 * parseHex('Hello') =>
 *   {
 *     hasPrefix: false,
 *     incompleteChars: 'Hello'
 *   }
 *
 * @example
 * parseHex('ab12e') =>
 *   {
 *     hasPrefix: false,
 *     byteChars: 'ab12'
 *     incompleteChars: 'e'
 *   }
 *
 * @example
 * parseHex('0xab12') =>
 *   {
 *     hasPrefix: true,
 *     byteChars: 'ab12'
 *     incompleteChars: ''
 *   }
 */
export const parseHex = (source: string): ParsedHexString => {
  const groups = HEX_STRING_REGEXP.exec(source)?.groups as Record<string, string>;

  return {
    hasPrefix: groups.prefix === '0x',
    byteChars: groups.byteChars,
    incompleteChars: groups.incompleteChars
  } as ParsedHexString;
};

/**
 * Converts a byte string into a hex string.
 *
 * @param bytes The byte string to encode.
 */
export const toHex = (bytes: Uint8Array): string => Buffer.from(bytes).toString('hex');

/**
 * Converts a hex string into a byte string.
 *
 * @param str The hex string to decode.
 */
export const fromHex = (str: string): Buffer => Buffer.from(str, 'hex');

/**
 * Determines if a string represents a hex-encoded sequence of bytes.
 *
 * @param source The source string.
 * @param byteLen An optional number of bytes that `source` should represent. If not specified
 * then any number of bytes can be represented by `source`.
 * @returns `true` if the `source` string is parsable as a hex-string, of non-zero length, and
 * of the optional byte length of `byteLen`; otherwise `false`.
 */
export const isHex = (source: string, byteLen?: number): boolean => {
  if (!source || (byteLen !== undefined && byteLen <= 0)) {
    return false;
  }

  const parsedHex = parseHex(source);
  const validByteLen = byteLen
    ? parsedHex.byteChars.length / 2 === byteLen // `byteLen` number of bytes
    : parsedHex.byteChars.length > 0; // any number of bytes

  return validByteLen && !parsedHex.incompleteChars;
};

/**
 * Asserts that a string represents a hex-encoded sequence of bytes.
 *
 * @param source The source string.
 * @param byteLen An optional number of bytes that `source` should represent. If not specified
 * then any number of bytes can be represented by `source`.
 *
 * @throws `Error`
 * `byteLen` is \<= zero. Valid hex-strings will be required to have at least one byte.
 * @throws `TypeError`
 * `source` is not a hex-encoded string because it:
 * - is empty,
 * - contains invalid or incomplete characters, or
 * - does not represent `byteLen` bytes.
 */
export function assertIsHex(source: string, byteLen?: number): asserts source is NonNullable<string> {
  if (!source) {
    throw new TypeError('Input string must have non-zero length.');
  }
  if (byteLen !== undefined && byteLen <= 0) {
    throw new Error('Expected byte length must be greater than zero.');
  }

  const parsedHex = parseHex(source);

  if (parsedHex.incompleteChars) {
    if (parsedHex.incompleteChars.length % 2 > 0) {
      throw new TypeError(`The last byte of input string '${source}' is incomplete.`);
    }

    const invalidCharPos = parsedHex.byteChars.length + (parsedHex.hasPrefix ? 2 : 0);
    throw new TypeError(
      `Invalid hex-digit '${source[invalidCharPos]}' found in input string at index ${invalidCharPos}.`
    );
  }

  if (!parsedHex.byteChars) {
    throw new TypeError(`Input string '${source}' is not a valid hex-string.`);
  }

  if (byteLen) {
    const actualByteLen = parsedHex.byteChars.length / 2;

    if (byteLen !== actualByteLen) {
      throw new TypeError(`Expected an input string with byte length of ${byteLen}, got ${actualByteLen}.`);
    }
  }
}

/**
 * Parses a coin public key (in Bech32m format or hex) into a hex formatted string.
 *
 * @param possibleBech32 The input string, which can be a Bech32m-encoded coin public key or a hex string.
 * @param zswapNetworkId The network ID used for decoding the Bech32m formatted string.
 * @returns The hex string representation of the coin public key.
 *
 * @throws `Error`
 * If the input string is not a valid hex string or a valid Bech32m-encoded coin public key.
 */
export const parseCoinPublicKeyToHex = (possibleBech32: string, zswapNetworkId: NetworkId): string => {
  if (isHex(possibleBech32)) return possibleBech32;
  const parsedBech32 = MidnightBech32m.parse(possibleBech32); // Ensure compatibility
  const decoded = ShieldedCoinPublicKey.codec.decode(zswapNetworkId, parsedBech32);
  return Buffer.from(decoded.data).toString('hex');
};

/**
 * Parses an encryption public key (in Bech32m or hex format) into a hex formatted string.
 *
 * @param possibleBech32 The input string, which can be a Bech32m-encoded encryption public key or a hex string.
 * @param zswapNetworkId The network ID used for decoding the Bech32m formatted string.
 * @returns The hex string representation of the encryption public key.
 *
 * @throws `Error`
 * If the input string is not a valid hex string or a valid Bech32m-encoded encryption public key.
 */
export const parseEncPublicKeyToHex = (possibleBech32: string, zswapNetworkId: NetworkId): string => {
  if (isHex(possibleBech32)) return possibleBech32;
  const parsedBech32 = MidnightBech32m.parse(possibleBech32);
  const decoded = ShieldedEncryptionPublicKey.codec.decode(zswapNetworkId, parsedBech32);
  return Buffer.from(decoded.data).toString('hex');
};

================
File: platform-js/platform-js/src/effect/CoinPublicKey.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Buffer } from 'buffer';
import { Brand } from 'effect';
import * as Either from 'effect/Either';

import * as Hex_ from './Hex.js';

/**
 * A user public key capable of receiving Zswap coins.
 *
 * @remarks
 * `CoinPublicKey` is a 'branded' string type that represents a public key encoded either as a sequence of
 * hexadecimal characters, or as a string formatted according to the Bech32m encoding scheme.
 *
 * @see {@link CoinPublicKey.Hex}
 * @see {@link CoinPublicKey.Bech32m}
 * @category keys
 */
export type CoinPublicKey = CoinPublicKey.Bech32m | CoinPublicKey.Hex;

export declare namespace CoinPublicKey {
  /**
   * A user public key capable of receiving Zswap coins, formatted as a hex-encoded string.
   *
   * @category keys
   */
  export type Hex = Brand.Branded<string, 'CoinPublicKeyHex'>;

  /**
   * A user public key capable of receiving Zswap coins, formatted as a string according to the Bech32m encoding
   * scheme.
   *
   * @category keys
   */
  export type Bech32m = Brand.Branded<string, 'CoinPublicKeyBech32m'>;
}

/**
 * Creates a coin public key from a plain hex-encoded source string ({@link Hex_.PlainHex | PlainHex}).
 *
 * @category constructors
 */
export const Hex = Brand.all(
  Brand.nominal<CoinPublicKey.Hex>(),
  Hex_.PlainHex
);

/**
 * Create a coin public key from a source string formatted according to the Bech32m encoding scheme.
 *
 * @category constructors
 */
export const Bech32m = Brand.nominal<CoinPublicKey.Bech32m>();

/**
 * Creates a hex-encoded coin public key from a given source.
 *
 * @param self A source string that should become a {@link CoinPublicKey.Hex}, or a {@link CoinPublicKey} that
 * should become a {@link CoinPublicKey.Hex}.
 * @returns A {@link CoinPublicKey.Hex}.
 *
 * @category constructors
 */
export const asHex: (self: CoinPublicKey | string) => CoinPublicKey.Hex = (self) => {
  if (Hex.is(self)) return self;
  if (Bech32m.is(self)) {
    return /* TODO: convert */ Hex(self);
  }
  return Hex(self);
};

/**
 * Creates a Bech32m formatted coin public key from a given source.
 *
 * @param self A source string that should become a {@link CoinPublicKey.Bech32m}, or a {@link CoinPublicKey} that
 * should become a {@link CoinPublicKey.Bech32m}.
 * @returns A {@link CoinPublicKey.Bech32m}.
 *
 * @category constructors
 */
export const asBech32m: (self: CoinPublicKey | string) => CoinPublicKey.Bech32m = (self) => {
  if (Bech32m.is(self)) return self;
  if (Hex.is(self)) {
    return /* TODO: convert */ Bech32m(self);
  }
  return Bech32m(self);
};

/**
 * Creates a buffer representing the raw bytes of a coin public key.
 *
 * @param self The {@link CoinPublicKey} for which raw bytes are required.
 * @returns A `Uint8Array` representing the raw bytes of `self`.
 *
 * @category constructors
 */
export const asBytes: (self: CoinPublicKey) => Uint8Array = (self) => Buffer.from(asHex(self), 'hex');

/**
 * Create a coin public key from a source string.
 *
 * @param value The string value that is become a {@link CoinPublicKey}.
 * @returns A {@link CoinPublicKey} that is an instance of {@link CoinPublicKey.Hex} if `value` could be
 * parsed as a hex-encoded string; otherwise as an instance of {@link CoinPublicKey.Bech32m}.
 *
 * @category constructors
 */
export const make: (value: string) => CoinPublicKey = (value) => {
  return Either.match(Hex_.parseHex(value), {
    onRight: (_) => Hex(value),
    onLeft: (_) => Bech32m(value)
  });
};

================
File: platform-js/platform-js/src/effect/ContractAddress.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Buffer } from 'buffer';
import { Brand } from 'effect';

import * as Hex from './Hex.js';

/**
 * A plain hex-encoded contract address, 32 bytes in length.
 *
 * @category models
 */
export type ContractAddress = Brand.Branded<string, 'ContractAddress'>;
export const ContractAddress = Brand.all(
  Brand.nominal<ContractAddress>(),
  Hex.ConstrainedPlainHex({ byteLength: '32..=32' })
);

/**
 * Creates a buffer representing the raw bytes of a contract address.
 *
 * @param self The {@link ContractAddress} for which raw bytes are required.
 * @returns A `Uint8Array` representing the raw bytes of `self`.
 *
 * @category constructors
 */
export const asBytes: (self: ContractAddress) => Uint8Array = (self) => Buffer.from(self, 'hex');

================
File: platform-js/platform-js/src/effect/DomainSeparator.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Buffer } from 'buffer';
import { Brand } from 'effect';

import * as Hex from './Hex.js';

/**
 * A plain hex-encoded token domain separator, 32 bytes in length.
 *
 * @category models
 */
export type DomainSeparator = Brand.Branded<string, 'DomainSeparator'>;
export const DomainSeparator = Brand.all(
  Brand.nominal<DomainSeparator>(),
  Hex.ConstrainedPlainHex({ byteLength: '32..=32' })
);

/**
 * Creates a buffer representing the raw bytes of a token domain separator.
 *
 * @param self The {@link DomainSeparator} for which raw bytes are required.
 * @returns A `Uint8Array` representing the raw bytes of `self`.
 *
 * @category constructors
 */
export const asBytes: (self: DomainSeparator) => Uint8Array = (self) => Buffer.from(self, 'hex');

================
File: testkit-js/testkit-js/src/wallet/wallet-builder.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { DustSecretKey, LedgerParameters, ZswapSecretKeys } from '@midnight-ntwrk/ledger-v6';
import { type NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { DustWallet } from '@midnight-ntwrk/wallet-sdk-dust-wallet';
import { WalletFacade } from '@midnight-ntwrk/wallet-sdk-facade';
import { generateRandomSeed } from '@midnight-ntwrk/wallet-sdk-hd';
import { ShieldedWallet } from '@midnight-ntwrk/wallet-sdk-shielded';
import { type DefaultV1Configuration } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import {
  createKeystore,
  PublicKey,
  type UnshieldedWallet,
  WalletBuilder as UnshieldedWalletBuilder
} from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';

import { logger } from '@/logger';
import { type EnvironmentConfiguration } from '@/test-environment/environment-configuration';
import { mapEnvironmentToConfiguration } from '@/wallet/wallet-configuration-mapper';
import { getDustSeed, getShieldedSeed, getUnshieldedSeed } from '@/wallet/wallet-seed-utils';

declare global {
  interface BigInt {
    toJSON(): number;
  }
}

BigInt.prototype.toJSON = function () { return Number(this) }

export const DustOptions = {
  ledgerParams: LedgerParameters.initialParameters(),
  additionalFeeOverhead: 500_000_000_000_000_000_000n,
  feeBlocksMargin: 5
};

export class WalletBuilder {
  static buildShieldedWallet(config: DefaultV1Configuration, seed: Uint8Array): ShieldedWallet {
    const Shielded = ShieldedWallet(config);
    return Shielded.startWithShieldedSeed(seed);
  }

  static async buildUnshieldedWallet(
    config: DefaultV1Configuration,
    seed: Uint8Array,
    networkId: NetworkId.NetworkId
  ): Promise<UnshieldedWallet> {
    const keystore = createKeystore(seed, networkId);
    return await UnshieldedWalletBuilder.build({
      publicKey: PublicKey.fromKeyStore(keystore),
      networkId,
      indexerUrl: config.indexerClientConnection.indexerWsUrl!,
    });
  }

  static buildDustWallet(
    config: DefaultV1Configuration,
    seed: Uint8Array,
    networkId: NetworkId.NetworkId,
    dustOptions = DustOptions
  ): DustWallet {
    const dustConfig = {
      ...config,
      costParameters: {
        ledgerParams: dustOptions.ledgerParams,
        additionalFeeOverhead: dustOptions.additionalFeeOverhead,
        feeBlocksMargin: dustOptions.feeBlocksMargin,
      },
    };
    logger.info(`Building dust wallet with params: ${JSON.stringify(dustConfig)}`);
    const Dust = DustWallet(dustConfig);
    const dustParameters = LedgerParameters.initialParameters().dust;
    return Dust.startWithSeed(seed, dustParameters);
  }

  static async restoreShieldedWallet(
    config: DefaultV1Configuration,
    serializedState: string
  ): Promise<ShieldedWallet> {
    return ShieldedWallet(config).restore(serializedState);
  }

  static async buildWallet(
    envConfig: EnvironmentConfiguration,
    shieldedSeed: Uint8Array,
    unshieldedSeed: Uint8Array,
    dustSeed: Uint8Array
  ): Promise<WalletFacade> {
    logger.info(`Starting wallet for ${envConfig.walletNetworkId}`);
    const config = mapEnvironmentToConfiguration(envConfig);
    logger.info(`Starting wallet for ${JSON.stringify(config)}`);
    return new WalletFacade(
      this.buildShieldedWallet(config, shieldedSeed),
      await this.buildUnshieldedWallet(config, unshieldedSeed, envConfig.walletNetworkId),
      this.buildDustWallet(config, dustSeed, envConfig.walletNetworkId, DustOptions)
    );
  }

  static async startWallet(wallet: WalletFacade, shieldedSeed: Uint8Array, dustSeed: Uint8Array): Promise<WalletFacade> {
    logger.info(`Starting wallet...`);
    await wallet.start(ZswapSecretKeys.fromSeed(shieldedSeed), DustSecretKey.fromSeed(dustSeed));
    return wallet;
  }

  static async buildAndStartWallet(
    envConfig: EnvironmentConfiguration,
    seed?: string
  ): Promise<WalletFacade> {
    const walletSeed = seed ?? generateRandomSeed().toString();
    const shieldedSeed = getShieldedSeed(walletSeed);
    const unshieldedSeed = getUnshieldedSeed(walletSeed);
    const dustSeed = getDustSeed(walletSeed);

    const wallet = await this.buildWallet(envConfig, shieldedSeed, unshieldedSeed, dustSeed);
    return this.startWallet(wallet, shieldedSeed, dustSeed);
  }
}

================
File: testkit-js/testkit-js/src/env-vars.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

if (!process.env.MIDNIGHT_STORAGE_PASSWORD) {
  process.env.MIDNIGHT_STORAGE_PASSWORD = 'testkit-default-storage-password-for-testing-only';
}

export const getEnvVarEnvironment = () => {
  if (process.env.MN_TEST_ENVIRONMENT === undefined || process.env.MN_TEST_ENVIRONMENT === 'undefined') {
    return 'undeployed';
  }
  return process.env.MN_TEST_ENVIRONMENT;
};
export const getEnvVarWalletSeeds = () => {
  const envSeeds = process.env.MN_TEST_WALLET_SEED || process.env.TEST_WALLET_SEED;
  return envSeeds ? envSeeds.split(',') : undefined;
};
export const MN_TEST_INDEXER = process.env.MN_TEST_INDEXER;
export const MN_TEST_INDEXER_WS = process.env.MN_TEST_INDEXER_WS;
export const MN_TEST_NODE = process.env.MN_TEST_NODE;
export const MN_TEST_NODE_WS = process.env.MN_TEST_NODE_WS;
export const MN_TEST_FAUCET = process.env.MN_TEST_FAUCET;
export const MN_TEST_NETWORK_ID = process.env.MN_TEST_NETWORK_ID;
export const MN_TEST_WALLET_NETWORK_ID = process.env.MN_TEST_WALLET_NETWORK_ID;

================
File: testkit-js/testkit-js/README.md
================
# What is this?
A comprehensive testing solution for your Midnight.JS applications, providing seamless integration with various test environments.

This package was created for the [Midnight network](https://midnight.network). 

Please visit the [Midnight Developer Hub](https://midnight.network/developer-hub) to learn more.

# Use only in Midnight test environments
Image exclusively for Midnight test environments use.  

# Agree to Terms
By downloading and using this image, you agree to [Midnights Terms and Conditions](https://midnight.network/static/terms.pdf), which includes the [Privacy Policy](https://midnight.network/static/privacy-policy.pdf).

# License
The software provided herein is licensed under the [Apache License V2.0](http://www.apache.org/licenses/LICENSE-2.0).

## Table of Contents
1. [Installation](#installation)
2. [Getting Started](#getting-started)
3. [Features](#Features)
4. [Limitations](#Limitations)
5. [Examples of Usage](#Examples-of-Usage)

---

## Installation
Before using the testing library, ensure you have the following prerequisites:
1. Node.js and yarn installed
2. Docker Desktop (optional for local dockerized tests)
3. Midnight.JS project set up

Install the testing library by running the following command in your terminal:
```
yarn add -D @midnight-ntwrk/testkit-js
```

## Getting Started
To use the testing library, create a new file called `midnight.test.js` in the `__tests__` directory of your project. In this file, import the necessary dependencies:
```typescript
import { getTestEnvironment } from '@midnight-ntwrk/testkit-js';

beforeAll(async () => {
  testEnvironment = getTestEnvironment(logger);
  environmentConfiguration = await testEnvironment.start();
  walletProvider = await testEnvironment.getMidnightWalletProvider();
});

afterAll(async () => {
  await testEnvironment.shutdown();
});
```

---

## Features

Set of functions that simplify testing of DApps in Midnight

- [x] Standard Dockerized environment setup - both live and local
- [x] Predefined Midnight environments configuration 
- [x] Proof server control
- [x] Wallets management
- [x] Fund wallets
- [x] Check system health

---

## Environment variables

### Storage Password (Automatic Setup):
- **MIDNIGHT_STORAGE_PASSWORD** is automatically set by testkit-js if not already defined
- Default test value: `testkit-default-storage-password-for-testing-only`
- This ensures encrypted storage works in test environments without manual configuration
- For production or custom testing, set your own password before importing testkit-js

### Environment selection:
- MN_TEST_ENVIRONMENT controls the environment to be used for testing. It can take one of these values:
   - undeployed
   - devnet
   - testnet
   - env-var-remote

If **MN_TEST_ENVIRONMENT** is not set, the default value will be `undeployed`.
If **MN_TEST_ENVIRONMENT** is set to `undeployed`, the testing environment will be deployed locally using Docker.
If **MN_TEST_ENVIRONMENT** is set to `devnet`,`testnet, env-var-remote` the testing environment will the corresponding live network, with proof server setup using predefined NETWORK_ID.
If **MN_TEST_ENVIRONMENT** is set to `env-var-remote`, below environment variables must be set:
  - *MN_TEST_NETWORK_ID* - Proof server NETWORK_ID
  - *MN_TEST_INDEXER* - Indexer URL
  - *MN_TEST_INDEXER_WS* - Indexer WebSocket URL
  - *MN_TEST_NODE* - Node URL
  - *MN_TEST_FAUCET* - Faucet URL

### Wallet setup:
- MN_TEST_WALLET_SEED can be used to set a specific seed phrase for the wallet. If not set, a random seed phrase will be used.

---

## Limitations

- Localnet wallets limit count is 4

---

## Examples of Usage

### 1. Selecting Different Environments

You can control the test environment using the `MN_TEST_ENVIRONMENT` environment variable. Here's how you can set it:

```typescript
const testEnvironment = getTestEnvironment(logger);
environmentConfiguration = await testEnvironment.start();
```

```shell
# Example: Set the environment variable before initializing the test environment
MN_TEST_ENVIRONMENT='devnet'; yarn test
```

This allows you to easily switch between predefined environments like `devnet`, `testnet`, and others.
Default (undefined) value is `undeployed` which will deploy the testing environment locally using Docker.

---

### 2. Creating and Managing Wallets

Here's an example of creating wallets in your test environment:

```typescript
// Example: Create multiple wallets in a test environment
const testEnvironment = getTestEnvironment(logger);
await testEnvironment.start();

// Create 2 wallets
const wallets = await testEnvironment.startMidnightWalletProviders(2);

// Verify wallet properties
expect(wallets).toHaveLength(2);
wallets.forEach(async (wallet) => {
  expect(wallet.coinPublicKey).not.toBeUndefined();
});

// Shutdown the environment after testing
await testEnvironment.shutdown();
```

This demonstrates how to create wallets and verify their properties, such as the `coinPublicKey`.

---

### 3. Setting Wallet Seeds

If you need to use specific wallet seeds for testing, you can do the following:

```typescript
// Example: Create a wallet with a predefined seed phrase
const wallet = await testEnvironment.getMidnightWalletProvider();

expect(wallet.coinPublicKey).not.toBeUndefined();
```

```shell
# Example: Set the environment variable before initializing the test environment
MN_TEST_WALLET_SEED='00000000000000000000000000000042'; yarn test
```

This allows you to test specific scenarios using known wallet seeds.

---

### 4. Handling Environment Configuration

You can also customize the test environment configuration by modifying the `defaultContainersConfiguration` object:

```typescript
import {
  defaultContainersConfiguration,
  getContainersConfiguration,
  setContainersConfiguration
} from '../configuration';

// Example: Modify default environment configuration before starting
const config: ContainersConfiguration = {
  ...defaultContainersConfiguration,
  proofServer: {
    ...defaultContainersConfiguration.proofServer,
    fileName: 'proof-server.yml'
  }
};
setContainersConfiguration(config);
```

This gives developers flexibility in configuring the test environment according to their needs.

---

### 5. Error Handling

Here's an example of handling errors when setting up wallets:

```typescript
// Example: Test for maximum wallet limit exceeded
process.env.MN_TEST_ENVIRONMENT = undefined; // Use local environment
const testEnvironment = getTestEnvironment(logger);
await testEnvironment.start();

try {
  await testEnvironment.startMidnightWalletProviders(5); // Assuming max is 4
} catch (error) {
  expect(error.message).toContain('Maximum supported number of wallets for this environment reached');
}

await testEnvironment.shutdown();
```

This demonstrates how to handle cases where the wallet limit is exceeded.

---

### 6. Advanced Usage with Proof Server

Here's an example of integrating with the proof server:

```typescript
// Example: Start a proof server with networkd ID = testnet and ID = 123
const proofServer = await DynamicProofServerContainer.start(logger, '123', 'testnet');

//stop the proof server
await proofServer.stop();
```

This shows how to integrate with and customize the proof server for testing.

---

### 7. Customized test environments

Library is provided with set of predefined environment configurations i.e.:

- LocalTestEnvironment 
- Testnet2TestEnvironment

By using `getTestEnvironment(logger);` based on environment variable MN_TEST_ENVIRONMENT test environment configuration is provided.
However, you can either create your own class defining the environment endpoints or use below enviroment variables.

Here's an example of fully customized endpoints of the test environment, that you can provide using environment variables:

```shell
MN_TEST_ENVIRONMENT="env-var-remote" \
MN_TEST_NETWORK_ID="undeployed" \
MN_TEST_INDEXER="http://localhost:3085/api/" \
MN_TEST_INDEXER_WS="ws://localhost:3085/ws/" \
MN_TEST_NODE="http://localhost:3086" \
yarn test

```

---

### 8. System health check before tests

For the remote test environemnts (testnet-02, ...) simple health check is performed for each of the components to check their state before test.

================
File: testkit-js/testkit-js-e2e/src/contract/unshielded.compact
================
import CompactStandardLibrary;

export circuit mintUnshieldedToSelfTest(domainSep: Bytes<32>, amount: Uint<64>): Bytes<32> {
  return mintUnshieldedToken(disclose(domainSep), disclose(amount), left<ContractAddress, UserAddress>(kernel.self()));
}

export circuit mintUnshieldedToContractTest(domainSep: Bytes<32>, address: ContractAddress, amount: Uint<64>): Bytes<32> {
  return mintUnshieldedToken(disclose(domainSep), disclose(amount), left<ContractAddress, UserAddress>(disclose(address)));
}

export circuit mintUnshieldedToUserTest(domainSep: Bytes<32>, address: UserAddress, amount: Uint<64>): Bytes<32> {
  return mintUnshieldedToken(disclose(domainSep), disclose(amount), right<ContractAddress, UserAddress>(disclose(address)));
}

export circuit sendUnshieldedToSelfTest(color: Bytes<32>, amount: Uint<128>): [] {
  sendUnshielded(disclose(color), disclose(amount), left<ContractAddress, UserAddress>(kernel.self()));
}

export circuit sendUnshieldedToContractTest(color: Bytes<32>, amount: Uint<128>, address: ContractAddress): [] {
  sendUnshielded(disclose(color), disclose(amount), left<ContractAddress, UserAddress>(disclose(address)));
}

export circuit sendUnshieldedToUserTest(color: Bytes<32>, amount: Uint<128>, address: UserAddress): [] {
  sendUnshielded(disclose(color), disclose(amount), right<ContractAddress, UserAddress>(disclose(address)));
}

export circuit receiveUnshieldedTest(color: Bytes<32>, amount: Uint<128>): [] {
  receiveUnshielded(disclose(color), disclose(amount));
}

export circuit getUnshieldedBalanceTest(color: Bytes<32>): Uint<128> {
  return unshieldedBalance(disclose(color));
}

export circuit getUnshieldedBalanceGtTest(color: Bytes<32>, amount: Uint<128>): Boolean {
  return unshieldedBalanceGt(disclose(color), disclose(amount));
}

export circuit getUnshieldedBalanceLtTest(color: Bytes<32>, amount: Uint<128>): Boolean {
  return unshieldedBalanceLt(disclose(color), disclose(amount));
}

export circuit mintToSelfReceive(domainSep: Bytes<32>, amount: Uint<64>): Bytes<32> {
  const color = mintUnshieldedToken(disclose(domainSep), disclose(amount), left<ContractAddress, UserAddress>(kernel.self()));
  receiveUnshielded(color, disclose(amount) as Uint<128>);
  return color;
}

export circuit mintNativeTokens(amount: Uint<64>): Uint<128> {
    const domain = pad(32, "simple:shielded:native");
    kernel.mintShielded(disclose(domain), disclose(amount));
    return disclose(amount);
}

================
File: testkit-js/testkit-js-e2e/test/contracts.it.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  ContractState,
  decodeZswapLocalState,
  emptyZswapLocalState,
  sampleContractAddress,
  sampleSigningKey
} from '@midnight-ntwrk/compact-runtime';
import { type ContractAddress, sampleCoinPublicKey, ZswapChainState } from '@midnight-ntwrk/ledger-v6';
import {
  call,
  callContractConstructor,
  ContractTypeError,
  createCircuitCallTxInterface,
  createUnprovenCallTxFromInitialStates,
  createUnprovenDeployTx,
  deployContract,
  type FinalizedDeployTxData,
  findDeployedContract,
  submitCallTx,
  submitDeployTx} from '@midnight-ntwrk/midnight-js-contracts';
import { getNetworkId } from '@midnight-ntwrk/midnight-js-network-id';
import { SucceedEntirely } from '@midnight-ntwrk/midnight-js-types';
import { parseCoinPublicKeyToHex } from '@midnight-ntwrk/midnight-js-utils';
import type {
  EnvironmentConfiguration,
  MidnightWalletProvider,
  TestEnvironment} from '@midnight-ntwrk/testkit-js';
import {
  createLogger,
  expectFoundAndDeployedStatesEqual,
  expectFoundAndDeployedTxDataEqual,
  expectFoundAndDeployedTxPublicDataEqual,
  expectSuccessfulCallTx,
  expectSuccessfulDeployTx,
  getTestEnvironment,
  initializeMidnightProviders} from '@midnight-ntwrk/testkit-js';
import path from 'path';

import {
  INVALID_CONTRACT_ADDRESS_HEX_FORMAT,
  INVALID_CONTRACT_ADDRESS_TOO_LONG,
  SLOW_TEST_TIMEOUT,
  UNDEPLOYED_CONTRACT_ADDRESS
} from '@/constants';
import {
  CompiledCounter,
  type CounterPrivateState,
  createInitialPrivateState,
  createPrivateState,
} from '@/contract';
import * as api from '@/counter-api';
import {
  CIRCUIT_ID_INCREMENT,
  cloneContractInstance,
  CounterCloneConfiguration,
  CounterConfiguration,
  counterContractInstance,
  SimpleConfiguration,
  simpleContractInstance
} from '@/counter-api';
import { type CounterCloneCircuits,CounterClonePrivateStateId } from '@/counter-clone-types';
import {
  type CounterCircuits,
  type CounterContract,
  CounterPrivateStateId,
  type CounterProviders,
  type DeployedCounterContract,
  privateStateZero
} from '@/counter-types';
import { type SimpleCircuits } from '@/simple-types';

const logger = createLogger(
  path.resolve(`${process.cwd()}`, 'logs', 'tests', `contracts_${new Date().toISOString()}.log`)
);

const { ledger } = CompiledCounter;

describe('Contracts API', () => {
  const WAITING_PROMISE_TIMEOUT = 20_000;
  let providers: CounterProviders;
  let finalizedDeployTxData: FinalizedDeployTxData<CounterContract>;
  let deployedContract: DeployedCounterContract;
  let contractAddress: ContractAddress;
  let testEnvironment: TestEnvironment;
  let wallet: MidnightWalletProvider;
  let environmentConfiguration: EnvironmentConfiguration;
  let contractConfiguration: CounterConfiguration;

  const getConfigurationWithEmptyPrivateStore = () => {
    return new CounterConfiguration(`counter-private-store-${Date.now()}`);
  };

  beforeEach(() => {
    logger.info(`Running test=${expect.getState().currentTestName}`);
  });

  beforeAll(async () => {
    testEnvironment = getTestEnvironment(logger);
    environmentConfiguration = await testEnvironment.start();
    contractConfiguration = new CounterConfiguration();
    api.setLogger(logger);
    logger.info(`Private state: ${JSON.stringify(privateStateZero)}`);
    wallet = await testEnvironment.getMidnightWalletProvider();

    providers = initializeMidnightProviders(wallet, environmentConfiguration, contractConfiguration);
    deployedContract = await api.deploy(providers, privateStateZero);
    finalizedDeployTxData = deployedContract.deployTxData;
    contractAddress = finalizedDeployTxData.public.contractAddress;
  });

  afterAll(async () => {
    await testEnvironment.shutdown();
  });

  /**
   * Test constructor and circuit execution for contracts with private state.
   *
   * @given A contract with private state and initial configuration
   * @and A coin public key and constructor result
   * @when Executing constructor and increment circuit
   * @then Should correctly update contract state, private state, and local state
   * @and Should maintain proper state consistency across operations
   */
  it('should execute constructor and circuits of contracts with private state', () => {
    const coinPublicKey = sampleCoinPublicKey();
    const constructorResult = callContractConstructor({
      contract: api.counterContractInstance,
      coinPublicKey,
      initialPrivateState: privateStateZero
    });
    expect(ledger(constructorResult.nextContractState.data).round).toEqual(0n);
    expect(constructorResult.nextPrivateState).toEqual(privateStateZero);
    expect(constructorResult.nextZswapLocalState).toEqual(decodeZswapLocalState(emptyZswapLocalState(coinPublicKey)));

    const callResult = call({
      contract: api.counterContractInstance,
      coinPublicKey,
      circuitId: 'increment',
      contractAddress: sampleContractAddress(),
      initialContractState: constructorResult.nextContractState,
      initialZswapChainState: new ZswapChainState(),
      initialPrivateState: privateStateZero
    });

    expect(ledger(callResult.public.nextContractState).round).toEqual(1n);
    expect(callResult.private.nextPrivateState).toEqual(createPrivateState(1));
    expect(callResult.private.nextZswapLocalState).toEqual(decodeZswapLocalState(emptyZswapLocalState(coinPublicKey)));
  });

  /**
   * Test creating unproven call and deploy transactions for contract with private state.
   *
   * @given A contract with private state configuration
   * @and A signing key and initial private state
   * @when Creating unproven deploy and call transactions
   * @then Should properly set up transaction data with correct state initialization
   * @and Should maintain consistent state values and transaction structure
   */
  it('should create unproven call and deploy transactions for contract with private state', async () => {
    const signingKey = sampleSigningKey();
    const unprovenDeployTxResult = await createUnprovenDeployTx(providers, {
      contract: api.counterContractInstance,
      signingKey,
      initialPrivateState: privateStateZero
    });

    expect(ledger(unprovenDeployTxResult.public.initialContractState.data).round).toEqual(0n);
    expect(unprovenDeployTxResult.private.initialPrivateState).toEqual(privateStateZero);
    expect(unprovenDeployTxResult.private.initialZswapState).toEqual(
      decodeZswapLocalState(
        emptyZswapLocalState(parseCoinPublicKeyToHex(providers.walletProvider.getCoinPublicKey(), getNetworkId()))
      )
    );
    expect(unprovenDeployTxResult.private.signingKey).toEqual(signingKey);
    expect(unprovenDeployTxResult.private.newCoins).toEqual([]);

    const unprovenCallTxData = createUnprovenCallTxFromInitialStates(
      {
        contract: api.counterContractInstance,
        circuitId: 'increment',
        contractAddress: unprovenDeployTxResult.public.contractAddress,
        coinPublicKey: providers.walletProvider.getCoinPublicKey(),
        initialPrivateState: createPrivateState(1),
        initialContractState: unprovenDeployTxResult.public.initialContractState,
        initialZswapChainState: new ZswapChainState()
      },
      providers.walletProvider.getCoinPublicKey(),
      providers.walletProvider.getEncryptionPublicKey()
    );

    expect(ledger(unprovenCallTxData.public.nextContractState).round).toEqual(1n);
    expect(unprovenCallTxData.private.newCoins).toEqual([]);
    expect(unprovenCallTxData.private.nextZswapLocalState).toEqual(
      decodeZswapLocalState(
        emptyZswapLocalState(parseCoinPublicKeyToHex(providers.walletProvider.getCoinPublicKey(), getNetworkId()))
      )
    );
    expect(unprovenCallTxData.private.nextPrivateState).toEqual(createPrivateState(2));
  });

  /**
   * Test contract deployment on the blockchain.
   *
   * @given A counter contract instance and private state configuration
   * @and Valid deployment transaction options
   * @when Deploying contract to the blockchain
   * @then Should successfully deploy contract and return valid deployment data
   * @and Should validate deployment transaction completion
   */
  it('should deploy contract on the chain [@slow]', async () => {
    const deployTxOptions = {
      contract: counterContractInstance,
      privateStateId: CounterPrivateStateId,
      initialPrivateState: privateStateZero
    };
    const deployedContractLocal = await deployContract(providers, deployTxOptions);
    await expectSuccessfulDeployTx(providers, deployedContractLocal.deployTxData, deployTxOptions);
  });

  /**
   * Test finding deployed contract by contract address.
   *
   * @given A deployed contract at a specific address
   * @and Valid contract configuration and private state ID
   * @when Finding the deployed contract with initial private state
   * @then Should return deployed contract with matching transaction data
   * @and Should maintain state consistency between found and deployed contract
   */
  it('should return deployed contract if it exists on specific address', async () => {
    const foundContract = await findDeployedContract(providers, {
      contract: counterContractInstance,
      contractAddress,
      privateStateId: CounterPrivateStateId,
      initialPrivateState: privateStateZero
    });
    expectFoundAndDeployedTxDataEqual(finalizedDeployTxData, foundContract.deployTxData);
    await expectFoundAndDeployedStatesEqual(
      providers,
      finalizedDeployTxData,
      foundContract.deployTxData,
      CounterPrivateStateId,
      privateStateZero
    );
  });

  /**
   * Test finding deployed contract without initial private state.
   *
   * @given A deployed contract at a specific address
   * @and Valid contract configuration without initial private state
   * @when Finding the deployed contract
   * @then Should return deployed contract with matching transaction data
   * @and Should maintain state consistency without initial private state
   */
  it('should return deployed contract if it exists on specific address without initialPrivateState', async () => {
    const foundContract = await findDeployedContract(providers, {
      contract: counterContractInstance,
      contractAddress,
      privateStateId: CounterPrivateStateId
    });
    expectFoundAndDeployedTxDataEqual(finalizedDeployTxData, foundContract.deployTxData);
    await expectFoundAndDeployedStatesEqual(
      providers,
      finalizedDeployTxData,
      foundContract.deployTxData,
      CounterPrivateStateId
    );
  });

  /**
   * Test error handling for invalid contract address format.
   *
   * @given An invalid contract address with wrong format
   * @and Valid contract configuration
   * @when Finding the deployed contract with invalid address
   * @then Should throw error with specific message about byte length
   */
  it('should throw error if contract address has wrong format - length', async () => {
    await expect(
      findDeployedContract(providers, {
        contract: counterContractInstance,
        contractAddress: INVALID_CONTRACT_ADDRESS_TOO_LONG,
        privateStateId: CounterPrivateStateId
      })
    ).rejects.toThrow('Expected an input string with byte length of 32, got 33.');
  });

  /**
   * Test finding deployed contract with empty local private state store.
   *
   * @given A deployed contract and empty private state store
   * @and Initial private state configuration
   * @when Finding the deployed contract with empty local store
   * @then Should return deployed contract with matching transaction data
   * @and Should validate state consistency despite empty local store
   */
  it('should return deployed contract if it exists on specific address with initialPrivateState and empty local private state store', async () => {
    const providersLocal = initializeMidnightProviders<CounterCircuits, CounterPrivateState>(
      wallet,
      environmentConfiguration,
      getConfigurationWithEmptyPrivateStore()
    );

    const foundContract = await findDeployedContract(providersLocal, {
      contract: counterContractInstance,
      contractAddress,
      privateStateId: CounterPrivateStateId,
      initialPrivateState: privateStateZero
    });
    expectFoundAndDeployedTxDataEqual(finalizedDeployTxData, foundContract.deployTxData);
    await expectFoundAndDeployedStatesEqual(
      providers,
      finalizedDeployTxData,
      foundContract.deployTxData,
      CounterPrivateStateId,
      privateStateZero
    );
  });

  /**
   * Test finding deployed contract with different initial private state.
   *
   * @given A deployed contract and different initial private state
   * @and Modified private state configuration
   * @when Finding the deployed contract with different initial state
   * @then Should return deployed contract with updated private state
   * @and Should maintain public data consistency while updating private data
   */
  it('should return deployed contract if it exists on specific address with different initialPrivateState', async () => {
    const privateStateLocal = createInitialPrivateState(5);
    const foundContract = await findDeployedContract(providers, {
      contract: counterContractInstance,
      contractAddress,
      privateStateId: CounterPrivateStateId,
      initialPrivateState: privateStateLocal
    });
    expectFoundAndDeployedTxPublicDataEqual(finalizedDeployTxData, foundContract.deployTxData);
    expect(foundContract.deployTxData.private.initialPrivateState).toEqual(privateStateLocal);
    await expectFoundAndDeployedStatesEqual(
      providers,
      finalizedDeployTxData,
      foundContract.deployTxData,
      CounterPrivateStateId,
      privateStateLocal
    );
  });

  /**
   * Test indefinite waiting for contract deployment.
   *
   * @given An undeployed contract address
   * @and Valid contract configuration
   * @when Finding the deployed contract at undeployed address
   * @then Should wait indefinitely without timing out
   * @and Should not resolve within the waiting timeout period
   */
  it('should wait indefinitely until contract exists on specific address [@slow]', async () => {
    const contractPromise = findDeployedContract(providers, {
      contract: counterContractInstance,
      contractAddress: UNDEPLOYED_CONTRACT_ADDRESS,
      privateStateId: CounterPrivateStateId
    });

    const timeoutPromise = new Promise((resolve) => {
      setTimeout(resolve, WAITING_PROMISE_TIMEOUT);
    });
    const result = await Promise.race([contractPromise, timeoutPromise]);
    expect(result).toBeUndefined();
  });

  /**
   * Test error handling for incompatible contract types with different circuit IDs.
   *
   * @given A deployed Counter contract at specific address
   * @and Simple contract configuration with different circuit IDs
   * @when Finding deployed contract with incompatible contract type
   * @then Should throw ContractTypeError for mismatched circuit IDs
   */
  it('should throw for incompatible contract types that differ by circuit ids', async () => {
    const providersLocal = initializeMidnightProviders<SimpleCircuits, unknown>(
      wallet,
      environmentConfiguration,
      new SimpleConfiguration()
    );

    // Use the address of the already deployed Counter contract to attempt a find on a Simple
    // contract. This should result in an error.
    await expect(
      findDeployedContract(providersLocal, {
        contract: simpleContractInstance,
        contractAddress
      })
    ).rejects.toThrow(ContractTypeError);
  });

  /**
   * Test error handling for incompatible contract types with same shape but different verifier keys.
   *
   * @given A deployed Counter contract at specific address
   * @and CounterClone contract with same shape but different verifier keys
   * @when Finding deployed contract with same shape but different keys
   * @then Should throw ContractTypeError for mismatched verifier keys
   */
  it('should throw for incompatible contract types with same shape but different verifier keys', async () => {
    const providersLocal = initializeMidnightProviders<CounterCloneCircuits, CounterPrivateState>(
      wallet,
      environmentConfiguration,
      new CounterCloneConfiguration()
    );

    // Use the address of the already deployed Counter contract to attempt a find on a contract that
    // has the "same shape" in terms of circuits ids, but with different verifier keys. This should
    // result in an error.
    await expect(
      findDeployedContract(providersLocal, {
        contract: cloneContractInstance,
        contractAddress,
        privateStateId: CounterClonePrivateStateId
      })
    ).rejects.toThrow(ContractTypeError);
  });

  /**
   * Test creating contract circuits interface for contract interactions.
   *
   * @given A deployed contract and circuits interface
   * @and Initial counter and private state values
   * @when Executing increment, decrement, and reset operations
   * @then Should properly update both ledger and private state values
   * @and Should return successful transaction status for all operations
   */
  it(
    'should return contract interface and execute circuit operations [@slow]',
    async () => {
      const contractCircuitsInterface = createCircuitCallTxInterface(
        providers,
        counterContractInstance,
        contractAddress,
        CounterPrivateStateId
      );
      const counterValue1 = await api.getCounterLedgerState(providers, contractAddress);
      const privateState1 = await api.getCounterPrivateState(providers, CounterPrivateStateId);

      const incrementSubmittedCallTx = await contractCircuitsInterface.increment();
      const counterValue2 = await api.getCounterLedgerState(providers, contractAddress);
      const privateState2 = await api.getCounterPrivateState(providers, CounterPrivateStateId);

      const increment2SubmittedCallTx = await contractCircuitsInterface.increment();
      const counterValue3 = await api.getCounterLedgerState(providers, contractAddress);
      const privateState3 = await api.getCounterPrivateState(providers, CounterPrivateStateId);

      const decrementSubmittedCallTx = await contractCircuitsInterface.decrement(1n);
      const counterValue4 = await api.getCounterLedgerState(providers, contractAddress);
      const privateState4 = await api.getCounterPrivateState(providers, CounterPrivateStateId);

      const resetSubmittedCallTx = await contractCircuitsInterface.reset();
      const counterValue5 = await api.getCounterLedgerState(providers, contractAddress);
      const privateState5 = await api.getCounterPrivateState(providers, CounterPrivateStateId);

      expect(counterValue1).not.toBeNull();
      if (counterValue1) {
        expect(counterValue2).toEqual(counterValue1 + 1n);
        expect(counterValue3).toEqual(counterValue1 + 2n);
        expect(counterValue4).toEqual(counterValue1 + 1n);
        expect(counterValue5).toEqual(0n);
      }
      expect(privateState1).not.toBeNull();
      expect(privateState1?.privateCounter).not.toBeUndefined();
      if (privateState1?.privateCounter) {
        const startValue = privateState1?.privateCounter;
        expect(privateState2?.privateCounter).toEqual(startValue + 1);
        expect(privateState3?.privateCounter).toEqual(startValue + 2);
        expect(privateState4?.privateCounter).toEqual(startValue + 3);
        expect(privateState5?.privateCounter).toEqual(startValue + 4);
      }
      expect(incrementSubmittedCallTx.public.status).toEqual(SucceedEntirely);
      expect(increment2SubmittedCallTx.public.status).toEqual(SucceedEntirely);
      expect(decrementSubmittedCallTx.public.status).toEqual(SucceedEntirely);
      expect(resetSubmittedCallTx.public.status).toEqual(SucceedEntirely);
    },
    SLOW_TEST_TIMEOUT
  );

  /**
   * Test error handling for undefined public state at wrong address.
   *
   * @given A contract circuits interface at undeployed address
   * @and Various circuit operations (increment, decrement, reset)
   * @when Executing circuits on non-existent contract
   * @then Should throw error about missing public state
   * @and Should fail for all circuit operations consistently
   */
  it('should throw error on undefined public state at wrong address', async () => {
    const contractCircuitsInterface = createCircuitCallTxInterface(
      providers,
      counterContractInstance,
      UNDEPLOYED_CONTRACT_ADDRESS,
      CounterPrivateStateId
    );

    await expect(contractCircuitsInterface.increment()).rejects.toThrow(
      `No public state found at contract address '${UNDEPLOYED_CONTRACT_ADDRESS}'`
    );
    await expect(contractCircuitsInterface.decrement(1n)).rejects.toThrow(
      `No public state found at contract address '${UNDEPLOYED_CONTRACT_ADDRESS}'`
    );
    await expect(contractCircuitsInterface.reset()).rejects.toThrow(
      `No public state found at contract address '${UNDEPLOYED_CONTRACT_ADDRESS}'`
    );
  });

  /**
   * Test submitting deploy transaction to blockchain.
   *
   * @given A signing key and deploy transaction options
   * @and Counter contract configuration with initial private state
   * @when Submitting deploy transaction to blockchain
   * @then Should successfully deploy and validate transaction
   * @and Should enable subsequent call transactions on deployed contract
   */
  it('should submit a deploy transaction [@slow]', async () => {
    const signingKey = sampleSigningKey();
    const deployTxOptions = {
      contract: api.counterContractInstance,
      signingKey,
      privateStateId: CounterPrivateStateId,
      initialPrivateState: privateStateZero
    };
    const deployTxData = await submitDeployTx(providers, deployTxOptions);
    await expectSuccessfulDeployTx(providers, deployTxData, deployTxOptions);
    const callTxOptions = {
      contract: api.counterContractInstance,
      contractAddress: deployTxData.public.contractAddress,
      circuitId: CIRCUIT_ID_INCREMENT,
      privateStateId: CounterPrivateStateId
    } as const;
    const callTxData = await submitCallTx(providers, callTxOptions);
    await expectSuccessfulCallTx(providers, callTxData, callTxOptions, createPrivateState(1));
  });

  /**
   * Test submitting call transaction that executes circuit in contract.
   *
   * @given A deployed contract with current state values
   * @and Valid call transaction options for increment circuit
   * @when Submitting call transaction to execute increment
   * @then Should successfully execute and update contract state
   * @and Should increment counter value by one and update private state
   */
  it('should submit transaction that calls circuit in contract [@slow]', async () => {
    const counterValue1 = await api.getCounterLedgerState(providers, contractAddress);
    expect(counterValue1).toBeDefined();

    const privateState1 = await api.getCounterPrivateState(providers, CounterPrivateStateId);
    expect(privateState1).toBeDefined();

    const callTxOptions = {
      contract: counterContractInstance,
      contractAddress,
      circuitId: CIRCUIT_ID_INCREMENT,
      privateStateId: CounterPrivateStateId
    } as const;
    const callTxData = await submitCallTx(providers, callTxOptions);
    await expectSuccessfulCallTx(
      providers,
      callTxData,
      callTxOptions,
      createPrivateState(privateState1!.privateCounter + 1)
    );

    const counterValue2 = await api.getCounterLedgerState(providers, contractAddress);
    expect(counterValue2).toBeDefined();
    expect(counterValue2!).toEqual(counterValue1! + 1n);
  });

  /**
   * Test error handling when private state is undefined.
   *
   * @given Providers with empty private state store
   * @and Valid contract and call transaction configuration
   * @when Submitting call transaction without private state
   * @then Should throw error about missing private state
   * @and Should reference specific private state ID in error message
   */
  it('should throw error if private state is undefined', async () => {
    const providersLocal = initializeMidnightProviders<CounterCircuits, CounterPrivateState>(
      wallet,
      environmentConfiguration,
      getConfigurationWithEmptyPrivateStore()
    );

    await expect(
      submitCallTx(providersLocal, {
        contract: counterContractInstance,
        circuitId: CIRCUIT_ID_INCREMENT,
        contractAddress,
        privateStateId: CounterPrivateStateId
      })
    ).rejects.toThrow(`No private state found at private state ID '${CounterPrivateStateId}'`);
  });

  /**
   * Test error handling when public state is undefined.
   *
   * @given Valid providers and call transaction configuration
   * @and Undeployed contract address without public state
   * @when Submitting call transaction to non-existent contract
   * @then Should throw error about missing public state
   * @and Should reference specific contract address in error message
   */
  it('should throw error if public state is undefined', async () => {
    await expect(
      submitCallTx(providers, {
        contract: counterContractInstance,
        circuitId: CIRCUIT_ID_INCREMENT,
        contractAddress: UNDEPLOYED_CONTRACT_ADDRESS,
        privateStateId: CounterPrivateStateId
      })
    ).rejects.toThrow(`No public state found at contract address '${UNDEPLOYED_CONTRACT_ADDRESS}'`);
  });

  /**
   * Test error handling for invalid contract address format.
   *
   * @given Valid providers and call transaction configuration
   * @and Invalid contract address with wrong hex format
   * @when Submitting call transaction with malformed address
   * @then Should throw error about incomplete byte in input string
   * @and Should reference the invalid address in error message
   */
  it('should throw error if contract address has wrong format - not hex', async () => {
    await expect(
      submitCallTx(providers, {
        contract: counterContractInstance,
        circuitId: CIRCUIT_ID_INCREMENT,
        contractAddress: INVALID_CONTRACT_ADDRESS_HEX_FORMAT,
        privateStateId: CounterPrivateStateId
      })
    ).rejects.toThrow(`The last byte of input string '${INVALID_CONTRACT_ADDRESS_HEX_FORMAT}' is incomplete.`);
  });

  /**
   * Test watching for contract state changes independently of chain state.
   *
   * @given A deployed contract with initial state
   * @and Contract state observation functionality
   * @when Incrementing contract and observing state changes
   * @then Should return latest observed state independent of chain state
   * @and Should maintain state consistency during observations
   */
  it('should return the latest observed state of a deployed contract and is independent of the chain state', async () => {
    await api.increment(deployedContract);
    const counterValue1 = await api.getCounterLedgerState(providers, contractAddress);
    expect(counterValue1).toBeDefined();

    const state = await providers.publicDataProvider.watchForContractState(
      deployedContract.deployTxData.public.contractAddress
    );
    expect(state).toBeDefined();

    // increment modifies state on the ledger, but not the state previously returned
    await api.increment(deployedContract);

    expect(ledger(state.data).round).toEqual(counterValue1);
  });

  /**
   * Test indefinite waiting for state changes with timeout behavior.
   *
   * @given A deployed contract with current state
   * @and Contract state watching with timeout configuration
   * @when Waiting for state changes within timeout period
   * @then Should wait indefinitely until stopped and return last contract state
   * @and Should return valid ContractState instance when timeout occurs
   */
  it('should wait indefinitely until state change, if stopped returns last contract state [@slow]', async () => {
    const counterValue1 = await api.getCounterLedgerState(providers, contractAddress);
    const contractPromise = providers.publicDataProvider.watchForContractState(
      deployedContract.deployTxData.public.contractAddress
    );
    const timeoutPromise = new Promise((resolve) => {
      setTimeout(resolve, WAITING_PROMISE_TIMEOUT);
    });
    const result = await Promise.race([contractPromise, timeoutPromise]);

    expect(result).toBeInstanceOf(ContractState);
    expect(ledger((result as ContractState).data).round).toEqual(counterValue1);
  });
});

================
File: testkit-js/testkit-js-e2e/test/contracts.singlecontract.nostate.it.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  type CoinPublicKey,
  decodeZswapLocalState,
  emptyZswapLocalState,
  sampleContractAddress,
  sampleSigningKey,
  type SigningKey
} from '@midnight-ntwrk/compact-runtime';
import { ZswapChainState } from '@midnight-ntwrk/ledger-v6';
import {
  call,
  callContractConstructor,
  type CallResult,
  createUnprovenCallTx,
  createUnprovenCallTxFromInitialStates,
  createUnprovenDeployTx,
  deployContract,
  findDeployedContract,
  submitCallTx,
  submitDeployTx,
  type UnsubmittedCallTxData,
  type UnsubmittedDeployTxData
} from '@midnight-ntwrk/midnight-js-contracts';
import { getNetworkId } from '@midnight-ntwrk/midnight-js-network-id';
import { parseCoinPublicKeyToHex } from '@midnight-ntwrk/midnight-js-utils';
import {
  createLogger,
  type EnvironmentConfiguration,
  expectFoundAndDeployedStatesEqual,
  expectFoundAndDeployedTxDataEqual,
  expectSuccessfulCallTx,
  expectSuccessfulDeployTx,
  getTestEnvironment,
  initializeMidnightProviders,
  type MidnightWalletProvider,
  type TestEnvironment} from '@midnight-ntwrk/testkit-js';
import path from 'path';

import { CompiledSimple } from '@/contract';
import * as api from '@/counter-api';
import type { SimpleContract, SimpleProviders } from '@/simple-types';

const logger = createLogger(
  path.resolve(`${process.cwd()}`, 'logs', 'tests', `contracts_nostate_${new Date().toISOString()}.log`)
);

const { ledger } = CompiledSimple;

const expectSimpleContractCallResult = (
  coinPublicKey: CoinPublicKey,
  round: bigint,
  callResult: CallResult<SimpleContract, 'noop'>
): void => {
  expect(ledger(callResult.public.nextContractState).round).toEqual(round);
  expect(callResult.private.nextZswapLocalState).toEqual(
    decodeZswapLocalState(emptyZswapLocalState(parseCoinPublicKeyToHex(coinPublicKey, getNetworkId())))
  );
  expect(callResult.private.nextPrivateState).toBeUndefined();
  expect(callResult.private.privateTranscriptOutputs).toEqual([]);
};

const expectSimpleContractCallTxData = (
  coinPublicKey: CoinPublicKey,
  round: bigint,
  unprovenCallTxData: UnsubmittedCallTxData<SimpleContract, 'noop'>
): void => {
  expectSimpleContractCallResult(coinPublicKey, round, unprovenCallTxData);
  expect(unprovenCallTxData.private.newCoins).toEqual([]);
  expect(unprovenCallTxData.private.unprovenTx).toBeTruthy();
  expect(unprovenCallTxData.private.input).toBeTruthy();
  expect(unprovenCallTxData.private.output).toBeTruthy();
};

const expectSimpleContractDeployTxData = (
  signingKey: SigningKey,
  coinPublicKey: CoinPublicKey,
  round: bigint,
  deployTxResult: UnsubmittedDeployTxData<SimpleContract>
): void => {
  expect(ledger(deployTxResult.public.initialContractState.data).round).toEqual(round);
  expect(deployTxResult.private.initialPrivateState).toBeUndefined();
  expect(deployTxResult.private.initialZswapState).toEqual(
    decodeZswapLocalState(emptyZswapLocalState(parseCoinPublicKeyToHex(coinPublicKey, getNetworkId())))
  );
  expect(deployTxResult.private.signingKey).toEqual(signingKey);
  expect(deployTxResult.private.newCoins).toEqual([]);
};

describe('Contracts API', () => {
  let providers: SimpleProviders;
  let testEnvironment: TestEnvironment;
  let environmentConfiguration: EnvironmentConfiguration;
  let wallet: MidnightWalletProvider;
  let contractConfiguration: api.SimpleConfiguration;

  beforeAll(async () => {
    testEnvironment = getTestEnvironment(logger);
    environmentConfiguration = await testEnvironment.start();
    contractConfiguration = new api.SimpleConfiguration();
    api.setLogger(logger);
    wallet = await testEnvironment.getMidnightWalletProvider();
    providers = initializeMidnightProviders(wallet, environmentConfiguration, contractConfiguration);
  });

  afterAll(async () => {
    await testEnvironment.shutdown();
  });

  beforeEach(() => {
    logger.info(`Running test=${expect.getState().currentTestName}`);
  });

  /**
   * Test constructor and circuit execution for contracts with no private state.
   *
   * @given A simple contract with no private state
   * @and A coin public key from wallet provider
   * @when Executing constructor and noop circuit
   * @then Should correctly initialize contract state without private state
   * @and Should maintain proper ledger state and local state consistency
   */
  it('should execute constructor and circuits of contracts with no private state', () => {
    const coinPublicKey = providers.walletProvider.getCoinPublicKey();
    const constructorResult = callContractConstructor({
      contract: api.simpleContractInstance,
      coinPublicKey
    });
    expect(ledger(constructorResult.nextContractState.data).round).toEqual(0n);
    expect(constructorResult.nextPrivateState).toBeUndefined();
    expect(constructorResult.nextZswapLocalState).toEqual(
      decodeZswapLocalState(emptyZswapLocalState(parseCoinPublicKeyToHex(coinPublicKey, getNetworkId())))
    );
    const callResult = call({
      contract: api.simpleContractInstance,
      coinPublicKey,
      circuitId: 'noop',
      contractAddress: sampleContractAddress(),
      initialContractState: constructorResult.nextContractState,
      initialZswapChainState: new ZswapChainState()
    });
    expectSimpleContractCallResult(coinPublicKey, 1n, callResult);
  });

  /**
   * Test deploying and finding contracts with no private state.
   *
   * @given A simple contract instance with no private state
   * @and Providers configured for simple contract operations
   * @when Deploying contract and finding deployed instance
   * @and Executing noop circuit on found contract
   * @then Should successfully deploy contract without private state
   * @and Should find deployed contract with matching transaction data
   * @and Should execute circuit operations successfully
   * @and Should validate error handling for invalid private state configuration
   */
  it('should deploy and find contracts with no private state [@slow]', async () => {
    const deployedSimpleContract = await deployContract(providers, {
      contract: api.simpleContractInstance
    });
    await expectSuccessfulDeployTx(providers, deployedSimpleContract.deployTxData);

    const foundSimpleContract = await findDeployedContract(providers, {
      contract: api.simpleContractInstance,
      contractAddress: deployedSimpleContract.deployTxData.public.contractAddress
    });
    expectFoundAndDeployedTxDataEqual(deployedSimpleContract.deployTxData, foundSimpleContract.deployTxData);
    await expectFoundAndDeployedStatesEqual(
      providers,
      deployedSimpleContract.deployTxData,
      foundSimpleContract.deployTxData
    );

    const finalizedCallTxData = await foundSimpleContract.callTx.noop();
    await expectSuccessfulCallTx(providers, finalizedCallTxData);
    expectSimpleContractCallTxData(
      parseCoinPublicKeyToHex(providers.walletProvider.getCoinPublicKey(), getNetworkId()),
      1n,
      finalizedCallTxData
    );

    const expandedFindDeployedContractConfig = {
      contract: api.simpleContractInstance,
      contractAddress: deployedSimpleContract.deployTxData.public.contractAddress,
      initialPrivateState: 'random'
    };
    await expect(findDeployedContract(providers, expandedFindDeployedContractConfig)).rejects.toThrow(
      "'initialPrivateState' was defined for contract find while 'privateStateId' was undefined"
    );
  });

  /**
   * Test creating unproven transactions for contracts with no private state.
   *
   * @given A simple contract with no private state and signing key
   * @and Providers configured for transaction creation
   * @when Creating unproven deploy and call transactions
   * @and Testing with and without private state provider
   * @then Should create valid unproven deploy transaction data
   * @and Should create valid unproven call transaction data
   * @and Should handle reduced providers correctly for stateless contracts
   * @and Should validate error for mismatched private state configuration
   */
  it('should create unproven call and deploy transactions for contract with no private state', async () => {
    const signingKey = sampleSigningKey();
    const coinPublicKey = providers.walletProvider.getCoinPublicKey();
    const unprovenDeployTxResult = await createUnprovenDeployTx(providers, {
      contract: api.simpleContractInstance,
      signingKey
    });
    expectSimpleContractDeployTxData(signingKey, coinPublicKey, 0n, unprovenDeployTxResult);

    const unprovenCallTxData0 = createUnprovenCallTxFromInitialStates(
      {
        contract: api.simpleContractInstance,
        circuitId: 'noop',
        contractAddress: unprovenDeployTxResult.public.contractAddress,
        coinPublicKey,
        initialContractState: unprovenDeployTxResult.public.initialContractState,
        initialZswapChainState: new ZswapChainState()
      },
      providers.walletProvider.getCoinPublicKey(),
      providers.walletProvider.getEncryptionPublicKey()
    );
    expectSimpleContractCallTxData(coinPublicKey, 1n, unprovenCallTxData0);

    // Need to deploy fresh contract to test 'createUnprovenCallTx' independently

    const deployedSimpleContract = await deployContract(providers, {
      contract: api.simpleContractInstance
    });
    await expectSuccessfulDeployTx(providers, deployedSimpleContract.deployTxData);

    // If there is no private state ID, we should be able to leave out the private state provider

    const { privateStateProvider: _, ...reducedProviders } = providers;
    const callTxOptions = {
      contract: api.simpleContractInstance,
      circuitId: 'noop',
      contractAddress: deployedSimpleContract.deployTxData.public.contractAddress
    } as const;
    const unprovenCallTxData1 = await createUnprovenCallTx(reducedProviders, callTxOptions);
    expectSimpleContractCallTxData(
      parseCoinPublicKeyToHex(providers.walletProvider.getCoinPublicKey(), getNetworkId()),
      1n,
      unprovenCallTxData1
    );

    // If there is a private state ID, we should not be able to leave out the private state provider
    const expandedCallTxOptions = { privateStateId: 'random', ...callTxOptions };
    await expect(createUnprovenCallTx(reducedProviders, expandedCallTxOptions)).rejects.toThrow(
      "'privateStateId' was defined for call transaction while 'privateStateProvider' was undefined"
    );
  });

  /**
   * Test submitting deploy and call transactions for contracts with no private state.
   *
   * @given A simple contract with no private state
   * @and Deploy and call transaction options
   * @when Submitting deploy transaction with signing key
   * @and Submitting call transaction with reduced providers
   * @then Should successfully submit deploy transaction
   * @and Should successfully submit call transaction without private state provider
   * @and Should validate error for mismatched private state configuration
   */
  it('should submit deploy and call transactions for contracts with no private state [@slow]', async () => {
    // Need to deploy fresh contract to test 'submitDeployTx' independently
    const deployTxOptions = {
      contract: api.simpleContractInstance,
      signingKey: sampleSigningKey()
    };
    const deployTxData = await submitDeployTx(providers, deployTxOptions);
    await expectSuccessfulDeployTx(providers, deployTxData, deployTxOptions);

    // If there is no private state ID, we should be able to leave out the private state provider

    const { privateStateProvider: _, ...reducedProviders } = providers;
    const callTxOptions = {
      contract: api.simpleContractInstance,
      contractAddress: deployTxData.public.contractAddress,
      circuitId: 'noop'
    } as const;
    const callTxData = await submitCallTx(reducedProviders, callTxOptions);
    await expectSuccessfulCallTx(providers, callTxData, callTxOptions);

    // If there is a private state ID, we should not be able to leave out the private state provider
    const expandedCallTxOptions = { privateStateId: 'random', ...callTxOptions };
    await expect(submitCallTx(reducedProviders, expandedCallTxOptions)).rejects.toThrow(
      "'privateStateId' was defined for call transaction while 'privateStateProvider' was undefined"
    );
  });
});

================
File: testkit-js/testkit-js-e2e/test/unshielded.it.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type ContractAddress, sampleSigningKey } from '@midnight-ntwrk/compact-runtime';
import { deployContract, submitCallTx } from '@midnight-ntwrk/midnight-js-contracts';
import { SucceedEntirely } from '@midnight-ntwrk/midnight-js-types';
import {
  type ContractConfiguration,
  createLogger,
  type EnvironmentConfiguration,
  expectSuccessfulDeployTx,
  getTestEnvironment,
  initializeMidnightProviders,
  type MidnightWalletProvider,
  type TestEnvironment
} from '@midnight-ntwrk/testkit-js';
import { afterAll, beforeAll, beforeEach,describe, test } from '@vitest/runner';
import path from 'path';
import { expect } from 'vitest';

import {
  createUnshieldedContract,
  type UnshieldedContract,
  type UnshieldedContractCircuits,
  type UnshieldedContractProviders
} from '@/unshielded-types';

const logger = createLogger(
  path.resolve(`${process.cwd()}`, 'logs', 'tests', `unshielded_${new Date().toISOString()}.log`)
);

class UnshieldedConfiguration implements ContractConfiguration {
  constructor(private suffix = Date.now().toString()) {}

  get privateStateStoreName(): string {
    return `unshielded-private-store-${this.suffix}`;
  }

  get zkConfigPath(): string {
    return path.resolve(__dirname, '../dist/contract/managed/unshielded');
  }
}

describe('Unshielded tokens', () => {
  const TEST_TOKEN_AMOUNT = 1_000_000n;
  const TEST_DOMAIN_SEP = new Uint8Array(32).fill(1);

  let testEnvironment: TestEnvironment;
  let wallet: MidnightWalletProvider;
  let environmentConfiguration: EnvironmentConfiguration;
  let providers: UnshieldedContractProviders;
  let contractAddress: ContractAddress;
  let unshieldedContract: UnshieldedContract;
  let contractConfiguration: UnshieldedConfiguration;

  beforeEach(() => {
    logger.info(`Running test=${expect.getState().currentTestName}`);
  });

  beforeAll(async () => {
    testEnvironment = getTestEnvironment(logger);
    environmentConfiguration = await testEnvironment.start();
    wallet = await testEnvironment.getMidnightWalletProvider();
    contractConfiguration = new UnshieldedConfiguration();

    providers = initializeMidnightProviders(wallet, environmentConfiguration, contractConfiguration);

    unshieldedContract = createUnshieldedContract();

    const deployTxOptions = {
      contract: unshieldedContract,
      signingKey: sampleSigningKey(),
      initialPrivateState: undefined
    };

    const deployedContract = await deployContract(providers, deployTxOptions);
    await expectSuccessfulDeployTx(providers, deployedContract.deployTxData, deployTxOptions);
    contractAddress = deployedContract.deployTxData.public.contractAddress;

    logger.info(`Deployed unshielded contract at address: ${contractAddress}`);
  });

  afterAll(async () => {
    await testEnvironment.shutdown();
  });

  test('should mint tokens', async () => {
    const mintTxData = await submitCallTx(providers, {
      contract: unshieldedContract,
      contractAddress,
      circuitId: 'mintToSelfReceive' as UnshieldedContractCircuits,
      args: [TEST_DOMAIN_SEP, TEST_TOKEN_AMOUNT]
    });

    expect(mintTxData.public.status).toBe(SucceedEntirely);
    expect(mintTxData.public.unshielded).toBeDefined();

    const created = mintTxData.public.unshielded.created;
    const spent = mintTxData.public.unshielded.spent;
    expect(created.length).toEqual(0);
    expect(spent.length).toEqual(0);

    logger.info(`Minted token: ${JSON.stringify(mintTxData)}`);
  });

  test('should get balance of tokens - 0 value', async () => {
    const txData = await submitCallTx(providers, {
      contract: unshieldedContract,
      contractAddress,
      circuitId: 'getUnshieldedBalanceTest' as UnshieldedContractCircuits,
      args: [TEST_DOMAIN_SEP]
    });

    expect(txData.public.status).toBe(SucceedEntirely);
    expect(txData.private.result).toEqual(0n);
    expect(txData.public.unshielded).toBeDefined();

    const spent = txData.public.unshielded.spent;
    const created = txData.public.unshielded.created;
    expect(spent.length).toEqual(0);
    expect(created.length).toEqual(0);
  });

  test.skip('should get balance of tokens - greater than', async () => {
    const txData = await submitCallTx(providers, {
      contract: unshieldedContract,
      contractAddress,
      circuitId: 'getUnshieldedBalanceGtTest' as UnshieldedContractCircuits,
      args: [TEST_DOMAIN_SEP, 1n]
    });

    expect(txData.public.status).toBe(SucceedEntirely);
    expect(txData.private.result).toEqual(false);
    expect(txData.public.unshielded).toBeDefined();

    const spent = txData.public.unshielded.spent;
    const created = txData.public.unshielded.created;
    expect(spent.length).toEqual(0);
    expect(created.length).toEqual(0);
  });

  test.skip('should get balance of tokens - less than', async () => {
    const txData = await submitCallTx(providers, {
      contract: unshieldedContract,
      contractAddress,
      circuitId: 'getUnshieldedBalanceGtTest' as UnshieldedContractCircuits,
      args: [TEST_DOMAIN_SEP, 1n]
    });

    expect(txData.public.status).toBe(SucceedEntirely);
    expect(txData.private.result).toEqual(true);
    expect(txData.public.unshielded).toBeDefined();

    const spent = txData.public.unshielded.spent;
    const created = txData.public.unshielded.created;
    expect(spent.length).toEqual(0);
    expect(created.length).toEqual(0);
  });

  test('should receive tokens - invalid', async () => {
    await expect(() =>
      submitCallTx(providers, {
        contract: unshieldedContract,
        contractAddress,
        circuitId: 'receiveUnshieldedTest' as UnshieldedContractCircuits,
        args: [TEST_DOMAIN_SEP, TEST_TOKEN_AMOUNT]
      })
    ).rejects.toThrow('Insufficient Funds: could not balance 0101010101010101010101010101010101010101010101010101010101010101');
  });

  test.skip('should receive tokens - wallet', async () => {
    const sep = new Uint8Array(32).fill(0);

    const txData = await submitCallTx(providers, {
      contract: unshieldedContract,
      contractAddress,
      circuitId: 'receiveUnshieldedTest' as UnshieldedContractCircuits,
      args: [sep, TEST_TOKEN_AMOUNT]
    });

    expect(txData.public.status).toBe(SucceedEntirely);
    expect(txData.private.result).toEqual(0n);
    expect(txData.public.unshielded).toBeDefined();

    const spent = txData.public.unshielded.spent;
    const created = txData.public.unshielded.created;
    expect(spent.length).toEqual(0);
    expect(created.length).toEqual(0);
  });

  test.skip('should send tokens to wallet', async () => {
    const address = new Uint8Array(Buffer.from('0f09f9eb5538606c6490c0595b771ecb0c29ae71778f089a95e8465b84774aed', 'hex'));
    const sep = new Uint8Array(32).fill(0);

    const txData = await submitCallTx(providers, {
      contract: unshieldedContract,
      contractAddress,
      circuitId: 'sendUnshieldedToUserTest' as UnshieldedContractCircuits,
      args: [sep, 1_000_000n, { bytes: address } ]
    });

    expect(txData.public.status).toBe(SucceedEntirely);
    expect(txData.private.result).toEqual(0n);
    expect(txData.public.unshielded).toBeDefined();

    const spent = txData.public.unshielded.spent;
    const created = txData.public.unshielded.created;
    expect(spent.length).toEqual(0);
    expect(created.length).toEqual(0);
  });

  test('should mint native tokens', async () => {
    const txData = await submitCallTx(providers, {
      contract: unshieldedContract,
      contractAddress,
      circuitId: 'mintNativeTokens' as UnshieldedContractCircuits,
      args: [1_000_000n]
    });

    expect(txData.public.status).toBe(SucceedEntirely);
  });
});

================
File: testkit-js/proof-server.yml
================
services:
  proof-server:
    image: "ghcr.io/midnight-ntwrk/proof-server:6.1.0-alpha.6"
    container_name: "proof-server_$TESTCONTAINERS_UID"
    ports:
      - "0:6300"
    environment:
      EXTRA_ARGS: -v
      RUST_BACKTRACE: "full"
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost:6300/version" ]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

================
File: packages/contracts/src/submit-call-tx.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { Contract, ImpureCircuitId } from '@midnight-ntwrk/midnight-js-types';
import { SucceedEntirely } from '@midnight-ntwrk/midnight-js-types';
import { assertDefined, assertIsContractAddress } from '@midnight-ntwrk/midnight-js-utils';

import { type ContractProviders } from './contract-providers';
import { CallTxFailedError, IncompleteCallTxPrivateStateConfig } from './errors';
import type { SubmitTxProviders } from './submit-tx';
import { submitTx, submitTxAsync } from './submit-tx';
import type { FinalizedCallTxData, SubmittedCallTx } from './tx-model';
import {
  type CallTxOptions,
  type CallTxOptionsBase,
  type CallTxOptionsWithPrivateStateId,
  createUnprovenCallTx
} from './unproven-call-tx';

export type SubmitCallTxProviders<C extends Contract, ICK extends ImpureCircuitId<C>> =
  | ContractProviders<C>
  | SubmitTxProviders<C, ICK>;

export async function submitCallTx<C extends Contract<undefined>, ICK extends ImpureCircuitId<C>>(
  providers: SubmitTxProviders<C, ICK>,
  options: CallTxOptionsBase<C, ICK>
): Promise<FinalizedCallTxData<C, ICK>>;

export async function submitCallTx<C extends Contract, ICK extends ImpureCircuitId<C>>(
  providers: ContractProviders<C>,
  options: CallTxOptionsWithPrivateStateId<C, ICK>
): Promise<FinalizedCallTxData<C, ICK>>;

/**
 * Creates and submits a transaction for the invocation of a circuit on a given contract.
 *
 * ## Transaction Execution Phases
 *
 * Midnight transactions execute in two phases:
 * 1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
 * 2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success
 *
 * ## Failure Behavior
 *
 * **Guaranteed Phase Failure:**
 * - Transaction is rejected and not included in the blockchain
 * - `CallTxFailedError` is thrown with transaction data and circuit ID
 * - Private state updates are NOT stored (state remains unchanged)
 * - No on-chain record of the failed transaction
 *
 * **Fallible Phase Failure:**
 * - Transaction is recorded on-chain with non-`SucceedEntirely` status
 * - `CallTxFailedError` is thrown with transaction data and circuit ID
 * - Private state updates are NOT stored (state remains unchanged)
 * - Transaction appears in blockchain history as partial success
 *
 * @param providers The providers used to manage the invocation lifecycle.
 * @param options Configuration.
 *
 * @returns A `Promise` that resolves with the finalized transaction data for the invocation of
 *         `circuitId` on `contract` with the given `args`; or rejects with an error if the invocation fails.
 *
 * @throws {CallTxFailedError} When transaction fails in either guaranteed or fallible phase.
 *         The error contains the finalized transaction data and circuit ID for debugging.
 */
export async function submitCallTx<C extends Contract, ICK extends ImpureCircuitId<C>>(
  providers: SubmitCallTxProviders<C, ICK>,
  options: CallTxOptions<C, ICK>
): Promise<FinalizedCallTxData<C, ICK>> {
  assertIsContractAddress(options.contractAddress);
  assertDefined(options.contract.impureCircuits[options.circuitId], `Circuit '${options.circuitId}' is undefined`);

  const hasPrivateStateProvider = 'privateStateProvider' in providers;
  const hasPrivateStateId = 'privateStateId' in options;

  if (hasPrivateStateId && !hasPrivateStateProvider) {
    throw new IncompleteCallTxPrivateStateConfig();
  }

  const unprovenCallTxData = await createUnprovenCallTx(providers, options);

  const finalizedTxData = await submitTx(providers, {
    unprovenTx: unprovenCallTxData.private.unprovenTx,
    newCoins: unprovenCallTxData.private.newCoins,
    circuitId: options.circuitId
  });

  if (finalizedTxData.status !== SucceedEntirely) {
    throw new CallTxFailedError(finalizedTxData, options.circuitId);
  }

  if (hasPrivateStateId && hasPrivateStateProvider) {
    await providers.privateStateProvider.set(options.privateStateId, unprovenCallTxData.private.nextPrivateState);
  }

  return {
    private: unprovenCallTxData.private,
    public: {
      ...unprovenCallTxData.public,
      ...finalizedTxData
    }
  };
}

/**
 * Creates and submits a transaction for the invocation of a circuit on a given contract,
 * returning immediately after submission without waiting for finalization.
 *
 * Unlike {@link submitCallTx}, this function does not wait for transaction finalization,
 * check transaction status, or update private state. The caller must handle these steps manually.
 *
 * ## Transaction Execution Phases
 *
 * Midnight transactions execute in two phases:
 * 1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
 * 2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success
 *
 * ## Manual Post-Submission Steps
 *
 * After calling this function, you must manually:
 * 1. Watch for transaction finalization using `providers.publicDataProvider.watchForTxData(txId)`
 * 2. Check transaction status (compare against `SucceedEntirely`)
 * 3. Handle failures appropriately (throw errors, log, etc.)
 * 4. Update private state if transaction succeeded and `privateStateId` was provided
 *
 * ## Failure Behavior (Manual Handling Required)
 *
 * **Guaranteed Phase Failure:**
 * - Transaction is rejected and not included in the blockchain
 * - `watchForTxData` may reject or return error status
 * - You must NOT store private state updates
 *
 * **Fallible Phase Failure:**
 * - Transaction is recorded on-chain with non-`SucceedEntirely` status
 * - `watchForTxData` returns transaction data with failed status
 * - You must NOT store private state updates
 * - Transaction appears in blockchain history as partial success
 *
 * @param providers The providers used to manage the invocation lifecycle.
 * @param options Configuration.
 *
 * @returns A `Promise` that resolves with the transaction ID and call transaction data immediately after submission;
 *         or rejects with an error if the submission fails.
 *
 * @example
 * ```typescript
 * // 1. Submit
 * const { txId, callTxData } = await submitCallTxAsync(providers, options);
 *
 * // 2. Watch (when ready)
 * const finalizedData = await providers.publicDataProvider.watchForTxData(txId);
 *
 * // 3. Check status
 * if (finalizedData.status !== SucceedEntirely) {
 *   throw new CallTxFailedError(finalizedData, options.circuitId);
 * }
 *
 * // 4. Update private state manually if needed
 * if (options.privateStateId) {
 *   await providers.privateStateProvider.set(
 *     privateStateId,
 *     callTxData.private.nextPrivateState
 *   );
 * }
 * ```
 */
export async function submitCallTxAsync<C extends Contract, ICK extends ImpureCircuitId<C>>(
  providers: SubmitCallTxProviders<C, ICK>,
  options: CallTxOptions<C, ICK>
): Promise<SubmittedCallTx<C, ICK>> {
  assertIsContractAddress(options.contractAddress);
  assertDefined(options.contract.impureCircuits[options.circuitId], `Circuit '${options.circuitId}' is undefined`);

  const hasPrivateStateProvider = 'privateStateProvider' in providers;
  const hasPrivateStateId = 'privateStateId' in options;

  if (hasPrivateStateId && !hasPrivateStateProvider) {
    throw new IncompleteCallTxPrivateStateConfig();
  }

  const unprovenCallTxData = await createUnprovenCallTx(providers, options);

  const txId = await submitTxAsync(providers, {
    unprovenTx: unprovenCallTxData.private.unprovenTx,
    newCoins: unprovenCallTxData.private.newCoins,
    circuitId: options.circuitId
  });

  return {
    txId,
    callTxData: unprovenCallTxData
  };
}

================
File: packages/level-private-state-provider/src/test/storage-encryption.test.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { getStoragePassword, StorageEncryption } from '../storage-encryption';

describe('StorageEncryption', () => {
  const testPassword = 'test-password-123';
  const testData = 'sensitive data that needs encryption';

  describe('encrypt and decrypt', () => {
    test('successfully encrypts and decrypts data', () => {
      const encryption = new StorageEncryption(testPassword);

      const encrypted = encryption.encrypt(testData);
      const decrypted = encryption.decrypt(encrypted);

      expect(decrypted).toBe(testData);
      expect(decrypted).not.toBe(encrypted);
    });

    test('produces different ciphertext for same plaintext', () => {
      const encryption = new StorageEncryption(testPassword);

      const encrypted1 = encryption.encrypt(testData);
      const encrypted2 = encryption.encrypt(testData);

      expect(encrypted1).not.toBe(encrypted2);
      expect(encryption.decrypt(encrypted1)).toBe(testData);
      expect(encryption.decrypt(encrypted2)).toBe(testData);
    });

    test('handles empty string', () => {
      const encryption = new StorageEncryption(testPassword);

      const encrypted = encryption.encrypt('');
      const decrypted = encryption.decrypt(encrypted);

      expect(decrypted).toBe('');
    });

    test('handles unicode characters', () => {
      const encryption = new StorageEncryption(testPassword);
      const unicodeData = ' Encrypted data with mojis and spcial hars ';

      const encrypted = encryption.encrypt(unicodeData);
      const decrypted = encryption.decrypt(encrypted);

      expect(decrypted).toBe(unicodeData);
    });
  });

  describe('error handling', () => {
    test('throws on wrong password', () => {
      const encryption1 = new StorageEncryption('password1');
      const encrypted = encryption1.encrypt(testData);

      const encryption2 = new StorageEncryption('password2', encryption1.getSalt());

      expect(() => encryption2.decrypt(encrypted)).toThrow();
    });
  });

  describe('getStoragePassword', () => {
    const originalEnv = process.env.MIDNIGHT_STORAGE_PASSWORD;

    afterEach(() => {
      if (originalEnv) {
        process.env.MIDNIGHT_STORAGE_PASSWORD = originalEnv;
      } else {
        delete process.env.MIDNIGHT_STORAGE_PASSWORD;
      }
    });

    test('throws error when environment variable is not set', () => {
      delete process.env.MIDNIGHT_STORAGE_PASSWORD;

      expect(() => getStoragePassword()).toThrow('MIDNIGHT_STORAGE_PASSWORD environment variable is required');
    });

    test('throws error when password is too short', () => {
      process.env.MIDNIGHT_STORAGE_PASSWORD = 'short';

      expect(() => getStoragePassword()).toThrow('must be at least 16 characters long');
    });

    test('returns password when valid', () => {
      const validPassword = 'this-is-a-valid-password-123';
      process.env.MIDNIGHT_STORAGE_PASSWORD = validPassword;

      expect(getStoragePassword()).toBe(validPassword);
    });
  });
});

================
File: packages/types/src/index.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export {
  CircuitParameters,
  CircuitReturnType,
  Contract,
  getImpureCircuitIds,
  ImpureCircuit,
  ImpureCircuitId,
  ImpureCircuits,
  InitialStateParameters,
  PrivateState,
  Witness,
  Witnesses
} from './contract';
export * from './errors';
export * from './logger-provider';
export * from './midnight-provider';
export {
  BlockHash,
  createProverKey,
  createVerifierKey,
  createZKIR,
  FailEntirely,
  FailFallible,
  Fees,
  FinalizedTxData,
  ProverKey,
  SegmentFail,
  SegmentStatus,
  SegmentSuccess,
  SucceedEntirely,
  TxStatus,
  UnshieldedBalance,
  UnshieldedBalances,
  UnshieldedUtxo,
  UnshieldedUtxos,
  VerifierKey,
  ZKConfig,
  ZKIR
} from './midnight-types';
export * from './private-state-provider';
export * from './proof-provider';
export * from './providers';
export * from './public-data-provider';
export * from './wallet-provider';
export * from './zk-config-provider';
export { Transaction } from '@midnight-ntwrk/ledger-v6';

================
File: packages/types/src/midnight-types.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  type Binding,
  type ContractAddress,
  type IntentHash,
  type Proof,
  type RawTokenType,
  type SignatureEnabled,
  type Transaction,
  type TransactionHash,
  type TransactionId,
} from '@midnight-ntwrk/ledger-v6';

/**
 * A type representing a prover key derived from a contract circuit.
 */
export type ProverKey = Uint8Array & {
  /**
   * Unique symbol brand.
   */
  readonly ProverKey: unique symbol;
};
/**

 * Creates a branded prover key representation from a prover key binary.
 *
 * @param uint8Array The prover key binary.
 */
export const createProverKey = (uint8Array: Uint8Array): ProverKey => {
  return uint8Array as ProverKey;
};

/**
 * A type representing a verifier key derived from a contract circuit.
 */
export type VerifierKey = Uint8Array & {
  /**
   * Unique symbol brand.
   */
  readonly VerifierKey: unique symbol;
};

/**
 * Creates a branded verifier key representation from a verifier key binary.
 *
 * @param uint8Array The verifier key binary.
 */
export const createVerifierKey = (uint8Array: Uint8Array): VerifierKey => {
  return uint8Array as VerifierKey;
};

/**
 * A type representing a zero-knowledge circuit intermediate representation derived from a contract circuit.
 */
export type ZKIR = Uint8Array & {
  /**
   * Unique symbol brand.
   */
  readonly ZKIR: unique symbol;
};

/**
 * Creates a branded ZKIR representation from a ZKIR binary.
 *
 * @param uint8Array The ZKIR binary.
 */
export const createZKIR = (uint8Array: Uint8Array): ZKIR => {
  return uint8Array as ZKIR;
};

/**
 * Contains all information required by the {@link ProofProvider}
 * @typeParam K - The type of the circuit ID.
 */
export interface ZKConfig<K extends string> {
  /**
   * A circuit identifier.
   */
  readonly circuitId: K;
  /**
   * The prover key corresponding to {@link ZKConfig.circuitId}.
   */
  readonly proverKey: ProverKey;
  /**
   * The verifier key corresponding to {@link ZKConfig.circuitId}.
   */
  readonly verifierKey: VerifierKey;
  /**
   * The zero-knowledge intermediate representation corresponding to {@link ZKConfig.circuitId}.
   */
  readonly zkir: ZKIR;
}

/**
 * Indicates that the segment update is invalid.
 */
export const SegmentFail = 'SegmentFail' as const;

/**
 * Indicates that the segment is valid.
 */
export const SegmentSuccess = 'SegmentSuccess' as const;

/**
 * Represents the result of a segment operation, which can either be a successful operation
 * (`SegmentSuccess`) or a failed operation (`SegmentFail`).
 */
export type SegmentStatus = typeof SegmentSuccess | typeof SegmentFail;

/**
 * Indicates that the transaction is invalid.
 */
export const FailEntirely = 'FailEntirely' as const;

/**
 * Indicates that the transaction is valid but the portion of the transcript
 * that is allowed to fail (the portion after a checkpoint) did fail. All effects
 * from the guaranteed part of the transaction are kept but the effects from the
 * fallible part of the transaction are discarded.
 */
export const FailFallible = 'FailFallible' as const;

/**
 * Indicates that the guaranteed and fallible portions of the transaction were
 * successful.
 */
export const SucceedEntirely = 'SucceedEntirely' as const;

/**
 * The status of a transaction.
 */
export type TxStatus = typeof FailEntirely | typeof FailFallible | typeof SucceedEntirely;

/**
 * Represents an unshielded UTXO (Unspent Transaction Output).
 * Unshielded UTXOs are outputs that have not been shielded or encrypted, making them visible on the public ledger.
 */
export type UnshieldedUtxo = {
  /**
   * The unique identifier of the unshielded UTXO.
   */
  readonly owner: ContractAddress;
  /**
   * The identifier of the intent associated with the unshielded UTXO.
   * This is used to track the intent behind the creation or use of the UTXO.
   */
  readonly intentHash: IntentHash;
  /**
   * The type of token associated with the unshielded UTXO.
   * This indicates the kind of asset or currency represented by the UTXO.
   */
  readonly tokenType: RawTokenType;
  /**
   * The value of the unshielded UTXO, represented as a bigint.
   */
  readonly value: bigint;
}

/**
 * Represents a collection of unshielded UTXOs, which are unspent transaction outputs that are not shielded.
 * This type is used to manage and track the state of unshielded UTXOs.
 */
export type UnshieldedUtxos = {
  /**
   * Represents the unshielded UTXOs that have been created but not yet spent.
   */
  readonly created: readonly UnshieldedUtxo[];
  /**
   * Represents the unshielded UTXOs that have been spent.
   */
  readonly spent: readonly UnshieldedUtxo[];
};

/**
 * Represents the fees associated with a particular entity or operation.
 *
 * This type includes both the paid fees and the estimated fees. The paid fees represent
 * the amount that has already been settled, while the estimated fees provide a calculation
 * or projection of expected fees.
 */
export type Fees = {
  /**
   * The fees that have already been paid.
   */
  readonly paidFees: string;
  /**
   * The estimated fees that are expected to be incurred.
   */
  readonly estimatedFees: string;
};

/**
 * Block identifier
 */
export type BlockHash = string;

/**
 * Data for any finalized transaction.
 */
export interface FinalizedTxData {
  /**
   * The transaction that was finalized.
   */
  readonly tx: Transaction<SignatureEnabled, Proof, Binding>;
  /**
   * The status of a submitted transaction.
   */
  readonly status: TxStatus;
  /**
   * One of the transaction ID of the submitted transaction.
   */
  readonly txId: TransactionId;
  /**
   * All transaction IDs of the submitted transaction.
   */
  readonly identifiers: readonly TransactionId[];
  /**
   * The transaction hash of the transaction in which the original transaction was included.
   */
  readonly txHash: TransactionHash;
  /**
   * The block hash of the block in which the transaction was included.
   */
  readonly blockHash: BlockHash;
  /**
   * The block height of the block in which the transaction was included.
   */
  readonly blockHeight: number;
  /**
   * The timestamp of the block in which the transaction was included.
   */
  readonly blockTimestamp: number;
  /**
   * The author of the block in which the transaction was included.
   */
  readonly blockAuthor: string | null;
  /**
   * The indexer internal db ID.
   */
  readonly indexerId: number;
  /**
   * The protocol version of the transaction.
   */
  readonly protocolVersion: number;
  /**
   * The fees associated with the transaction, including both paid and estimated fees.
   */
  readonly fees: Fees;
  /**
   * The map that associates segment identifiers (numbers) with their corresponding status {@link SegmentStatus}.
   * The segment identifier is represented as a number (key in the map), and the status indicates the success or failure of the transaction update.
   */
  readonly segmentStatusMap: Map<number, SegmentStatus> | undefined;
  /**
   * Represents the unshielded outputs, typically used for transactions or operations
   * involving data or values that are not encrypted or concealed.
   */
  readonly unshielded: UnshieldedUtxos;
}

/**
 * Represents an unshielded balance, which is a balance that is not shielded or encrypted.
 * This type is used to track the available funds in an account that are visible on the public ledger.
 */
export type UnshieldedBalance = {
  /**
   * Represents the current number of funds available or held in an account.
   */
  readonly balance: bigint;
  /**
   * Represents the type of token in the system.
   */
  readonly tokenType: RawTokenType;
}

/**
 * Represents a collection of unshielded balances, which are balances that are not shielded or encrypted.
 */
export type UnshieldedBalances = UnshieldedBalance[];

================
File: packages/types/src/public-data-provider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ContractState } from '@midnight-ntwrk/compact-runtime';
import type { ContractAddress, TransactionId, ZswapChainState } from '@midnight-ntwrk/ledger-v6';
import type { Observable } from 'rxjs';

import type { FinalizedTxData, UnshieldedBalances } from './midnight-types';

/**
 * Streams all previous states of a contract.
 */
export type All = {
  readonly type: 'all';
}

/**
 * Streams all states of a contract starting with the most recent.
 */
export type Latest = {
  readonly type: 'latest';
}

/**
 * Starts a contract state stream at the given transaction identifier.
 */
export type TxIdConfig = {
  readonly type: 'txId';
  /**
   * The transaction identifier indicating where to begin the state stream.
   */
  readonly txId: TransactionId;
}

/**
 * Starts a contract state stream at the given block height.
 * @type
 */
export type BlockHeightConfig = {
  readonly type: 'blockHeight';
  /**
   * The block height indicating where to begin the state stream.
   */
  readonly blockHeight: number;
}

/**
 * Starts a contract state stream at the given block hash.
 */
export type BlockHashConfig = {
  readonly type: 'blockHash';
  /**
   * The block height indicating where to begin the state stream.
   */
  readonly blockHash: string;
}

/**
 * The configuration for a contract state observable. The corresponding observables may begin at different
 * places (e.g. after a specific transaction identifier / block height) depending on the configuration, but
 * all state updates after the beginning are always included.
 */
export type ContractStateObservableConfig =
  | ((TxIdConfig | BlockHashConfig | BlockHeightConfig) & {
      /**
       * If `true`, the state of the contract after the last block or transaction specified by the configuration
       * is the first value emitted. If `false`, the state of the contract after the next state update is the
       * first value emitted. If `undefined`, defaults to `true`.
       */
      readonly inclusive?: boolean;
    })
  | Latest
  | All;

/**
 * Interface for a public data service. This service retrieves public data from the blockchain.
 * TODO: Add timeouts or retry limits to 'watchFor' queries.
 */
export interface PublicDataProvider {
  /**
   * Retrieves the on-chain state of a contract. If no block hash or block height are provided, the
   * contract state at the address in the latest block is returned.
   * Immediately returns null if no matching data is found.
   * @param contractAddress The address of the contract of interest.
   * @param config The configuration of the query.
   *               If `undefined` returns the latest states.
   */
  queryContractState(
    contractAddress: ContractAddress,
    config?: BlockHeightConfig | BlockHashConfig
  ): Promise<ContractState | null>;

  /**
   * Retrieves the zswap chain state (token balances) and the contract state of the contract at the
   * given address. Both states are retrieved in a single query to ensure consistency between the two.
   * Immediately returns null if no matching data is found.
   * @param contractAddress The address of the contract of interest.
   * @param config The configuration of the query.
   *               If `undefined` returns the latest states.
   */
  queryZSwapAndContractState(
    contractAddress: ContractAddress,
    config?: BlockHeightConfig | BlockHashConfig
  ): Promise<[ZswapChainState, ContractState] | null>;

  /**
   * Retrieves the contract state included in the deployment of the contract at the given contract address.
   * Immediately returns null if no matching data is found.
   * @param contractAddress The address of the contract of interest.
   */
  queryDeployContractState(contractAddress: ContractAddress): Promise<ContractState | null>;

  /**
   * Retrieves the unshielded balances associated with a specific contract address.
   * @param contractAddress The address of the contract of interest.
   * @param config The configuration of the query.
   *               If `undefined` returns the latest states.
   */
  queryUnshieldedBalances(
    contractAddress: ContractAddress,
    config?: BlockHeightConfig | BlockHashConfig
  ): Promise<UnshieldedBalances | null>;

  /**
   * Retrieves the contract state of the contract with the given address.
   * Waits indefinitely for matching data to appear.
   * @param contractAddress The address of the contract of interest.
   */
  watchForContractState(contractAddress: ContractAddress): Promise<ContractState>;

  /**
   * Monitors for any unshielded balances associated with a specific contract address.
   *
   * @param {ContractAddress} contractAddress - The address of the contract to monitor for unshielded balances.
   * @return {Promise<UnshieldedBalances>} A promise that resolves to the detected unshielded balances.
   */
  watchForUnshieldedBalances(contractAddress: ContractAddress): Promise<UnshieldedBalances>;

  /**
   * Retrieves data of the deployment transaction for the contract at the given contract address.
   *
   * **IMPORTANT: This method waits indefinitely** until the deployment transaction appears on the
   * blockchain. It will never timeout or reject unless an error occurs.
   *
   * Custom implementations MUST maintain this indefinite waiting behavior to ensure consistency
   * across all PublicDataProvider implementations. Do not implement timeouts in this method.
   *
   * @param contractAddress The address of the contract of interest.
   *
   * @returns A promise that resolves with finalized transaction data when the deployment appears on-chain.
   *          The promise never rejects due to timeout.
   */
  watchForDeployTxData(contractAddress: ContractAddress): Promise<FinalizedTxData>;

  /**
   * Retrieves data of the transaction containing the call or deployment with the given identifier.
   *
   * **IMPORTANT: This method waits indefinitely** until the transaction appears on the blockchain.
   * It will never timeout or reject unless an error occurs.
   *
   * Custom implementations MUST maintain this indefinite waiting behavior to ensure consistency
   * across all PublicDataProvider implementations. Do not implement timeouts in this method.
   *
   * Applications using this method should be aware that:
   * - The promise will not resolve until the transaction appears on-chain
   * - If a transaction is invalid and never appears, this will never return
   * - Consider using application-level timeouts or cancellation mechanisms if needed
   *
   * @param txId The identifier of the call or deployment of interest.
   *
   * @returns A promise that resolves with finalized transaction data when the transaction appears on-chain.
   *          The promise never rejects due to timeout.
   */
  watchForTxData(txId: TransactionId): Promise<FinalizedTxData>;

  /**
   * Creates a stream of contract states. The observable emits a value every time a state is either
   * created or updated at the given address.
   * Waits indefinitely for matching data to appear.
   * @param address The address of the contract of interest.
   * @param config The configuration for the observable.
   */
  contractStateObservable(address: ContractAddress, config: ContractStateObservableConfig): Observable<ContractState>;

  /**
   * Retrieves an observable that tracks the unshielded balances for a specific contract address.
   *
   * @param {ContractAddress} address - The contract address for which unshielded balances are being observed.
   * @param {ContractStateObservableConfig} config - The configuration object for observing contract state changes.
   * @return {Observable<UnshieldedBalances>} An observable that emits the unshielded balances for the provided address.
   */
  unshieldedBalancesObservable(address: ContractAddress, config: ContractStateObservableConfig): Observable<UnshieldedBalances>;
}

================
File: packages/types/src/wallet-provider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  type CoinPublicKey,
  type EncPublicKey,
  type FinalizedTransaction,
  type ShieldedCoinInfo,
  type UnprovenTransaction,
} from '@midnight-ntwrk/ledger-v6';

export const TRANSACTION_TO_PROVE = 'TransactionToProve';
export const BALANCE_TRANSACTION_TO_PROVE = 'BalanceTransactionToProve';
export const NOTHING_TO_PROVE = 'NothingToProve';

export type TransactionToProve = {
  readonly type: typeof TRANSACTION_TO_PROVE;
  readonly transaction: UnprovenTransaction;
};

export type BalanceTransactionToProve<TTransaction> = {
  readonly type: typeof BALANCE_TRANSACTION_TO_PROVE;
  readonly transactionToProve: UnprovenTransaction;
  readonly transactionToBalance: TTransaction;
};

export type NothingToProve<TTransaction> = {
  readonly type: typeof NOTHING_TO_PROVE;
  readonly transaction: TTransaction;
};

export type ProvingRecipe<TTransaction> =
  | TransactionToProve
  | BalanceTransactionToProve<TTransaction>
  | NothingToProve<TTransaction>;

export type BalancedProvingRecipe = ProvingRecipe<UnprovenTransaction | FinalizedTransaction>;

/**
 * Interface representing a WalletProvider that handles operations such as
 * transaction balancing and finalization, and provides access to cryptographic secret keys.
 */
export interface WalletProvider {

  /**
   * Balances a transaction
   * @param tx The transaction to balance.
   * @param newCoins
   * @param ttl
   */
  balanceTx(tx: UnprovenTransaction, newCoins?: ShieldedCoinInfo[], ttl?: Date): Promise<BalancedProvingRecipe>;

  getCoinPublicKey(): CoinPublicKey;

  getEncryptionPublicKey(): EncPublicKey;
}

================
File: platform-js/platform-js/package.json
================
{
  "name": "@midnight-ntwrk/platform-js",
  "version": "2.1.0",
  "description": "Provides a set of core abstractions, utilities, and types for building services and libraries that work with the Midnight blockchain",
  "type": "module",
  "exports": {
    "./package.json": "./package.json",
    ".": "./src/index.ts",
    "./effect": "./src/effect/index.ts",
    "./effect/*": "./src/effect/*.ts",
    "./effect/internal/*": null
  },
  "dependencies": {
    "@effect/platform": "^0.92.1",
    "effect": "^3.18.4"
  },
  "devDependencies": {
    "@effect/vitest": "^0.27.0",
    "@types/node": "^24.10.1"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/midnight-ntwrk/artifacts.git"
  },
  "packageManager": "yarn@4.10.3",
  "author": "IOHK",
  "license": "Apache-2.0",
  "scripts": {
    "build": "yarn build-esm && build-utils pack-v3",
    "build-esm": "tsc -b tsconfig.build.json",
    "clean": "shx rm -rf ./build ./dist ./.tsbuildinfo ./reports ./coverage",
    "test": "vitest run",
    "deploy": "shx rm -rf ./dist/src && (cd ./dist; npm publish)"
  },
  "files": [
    "dist/"
  ]
}

================
File: scripts/release.sh
================
# This file is part of midnight-js.
# Copyright (C) 2025 Midnight Foundation
# SPDX-License-Identifier: Apache-2.0
# Licensed under the Apache License, Version 2.0 (the "License");
# You may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#!/bin/bash

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

NEW_VERSION=""
DRY_RUN=true
RUN_TESTS=false

print_usage() {
  echo "Usage: $0 <version> [--execute] [--with-tests]"
  echo ""
  echo "Options:"
  echo "  --execute     Actually execute commands (default: dry-run)"
  echo "  --with-tests  Run build and tests before release"
  echo ""
  echo "Example:"
  echo "  $0 3.0.0-alpha.2                    # Dry-run mode"
  echo "  $0 3.0.0-alpha.2 --execute          # Execute release"
  echo "  $0 3.0.0-alpha.2 --execute --with-tests  # Execute with tests"
}

log_info() {
  echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
  echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
  echo -e "${RED}[ERROR]${NC} $1"
}

execute_or_log() {
  local cmd="$1"
  if [ "$DRY_RUN" = true ]; then
    echo -e "${YELLOW}[DRY-RUN]${NC} $cmd"
  else
    log_info "Executing: $cmd"
    eval "$cmd"
  fi
}

if [ $# -lt 1 ]; then
  print_usage
  exit 1
fi

NEW_VERSION="$1"
shift

while [[ $# -gt 0 ]]; do
  case $1 in
    --execute)
      DRY_RUN=false
      shift
      ;;
    --with-tests)
      RUN_TESTS=true
      shift
      ;;
    *)
      log_error "Unknown option: $1"
      print_usage
      exit 1
      ;;
  esac
done

if [ "$DRY_RUN" = true ]; then
  log_warn "Running in DRY-RUN mode. Use --execute to actually run commands."
fi

log_info "Target version: $NEW_VERSION"

CURRENT_BRANCH=$(git branch --show-current)
if [ "$CURRENT_BRANCH" != "main" ]; then
  log_error "Must be on main branch (currently on: $CURRENT_BRANCH)"
  exit 1
fi

if [ -n "$(git status --porcelain)" ]; then
  log_error "Working directory is not clean. Commit or stash changes first."
  exit 1
fi

log_info "Step 1: Update version in root package.json"
execute_or_log "yarn version $NEW_VERSION"

log_info "Step 2: Update versions in packages/* workspaces"
PACKAGES=$(yarn workspaces list --json | jq -r 'select(.location | startswith("packages/")) | .name')
for pkg in $PACKAGES; do
  execute_or_log "yarn workspace $pkg version $NEW_VERSION"
done

log_info "Step 3: Update versions in testkit-js/* workspaces"
TESTKIT_PACKAGES=$(yarn workspaces list --json | jq -r 'select(.location | startswith("testkit-js/")) | .name')
for pkg in $TESTKIT_PACKAGES; do
  execute_or_log "yarn workspace $pkg version $NEW_VERSION"
done

log_info "Step 4: Generate changelog"
if [ "$DRY_RUN" = false ]; then
  CHANGELOG_OUTPUT=$(yarn changelog 2>&1)
  log_info "Changelog generated"
else
  execute_or_log "yarn changelog"
fi

if [ "$RUN_TESTS" = true ]; then
  log_info "Step 5: Build and test"
  execute_or_log "yarn clean-build"
  execute_or_log "yarn check"
  execute_or_log "yarn test"
else
  log_warn "Skipping build and tests (use --with-tests to include)"
fi

log_info "Step 6: Create release branch"
RELEASE_BRANCH="release/v$NEW_VERSION"
execute_or_log "git checkout -b $RELEASE_BRANCH"

log_info "Step 7: Commit changes"
execute_or_log "git add ."
execute_or_log "git commit -m 'chore(release): bump version to $NEW_VERSION'"

log_info "Step 8: Create and push tag"
execute_or_log "git tag -a v$NEW_VERSION -m 'Release v$NEW_VERSION'"
execute_or_log "git push origin $RELEASE_BRANCH"
execute_or_log "git push origin v$NEW_VERSION"

log_info "Release process completed successfully!"

if [ "$DRY_RUN" = true ]; then
  log_warn "This was a DRY-RUN. Run with --execute to perform actual release."
fi

================
File: testkit-js/testkit-js/src/wallet/midnight-wallet-provider.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  type CoinPublicKey,
  DustSecretKey,
  type EncPublicKey,
  type FinalizedTransaction,
  type ShieldedCoinInfo,
  shieldedToken,
  type TokenType,
  type UnprovenTransaction,
  ZswapSecretKeys
} from '@midnight-ntwrk/ledger-v6';
import {
  type BalancedProvingRecipe,
  type MidnightProvider,
  type WalletProvider
} from '@midnight-ntwrk/midnight-js-types';
import { ttlOneHour } from '@midnight-ntwrk/midnight-js-utils';
import { type WalletFacade } from '@midnight-ntwrk/wallet-sdk-facade';
import { generateRandomSeed } from '@midnight-ntwrk/wallet-sdk-hd';
import type { Logger } from 'pino';

import { type EnvironmentConfiguration } from '@/index';
import { getDustSeed, getShieldedSeed } from '@/wallet/wallet-seed-utils';

import { WalletBuilder } from './wallet-builder';
import { getInitialShieldedState, waitForFunds } from './wallet-utils';

/**
 * Provider class that implements wallet functionality for the Midnight network.
 * Handles transaction balancing, submission, and wallet state management.
 */
export class MidnightWalletProvider implements MidnightProvider, WalletProvider {
  logger: Logger;
  readonly env: EnvironmentConfiguration;
  readonly wallet: WalletFacade;
  readonly zswapSecretKeys: ZswapSecretKeys;
  readonly dustSecretKey: DustSecretKey;

  private constructor(
    logger: Logger,
    environmentConfiguration: EnvironmentConfiguration,
    wallet: WalletFacade,
    zswapSecretKeys: ZswapSecretKeys,
    dustSecretKey: DustSecretKey
  ) {
    this.logger = logger;
    this.env = environmentConfiguration;
    this.wallet = wallet;
    this.zswapSecretKeys = zswapSecretKeys;
    this.dustSecretKey = dustSecretKey;
  }

  getCoinPublicKey(): CoinPublicKey {
    return this.zswapSecretKeys.coinPublicKey;
  }

  getEncryptionPublicKey(): EncPublicKey {
    return this.zswapSecretKeys.encryptionPublicKey;
  }

  async balanceTx(
    tx: UnprovenTransaction,
    _newCoins: ShieldedCoinInfo[],
    ttl: Date = ttlOneHour()
  ): Promise<BalancedProvingRecipe> {
    return this.wallet.balanceTransaction(this.zswapSecretKeys, this.dustSecretKey, tx, ttl);
  }

  submitTx(tx: FinalizedTransaction): Promise<string> {
    return this.wallet.submitTransaction(tx);
  }

  async start(waitForFundsInWallet = true, tokenType: TokenType = shieldedToken()): Promise<void> {
    this.logger.info('Starting wallet...');
    await this.wallet.start(this.zswapSecretKeys, this.dustSecretKey);
    if (waitForFundsInWallet) {
      const balance = await waitForFunds(this.wallet, this.env, tokenType, true);
      this.logger.info(`Your wallet balance is: ${JSON.stringify(balance)}`);
    }
  }

  async stop(): Promise<void> {
    return this.wallet.stop();
  }

  static async build(
    logger: Logger,
    env: EnvironmentConfiguration,
    seed?: string | undefined
  ): Promise<MidnightWalletProvider> {
    const walletSeed = seed ?? Buffer.from(generateRandomSeed()).toString('hex');
    const wallet = await WalletBuilder.buildAndStartWallet(env, walletSeed);
    const initialState = await getInitialShieldedState(wallet.shielded);
    logger.info(`Your wallet seed is: ${seed} and your address is: ${initialState.address.coinPublicKeyString()}`);
    const shieldedSeed = getShieldedSeed(walletSeed);
    const dustSeed = getDustSeed(walletSeed);
    return new MidnightWalletProvider(
      logger,
      env,
      wallet,
      ZswapSecretKeys.fromSeed(shieldedSeed),
      DustSecretKey.fromSeed(dustSeed)
    );
  }

  static async withWallet(
    logger: Logger,
    env: EnvironmentConfiguration,
    wallet: WalletFacade,
    zswapSecretKeys: ZswapSecretKeys,
    dustSecretKey: DustSecretKey
  ): Promise<MidnightWalletProvider> {
    return new MidnightWalletProvider(logger, env, wallet, zswapSecretKeys, dustSecretKey);
  }
}

================
File: testkit-js/testkit-js/src/configuration.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import path from 'path';
import { Wait } from 'testcontainers';

import type { ContainersConfiguration } from './configuration-types';

const currentWorkingDir = path.resolve(`${process.cwd()}`);

export const defaultContainersConfiguration: ContainersConfiguration = {
  proofServer: {
    path: currentWorkingDir,
    fileName: 'proof-server.yml',
    container: {
      name: 'proof-server',
      port: 6300,
      waitStrategy: Wait.forListeningPorts().withStartupTimeout(3 * 60_000)
    }
  },
  standalone: {
    path: currentWorkingDir,
    fileName: 'compose.yml',
    container: {
      proofServer: {
        name: 'proof-server',
        port: 6300,
        waitStrategy: Wait.forListeningPorts().withStartupTimeout(3 * 60_000)
      },
      node: {
        name: 'node',
        port: 9944,
        waitStrategy: Wait.forListeningPorts()
      },
      indexer: {
        name: 'indexer',
        port: 8088,
        waitStrategy: Wait.forListeningPorts()
      }
    }
  },
  log: {
    fileName: `tests_${new Date().toISOString().replace(/:/g, '_')}.log`,
    path: path.resolve(currentWorkingDir, 'logs', 'tests'),
    level: 'info' as const
  }
};

export const latestContainersConfiguration: ContainersConfiguration = {
  ...defaultContainersConfiguration,
  standalone: {
    ...defaultContainersConfiguration.standalone,
    fileName: 'compose-latest.yml'
  },
  proofServer: {
    ...defaultContainersConfiguration.proofServer,
    fileName: 'proof-server-latest.yml'
  }
};

let containersConfiguration = defaultContainersConfiguration;

export const getContainersConfiguration = () => {
  return containersConfiguration;
};

export const setContainersConfiguration = (containersConfig: ContainersConfiguration) => {
  containersConfiguration = containersConfig;
};

================
File: compact-js/compact-js-node/package.json
================
{
  "name": "@midnight-ntwrk/compact-js-node",
  "version": "2.3.0",
  "description": "Platform specific types and utilities for working with the Compact language on a Node.js runtime",
  "type": "module",
  "exports": {
    "./package.json": "./package.json",
    ".": "./src/index.ts",
    "./effect": "./src/effect/index.ts",
    "./effect/*": "./src/effect/*.ts",
    "./effect/internal/*": null
  },
  "dependencies": {
    "@effect/cluster": "^0.50.4",
    "@effect/experimental": "^0.57.0",
    "@effect/platform": "^0.92.1",
    "@effect/platform-node": "^0.98.3",
    "@effect/rpc": "^0.72.0",
    "@effect/sql": "^0.48.0",
    "@effect/workflow": "^0.12.0",
    "effect": "^3.18.4"
  },
  "peerDependencies": {
    "@midnight-ntwrk/compact-js": ">=2.3.0"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/midnight-ntwrk/artifacts.git"
  },
  "packageManager": "yarn@4.10.3",
  "author": "IOHK",
  "license": "Apache-2.0",
  "scripts": {
    "build": "yarn build-esm && build-utils pack-v3",
    "build-esm": "tsc -b tsconfig.build.json",
    "clean": "shx rm -rf ./build ./dist ./.tsbuildinfo ./reports ./coverage",
    "test": "vitest run --passWithNoTests",
    "deploy": "shx rm -rf ./dist/src && (cd ./dist; npm publish)"
  },
  "files": [
    "dist/"
  ]
}

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/BalanceTransactionToProve.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / BalanceTransactionToProve

# Type Alias: BalanceTransactionToProve\<TTransaction\>

> **BalanceTransactionToProve**\<`TTransaction`\> = `object`

## Type Parameters

### TTransaction

`TTransaction`

## Properties

### transactionToBalance

> `readonly` **transactionToBalance**: `TTransaction`

***

### transactionToProve

> `readonly` **transactionToProve**: `UnprovenTransaction`

***

### type

> `readonly` **type**: *typeof* [`BALANCE_TRANSACTION_TO_PROVE`](../variables/BALANCE_TRANSACTION_TO_PROVE.md)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/variables/BALANCE_TRANSACTION_TO_PROVE.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / BALANCE\_TRANSACTION\_TO\_PROVE

# Variable: BALANCE\_TRANSACTION\_TO\_PROVE

> `const` **BALANCE\_TRANSACTION\_TO\_PROVE**: `"BalanceTransactionToProve"` = `'BalanceTransactionToProve'`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/CallTxFailedError.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallTxFailedError

# Class: CallTxFailedError

An error indicating that a call transaction was not successfully applied by the consensus node.

## Extends

- [`TxFailedError`](TxFailedError.md)

## Constructors

### Constructor

> **new CallTxFailedError**(`finalizedTxData`, `circuitId`): `CallTxFailedError`

#### Parameters

##### finalizedTxData

`FinalizedTxData`

The finalization data of the call transaction that failed.

##### circuitId

`string`

The name of the circuit that was called to build the transaction.

#### Returns

`CallTxFailedError`

#### Overrides

[`TxFailedError`](TxFailedError.md).[`constructor`](TxFailedError.md#constructor)

## Properties

### circuitId?

> `readonly` `optional` **circuitId**: `string`

The name of the circuit that was called to create the call
                 transaction that failed. Only defined if a call transaction
                 failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`circuitId`](TxFailedError.md#circuitid)

***

### finalizedTxData

> `readonly` **finalizedTxData**: `FinalizedTxData`

The finalization data of the transaction that failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`finalizedTxData`](TxFailedError.md#finalizedtxdata)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/ContractTypeError.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractTypeError

# Class: ContractTypeError

The error that is thrown when there is a contract type mismatch between a given contract type,
and the initial state that is deployed at a given contract address.

## Remarks

This error is typically thrown during calls to [findDeployedContract](../functions/findDeployedContract.md) where the supplied contract
address represents a different type of contract to the contract type given.

## Extends

- `TypeError`

## Constructors

### Constructor

> **new ContractTypeError**(`contractState`, `circuitIds`): `ContractTypeError`

Initializes a new ContractTypeError.

#### Parameters

##### contractState

`ContractState`

The initial deployed contract state.

##### circuitIds

`string`[]

The circuits that are undefined, or have a verifier key mismatch with the
                  key present in `contractState`.

#### Returns

`ContractTypeError`

#### Overrides

`TypeError.constructor`

## Properties

### circuitIds

> `readonly` **circuitIds**: `string`[]

The circuits that are undefined, or have a verifier key mismatch with the
                  key present in `contractState`.

***

### contractState

> `readonly` **contractState**: `ContractState`

The initial deployed contract state.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/DeployTxFailedError.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployTxFailedError

# Class: DeployTxFailedError

An error indicating that a deploy transaction was not successfully applied by the consensus node.

## Extends

- [`TxFailedError`](TxFailedError.md)

## Constructors

### Constructor

> **new DeployTxFailedError**(`finalizedTxData`): `DeployTxFailedError`

#### Parameters

##### finalizedTxData

`FinalizedTxData`

The finalization data of the deployment transaction that failed.

#### Returns

`DeployTxFailedError`

#### Overrides

[`TxFailedError`](TxFailedError.md).[`constructor`](TxFailedError.md#constructor)

## Properties

### circuitId?

> `readonly` `optional` **circuitId**: `string`

The name of the circuit that was called to create the call
                 transaction that failed. Only defined if a call transaction
                 failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`circuitId`](TxFailedError.md#circuitid)

***

### finalizedTxData

> `readonly` **finalizedTxData**: `FinalizedTxData`

The finalization data of the transaction that failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`finalizedTxData`](TxFailedError.md#finalizedtxdata)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/IncompleteCallTxPrivateStateConfig.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / IncompleteCallTxPrivateStateConfig

# Class: IncompleteCallTxPrivateStateConfig

An error indicating that a private state ID was specified for a call transaction while a private
state provider was not. We want to let the user know so that they aren't under the impression the
private state of a contract was updated when it wasn't.

## Extends

- `Error`

## Constructors

### Constructor

> **new IncompleteCallTxPrivateStateConfig**(): `IncompleteCallTxPrivateStateConfig`

#### Returns

`IncompleteCallTxPrivateStateConfig`

#### Overrides

`Error.constructor`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/IncompleteFindContractPrivateStateConfig.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / IncompleteFindContractPrivateStateConfig

# Class: IncompleteFindContractPrivateStateConfig

An error indicating that an initial private state was specified for a contract find while a
private state ID was not. We can't store the initial private state if we don't have a private state ID,
and we need to let the user know that.

## Extends

- `Error`

## Constructors

### Constructor

> **new IncompleteFindContractPrivateStateConfig**(): `IncompleteFindContractPrivateStateConfig`

#### Returns

`IncompleteFindContractPrivateStateConfig`

#### Overrides

`Error.constructor`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/InsertVerifierKeyTxFailedError.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / InsertVerifierKeyTxFailedError

# Class: InsertVerifierKeyTxFailedError

An error indicating that a verifier key insertion transaction failed.

## Extends

- [`TxFailedError`](TxFailedError.md)

## Constructors

### Constructor

> **new InsertVerifierKeyTxFailedError**(`finalizedTxData`): `InsertVerifierKeyTxFailedError`

#### Parameters

##### finalizedTxData

`FinalizedTxData`

#### Returns

`InsertVerifierKeyTxFailedError`

#### Overrides

[`TxFailedError`](TxFailedError.md).[`constructor`](TxFailedError.md#constructor)

## Properties

### circuitId?

> `readonly` `optional` **circuitId**: `string`

The name of the circuit that was called to create the call
                 transaction that failed. Only defined if a call transaction
                 failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`circuitId`](TxFailedError.md#circuitid)

***

### finalizedTxData

> `readonly` **finalizedTxData**: `FinalizedTxData`

The finalization data of the transaction that failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`finalizedTxData`](TxFailedError.md#finalizedtxdata)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/RemoveVerifierKeyTxFailedError.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / RemoveVerifierKeyTxFailedError

# Class: RemoveVerifierKeyTxFailedError

An error indicating that a verifier key removal transaction failed.

## Extends

- [`TxFailedError`](TxFailedError.md)

## Constructors

### Constructor

> **new RemoveVerifierKeyTxFailedError**(`finalizedTxData`): `RemoveVerifierKeyTxFailedError`

#### Parameters

##### finalizedTxData

`FinalizedTxData`

#### Returns

`RemoveVerifierKeyTxFailedError`

#### Overrides

[`TxFailedError`](TxFailedError.md).[`constructor`](TxFailedError.md#constructor)

## Properties

### circuitId?

> `readonly` `optional` **circuitId**: `string`

The name of the circuit that was called to create the call
                 transaction that failed. Only defined if a call transaction
                 failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`circuitId`](TxFailedError.md#circuitid)

***

### finalizedTxData

> `readonly` **finalizedTxData**: `FinalizedTxData`

The finalization data of the transaction that failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`finalizedTxData`](TxFailedError.md#finalizedtxdata)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/ReplaceMaintenanceAuthorityTxFailedError.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ReplaceMaintenanceAuthorityTxFailedError

# Class: ReplaceMaintenanceAuthorityTxFailedError

An error indicating that a contract maintenance authority replacement transaction failed.

## Extends

- [`TxFailedError`](TxFailedError.md)

## Constructors

### Constructor

> **new ReplaceMaintenanceAuthorityTxFailedError**(`finalizedTxData`): `ReplaceMaintenanceAuthorityTxFailedError`

#### Parameters

##### finalizedTxData

`FinalizedTxData`

#### Returns

`ReplaceMaintenanceAuthorityTxFailedError`

#### Overrides

[`TxFailedError`](TxFailedError.md).[`constructor`](TxFailedError.md#constructor)

## Properties

### circuitId?

> `readonly` `optional` **circuitId**: `string`

The name of the circuit that was called to create the call
                 transaction that failed. Only defined if a call transaction
                 failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`circuitId`](TxFailedError.md#circuitid)

***

### finalizedTxData

> `readonly` **finalizedTxData**: `FinalizedTxData`

The finalization data of the transaction that failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`finalizedTxData`](TxFailedError.md#finalizedtxdata)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/TxFailedError.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / TxFailedError

# Class: TxFailedError

An error indicating that a transaction submitted to a consensus node failed.

## Extends

- `Error`

## Extended by

- [`CallTxFailedError`](CallTxFailedError.md)
- [`DeployTxFailedError`](DeployTxFailedError.md)
- [`InsertVerifierKeyTxFailedError`](InsertVerifierKeyTxFailedError.md)
- [`RemoveVerifierKeyTxFailedError`](RemoveVerifierKeyTxFailedError.md)
- [`ReplaceMaintenanceAuthorityTxFailedError`](ReplaceMaintenanceAuthorityTxFailedError.md)

## Constructors

### Constructor

> **new TxFailedError**(`finalizedTxData`, `circuitId?`): `TxFailedError`

#### Parameters

##### finalizedTxData

`FinalizedTxData`

The finalization data of the transaction that failed.

##### circuitId?

`string`

The name of the circuit that was called to create the call
                 transaction that failed. Only defined if a call transaction
                 failed.

#### Returns

`TxFailedError`

#### Overrides

`Error.constructor`

## Properties

### circuitId?

> `readonly` `optional` **circuitId**: `string`

The name of the circuit that was called to create the call
                 transaction that failed. Only defined if a call transaction
                 failed.

***

### finalizedTxData

> `readonly` **finalizedTxData**: `FinalizedTxData`

The finalization data of the transaction that failed.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/call.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / call

# Function: call()

> **call**\<`C`, `ICK`\>(`options`): [`CallResult`](../type-aliases/CallResult.md)\<`C`, `ICK`\>

Calls a circuit in the given contract according to the given configuration.

## Type Parameters

### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

### ICK

`ICK` *extends* `string`

## Parameters

### options

[`CallOptions`](../type-aliases/CallOptions.md)\<`C`, `ICK`\>

Configuration.

## Returns

[`CallResult`](../type-aliases/CallResult.md)\<`C`, `ICK`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/callContractConstructor.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / callContractConstructor

# Function: callContractConstructor()

> **callContractConstructor**\<`C`\>(`options`): [`ContractConstructorResult`](../type-aliases/ContractConstructorResult.md)\<`C`\>

Calls the constructor of the given contract according to the given configuration.

## Type Parameters

### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

## Parameters

### options

[`ContractConstructorOptions`](../type-aliases/ContractConstructorOptions.md)\<`C`\>

Configuration.

## Returns

[`ContractConstructorResult`](../type-aliases/ContractConstructorResult.md)\<`C`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createCallTxOptions.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createCallTxOptions

# Function: createCallTxOptions()

> **createCallTxOptions**\<`C`, `ICK`\>(`contract`, `circuitId`, `contractAddress`, `privateStateId`, `args`): [`CallTxOptions`](../type-aliases/CallTxOptions.md)\<`C`, `ICK`\>

Creates a [CallTxOptions](../type-aliases/CallTxOptions.md) object from various data.

## Type Parameters

### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

### ICK

`ICK` *extends* `string`

## Parameters

### contract

`C`

### circuitId

`ICK`

### contractAddress

`string`

### privateStateId

`string` | `undefined`

### args

`CircuitParameters`\<`C`, `ICK`\>

## Returns

[`CallTxOptions`](../type-aliases/CallTxOptions.md)\<`C`, `ICK`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createCircuitCallTxInterface.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createCircuitCallTxInterface

# Function: createCircuitCallTxInterface()

> **createCircuitCallTxInterface**\<`C`\>(`providers`, `contract`, `contractAddress`, `privateStateId`): [`CircuitCallTxInterface`](../type-aliases/CircuitCallTxInterface.md)\<`C`\>

Creates a circuit call transaction interface for a contract.

## Type Parameters

### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

## Parameters

### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`\>

The providers to use to build transactions.

### contract

`C`

The contract to use to execute circuits.

### contractAddress

`string`

The ledger address of the contract.

### privateStateId

The identifier of the state of the witnesses of the contract.

`string` | `undefined`

## Returns

[`CircuitCallTxInterface`](../type-aliases/CircuitCallTxInterface.md)\<`C`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createCircuitMaintenanceTxInterface.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createCircuitMaintenanceTxInterface

# Function: createCircuitMaintenanceTxInterface()

> **createCircuitMaintenanceTxInterface**\<`C`, `ICK`\>(`providers`, `circuitId`, `contractAddress`): [`CircuitMaintenanceTxInterface`](../type-aliases/CircuitMaintenanceTxInterface.md)

Creates a [CircuitMaintenanceTxInterface](../type-aliases/CircuitMaintenanceTxInterface.md).

## Type Parameters

### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

### ICK

`ICK` *extends* `string`

## Parameters

### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`, `ICK`\>

The providers to use to create and submit transactions.

### circuitId

`ICK`

The circuit ID the interface is for.

### contractAddress

`string`

The address of the deployed contract for which this
                       interface is being created.

## Returns

[`CircuitMaintenanceTxInterface`](../type-aliases/CircuitMaintenanceTxInterface.md)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createCircuitMaintenanceTxInterfaces.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createCircuitMaintenanceTxInterfaces

# Function: createCircuitMaintenanceTxInterfaces()

> **createCircuitMaintenanceTxInterfaces**\<`C`\>(`providers`, `contract`, `contractAddress`): [`CircuitMaintenanceTxInterfaces`](../type-aliases/CircuitMaintenanceTxInterfaces.md)\<`C`\>

Creates a [CircuitMaintenanceTxInterfaces](../type-aliases/CircuitMaintenanceTxInterfaces.md).

## Type Parameters

### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

## Parameters

### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`\>

The providers to use to build transactions.

### contract

`C`

The contract to use to execute circuits.

### contractAddress

`string`

The ledger address of the contract.

## Returns

[`CircuitMaintenanceTxInterfaces`](../type-aliases/CircuitMaintenanceTxInterfaces.md)\<`C`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createContractMaintenanceTxInterface.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createContractMaintenanceTxInterface

# Function: createContractMaintenanceTxInterface()

> **createContractMaintenanceTxInterface**(`providers`, `contractAddress`): [`ContractMaintenanceTxInterface`](../interfaces/ContractMaintenanceTxInterface.md)

Creates a [ContractMaintenanceTxInterface](../interfaces/ContractMaintenanceTxInterface.md).

## Parameters

### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)

The providers to use to build transactions.

### contractAddress

`string`

The ledger address of the contract.

## Returns

[`ContractMaintenanceTxInterface`](../interfaces/ContractMaintenanceTxInterface.md)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createUnprovenCallTx.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createUnprovenCallTx

# Function: createUnprovenCallTx()

Calls a circuit using states fetched from the public data provider and private state
provider, then creates an unbalanced, unproven, unsubmitted, call transaction.

## Param

The providers to use to create the call transaction.

## Param

Configuration.

## Throws

IncompleteCallTxPrivateStateConfig If a `privateStateId` was given but a `privateStateProvider`
                                          was not. We assume that when a user gives a `privateStateId`,
                                          they want to update the private state store.

## Call Signature

> **createUnprovenCallTx**\<`C`, `ICK`\>(`providers`, `options`): `Promise`\<[`UnsubmittedCallTxData`](../type-aliases/UnsubmittedCallTxData.md)\<`C`, `ICK`\>\>

### Type Parameters

#### C

`C` *extends* `Contract`\<`undefined`, `Witnesses`\<`undefined`\>\>

#### ICK

`ICK` *extends* `string`

### Parameters

#### providers

[`UnprovenCallTxProvidersBase`](../type-aliases/UnprovenCallTxProvidersBase.md)

#### options

[`CallOptionsWithArguments`](../type-aliases/CallOptionsWithArguments.md)\<`C`, `ICK`\>

### Returns

`Promise`\<[`UnsubmittedCallTxData`](../type-aliases/UnsubmittedCallTxData.md)\<`C`, `ICK`\>\>

## Call Signature

> **createUnprovenCallTx**\<`C`, `ICK`\>(`providers`, `options`): `Promise`\<[`UnsubmittedCallTxData`](../type-aliases/UnsubmittedCallTxData.md)\<`C`, `ICK`\>\>

### Type Parameters

#### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

#### ICK

`ICK` *extends* `string`

### Parameters

#### providers

[`UnprovenCallTxProvidersWithPrivateState`](../type-aliases/UnprovenCallTxProvidersWithPrivateState.md)\<`C`\>

#### options

[`CallTxOptionsWithPrivateStateId`](../type-aliases/CallTxOptionsWithPrivateStateId.md)\<`C`, `ICK`\>

### Returns

`Promise`\<[`UnsubmittedCallTxData`](../type-aliases/UnsubmittedCallTxData.md)\<`C`, `ICK`\>\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createUnprovenCallTxFromInitialStates.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createUnprovenCallTxFromInitialStates

# Function: createUnprovenCallTxFromInitialStates()

Calls a circuit using the provided initial `states` and creates an unbalanced,
unproven, unsubmitted, call transaction.

## Param

Configuration.

## Param

## Param

## Call Signature

> **createUnprovenCallTxFromInitialStates**\<`C`, `ICK`\>(`options`, `walletCoinPublicKey`, `walletEncryptionPublicKey`): [`UnsubmittedCallTxData`](../type-aliases/UnsubmittedCallTxData.md)\<`C`, `ICK`\>

### Type Parameters

#### C

`C` *extends* `Contract`\<`undefined`, `Witnesses`\<`undefined`\>\>

#### ICK

`ICK` *extends* `string`

### Parameters

#### options

[`CallOptionsWithProviderDataDependencies`](../type-aliases/CallOptionsWithProviderDataDependencies.md)\<`C`, `ICK`\>

#### walletCoinPublicKey

`string`

#### walletEncryptionPublicKey

`string`

### Returns

[`UnsubmittedCallTxData`](../type-aliases/UnsubmittedCallTxData.md)\<`C`, `ICK`\>

## Call Signature

> **createUnprovenCallTxFromInitialStates**\<`C`, `ICK`\>(`options`, `walletCoinPublicKey`, `walletEncryptionPublicKey`): [`UnsubmittedCallTxData`](../type-aliases/UnsubmittedCallTxData.md)\<`C`, `ICK`\>

### Type Parameters

#### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

#### ICK

`ICK` *extends* `string`

### Parameters

#### options

[`CallOptionsWithPrivateState`](../type-aliases/CallOptionsWithPrivateState.md)\<`C`, `ICK`\>

#### walletCoinPublicKey

`string`

#### walletEncryptionPublicKey

`string`

### Returns

[`UnsubmittedCallTxData`](../type-aliases/UnsubmittedCallTxData.md)\<`C`, `ICK`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createUnprovenDeployTx.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createUnprovenDeployTx

# Function: createUnprovenDeployTx()

Calls a contract constructor and creates an unbalanced, unproven, unsubmitted, deploy transaction
from the constructor results.

## Param

The providers to use to create the deploy transaction.

## Param

Configuration.

## Call Signature

> **createUnprovenDeployTx**\<`C`\>(`providers`, `options`): `Promise`\<[`UnsubmittedDeployTxData`](../type-aliases/UnsubmittedDeployTxData.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* `Contract`\<`undefined`, `Witnesses`\<`undefined`\>\>

### Parameters

#### providers

[`UnprovenDeployTxProviders`](../type-aliases/UnprovenDeployTxProviders.md)\<`C`\>

#### options

[`DeployTxOptionsBase`](../type-aliases/DeployTxOptionsBase.md)\<`C`\>

### Returns

`Promise`\<[`UnsubmittedDeployTxData`](../type-aliases/UnsubmittedDeployTxData.md)\<`C`\>\>

## Call Signature

> **createUnprovenDeployTx**\<`C`\>(`providers`, `options`): `Promise`\<[`UnsubmittedDeployTxData`](../type-aliases/UnsubmittedDeployTxData.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

### Parameters

#### providers

[`UnprovenDeployTxProviders`](../type-aliases/UnprovenDeployTxProviders.md)\<`C`\>

#### options

[`DeployTxOptionsWithPrivateState`](../type-aliases/DeployTxOptionsWithPrivateState.md)\<`C`\>

### Returns

`Promise`\<[`UnsubmittedDeployTxData`](../type-aliases/UnsubmittedDeployTxData.md)\<`C`\>\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createUnprovenDeployTxFromVerifierKeys.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createUnprovenDeployTxFromVerifierKeys

# Function: createUnprovenDeployTxFromVerifierKeys()

Calls a contract constructor and creates an unbalanced, unproven, unsubmitted, deploy transaction
from the constructor results.

## Param

The verifier keys for the contract being deployed.

## Param

The Zswap coin public key of the current user.

## Param

Configuration.

## Param

## Call Signature

> **createUnprovenDeployTxFromVerifierKeys**\<`C`\>(`verifierKeys`, `coinPublicKey`, `options`, `encryptionPublicKey`): [`UnsubmittedDeployTxData`](../type-aliases/UnsubmittedDeployTxData.md)\<`C`\>

### Type Parameters

#### C

`C` *extends* `Contract`\<`undefined`, `Witnesses`\<`undefined`\>\>

### Parameters

#### verifierKeys

\[`ImpureCircuitId`\<`C`\>, `VerifierKey`\][]

#### coinPublicKey

`string`

#### options

[`DeployTxOptionsBase`](../type-aliases/DeployTxOptionsBase.md)\<`C`\>

#### encryptionPublicKey

`string`

### Returns

[`UnsubmittedDeployTxData`](../type-aliases/UnsubmittedDeployTxData.md)\<`C`\>

## Call Signature

> **createUnprovenDeployTxFromVerifierKeys**\<`C`\>(`verifierKeys`, `coinPublicKey`, `options`, `encryptionPublicKey`): [`UnsubmittedDeployTxData`](../type-aliases/UnsubmittedDeployTxData.md)\<`C`\>

### Type Parameters

#### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

### Parameters

#### verifierKeys

\[`ImpureCircuitId`\<`C`\>, `VerifierKey`\][]

#### coinPublicKey

`string`

#### options

[`DeployTxOptionsWithPrivateState`](../type-aliases/DeployTxOptionsWithPrivateState.md)\<`C`\>

#### encryptionPublicKey

`string`

### Returns

[`UnsubmittedDeployTxData`](../type-aliases/UnsubmittedDeployTxData.md)\<`C`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/deployContract.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / deployContract

# Function: deployContract()

Creates and submits a contract deployment transaction. This function is the entry point for the transaction
construction workflow and is used to create a [DeployedContract](../type-aliases/DeployedContract.md) instance.

## Param

The providers used to manage the transaction lifecycle.

## Param

Configuration.

## Throws

DeployTxFailedError If the transaction is submitted successfully but produces an error
                            when executed by the node.

## Call Signature

> **deployContract**\<`C`\>(`providers`, `options`): `Promise`\<[`DeployedContract`](../type-aliases/DeployedContract.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* `Contract`\<`undefined`, `Witnesses`\<`undefined`\>\>

### Parameters

#### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`, `ImpureCircuitId`\<`C`\>, `unknown`\>

#### options

[`DeployContractOptionsBase`](../type-aliases/DeployContractOptionsBase.md)\<`C`\>

### Returns

`Promise`\<[`DeployedContract`](../type-aliases/DeployedContract.md)\<`C`\>\>

## Call Signature

> **deployContract**\<`C`\>(`providers`, `options`): `Promise`\<[`DeployedContract`](../type-aliases/DeployedContract.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

### Parameters

#### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`\>

#### options

[`DeployContractOptionsWithPrivateState`](../type-aliases/DeployContractOptionsWithPrivateState.md)\<`C`\>

### Returns

`Promise`\<[`DeployedContract`](../type-aliases/DeployedContract.md)\<`C`\>\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/findDeployedContract.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / findDeployedContract

# Function: findDeployedContract()

Creates an instance of [FoundContract](../type-aliases/FoundContract.md) given the address of a deployed contract and an
optional private state ID at which an existing private state is stored. When given, the current value
at the private state ID is used as the `initialPrivateState` value in the `finalizedDeployTxData`
property of the returned `FoundContract`.

## Param

The providers used to manage transaction lifecycles.

## Param

Configuration.

## Throws

Error Improper `privateStateId` and `initialPrivateState` configuration.

## Throws

Error No contract state could be found at `contractAddress`.

## Throws

TypeError Thrown if `contractAddress` is not correctly formatted as a contract address.

## Throws

ContractTypeError One or more circuits defined on `contract` are undefined on the contract
                          state found at `contractAddress`, or have mis-matched verifier keys.

## Throws

IncompleteFindContractPrivateStateConfig If an `initialPrivateState` is given but no
                                                 `privateStateId` is given to store it under.

## Call Signature

> **findDeployedContract**\<`C`\>(`providers`, `options`): `Promise`\<[`FoundContract`](../type-aliases/FoundContract.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* `Contract`\<`undefined`, `Witnesses`\<`undefined`\>\>

### Parameters

#### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`, `ImpureCircuitId`\<`C`\>, `unknown`\>

#### options

[`FindDeployedContractOptionsBase`](../type-aliases/FindDeployedContractOptionsBase.md)\<`C`\>

### Returns

`Promise`\<[`FoundContract`](../type-aliases/FoundContract.md)\<`C`\>\>

## Call Signature

> **findDeployedContract**\<`C`\>(`providers`, `options`): `Promise`\<[`FoundContract`](../type-aliases/FoundContract.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

### Parameters

#### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`\>

#### options

[`FindDeployedContractOptionsExistingPrivateState`](../type-aliases/FindDeployedContractOptionsExistingPrivateState.md)\<`C`\>

### Returns

`Promise`\<[`FoundContract`](../type-aliases/FoundContract.md)\<`C`\>\>

## Call Signature

> **findDeployedContract**\<`C`\>(`providers`, `options`): `Promise`\<[`FoundContract`](../type-aliases/FoundContract.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

### Parameters

#### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`\>

#### options

[`FindDeployedContractOptionsStorePrivateState`](../type-aliases/FindDeployedContractOptionsStorePrivateState.md)\<`C`\>

### Returns

`Promise`\<[`FoundContract`](../type-aliases/FoundContract.md)\<`C`\>\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/getPublicStates.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / getPublicStates

# Function: getPublicStates()

> **getPublicStates**(`publicDataProvider`, `contractAddress`): `Promise`\<[`PublicContractStates`](../type-aliases/PublicContractStates.md)\>

Fetches only the public visible (Zswap and ledger) states of a contract.

## Parameters

### publicDataProvider

`PublicDataProvider`

The provider to use to fetch the public states (Zswap and ledger)
                          from the blockchain.

### contractAddress

`string`

The ledger address of the contract.

## Returns

`Promise`\<[`PublicContractStates`](../type-aliases/PublicContractStates.md)\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/getStates.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / getStates

# Function: getStates()

> **getStates**\<`PS`\>(`publicDataProvider`, `privateStateProvider`, `contractAddress`, `privateStateId`): `Promise`\<[`ContractStates`](../type-aliases/ContractStates.md)\<`PS`\>\>

Retrieves the Zswap, ledger, and private states of the contract corresponding
to the given identifier using the given providers.

## Type Parameters

### PS

`PS`

## Parameters

### publicDataProvider

`PublicDataProvider`

The provider to use to fetch the public states (Zswap and ledger)
                          from the blockchain.

### privateStateProvider

`PrivateStateProvider`\<`string`, `PS`\>

The provider to use to fetch the private state.

### contractAddress

`string`

The ledger address of the contract.

### privateStateId

`string`

The identifier for the private state of the contract.

## Returns

`Promise`\<[`ContractStates`](../type-aliases/ContractStates.md)\<`PS`\>\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/getUnshieldedBalances.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / getUnshieldedBalances

# Function: getUnshieldedBalances()

> **getUnshieldedBalances**(`publicDataProvider`, `contractAddress`): `Promise`\<`UnshieldedBalances`\>

Fetches the unshielded balances associated with a specific contract address.

## Parameters

### publicDataProvider

`PublicDataProvider`

The provider to use to fetch the unshielded balances from the blockchain.

### contractAddress

`string`

The ledger address of the contract.

## Returns

`Promise`\<`UnshieldedBalances`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/submitCallTx.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / submitCallTx

# Function: submitCallTx()

Creates and submits a transaction for the invocation of a circuit on a given contract.

## Transaction Execution Phases

Midnight transactions execute in two phases:
1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success

## Failure Behavior

**Guaranteed Phase Failure:**
- Transaction is rejected and not included in the blockchain
- `CallTxFailedError` is thrown with transaction data and circuit ID
- Private state updates are NOT stored (state remains unchanged)
- No on-chain record of the failed transaction

**Fallible Phase Failure:**
- Transaction is recorded on-chain with non-`SucceedEntirely` status
- `CallTxFailedError` is thrown with transaction data and circuit ID
- Private state updates are NOT stored (state remains unchanged)
- Transaction appears in blockchain history as partial success

## Param

The providers used to manage the invocation lifecycle.

## Param

Configuration.

## Throws

When transaction fails in either guaranteed or fallible phase.
        The error contains the finalized transaction data and circuit ID for debugging.

## Call Signature

> **submitCallTx**\<`C`, `ICK`\>(`providers`, `options`): `Promise`\<[`FinalizedCallTxData`](../type-aliases/FinalizedCallTxData.md)\<`C`, `ICK`\>\>

### Type Parameters

#### C

`C` *extends* `Contract`\<`undefined`, `Witnesses`\<`undefined`\>\>

#### ICK

`ICK` *extends* `string`

### Parameters

#### providers

[`SubmitTxProviders`](../type-aliases/SubmitTxProviders.md)\<`C`, `ICK`\>

#### options

[`CallTxOptionsBase`](../type-aliases/CallTxOptionsBase.md)\<`C`, `ICK`\>

### Returns

`Promise`\<[`FinalizedCallTxData`](../type-aliases/FinalizedCallTxData.md)\<`C`, `ICK`\>\>

## Call Signature

> **submitCallTx**\<`C`, `ICK`\>(`providers`, `options`): `Promise`\<[`FinalizedCallTxData`](../type-aliases/FinalizedCallTxData.md)\<`C`, `ICK`\>\>

### Type Parameters

#### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

#### ICK

`ICK` *extends* `string`

### Parameters

#### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`\>

#### options

[`CallTxOptionsWithPrivateStateId`](../type-aliases/CallTxOptionsWithPrivateStateId.md)\<`C`, `ICK`\>

### Returns

`Promise`\<[`FinalizedCallTxData`](../type-aliases/FinalizedCallTxData.md)\<`C`, `ICK`\>\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/submitDeployTx.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / submitDeployTx

# Function: submitDeployTx()

Creates and submits a deploy transaction for the given contract.

## Transaction Execution Phases

Midnight transactions execute in two phases:
1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success

## Failure Behavior

**Guaranteed Phase Failure:**
- Transaction is rejected and not included in the blockchain
- `DeployTxFailedError` is thrown with transaction data
- Private state (if `privateStateId` provided) is NOT stored
- Contract signing key is NOT stored in private state provider
- Contract is NOT deployed

**Fallible Phase Failure:**
- Transaction is recorded on-chain with non-`SucceedEntirely` status
- `DeployTxFailedError` is thrown with transaction data
- Private state (if `privateStateId` provided) is NOT stored
- Contract signing key is NOT stored in private state provider
- Transaction appears in blockchain history as partial success
- Contract may be partially deployed but not functional

## Param

The providers used to manage the deploy lifecycle.

## Param

Configuration.

## Throws

When transaction fails in either guaranteed or fallible phase.
        The error contains the finalized transaction data for debugging.

## Call Signature

> **submitDeployTx**\<`C`\>(`providers`, `options`): `Promise`\<[`FinalizedDeployTxData`](../type-aliases/FinalizedDeployTxData.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* `Contract`\<`undefined`, `Witnesses`\<`undefined`\>\>

### Parameters

#### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`, `ImpureCircuitId`\<`C`\>, `unknown`\>

#### options

[`DeployTxOptionsBase`](../type-aliases/DeployTxOptionsBase.md)\<`C`\>

### Returns

`Promise`\<[`FinalizedDeployTxData`](../type-aliases/FinalizedDeployTxData.md)\<`C`\>\>

## Call Signature

> **submitDeployTx**\<`C`\>(`providers`, `options`): `Promise`\<[`FinalizedDeployTxData`](../type-aliases/FinalizedDeployTxData.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

### Parameters

#### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`\>

#### options

[`DeployTxOptionsWithPrivateStateId`](../type-aliases/DeployTxOptionsWithPrivateStateId.md)\<`C`\>

### Returns

`Promise`\<[`FinalizedDeployTxData`](../type-aliases/FinalizedDeployTxData.md)\<`C`\>\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/submitInsertVerifierKeyTx.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / submitInsertVerifierKeyTx

# Function: submitInsertVerifierKeyTx()

> **submitInsertVerifierKeyTx**(`providers`, `contractAddress`, `circuitId`, `newVk`): `Promise`\<`FinalizedTxData`\>

Constructs and submits a transaction that adds a new verifier key to the
blockchain for the given circuit ID at the given contract address.

## Transaction Execution Phases

Midnight transactions execute in two phases:
1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success

## Failure Behavior

**Guaranteed Phase Failure:**
- Transaction is rejected and not included in the blockchain
- `InsertVerifierKeyTxFailedError` is thrown with transaction data
- Verifier key is NOT added to the contract
- No on-chain record of the failed transaction

**Fallible Phase Failure:**
- Transaction is recorded on-chain with non-`SucceedEntirely` status
- `InsertVerifierKeyTxFailedError` is thrown with transaction data
- Verifier key may be partially added but not usable
- Transaction appears in blockchain history as partial success

## Parameters

### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)

The providers to use to manage the transaction lifecycle.

### contractAddress

`string`

The address of the contract containing the circuit for which
                       the verifier key should be inserted.

### circuitId

`string`

The circuit for which the verifier key should be inserted.

### newVk

`VerifierKey`

The new verifier key for the circuit.

## Returns

`Promise`\<`FinalizedTxData`\>

A promise that resolves with the finalized transaction data, or rejects if
         an error occurs along the way.

## Throws

When transaction fails in either guaranteed or fallible phase.
        The error contains the finalized transaction data for debugging.

TODO: We'll likely want to modify ZKConfigProvider provider so that the verifier keys are
      automatically rotated in this function. This likely involves storing key versions
      along with keys in ZKConfigProvider. By default, artifacts for the latest version
      would be fetched to build transactions.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/submitRemoveVerifierKeyTx.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / submitRemoveVerifierKeyTx

# Function: submitRemoveVerifierKeyTx()

> **submitRemoveVerifierKeyTx**(`providers`, `contractAddress`, `circuitId`): `Promise`\<`FinalizedTxData`\>

Constructs and submits a transaction that removes the current verifier key stored
on the blockchain for the given circuit ID at the given contract address.

## Transaction Execution Phases

Midnight transactions execute in two phases:
1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success

## Failure Behavior

**Guaranteed Phase Failure:**
- Transaction is rejected and not included in the blockchain
- `RemoveVerifierKeyTxFailedError` is thrown with transaction data
- Verifier key remains on the contract (unchanged)
- No on-chain record of the failed transaction

**Fallible Phase Failure:**
- Transaction is recorded on-chain with non-`SucceedEntirely` status
- `RemoveVerifierKeyTxFailedError` is thrown with transaction data
- Verifier key may be partially removed but contract state is inconsistent
- Transaction appears in blockchain history as partial success

## Parameters

### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)

The providers to use to manage the transaction lifecycle.

### contractAddress

`string`

The address of the contract containing the circuit for which
                       the verifier key should be removed.

### circuitId

`string`

The circuit for which the verifier key should be removed.

## Returns

`Promise`\<`FinalizedTxData`\>

A promise that resolves with the finalized transaction data, or rejects if
         an error occurs along the way.

## Throws

When transaction fails in either guaranteed or fallible phase.
        The error contains the finalized transaction data for debugging.

TODO: We'll likely want to modify ZKConfigProvider provider so that the verifier keys are
      automatically rotated in this function. This likely involves storing key versions
      along with keys in ZKConfigProvider. By default, artifacts for the latest version
      would be fetched to build transactions.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/submitReplaceAuthorityTx.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / submitReplaceAuthorityTx

# Function: submitReplaceAuthorityTx()

> **submitReplaceAuthorityTx**(`providers`, `contractAddress`): (`newAuthority`) => `Promise`\<`FinalizedTxData`\>

Constructs and submits a transaction that replaces the maintenance
authority stored on the blockchain for this contract. After the transaction is
finalized, the current signing key stored in the given private state provider
is overwritten with the given new authority key.

## Transaction Execution Phases

Midnight transactions execute in two phases:
1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success

## Failure Behavior

**Guaranteed Phase Failure:**
- Transaction is rejected and not included in the blockchain
- `ReplaceMaintenanceAuthorityTxFailedError` is thrown with transaction data
- Signing key in private state provider is NOT updated (remains as current authority)
- Contract authority on-chain remains unchanged

**Fallible Phase Failure:**
- Transaction is recorded on-chain with non-`SucceedEntirely` status
- `ReplaceMaintenanceAuthorityTxFailedError` is thrown with transaction data
- Signing key in private state provider is NOT updated (remains as current authority)
- Contract authority on-chain may be partially updated but inconsistent
- Transaction appears in blockchain history as partial success

## Parameters

### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)

The providers to use to manage the transaction lifecycle.

### contractAddress

`string`

The address of the contract for which the maintenance
                       authority should be updated.

TODO: There are at least three options we should support in the future:
      1. Replace authority and maintain key (current).
      2. Replace authority and do not maintain key.
      3. Add additional authorities and maintain original key.

## Returns

> (`newAuthority`): `Promise`\<`FinalizedTxData`\>

### Parameters

#### newAuthority

`string`

The signing key of the new contract maintenance authority.

### Returns

`Promise`\<`FinalizedTxData`\>

A promise that resolves with the finalized transaction data, or rejects if
         an error occurs along the way.

### Throws

When transaction fails in either guaranteed or fallible phase.
        The error contains the finalized transaction data for debugging.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/submitTx.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / submitTx

# Function: submitTx()

> **submitTx**\<`C`, `ICK`\>(`providers`, `options`): `Promise`\<`FinalizedTxData`\>

Proves, balances, and submits an unproven deployment or call transaction using
the given providers, according to the given options.

## Blocking Behavior

This method **waits indefinitely** for the transaction to appear on the blockchain via
`providers.publicDataProvider.watchForTxData(txId)`. It will not return until:
- The transaction is successfully included in the blockchain, OR
- An error occurs during proving, balancing, or submission

## Conditions When Transaction May Not Appear

A submitted transaction may fail to appear on-chain if:
- Transaction is invalid in ways not detected during local validation
- Network issues prevent propagation to validators
- Transaction is rejected by validator consensus
- Insufficient fees or resources
- Contract state has changed making the transaction invalid

## Implications of Aborting This Method

If the application terminates this method before it returns:
- Transaction may still be pending/processing on-chain
- **Private state updates are NOT stored** (even if transaction later succeeds on-chain)
- **Signing keys are NOT updated** (for deploy/replace authority transactions)
- Application state will be out of sync with blockchain state
- Manual recovery may be required to reconcile state

**Recommendation**: Use [submitTxAsync](submitTxAsync.md) for non-blocking submission with manual
finalization handling and timeout control.

## Type Parameters

### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

### ICK

`ICK` *extends* `string`

## Parameters

### providers

[`SubmitTxProviders`](../type-aliases/SubmitTxProviders.md)\<`C`, `ICK`\>

The providers used to manage the transaction lifecycle.

### options

[`SubmitTxOptions`](../type-aliases/SubmitTxOptions.md)\<`ICK`\>

Configuration.

## Returns

`Promise`\<`FinalizedTxData`\>

A promise that resolves with the finalized transaction data for the invocation,
         or rejects if an error occurs along the way.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/verifierKeysEqual.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / verifierKeysEqual

# Function: verifierKeysEqual()

> **verifierKeysEqual**(`a`, `b`): `boolean`

Checks that two verifier keys are equal. Does initial length check match for efficiency.

## Parameters

### a

`Uint8Array`

First verifier key.

### b

`Uint8Array`

Second verifier key.

## Returns

`boolean`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/verifyContractState.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / verifyContractState

# Function: verifyContractState()

> **verifyContractState**(`verifierKeys`, `contractState`): `void`

Checks that the given `contractState` contains the given `verifierKeys`.

## Parameters

### verifierKeys

\[`string`, `VerifierKey`\][]

The verifier keys the client has for the deployed contract we're checking.

### contractState

`ContractState`

The (typically already deployed) contract state containing verifier keys.

## Returns

`void`

## Throws

ContractTypeError When one or more of the local and deployed verifier keys do not match.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/interfaces/ContractMaintenanceTxInterface.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractMaintenanceTxInterface

# Interface: ContractMaintenanceTxInterface

Interface for creating maintenance transactions for a contract that was
deployed.

## Methods

### replaceAuthority()

> **replaceAuthority**(`newAuthority`): `Promise`\<`FinalizedTxData`\>

Constructs and submits a transaction that replaces the maintenance
authority stored on the blockchain for this contract.

#### Parameters

##### newAuthority

`string`

The new contract maintenance authority for this contract.

#### Returns

`Promise`\<`FinalizedTxData`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallOptions.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallOptions

# Type Alias: CallOptions\<C, ICK\>

> **CallOptions**\<`C`, `ICK`\> = [`CallOptionsWithProviderDataDependencies`](CallOptionsWithProviderDataDependencies.md)\<`C`, `ICK`\> \| [`CallOptionsWithPrivateState`](CallOptionsWithPrivateState.md)\<`C`, `ICK`\>

Call options for a given contract and circuit.

## Type Parameters

### C

`C` *extends* `Contract`

### ICK

`ICK` *extends* `ImpureCircuitId`\<`C`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallOptionsBase.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallOptionsBase

# Type Alias: CallOptionsBase\<C, ICK\>

> **CallOptionsBase**\<`C`, `ICK`\> = `object`

Describes the target of a circuit invocation.

## Type Parameters

### C

`C` *extends* `Contract`

### ICK

`ICK` *extends* `ImpureCircuitId`\<`C`\>

## Properties

### circuitId

> `readonly` **circuitId**: `ICK`

The identifier of the circuit to call.

***

### contract

> `readonly` **contract**: `C`

The contract defining the circuit to call.

***

### contractAddress

> `readonly` **contractAddress**: `ContractAddress`

The address of the contract being executed.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallOptionsProviderDataDependencies.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallOptionsProviderDataDependencies

# Type Alias: CallOptionsProviderDataDependencies

> **CallOptionsProviderDataDependencies** = `object`

Data retrieved via providers that should be included in the call options.

## Properties

### coinPublicKey

> `readonly` **coinPublicKey**: `CoinPublicKey`

The Zswap public key of the current user.

***

### initialContractState

> `readonly` **initialContractState**: `ContractState`

The initial public state of the contract to run the circuit against.

***

### initialZswapChainState

> `readonly` **initialZswapChainState**: `ZswapChainState`

The initial public Zswap state of the contract to run the circuit against.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallOptionsWithArguments.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallOptionsWithArguments

# Type Alias: CallOptionsWithArguments\<C, ICK\>

> **CallOptionsWithArguments**\<`C`, `ICK`\> = `CircuitParameters`\<`C`, `ICK`\> *extends* \[\] ? [`CallOptionsBase`](CallOptionsBase.md)\<`C`, `ICK`\> : [`CallOptionsBase`](CallOptionsBase.md)\<`C`, `ICK`\> & `object`

Conditional type that optionally adds the inferred circuit argument types to
the options for a circuit call.

## Type Parameters

### C

`C` *extends* `Contract`

### ICK

`ICK` *extends* `ImpureCircuitId`\<`C`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallOptionsWithPrivateState.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallOptionsWithPrivateState

# Type Alias: CallOptionsWithPrivateState\<C, ICK\>

> **CallOptionsWithPrivateState**\<`C`, `ICK`\> = [`CallOptionsWithProviderDataDependencies`](CallOptionsWithProviderDataDependencies.md)\<`C`, `ICK`\> & `object`

Call options for contracts with private state.

## Type Declaration

### initialPrivateState

> `readonly` **initialPrivateState**: `PrivateState`\<`C`\>

The private state to run the circuit against.

## Type Parameters

### C

`C` *extends* `Contract`

### ICK

`ICK` *extends* `ImpureCircuitId`\<`C`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallOptionsWithProviderDataDependencies.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallOptionsWithProviderDataDependencies

# Type Alias: CallOptionsWithProviderDataDependencies\<C, ICK\>

> **CallOptionsWithProviderDataDependencies**\<`C`, `ICK`\> = [`CallOptionsWithArguments`](CallOptionsWithArguments.md)\<`C`, `ICK`\> & [`CallOptionsProviderDataDependencies`](CallOptionsProviderDataDependencies.md)

Call options with circuit arguments and data

## Type Parameters

### C

`C` *extends* `Contract`

### ICK

`ICK` *extends* `ImpureCircuitId`\<`C`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallResult.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallResult

# Type Alias: CallResult\<C, ICK\>

> **CallResult**\<`C`, `ICK`\> = `object`

Contains all information resulting from circuit execution.

## Type Parameters

### C

`C` *extends* `Contract`

### ICK

`ICK` *extends* `ImpureCircuitId`\<`C`\>

## Properties

### private

> `readonly` **private**: [`CallResultPrivate`](CallResultPrivate.md)\<`C`, `ICK`\>

The private/sensitive data produced by the circuit execution.

***

### public

> `readonly` **public**: [`CallResultPublic`](CallResultPublic.md)

The public/non-sensitive data produced by the circuit execution.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallResultPrivate.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallResultPrivate

# Type Alias: CallResultPrivate\<C, ICK\>

> **CallResultPrivate**\<`C`, `ICK`\> = `object`

The private (sensitive) portions of the call result.

## Type Parameters

### C

`C` *extends* `Contract`

### ICK

`ICK` *extends* `ImpureCircuitId`\<`C`\>

## Properties

### input

> `readonly` **input**: `AlignedValue`

ZK representation of the circuit arguments.

***

### nextPrivateState

> `readonly` **nextPrivateState**: `PrivateState`\<`C`\>

The private state resulting from executing the circuit.

***

### nextZswapLocalState

> `readonly` **nextZswapLocalState**: `ZswapLocalState`

The Zswap local state resulting from executing the circuit.

***

### output

> `readonly` **output**: `AlignedValue`

ZK representation of the circuit result.

***

### privateTranscriptOutputs

> `readonly` **privateTranscriptOutputs**: `AlignedValue`[]

ZK representation of the circuit witness call results.

***

### result

> `readonly` **result**: `CircuitReturnType`\<`C`, `ICK`\>

The JS representation of the input to the circuit.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallResultPublic.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallResultPublic

# Type Alias: CallResultPublic

> **CallResultPublic** = `object`

The public portions of the call result.

## Properties

### nextContractState

> `readonly` **nextContractState**: `StateValue`

The public state resulting from executing the circuit.

***

### partitionedTranscript

> `readonly` **partitionedTranscript**: `PartitionedTranscript`

A [publicTranscript](#publictranscript) partitioned into guaranteed and fallible sections.
The guaranteed section of a public transcript must succeed for the corresponding
transaction to be considered valid. The fallible section of a public transcript
can fail without invalidating the transaction, as long as the guaranteed section succeeds.

***

### publicTranscript

> `readonly` **publicTranscript**: `Op`\<`AlignedValue`\>[]

The public transcript resulting from executing the circuit.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallTxOptions.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallTxOptions

# Type Alias: CallTxOptions\<C, ICK\>

> **CallTxOptions**\<`C`, `ICK`\> = [`CallTxOptionsBase`](CallTxOptionsBase.md)\<`C`, `ICK`\> \| [`CallTxOptionsWithPrivateStateId`](CallTxOptionsWithPrivateStateId.md)\<`C`, `ICK`\>

Call transaction configuration.

## Type Parameters

### C

`C` *extends* `Contract`

### ICK

`ICK` *extends* `ImpureCircuitId`\<`C`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallTxOptionsBase.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallTxOptionsBase

# Type Alias: CallTxOptionsBase\<C, ICK\>

> **CallTxOptionsBase**\<`C`, `ICK`\> = [`CallOptionsWithArguments`](CallOptionsWithArguments.md)\<`C`, `ICK`\>

Base type for configuration for a call transaction; identical to [CallOptionsWithArguments](CallOptionsWithArguments.md).

## Type Parameters

### C

`C` *extends* `Contract`

### ICK

`ICK` *extends* `ImpureCircuitId`\<`C`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallTxOptionsWithPrivateStateId.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallTxOptionsWithPrivateStateId

# Type Alias: CallTxOptionsWithPrivateStateId\<C, ICK\>

> **CallTxOptionsWithPrivateStateId**\<`C`, `ICK`\> = [`CallTxOptionsBase`](CallTxOptionsBase.md)\<`C`, `ICK`\> & `object`

Call transaction options with the private state ID to use to store the new private
state resulting from the circuit call. Since a private state should already be
stored at the given private state ID, we don't need an 'initialPrivateState' like
in [DeployTxOptionsWithPrivateState](DeployTxOptionsWithPrivateState.md).

## Type Declaration

### privateStateId

> `readonly` **privateStateId**: `PrivateStateId`

The identifier for the private state of the contract.

## Type Parameters

### C

`C` *extends* `Contract`

### ICK

`ICK` *extends* `ImpureCircuitId`\<`C`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CircuitCallTxInterface.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CircuitCallTxInterface

# Type Alias: CircuitCallTxInterface\<C\>

> **CircuitCallTxInterface**\<`C`\> = `{ [ICK in ImpureCircuitId<C>]: (args: CircuitParameters<C, ICK>) => Promise<FinalizedCallTxData<C, ICK>> }`

A type that lifts each circuit defined in a contract to a function that builds
and submits a call transaction.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CircuitMaintenanceTxInterface.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CircuitMaintenanceTxInterface

# Type Alias: CircuitMaintenanceTxInterface

> **CircuitMaintenanceTxInterface** = `object`

An interface for creating maintenance transactions for a specific circuit defined in a
given contract.

## Methods

### insertVerifierKey()

> **insertVerifierKey**(`newVk`): `Promise`\<`FinalizedTxData`\>

Constructs and submits a transaction that adds a new verifier key to the
blockchain for this circuit at this contract's address.

#### Parameters

##### newVk

`VerifierKey`

The new verifier key to add for this circuit.

#### Returns

`Promise`\<`FinalizedTxData`\>

***

### removeVerifierKey()

> **removeVerifierKey**(): `Promise`\<`FinalizedTxData`\>

Constructs and submits a transaction that removes the current verifier key stored
on the blockchain for this circuit at this contract's address.

#### Returns

`Promise`\<`FinalizedTxData`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CircuitMaintenanceTxInterfaces.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CircuitMaintenanceTxInterfaces

# Type Alias: CircuitMaintenanceTxInterfaces\<C\>

> **CircuitMaintenanceTxInterfaces**\<`C`\> = `Record`\<`ImpureCircuitId`\<`C`\>, [`CircuitMaintenanceTxInterface`](CircuitMaintenanceTxInterface.md)\>

A set of maintenance transaction creation interfaces, one for each circuit defined in
a given contract, keyed by the circuit name.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractConstructorOptions.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractConstructorOptions

# Type Alias: ContractConstructorOptions\<C\>

> **ContractConstructorOptions**\<`C`\> = [`ContractConstructorOptionsWithProviderDataDependencies`](ContractConstructorOptionsWithProviderDataDependencies.md)\<`C`\> \| [`ContractConstructorOptionsWithPrivateState`](ContractConstructorOptionsWithPrivateState.md)\<`C`\>

Conditional type that optionally adds the inferred circuit argument types to
the target of a circuit invocation.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractConstructorOptionsBase.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractConstructorOptionsBase

# Type Alias: ContractConstructorOptionsBase\<C\>

> **ContractConstructorOptionsBase**\<`C`\> = `object`

Describes the target of a circuit invocation.

## Type Parameters

### C

`C` *extends* `Contract`

## Properties

### contract

> `readonly` **contract**: `C`

The contract defining the circuit to call.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractConstructorOptionsProviderDataDependencies.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractConstructorOptionsProviderDataDependencies

# Type Alias: ContractConstructorOptionsProviderDataDependencies

> **ContractConstructorOptionsProviderDataDependencies** = `object`

Data retrieved via providers that should be included in the constructor call options.

## Properties

### coinPublicKey

> `readonly` **coinPublicKey**: `CoinPublicKey`

The current user's ZSwap public key.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractConstructorOptionsWithArguments.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractConstructorOptionsWithArguments

# Type Alias: ContractConstructorOptionsWithArguments\<C\>

> **ContractConstructorOptionsWithArguments**\<`C`\> = `InitialStateParameters`\<`C`\> *extends* \[\] ? [`ContractConstructorOptionsBase`](ContractConstructorOptionsBase.md)\<`C`\> : [`ContractConstructorOptionsBase`](ContractConstructorOptionsBase.md)\<`C`\> & `object`

Conditional type that optionally adds the inferred contract constructor argument types
to the constructor options.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractConstructorOptionsWithPrivateState.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractConstructorOptionsWithPrivateState

# Type Alias: ContractConstructorOptionsWithPrivateState\<C\>

> **ContractConstructorOptionsWithPrivateState**\<`C`\> = [`ContractConstructorOptionsWithProviderDataDependencies`](ContractConstructorOptionsWithProviderDataDependencies.md)\<`C`\> & `object`

Conditional type that optionally adds the inferred circuit argument types to
the target of a circuit invocation.

## Type Declaration

### initialPrivateState

> `readonly` **initialPrivateState**: `PrivateState`\<`C`\>

The private state to run the circuit against.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractConstructorOptionsWithProviderDataDependencies.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractConstructorOptionsWithProviderDataDependencies

# Type Alias: ContractConstructorOptionsWithProviderDataDependencies\<C\>

> **ContractConstructorOptionsWithProviderDataDependencies**\<`C`\> = [`ContractConstructorOptionsWithArguments`](ContractConstructorOptionsWithArguments.md)\<`C`\> & [`ContractConstructorOptionsProviderDataDependencies`](ContractConstructorOptionsProviderDataDependencies.md)

Contract constructor options including arguments and provider data.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractConstructorResult.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractConstructorResult

# Type Alias: ContractConstructorResult\<C\>

> **ContractConstructorResult**\<`C`\> = `object`

The updated states resulting from executing a contract constructor.

## Type Parameters

### C

`C` *extends* `Contract`

## Properties

### nextContractState

> `readonly` **nextContractState**: `ContractState`

The public state resulting from executing the contract constructor.

***

### nextPrivateState

> `readonly` **nextPrivateState**: `PrivateState`\<`C`\>

The private state resulting from executing the contract constructor.

***

### nextZswapLocalState

> `readonly` **nextZswapLocalState**: `ZswapLocalState`

The Zswap local state resulting from executing the contract constructor.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractProviders.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractProviders

# Type Alias: ContractProviders\<C, ICK, PS\>

> **ContractProviders**\<`C`, `ICK`, `PS`\> = `MidnightProviders`\<`ICK`, `PrivateStateId`, `PS`\>

Convenience type for representing the set of providers necessary to use
a given contract.

## Type Parameters

### C

`C` *extends* `Contract` = `Contract`

### ICK

`ICK` *extends* `ImpureCircuitId`\<`C`\> = `ImpureCircuitId`\<`C`\>

### PS

`PS` = `PrivateState`\<`C`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractStates.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractStates

# Type Alias: ContractStates\<PS\>

> **ContractStates**\<`PS`\> = [`PublicContractStates`](PublicContractStates.md) & `object`

Object containing the publicly visible states of a contract and the private
state of a contract.

## Type Declaration

### privateState

> `readonly` **privateState**: `PS`

The private state of a contract.

## Type Parameters

### PS

`PS`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployContractOptions.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployContractOptions

# Type Alias: DeployContractOptions\<C\>

> **DeployContractOptions**\<`C`\> = [`DeployContractOptionsBase`](DeployContractOptionsBase.md)\<`C`\> \| [`DeployContractOptionsWithPrivateState`](DeployContractOptionsWithPrivateState.md)\<`C`\>

Configuration for [deployContract](../functions/deployContract.md).

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployContractOptionsBase.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployContractOptionsBase

# Type Alias: DeployContractOptionsBase\<C\>

> **DeployContractOptionsBase**\<`C`\> = [`ContractConstructorOptionsWithArguments`](ContractConstructorOptionsWithArguments.md)\<`C`\> & `object`

Base type for configuration for [deployContract](../functions/deployContract.md); identical to
[ContractConstructorOptionsWithArguments](ContractConstructorOptionsWithArguments.md) except the `signingKey` is
now optional, since [deployContract](../functions/deployContract.md) will generate a fresh signing key
in the event that `signingKey` is undefined.

## Type Declaration

### signingKey?

> `readonly` `optional` **signingKey**: `SigningKey`

The signing key to add as the to-be-deployed contract's maintenance authority.
If undefined, a new signing key is sampled and used as the CMA then stored
in the private state provider under the newly deployed contract's address.
Otherwise, the passed signing key is added as the CMA. The second case is
useful when you want to use the same CMA for two different contracts.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployContractOptionsWithPrivateState.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployContractOptionsWithPrivateState

# Type Alias: DeployContractOptionsWithPrivateState\<C\>

> **DeployContractOptionsWithPrivateState**\<`C`\> = [`DeployContractOptionsBase`](DeployContractOptionsBase.md)\<`C`\> & `object`

[deployContract](../functions/deployContract.md) base options with information needed to store private states;
only used if the contract being deployed has a private state.

## Type Declaration

### initialPrivateState

> `readonly` **initialPrivateState**: `PrivateState`\<`C`\>

The private state to run the circuit against.

### privateStateId

> `readonly` **privateStateId**: `PrivateStateId`

An identifier for the private state of the contract being found.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployedContract.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployedContract

# Type Alias: DeployedContract\<C\>

> **DeployedContract**\<`C`\> = [`FoundContract`](FoundContract.md)\<`C`\> & `object`

Interface for a contract that has been deployed to the blockchain.

## Type Declaration

### deployTxData

> `readonly` **deployTxData**: [`FinalizedDeployTxData`](FinalizedDeployTxData.md)\<`C`\>

Data resulting from the deployment transaction that created this contract. The information in a
deployTxData contains additional private information that does not
exist in [FoundContract.deployTxData](FoundContract.md#deploytxdata) because certain private data is only available to
the deployer of a contract.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployTxOptions.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployTxOptions

# Type Alias: DeployTxOptions\<C\>

> **DeployTxOptions**\<`C`\> = [`DeployTxOptionsBase`](DeployTxOptionsBase.md)\<`C`\> \| [`DeployTxOptionsWithPrivateStateId`](DeployTxOptionsWithPrivateStateId.md)\<`C`\>

Configuration for creating deploy transactions.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployTxOptionsBase.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployTxOptionsBase

# Type Alias: DeployTxOptionsBase\<C\>

> **DeployTxOptionsBase**\<`C`\> = [`ContractConstructorOptionsWithArguments`](ContractConstructorOptionsWithArguments.md)\<`C`\> & `object`

Base type for deploy transaction configuration.

## Type Declaration

### signingKey

> `readonly` **signingKey**: `SigningKey`

The signing key to add as the to-be-deployed contract's maintenance authority.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployTxOptionsWithPrivateState.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployTxOptionsWithPrivateState

# Type Alias: DeployTxOptionsWithPrivateState\<C\>

> **DeployTxOptionsWithPrivateState**\<`C`\> = [`DeployTxOptionsBase`](DeployTxOptionsBase.md)\<`C`\> & `object`

Configuration for creating deploy transactions for contracts with private state. This
configuration used as a base type for the [DeployTxOptionsWithPrivateStateId](DeployTxOptionsWithPrivateStateId.md) configuration.
It is also used directly as parameter to [createUnprovenDeployTx](../functions/createUnprovenDeployTx.md) which doesn't need
to save private state (and therefore doesn't need a private state ID) but does need to supply an
initial private state to run the contract constructor against.

## Type Declaration

### initialPrivateState

> `readonly` **initialPrivateState**: `PrivateState`\<`C`\>

The private state to run the contract constructor against.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployTxOptionsWithPrivateStateId.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployTxOptionsWithPrivateStateId

# Type Alias: DeployTxOptionsWithPrivateStateId\<C\>

> **DeployTxOptionsWithPrivateStateId**\<`C`\> = [`DeployTxOptionsWithPrivateState`](DeployTxOptionsWithPrivateState.md)\<`C`\> & `object`

Configuration for creating deploy transactions for contracts with private state. This
configuration is used when a deployment transaction is created and an initial private
state needs to be stored, as is the case in [submitDeployTx](../functions/submitDeployTx.md).

## Type Declaration

### privateStateId

> `readonly` **privateStateId**: `PrivateStateId`

The identifier for the private state of the contract.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FinalizedCallTxData.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / FinalizedCallTxData

# Type Alias: FinalizedCallTxData\<C, ICK\>

> **FinalizedCallTxData**\<`C`, `ICK`\> = [`UnsubmittedCallTxData`](UnsubmittedCallTxData.md)\<`C`, `ICK`\> & `object`

Data for a submitted, finalized call transaction.

## Type Declaration

### public

> `readonly` **public**: `FinalizedTxData`

Public data relevant to this call transaction.

## Type Parameters

### C

`C` *extends* `Contract`

### ICK

`ICK` *extends* `ImpureCircuitId`\<`C`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FinalizedDeployTxData.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / FinalizedDeployTxData

# Type Alias: FinalizedDeployTxData\<C\>

> **FinalizedDeployTxData**\<`C`\> = [`UnsubmittedDeployTxData`](UnsubmittedDeployTxData.md)\<`C`\> & `object`

Data for a finalized deploy transaction submitted in this process.

## Type Declaration

### public

> `readonly` **public**: `FinalizedTxData`

The data of this transaction that is visible on the blockchain.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FinalizedDeployTxDataBase.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / FinalizedDeployTxDataBase

# Type Alias: FinalizedDeployTxDataBase\<C\>

> **FinalizedDeployTxDataBase**\<`C`\> = [`UnsubmittedDeployTxDataBase`](UnsubmittedDeployTxDataBase.md)\<`C`\> & `object`

Data for a finalized deploy transaction submitted in this process.

## Type Declaration

### public

> `readonly` **public**: `FinalizedTxData`

The data of this transaction that is visible on the blockchain.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FindDeployedContractOptions.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / FindDeployedContractOptions

# Type Alias: FindDeployedContractOptions\<C\>

> **FindDeployedContractOptions**\<`C`\> = [`FindDeployedContractOptionsBase`](FindDeployedContractOptionsBase.md)\<`C`\> \| [`FindDeployedContractOptionsExistingPrivateState`](FindDeployedContractOptionsExistingPrivateState.md)\<`C`\> \| [`FindDeployedContractOptionsStorePrivateState`](FindDeployedContractOptionsStorePrivateState.md)\<`C`\>

Configuration for [findDeployedContract](../functions/findDeployedContract.md).

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FindDeployedContractOptionsBase.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / FindDeployedContractOptionsBase

# Type Alias: FindDeployedContractOptionsBase\<C\>

> **FindDeployedContractOptionsBase**\<`C`\> = `object`

Base type for the configuration options for [findDeployedContract](../functions/findDeployedContract.md).

## Type Parameters

### C

`C` *extends* `Contract`

## Properties

### contract

> `readonly` **contract**: `C`

The contract to use to execute circuits.

***

### contractAddress

> `readonly` **contractAddress**: `ContractAddress`

The address of a previously deployed contract.

***

### signingKey?

> `readonly` `optional` **signingKey**: `SigningKey`

The signing key to use to perform contract maintenance updates. If defined, the given signing
key is stored for this contract address. This is useful when someone has already added the given signing
key to the contract maintenance authority. If undefined, and there is an existing signing key for the
contract address locally, the existing signing key is kept. This is useful when the contract was
deployed locally. If undefined, and there is not an existing signing key for the contract address
locally, a fresh signing key is generated and stored for the contract address locally. This is
useful when you want to give a signing key to someone else to add you as a maintenance authority.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FindDeployedContractOptionsExistingPrivateState.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / FindDeployedContractOptionsExistingPrivateState

# Type Alias: FindDeployedContractOptionsExistingPrivateState\<C\>

> **FindDeployedContractOptionsExistingPrivateState**\<`C`\> = [`FindDeployedContractOptionsBase`](FindDeployedContractOptionsBase.md)\<`C`\> & `object`

[findDeployedContract](../functions/findDeployedContract.md) base configuration that includes an initial private
state to store and the private state ID at which to store it. Only used if
the intention is to overwrite the private state currently stored at the given
private state ID.

## Type Declaration

### privateStateId

> `readonly` **privateStateId**: `PrivateStateId`

An identifier for the private state of the contract being found.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FindDeployedContractOptionsStorePrivateState.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / FindDeployedContractOptionsStorePrivateState

# Type Alias: FindDeployedContractOptionsStorePrivateState\<C\>

> **FindDeployedContractOptionsStorePrivateState**\<`C`\> = [`FindDeployedContractOptionsExistingPrivateState`](FindDeployedContractOptionsExistingPrivateState.md)\<`C`\> & `object`

[findDeployedContract](../functions/findDeployedContract.md) configuration that includes an initial private
state to store and the private state ID at which to store it. Only used if
the intention is to overwrite the private state currently stored at the given
private state ID.

## Type Declaration

### initialPrivateState

> `readonly` **initialPrivateState**: `PrivateState`\<`C`\>

For types of contract that make no use of private state and or witnesses that operate upon it, this
property may be `undefined`. Otherwise, the value provided via this property should be same initial
state that was used when calling [deployContract](../functions/deployContract.md).

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FoundContract.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / FoundContract

# Type Alias: FoundContract\<C\>

> **FoundContract**\<`C`\> = `object`

Base type for a deployed contract that has been found on the blockchain.

## Type Parameters

### C

`C` *extends* `Contract`

## Properties

### callTx

> `readonly` **callTx**: [`CircuitCallTxInterface`](CircuitCallTxInterface.md)\<`C`\>

Interface for creating call transactions for a contract.

***

### circuitMaintenanceTx

> `readonly` **circuitMaintenanceTx**: [`CircuitMaintenanceTxInterfaces`](CircuitMaintenanceTxInterfaces.md)\<`C`\>

An interface for creating maintenance transactions for circuits defined in the
contract that was deployed.

***

### contractMaintenanceTx

> `readonly` **contractMaintenanceTx**: [`ContractMaintenanceTxInterface`](../interfaces/ContractMaintenanceTxInterface.md)

Interface for creating maintenance transactions for the contract that was
deployed.

***

### deployTxData

> `readonly` **deployTxData**: [`FinalizedDeployTxDataBase`](FinalizedDeployTxDataBase.md)\<`C`\>

Data for the finalized deploy transaction corresponding to this contract.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/PublicContractStates.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / PublicContractStates

# Type Alias: PublicContractStates

> **PublicContractStates** = `object`

Object containing the publicly visible states of a contract.

## Properties

### contractState

> `readonly` **contractState**: `ContractState`

The (public) ledger state of a contract.

***

### zswapChainState

> `readonly` **zswapChainState**: `ZswapChainState`

The (public) Zswap chain state of a contract.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/SubmitTxOptions.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / SubmitTxOptions

# Type Alias: SubmitTxOptions\<ICK\>

> **SubmitTxOptions**\<`ICK`\> = `object`

Configuration for [submitTx](../functions/submitTx.md).

## Type Parameters

### ICK

`ICK` *extends* `ImpureCircuitId`

## Properties

### circuitId?

> `readonly` `optional` **circuitId**: `ICK`

A circuit identifier to use to fetch the ZK artifacts needed to prove the
transaction. Only defined if a call transaction is being submitted.

***

### newCoins?

> `readonly` `optional` **newCoins**: `ShieldedCoinInfo`[]

Any new coins created during the construction of the transaction. Only defined
if the transaction being submitted is a call or deploy transaction.

***

### unprovenTx

> `readonly` **unprovenTx**: `UnprovenTransaction`

The transaction to prove, balance, and submit.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/SubmitTxProviders.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / SubmitTxProviders

# Type Alias: SubmitTxProviders\<C, ICK\>

> **SubmitTxProviders**\<`C`, `ICK`\> = `Omit`\<[`ContractProviders`](ContractProviders.md)\<`C`, `ICK`\>, `"privateStateProvider"`\>

Providers required to submit an unproven deployment transaction. Since [submitTx](../functions/submitTx.md) doesn't
manipulate private state, the private state provider can be omitted.

## Type Parameters

### C

`C` *extends* `Contract`

### ICK

`ICK` *extends* `ImpureCircuitId`\<`C`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnprovenCallTxProvidersBase.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnprovenCallTxProvidersBase

# Type Alias: UnprovenCallTxProvidersBase

> **UnprovenCallTxProvidersBase** = `Pick`\<[`ContractProviders`](ContractProviders.md), `"publicDataProvider"` \| `"walletProvider"`\>

The minimum set of providers needed to create a call transaction, the ZK
artifact provider and a wallet. By defining this type, users can choose to
omit a private state provider if they're creating a call transaction for a
contract with no private state.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnprovenCallTxProvidersWithPrivateState.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnprovenCallTxProvidersWithPrivateState

# Type Alias: UnprovenCallTxProvidersWithPrivateState\<C\>

> **UnprovenCallTxProvidersWithPrivateState**\<`C`\> = [`UnprovenCallTxProvidersBase`](UnprovenCallTxProvidersBase.md) & `Pick`\<[`ContractProviders`](ContractProviders.md)\<`C`\>, `"privateStateProvider"`\>

Same providers as [UnprovenCallTxProvidersBase](UnprovenCallTxProvidersBase.md) with an additional private
state provider to store the new private state resulting from the circuit call -
only used when creating a call transaction for a contract with a private state.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnprovenDeployTxOptions.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnprovenDeployTxOptions

# Type Alias: UnprovenDeployTxOptions\<C\>

> **UnprovenDeployTxOptions**\<`C`\> = [`DeployTxOptionsBase`](DeployTxOptionsBase.md)\<`C`\> \| [`DeployTxOptionsWithPrivateState`](DeployTxOptionsWithPrivateState.md)\<`C`\>

Configuration for creating unproven deploy transactions.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnprovenDeployTxProviders.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnprovenDeployTxProviders

# Type Alias: UnprovenDeployTxProviders\<C\>

> **UnprovenDeployTxProviders**\<`C`\> = `Pick`\<[`ContractProviders`](ContractProviders.md)\<`C`\>, `"zkConfigProvider"` \| `"walletProvider"`\>

Providers needed to create an unproven deployment transactions, just the ZK artifact
provider and a wallet.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnsubmittedCallTxData.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnsubmittedCallTxData

# Type Alias: UnsubmittedCallTxData\<C, ICK\>

> **UnsubmittedCallTxData**\<`C`, `ICK`\> = [`CallResult`](CallResult.md)\<`C`, `ICK`\> & `object`

Data for an unsubmitted call transaction.

## Type Declaration

### private

> `readonly` **private**: [`UnsubmittedTxData`](UnsubmittedTxData.md)

Private data relevant to this call transaction.

## Type Parameters

### C

`C` *extends* `Contract`

### ICK

`ICK` *extends* `ImpureCircuitId`\<`C`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnsubmittedDeployTxData.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnsubmittedDeployTxData

# Type Alias: UnsubmittedDeployTxData\<C\>

> **UnsubmittedDeployTxData**\<`C`\> = [`UnsubmittedDeployTxDataBase`](UnsubmittedDeployTxDataBase.md)\<`C`\> & `object`

Data for an unsubmitted deployment transaction.

## Type Declaration

### private

> `readonly` **private**: [`UnsubmittedTxData`](UnsubmittedTxData.md) & `object`

The data of this transaction that is only visible on the user device.

#### Type Declaration

##### initialZswapState

> `readonly` **initialZswapState**: `ZswapLocalState`

The Zswap state produced as a result of running the contract constructor. Useful for when
inputs or outputs are created in the contract constructor.

## Type Parameters

### C

`C` *extends* `Contract`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnsubmittedDeployTxDataBase.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnsubmittedDeployTxDataBase

# Type Alias: UnsubmittedDeployTxDataBase\<C\>

> **UnsubmittedDeployTxDataBase**\<`C`\> = `object`

Base type for data relevant to an unsubmitted deployment transaction.

## Type Parameters

### C

`C` *extends* `Contract`

## Properties

### private

> `readonly` **private**: [`UnsubmittedDeployTxPrivateData`](UnsubmittedDeployTxPrivateData.md)\<`C`\>

The private data (data that will not be revealed upon tx submission) relevant to the deployment transaction.

***

### public

> `readonly` **public**: [`UnsubmittedDeployTxPublicData`](UnsubmittedDeployTxPublicData.md)

The public data (data that will be revealed upon tx submission) relevant to the deployment transaction.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnsubmittedDeployTxPrivateData.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnsubmittedDeployTxPrivateData

# Type Alias: UnsubmittedDeployTxPrivateData\<C\>

> **UnsubmittedDeployTxPrivateData**\<`C`\> = `object`

Base type for private data relevant to an unsubmitted deployment transaction.

## Type Parameters

### C

`C` *extends* `Contract`

## Properties

### initialPrivateState

> `readonly` **initialPrivateState**: `PrivateState`\<`C`\>

The initial private state of the contract deployed to the blockchain. This
value is persisted if the transaction succeeds.

***

### signingKey

> `readonly` **signingKey**: `SigningKey`

The signing key that was added as the deployed contract's maintenance authority.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnsubmittedDeployTxPublicData.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnsubmittedDeployTxPublicData

# Type Alias: UnsubmittedDeployTxPublicData

> **UnsubmittedDeployTxPublicData** = `object`

Base type for public data relevant to an unsubmitted deployment transaction.

## Properties

### contractAddress

> `readonly` **contractAddress**: `ContractAddress`

The ledger address of the contract that was deployed.

***

### initialContractState

> `readonly` **initialContractState**: `ContractState`

The initial public state of the contract deployed to the blockchain.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnsubmittedTxData.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnsubmittedTxData

# Type Alias: UnsubmittedTxData

> **UnsubmittedTxData** = `object`

Data relevant to any unsubmitted transaction.

## Properties

### newCoins

> `readonly` **newCoins**: `ShieldedCoinInfo`[]

New coins created during the construction of the transaction.

***

### unprovenTx

> `readonly` **unprovenTx**: `UnprovenTransaction`

The unproven ledger transaction produced.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-contracts/README.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-contracts

# @midnight-ntwrk/midnight-js-contracts

## Classes

- [CallTxFailedError](classes/CallTxFailedError.md)
- [ContractTypeError](classes/ContractTypeError.md)
- [DeployTxFailedError](classes/DeployTxFailedError.md)
- [IncompleteCallTxPrivateStateConfig](classes/IncompleteCallTxPrivateStateConfig.md)
- [IncompleteFindContractPrivateStateConfig](classes/IncompleteFindContractPrivateStateConfig.md)
- [InsertVerifierKeyTxFailedError](classes/InsertVerifierKeyTxFailedError.md)
- [RemoveVerifierKeyTxFailedError](classes/RemoveVerifierKeyTxFailedError.md)
- [ReplaceMaintenanceAuthorityTxFailedError](classes/ReplaceMaintenanceAuthorityTxFailedError.md)
- [TxFailedError](classes/TxFailedError.md)

## Interfaces

- [ContractMaintenanceTxInterface](interfaces/ContractMaintenanceTxInterface.md)

## Type Aliases

- [CallOptions](type-aliases/CallOptions.md)
- [CallOptionsBase](type-aliases/CallOptionsBase.md)
- [CallOptionsProviderDataDependencies](type-aliases/CallOptionsProviderDataDependencies.md)
- [CallOptionsWithArguments](type-aliases/CallOptionsWithArguments.md)
- [CallOptionsWithPrivateState](type-aliases/CallOptionsWithPrivateState.md)
- [CallOptionsWithProviderDataDependencies](type-aliases/CallOptionsWithProviderDataDependencies.md)
- [CallResult](type-aliases/CallResult.md)
- [CallResultPrivate](type-aliases/CallResultPrivate.md)
- [CallResultPublic](type-aliases/CallResultPublic.md)
- [CallTxOptions](type-aliases/CallTxOptions.md)
- [CallTxOptionsBase](type-aliases/CallTxOptionsBase.md)
- [CallTxOptionsWithPrivateStateId](type-aliases/CallTxOptionsWithPrivateStateId.md)
- [CircuitCallTxInterface](type-aliases/CircuitCallTxInterface.md)
- [CircuitMaintenanceTxInterface](type-aliases/CircuitMaintenanceTxInterface.md)
- [CircuitMaintenanceTxInterfaces](type-aliases/CircuitMaintenanceTxInterfaces.md)
- [ContractConstructorOptions](type-aliases/ContractConstructorOptions.md)
- [ContractConstructorOptionsBase](type-aliases/ContractConstructorOptionsBase.md)
- [ContractConstructorOptionsProviderDataDependencies](type-aliases/ContractConstructorOptionsProviderDataDependencies.md)
- [ContractConstructorOptionsWithArguments](type-aliases/ContractConstructorOptionsWithArguments.md)
- [ContractConstructorOptionsWithPrivateState](type-aliases/ContractConstructorOptionsWithPrivateState.md)
- [ContractConstructorOptionsWithProviderDataDependencies](type-aliases/ContractConstructorOptionsWithProviderDataDependencies.md)
- [ContractConstructorResult](type-aliases/ContractConstructorResult.md)
- [ContractProviders](type-aliases/ContractProviders.md)
- [ContractStates](type-aliases/ContractStates.md)
- [DeployContractOptions](type-aliases/DeployContractOptions.md)
- [DeployContractOptionsBase](type-aliases/DeployContractOptionsBase.md)
- [DeployContractOptionsWithPrivateState](type-aliases/DeployContractOptionsWithPrivateState.md)
- [DeployedContract](type-aliases/DeployedContract.md)
- [DeployTxOptions](type-aliases/DeployTxOptions.md)
- [DeployTxOptionsBase](type-aliases/DeployTxOptionsBase.md)
- [DeployTxOptionsWithPrivateState](type-aliases/DeployTxOptionsWithPrivateState.md)
- [DeployTxOptionsWithPrivateStateId](type-aliases/DeployTxOptionsWithPrivateStateId.md)
- [FinalizedCallTxData](type-aliases/FinalizedCallTxData.md)
- [FinalizedDeployTxData](type-aliases/FinalizedDeployTxData.md)
- [FinalizedDeployTxDataBase](type-aliases/FinalizedDeployTxDataBase.md)
- [FindDeployedContractOptions](type-aliases/FindDeployedContractOptions.md)
- [FindDeployedContractOptionsBase](type-aliases/FindDeployedContractOptionsBase.md)
- [FindDeployedContractOptionsExistingPrivateState](type-aliases/FindDeployedContractOptionsExistingPrivateState.md)
- [FindDeployedContractOptionsStorePrivateState](type-aliases/FindDeployedContractOptionsStorePrivateState.md)
- [FoundContract](type-aliases/FoundContract.md)
- [PublicContractStates](type-aliases/PublicContractStates.md)
- [SubmittedCallTx](type-aliases/SubmittedCallTx.md)
- [SubmitTxOptions](type-aliases/SubmitTxOptions.md)
- [SubmitTxProviders](type-aliases/SubmitTxProviders.md)
- [UnprovenCallTxProvidersBase](type-aliases/UnprovenCallTxProvidersBase.md)
- [UnprovenCallTxProvidersWithPrivateState](type-aliases/UnprovenCallTxProvidersWithPrivateState.md)
- [UnprovenDeployTxOptions](type-aliases/UnprovenDeployTxOptions.md)
- [UnprovenDeployTxProviders](type-aliases/UnprovenDeployTxProviders.md)
- [UnsubmittedCallTxData](type-aliases/UnsubmittedCallTxData.md)
- [UnsubmittedDeployTxData](type-aliases/UnsubmittedDeployTxData.md)
- [UnsubmittedDeployTxDataBase](type-aliases/UnsubmittedDeployTxDataBase.md)
- [UnsubmittedDeployTxPrivateData](type-aliases/UnsubmittedDeployTxPrivateData.md)
- [UnsubmittedDeployTxPublicData](type-aliases/UnsubmittedDeployTxPublicData.md)
- [UnsubmittedTxData](type-aliases/UnsubmittedTxData.md)

## Functions

- [call](functions/call.md)
- [callContractConstructor](functions/callContractConstructor.md)
- [createCallTxOptions](functions/createCallTxOptions.md)
- [createCircuitCallTxInterface](functions/createCircuitCallTxInterface.md)
- [createCircuitMaintenanceTxInterface](functions/createCircuitMaintenanceTxInterface.md)
- [createCircuitMaintenanceTxInterfaces](functions/createCircuitMaintenanceTxInterfaces.md)
- [createContractMaintenanceTxInterface](functions/createContractMaintenanceTxInterface.md)
- [createUnprovenCallTx](functions/createUnprovenCallTx.md)
- [createUnprovenCallTxFromInitialStates](functions/createUnprovenCallTxFromInitialStates.md)
- [createUnprovenDeployTx](functions/createUnprovenDeployTx.md)
- [createUnprovenDeployTxFromVerifierKeys](functions/createUnprovenDeployTxFromVerifierKeys.md)
- [deployContract](functions/deployContract.md)
- [findDeployedContract](functions/findDeployedContract.md)
- [getPublicStates](functions/getPublicStates.md)
- [getStates](functions/getStates.md)
- [getUnshieldedBalances](functions/getUnshieldedBalances.md)
- [submitCallTx](functions/submitCallTx.md)
- [submitCallTxAsync](functions/submitCallTxAsync.md)
- [submitDeployTx](functions/submitDeployTx.md)
- [submitInsertVerifierKeyTx](functions/submitInsertVerifierKeyTx.md)
- [submitRemoveVerifierKeyTx](functions/submitRemoveVerifierKeyTx.md)
- [submitReplaceAuthorityTx](functions/submitReplaceAuthorityTx.md)
- [submitTx](functions/submitTx.md)
- [submitTxAsync](functions/submitTxAsync.md)
- [verifierKeysEqual](functions/verifierKeysEqual.md)
- [verifyContractState](functions/verifyContractState.md)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-fetch-zk-config-provider/classes/FetchZkConfigProvider.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-fetch-zk-config-provider](../README.md) / FetchZkConfigProvider

# Class: FetchZkConfigProvider\<K\>

Retrieves ZK artifacts from a remote source.

## Extends

- `ZKConfigProvider`\<`K`\>

## Type Parameters

### K

`K` *extends* `string`

## Constructors

### Constructor

> **new FetchZkConfigProvider**\<`K`\>(`baseURL`, `fetchFunc`): `FetchZkConfigProvider`\<`K`\>

#### Parameters

##### baseURL

`string`

The endpoint to query for ZK artifacts.

##### fetchFunc

\{(`input`, `init?`): `Promise`\<`Response`\>; (`input`, `init?`): `Promise`\<`Response`\>; \}

The function to use to execute queries.

#### Returns

`FetchZkConfigProvider`\<`K`\>

#### Overrides

`ZKConfigProvider<K>.constructor`

## Properties

### baseURL

> `readonly` **baseURL**: `string`

The endpoint to query for ZK artifacts.

## Methods

### get()

> **get**(`circuitId`): `Promise`\<`ZKConfig`\<`K`\>\>

Retrieves all zero-knowledge artifacts produced by `compact` compiler for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the artifacts to retrieve.

#### Returns

`Promise`\<`ZKConfig`\<`K`\>\>

#### Inherited from

`ZKConfigProvider.get`

***

### getProverKey()

> **getProverKey**(`circuitId`): `Promise`\<`ProverKey`\>

Retrieves the prover key produced by `compact` compiler for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the prover key to retrieve.

#### Returns

`Promise`\<`ProverKey`\>

#### Overrides

`ZKConfigProvider.getProverKey`

***

### getVerifierKey()

> **getVerifierKey**(`circuitId`): `Promise`\<`VerifierKey`\>

Retrieves the verifier key produced by `compact` compiler for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the verifier key to retrieve.

#### Returns

`Promise`\<`VerifierKey`\>

#### Overrides

`ZKConfigProvider.getVerifierKey`

***

### getVerifierKeys()

> **getVerifierKeys**(`circuitIds`): `Promise`\<\[`K`, `VerifierKey`\][]\>

Retrieves the verifier keys produced by `compact` compiler for the given circuits.

#### Parameters

##### circuitIds

`K`[]

The circuit IDs of the verifier keys to retrieve.

#### Returns

`Promise`\<\[`K`, `VerifierKey`\][]\>

#### Inherited from

`ZKConfigProvider.getVerifierKeys`

***

### getZKIR()

> **getZKIR**(`circuitId`): `Promise`\<`ZKIR`\>

Retrieves the zero-knowledge intermediate representation produced by `compact` compiler for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the ZKIR to retrieve.

#### Returns

`Promise`\<`ZKIR`\>

#### Overrides

`ZKConfigProvider.getZKIR`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-fetch-zk-config-provider/README.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-fetch-zk-config-provider

# @midnight-ntwrk/midnight-js-fetch-zk-config-provider

## Classes

- [FetchZkConfigProvider](classes/FetchZkConfigProvider.md)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-http-client-proof-provider/functions/httpClientProofProvider.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-http-client-proof-provider](../README.md) / httpClientProofProvider

# Function: httpClientProofProvider()

> **httpClientProofProvider**\<`K`\>(`url`): `ProofProvider`\<`K`\>

Creates a ProofProvider by creating a client for a running proof server.
Allows for HTTP and HTTPS. The data passed to 'proveTx' are intended to be
secret, so usage of this function should be heavily scrutinized.

## Type Parameters

### K

`K` *extends* `string`

## Parameters

### url

`string`

The url of a running proof server.

## Returns

`ProofProvider`\<`K`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-http-client-proof-provider/functions/serializeTransactionPayload.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-http-client-proof-provider](../README.md) / serializeTransactionPayload

# Function: serializeTransactionPayload()

> **serializeTransactionPayload**\<`K`\>(`unprovenTx`, `zkConfig?`): `Uint8Array`

## Type Parameters

### K

`K` *extends* `string`

## Parameters

### unprovenTx

`UnprovenTransaction`

### zkConfig?

`ZKConfig`\<`K`\>

## Returns

`Uint8Array`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-http-client-proof-provider/variables/DEFAULT_CONFIG.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-http-client-proof-provider](../README.md) / DEFAULT\_CONFIG

# Variable: DEFAULT\_CONFIG

> `const` **DEFAULT\_CONFIG**: `object`

The default configuration for the proof server client.

## Type Declaration

### timeout

> **timeout**: `number` = `300000`

The default timeout for prove requests.

### zkConfig

> **zkConfig**: `undefined` = `undefined`

The default ZK configuration to use. It is overwritten with a proper ZK
configuration only if a call transaction is being proven.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-http-client-proof-provider/README.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-http-client-proof-provider

# @midnight-ntwrk/midnight-js-http-client-proof-provider

## Variables

- [DEFAULT\_CONFIG](variables/DEFAULT_CONFIG.md)

## Functions

- [httpClientProofProvider](functions/httpClientProofProvider.md)
- [serializeTransactionPayload](functions/serializeTransactionPayload.md)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-indexer-public-data-provider/classes/IndexerFormattedError.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-indexer-public-data-provider](../README.md) / IndexerFormattedError

# Class: IndexerFormattedError

An error describing the causes of error that occurred during server-side execution of
a query against the Indexer.

## Extends

- `Error`

## Constructors

### Constructor

> **new IndexerFormattedError**(`cause`): `IndexerFormattedError`

#### Parameters

##### cause

readonly `GraphQLFormattedError`[]

An array of GraphQL errors that occurred during the server-side execution.

#### Returns

`IndexerFormattedError`

#### Overrides

`Error.constructor`

## Properties

### cause

> `readonly` **cause**: readonly `GraphQLFormattedError`[]

An array of GraphQL errors that occurred during the server-side execution.

#### Inherited from

`Error.cause`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-indexer-public-data-provider/functions/indexerPublicDataProvider.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-indexer-public-data-provider](../README.md) / indexerPublicDataProvider

# Function: indexerPublicDataProvider()

> **indexerPublicDataProvider**(`queryURL`, `subscriptionURL`, `webSocketImpl`): `PublicDataProvider`

Constructs a PublicDataProvider based on an ApolloClient.

## Parameters

### queryURL

`string`

The URL of a GraphQL server query endpoint.

### subscriptionURL

`string`

The URL of a GraphQL server subscription (websocket) endpoint.

### webSocketImpl

*typeof* `WebSocket` = `ws.WebSocket`

An optional websocket implementation for the Apollo client to use.

TODO: Re-examine caching when 'ContractCall' and 'ContractDeploy' have transaction identifiers included.

## Returns

`PublicDataProvider`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-indexer-public-data-provider/functions/toUnshieldedBalances.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-indexer-public-data-provider](../README.md) / toUnshieldedBalances

# Function: toUnshieldedBalances()

> **toUnshieldedBalances**(`contractBalances`): `UnshieldedBalances`

## Parameters

### contractBalances

readonly `ContractBalance`[]

## Returns

`UnshieldedBalances`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-indexer-public-data-provider/functions/toUnshieldedUtxos.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-indexer-public-data-provider](../README.md) / toUnshieldedUtxos

# Function: toUnshieldedUtxos()

> **toUnshieldedUtxos**(`createdUtxo`, `spentUtxo`): `UnshieldedUtxos`

## Parameters

### createdUtxo

readonly [`IndexerUtxo`](../type-aliases/IndexerUtxo.md)[]

### spentUtxo

readonly [`IndexerUtxo`](../type-aliases/IndexerUtxo.md)[]

## Returns

`UnshieldedUtxos`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-indexer-public-data-provider/type-aliases/IndexerUtxo.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-indexer-public-data-provider](../README.md) / IndexerUtxo

# Type Alias: IndexerUtxo

> **IndexerUtxo** = `object`

## Properties

### intentHash

> **intentHash**: `string`

***

### owner

> **owner**: `string`

***

### tokenType

> **tokenType**: `string`

***

### value

> **value**: `string`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-indexer-public-data-provider/README.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-indexer-public-data-provider

# @midnight-ntwrk/midnight-js-indexer-public-data-provider

## Classes

- [IndexerFormattedError](classes/IndexerFormattedError.md)

## Type Aliases

- [IndexerUtxo](type-aliases/IndexerUtxo.md)

## Functions

- [indexerPublicDataProvider](functions/indexerPublicDataProvider.md)
- [toUnshieldedBalances](functions/toUnshieldedBalances.md)
- [toUnshieldedUtxos](functions/toUnshieldedUtxos.md)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-level-private-state-provider/functions/levelPrivateStateProvider.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-level-private-state-provider](../README.md) / levelPrivateStateProvider

# Function: levelPrivateStateProvider()

> **levelPrivateStateProvider**\<`PSI`, `PS`\>(`partialConfig`): `PrivateStateProvider`\<`PSI`, `PS`\>

Constructs an instance of PrivateStateProvider based on Level database.

## Type Parameters

### PSI

`PSI` *extends* `string`

### PS

`PS` = `any`

## Parameters

### partialConfig

`Partial`\<[`LevelPrivateStateProviderConfig`](../interfaces/LevelPrivateStateProviderConfig.md)\> = `{}`

Database configuration options.

## Returns

`PrivateStateProvider`\<`PSI`, `PS`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-level-private-state-provider/interfaces/LevelPrivateStateProviderConfig.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-level-private-state-provider](../README.md) / LevelPrivateStateProviderConfig

# Interface: LevelPrivateStateProviderConfig

Optional properties for the indexedDB based private state provider configuration.

## Properties

### midnightDbName

> `readonly` **midnightDbName**: `string`

The name of the LevelDB database used to store all Midnight related data.

***

### privateStateStoreName

> `readonly` **privateStateStoreName**: `string`

The name of the object store containing private states.

***

### signingKeyStoreName

> `readonly` **signingKeyStoreName**: `string`

The name of the object store containing signing keys.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-level-private-state-provider/variables/DEFAULT_CONFIG.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-level-private-state-provider](../README.md) / DEFAULT\_CONFIG

# Variable: DEFAULT\_CONFIG

> `const` **DEFAULT\_CONFIG**: `object`

The default configuration for the level database.

## Type Declaration

### midnightDbName

> **midnightDbName**: `string` = `MN_LDB_DEFAULT_DB_NAME`

The name of the database.

### privateStateStoreName

> **privateStateStoreName**: `string` = `MN_LDB_DEFAULT_PRIS_STORE_NAME`

The name of the "level" on which to store private state.

### signingKeyStoreName

> **signingKeyStoreName**: `string` = `MN_LDB_DEFAULT_KEY_STORE_NAME`

The name of the "level" on which to store signing keys.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-level-private-state-provider/README.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-level-private-state-provider

# @midnight-ntwrk/midnight-js-level-private-state-provider

## Classes

- [StorageEncryption](classes/StorageEncryption.md)

## Interfaces

- [LevelPrivateStateProviderConfig](interfaces/LevelPrivateStateProviderConfig.md)

## Variables

- [DEFAULT\_CONFIG](variables/DEFAULT_CONFIG.md)

## Functions

- [getStoragePassword](functions/getStoragePassword.md)
- [levelPrivateStateProvider](functions/levelPrivateStateProvider.md)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-logger-provider/classes/LoggerProvider.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-logger-provider](../README.md) / LoggerProvider

# Class: LoggerProvider

Implementation of LoggerProvider that returns a Logger instance.

## Constructors

### Constructor

> **new LoggerProvider**(`logger`): `LoggerProvider`

#### Parameters

##### logger

`Logger`

#### Returns

`LoggerProvider`

## Properties

### debug

> **debug**: `LogFn`

***

### error

> **error**: `LogFn`

***

### fatal

> **fatal**: `LogFn`

***

### info

> **info**: `LogFn`

***

### trace

> **trace**: `LogFn`

***

### warn

> **warn**: `LogFn`

## Methods

### isLevelEnabled()

> **isLevelEnabled**(`level`): `boolean`

#### Parameters

##### level

`LogLevel`

#### Returns

`boolean`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-logger-provider/README.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-logger-provider

# @midnight-ntwrk/midnight-js-logger-provider

## Classes

- [LoggerProvider](classes/LoggerProvider.md)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-network-id/functions/getNetworkId.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-network-id](../README.md) / getNetworkId

# Function: getNetworkId()

> **getNetworkId**(): `string`

Retrieves the currently set global network identifier.

## Returns

`string`

The currently set [NetworkId](../type-aliases/NetworkId.md).

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-network-id/functions/setNetworkId.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-network-id](../README.md) / setNetworkId

# Function: setNetworkId()

> **setNetworkId**(`id`): `void`

Sets the global network identifier.

## Parameters

### id

`string`

A valid [NetworkId](../type-aliases/NetworkId.md) value.

## Returns

`void`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-network-id/type-aliases/NetworkId.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-network-id](../README.md) / NetworkId

# Type Alias: NetworkId

> **NetworkId** = `string`

A valid named Midnight network identifier.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-network-id/README.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-network-id

# @midnight-ntwrk/midnight-js-network-id

## Type Aliases

- [NetworkId](type-aliases/NetworkId.md)

## Functions

- [getNetworkId](functions/getNetworkId.md)
- [setNetworkId](functions/setNetworkId.md)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-node-zk-config-provider/classes/NodeZkConfigProvider.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-node-zk-config-provider](../README.md) / NodeZkConfigProvider

# Class: NodeZkConfigProvider\<K\>

Implementation of ZKConfigProvider that reads the keys and zkIR from the local filesystem.

## Extends

- `ZKConfigProvider`\<`K`\>

## Type Parameters

### K

`K` *extends* `string`

The type of the circuit ID used by the provider.

## Constructors

### Constructor

> **new NodeZkConfigProvider**\<`K`\>(`directory`): `NodeZkConfigProvider`\<`K`\>

#### Parameters

##### directory

`string`

The path to the base directory containing the key and ZKIR subdirectories.

#### Returns

`NodeZkConfigProvider`\<`K`\>

#### Overrides

`ZKConfigProvider<K>.constructor`

## Properties

### directory

> `readonly` **directory**: `string`

The path to the base directory containing the key and ZKIR subdirectories.

## Methods

### get()

> **get**(`circuitId`): `Promise`\<`ZKConfig`\<`K`\>\>

Retrieves all zero-knowledge artifacts produced by `compact` compiler for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the artifacts to retrieve.

#### Returns

`Promise`\<`ZKConfig`\<`K`\>\>

#### Inherited from

`ZKConfigProvider.get`

***

### getProverKey()

> **getProverKey**(`circuitId`): `Promise`\<`ProverKey`\>

ZKConfigProvider.getProverKey

#### Parameters

##### circuitId

`K`

#### Returns

`Promise`\<`ProverKey`\>

#### Overrides

`ZKConfigProvider.getProverKey`

***

### getVerifierKey()

> **getVerifierKey**(`circuitId`): `Promise`\<`VerifierKey`\>

ZKConfigProvider.getVerifierKey

#### Parameters

##### circuitId

`K`

#### Returns

`Promise`\<`VerifierKey`\>

#### Overrides

`ZKConfigProvider.getVerifierKey`

***

### getVerifierKeys()

> **getVerifierKeys**(`circuitIds`): `Promise`\<\[`K`, `VerifierKey`\][]\>

Retrieves the verifier keys produced by `compact` compiler for the given circuits.

#### Parameters

##### circuitIds

`K`[]

The circuit IDs of the verifier keys to retrieve.

#### Returns

`Promise`\<\[`K`, `VerifierKey`\][]\>

#### Inherited from

`ZKConfigProvider.getVerifierKeys`

***

### getZKIR()

> **getZKIR**(`circuitId`): `Promise`\<`ZKIR`\>

ZKConfigProvider.getZKIR

#### Parameters

##### circuitId

`K`

#### Returns

`Promise`\<`ZKIR`\>

#### Overrides

`ZKConfigProvider.getZKIR`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-node-zk-config-provider/README.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-node-zk-config-provider

# @midnight-ntwrk/midnight-js-node-zk-config-provider

## Classes

- [NodeZkConfigProvider](classes/NodeZkConfigProvider.md)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/classes/InvalidProtocolSchemeError.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / InvalidProtocolSchemeError

# Class: InvalidProtocolSchemeError

An error describing an invalid protocol scheme.

## Extends

- `Error`

## Constructors

### Constructor

> **new InvalidProtocolSchemeError**(`invalidScheme`, `allowableSchemes`): `InvalidProtocolSchemeError`

#### Parameters

##### invalidScheme

`string`

The invalid scheme.

##### allowableSchemes

`string`[]

The valid schemes that are allowed.

#### Returns

`InvalidProtocolSchemeError`

#### Overrides

`Error.constructor`

## Properties

### allowableSchemes

> `readonly` **allowableSchemes**: `string`[]

The valid schemes that are allowed.

***

### invalidScheme

> `readonly` **invalidScheme**: `string`

The invalid scheme.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/classes/ZKConfigProvider.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ZKConfigProvider

# Abstract Class: ZKConfigProvider\<K\>

A provider for zero-knowledge intermediate representations, prover keys, and verifier keys. All
three are used by the [ProofProvider](../interfaces/ProofProvider.md) to create a proof for a call transaction. The implementation
of this provider depends on the runtime environment, since each environment has different conventions
for accessing static artifacts.

## Type Parameters

### K

`K` *extends* `string`

The type of the circuit ID used by the provider.

## Constructors

### Constructor

> **new ZKConfigProvider**\<`K`\>(): `ZKConfigProvider`\<`K`\>

#### Returns

`ZKConfigProvider`\<`K`\>

## Methods

### get()

> **get**(`circuitId`): `Promise`\<[`ZKConfig`](../interfaces/ZKConfig.md)\<`K`\>\>

Retrieves all zero-knowledge artifacts produced by `compact` compiler for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the artifacts to retrieve.

#### Returns

`Promise`\<[`ZKConfig`](../interfaces/ZKConfig.md)\<`K`\>\>

***

### getProverKey()

> `abstract` **getProverKey**(`circuitId`): `Promise`\<[`ProverKey`](../type-aliases/ProverKey.md)\>

Retrieves the prover key produced by `compact` compiler for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the prover key to retrieve.

#### Returns

`Promise`\<[`ProverKey`](../type-aliases/ProverKey.md)\>

***

### getVerifierKey()

> `abstract` **getVerifierKey**(`circuitId`): `Promise`\<[`VerifierKey`](../type-aliases/VerifierKey.md)\>

Retrieves the verifier key produced by `compact` compiler for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the verifier key to retrieve.

#### Returns

`Promise`\<[`VerifierKey`](../type-aliases/VerifierKey.md)\>

***

### getVerifierKeys()

> **getVerifierKeys**(`circuitIds`): `Promise`\<\[`K`, [`VerifierKey`](../type-aliases/VerifierKey.md)\][]\>

Retrieves the verifier keys produced by `compact` compiler for the given circuits.

#### Parameters

##### circuitIds

`K`[]

The circuit IDs of the verifier keys to retrieve.

#### Returns

`Promise`\<\[`K`, [`VerifierKey`](../type-aliases/VerifierKey.md)\][]\>

***

### getZKIR()

> `abstract` **getZKIR**(`circuitId`): `Promise`\<[`ZKIR`](../type-aliases/ZKIR.md)\>

Retrieves the zero-knowledge intermediate representation produced by `compact` compiler for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the ZKIR to retrieve.

#### Returns

`Promise`\<[`ZKIR`](../type-aliases/ZKIR.md)\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/enumerations/LogLevel.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / LogLevel

# Enumeration: LogLevel

A valid named log level.

## Enumeration Members

### DEBUG

> **DEBUG**: `"debug"`

Log levels used by Midnight.JS to report internal state.

***

### ERROR

> **ERROR**: `"error"`

***

### FATAL

> **FATAL**: `"fatal"`

***

### INFO

> **INFO**: `"info"`

Log levels typically used by DAapp developers.

***

### TRACE

> **TRACE**: `"trace"`

***

### WARN

> **WARN**: `"warn"`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/functions/createProverKey.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / createProverKey

# Function: createProverKey()

> **createProverKey**(`uint8Array`): [`ProverKey`](../type-aliases/ProverKey.md)

Creates a branded prover key representation from a prover key binary.

## Parameters

### uint8Array

`Uint8Array`

The prover key binary.

## Returns

[`ProverKey`](../type-aliases/ProverKey.md)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/functions/createVerifierKey.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / createVerifierKey

# Function: createVerifierKey()

> **createVerifierKey**(`uint8Array`): [`VerifierKey`](../type-aliases/VerifierKey.md)

Creates a branded verifier key representation from a verifier key binary.

## Parameters

### uint8Array

`Uint8Array`

The verifier key binary.

## Returns

[`VerifierKey`](../type-aliases/VerifierKey.md)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/functions/createZKIR.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / createZKIR

# Function: createZKIR()

> **createZKIR**(`uint8Array`): [`ZKIR`](../type-aliases/ZKIR.md)

Creates a branded ZKIR representation from a ZKIR binary.

## Parameters

### uint8Array

`Uint8Array`

The ZKIR binary.

## Returns

[`ZKIR`](../type-aliases/ZKIR.md)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/functions/getImpureCircuitIds.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / getImpureCircuitIds

# Function: getImpureCircuitIds()

> **getImpureCircuitIds**\<`C`\>(`contract`): [`ImpureCircuitId`](../type-aliases/ImpureCircuitId.md)\<`C`\>[]

Typesafe version of `Object.keys(contract.impureCircuits)`.

## Type Parameters

### C

`C` *extends* [`Contract`](../interfaces/Contract.md)\<`any`, [`Witnesses`](../type-aliases/Witnesses.md)\<`any`\>\>

The contract type for which we would like impure circuit IDs.

## Parameters

### contract

`C`

The contract having impure circuits for which we want ids.

## Returns

[`ImpureCircuitId`](../type-aliases/ImpureCircuitId.md)\<`C`\>[]

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/Contract.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / Contract

# Interface: Contract\<PS, W\>

Interface for a contract. The data types defined in this file are generic shapes for the artifacts
produced by the `compact` compiler. In other words, this `Contract` interface should match the shape
of any `Contract` class produced by `compact`. Midnight.js uses it for generic constraints.

## Type Parameters

### PS

`PS` = `any`

The private state modified by the contract witnesses.

### W

`W` *extends* [`Witnesses`](../type-aliases/Witnesses.md)\<`PS`\> = [`Witnesses`](../type-aliases/Witnesses.md)\<`PS`\>

The contract witnesses type.

## Properties

### impureCircuits

> `readonly` **impureCircuits**: [`ImpureCircuits`](../type-aliases/ImpureCircuits.md)\<`PS`\>

The impure circuits defined in a contract. These circuits can be used to create call transactions.

***

### witnesses

> `readonly` **witnesses**: `W`

The private oracle of the contract.

## Methods

### initialState()

> **initialState**(`context`, ...`args`): `ConstructorResult`\<`PS`\>

Constructs the initial public state of the public oracle of a contract. This is used during
deployment transaction construction.

#### Parameters

##### context

`ConstructorContext`\<`PS`\>

##### args

...`any`[]

#### Returns

`ConstructorResult`\<`PS`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/FinalizedTxData.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / FinalizedTxData

# Interface: FinalizedTxData

Data for any finalized transaction.

## Properties

### blockAuthor

> `readonly` **blockAuthor**: `string` \| `null`

The author of the block in which the transaction was included.

***

### blockHash

> `readonly` **blockHash**: `string`

The block hash of the block in which the transaction was included.

***

### blockHeight

> `readonly` **blockHeight**: `number`

The block height of the block in which the transaction was included.

***

### blockTimestamp

> `readonly` **blockTimestamp**: `number`

The timestamp of the block in which the transaction was included.

***

### fees

> `readonly` **fees**: [`Fees`](../type-aliases/Fees.md)

The fees associated with the transaction, including both paid and estimated fees.

***

### identifiers

> `readonly` **identifiers**: readonly `string`[]

All transaction IDs of the submitted transaction.

***

### indexerId

> `readonly` **indexerId**: `number`

The indexer internal db ID.

***

### protocolVersion

> `readonly` **protocolVersion**: `number`

The protocol version of the transaction.

***

### segmentStatusMap

> `readonly` **segmentStatusMap**: `Map`\<`number`, [`SegmentStatus`](../type-aliases/SegmentStatus.md)\> \| `undefined`

The map that associates segment identifiers (numbers) with their corresponding status [SegmentStatus](../type-aliases/SegmentStatus.md).
The segment identifier is represented as a number (key in the map), and the status indicates the success or failure of the transaction update.

***

### status

> `readonly` **status**: [`TxStatus`](../type-aliases/TxStatus.md)

The status of a submitted transaction.

***

### tx

> `readonly` **tx**: `Transaction`\<`SignatureEnabled`, `Proof`, `Binding`\>

The transaction that was finalized.

***

### txHash

> `readonly` **txHash**: `string`

The transaction hash of the transaction in which the original transaction was included.

***

### txId

> `readonly` **txId**: `string`

One of the transaction ID of the submitted transaction.

***

### unshielded

> `readonly` **unshielded**: [`UnshieldedUtxos`](../type-aliases/UnshieldedUtxos.md)

Represents the unshielded outputs, typically used for transactions or operations
involving data or values that are not encrypted or concealed.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/LoggerProvider.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / LoggerProvider

# Interface: LoggerProvider

A provider for logging functions.

## Properties

### debug?

> `optional` **debug**: `LogFn`

***

### error?

> `optional` **error**: `LogFn`

***

### fatal?

> `optional` **fatal**: `LogFn`

***

### info?

> `optional` **info**: `LogFn`

***

### warn?

> `optional` **warn**: `LogFn`

## Methods

### isLevelEnabled()

> **isLevelEnabled**(`level`): `boolean`

#### Parameters

##### level

[`LogLevel`](../enumerations/LogLevel.md)

#### Returns

`boolean`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/MidnightProvider.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / MidnightProvider

# Interface: MidnightProvider

Interface for Midnight transaction submission logic. It could be implemented, e.g., by a wallet,
a third-party service, or a node itself.

## Methods

### submitTx()

> **submitTx**(`tx`): `Promise`\<`string`\>

Submit a transaction to the network to be consensed upon.

#### Parameters

##### tx

`FinalizedTransaction`

The finalized transaction to submit.

#### Returns

`Promise`\<`string`\>

The transaction identifier of the submitted transaction.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/MidnightProviders.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / MidnightProviders

# Interface: MidnightProviders\<ICK, PSI, PS\>

Set of providers needed for transaction construction and submission.

## Type Parameters

### ICK

`ICK` *extends* [`ImpureCircuitId`](../type-aliases/ImpureCircuitId.md) = [`ImpureCircuitId`](../type-aliases/ImpureCircuitId.md)

A union of string literal types representing the callable circuits.

### PSI

`PSI` *extends* [`PrivateStateId`](../type-aliases/PrivateStateId.md) = [`PrivateStateId`](../type-aliases/PrivateStateId.md)

Parameter indicating the private state ID, sometimes a union of string literals.

### PS

`PS` = `any`

Parameter indicating the private state type stored, sometimes a union of private state types.

## Properties

### loggerProvider?

> `readonly` `optional` **loggerProvider**: [`LoggerProvider`](LoggerProvider.md)

An optional logger that provides utilities for logging at given levels.

***

### midnightProvider

> `readonly` **midnightProvider**: [`MidnightProvider`](MidnightProvider.md)

Submits proven, balanced transactions to the network.

***

### privateStateProvider

> `readonly` **privateStateProvider**: [`PrivateStateProvider`](PrivateStateProvider.md)\<`PSI`, `PS`\>

Manages the private state of a contract.

***

### proofProvider

> `readonly` **proofProvider**: [`ProofProvider`](ProofProvider.md)\<`ICK`\>

Creates proven, unbalanced transactions.

***

### publicDataProvider

> `readonly` **publicDataProvider**: [`PublicDataProvider`](PublicDataProvider.md)

Retrieves public data from the blockchain.

***

### walletProvider

> `readonly` **walletProvider**: [`WalletProvider`](WalletProvider.md)

Creates proven, balanced transactions.

***

### zkConfigProvider

> `readonly` **zkConfigProvider**: [`ZKConfigProvider`](../classes/ZKConfigProvider.md)\<`ICK`\>

Retrieves the ZK artifacts of a contract needed to create proofs.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/PrivateStateProvider.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / PrivateStateProvider

# Interface: PrivateStateProvider\<PSI, PS\>

Interface for a typed key-valued store containing contract private states.

## Type Parameters

### PSI

`PSI` *extends* [`PrivateStateId`](../type-aliases/PrivateStateId.md) = [`PrivateStateId`](../type-aliases/PrivateStateId.md)

Parameter indicating the private state ID, sometimes a union of string literals.

### PS

`PS` = `any`

Parameter indicating the private state type stored, sometimes a union of private state types.

## Methods

### clear()

> **clear**(): `Promise`\<`void`\>

Remove all contract private states.

#### Returns

`Promise`\<`void`\>

***

### clearSigningKeys()

> **clearSigningKeys**(): `Promise`\<`void`\>

Remove all contract signing keys.

#### Returns

`Promise`\<`void`\>

***

### get()

> **get**(`privateStateId`): `Promise`\<`PS` \| `null`\>

Retrieve the private state at the given private state ID.

#### Parameters

##### privateStateId

`PSI`

The private state identifier.

#### Returns

`Promise`\<`PS` \| `null`\>

***

### getSigningKey()

> **getSigningKey**(`address`): `Promise`\<`string` \| `null`\>

Retrieve the signing key for a contract.

#### Parameters

##### address

`string`

The address of the contract for which to get the signing key.

#### Returns

`Promise`\<`string` \| `null`\>

***

### remove()

> **remove**(`privateStateId`): `Promise`\<`void`\>

Remove the value at the given private state ID.

#### Parameters

##### privateStateId

`PSI`

The private state identifier.

#### Returns

`Promise`\<`void`\>

***

### removeSigningKey()

> **removeSigningKey**(`address`): `Promise`\<`void`\>

Remove the signing key for a contract.

#### Parameters

##### address

`string`

The address of the contract for which to delete the signing key.

#### Returns

`Promise`\<`void`\>

***

### set()

> **set**(`privateStateId`, `state`): `Promise`\<`void`\>

Store the given private state at the given private state ID.

#### Parameters

##### privateStateId

`PSI`

The private state identifier.

##### state

`PS`

The private state to store.

#### Returns

`Promise`\<`void`\>

***

### setSigningKey()

> **setSigningKey**(`address`, `signingKey`): `Promise`\<`void`\>

Store the given signing key at the given address.

#### Parameters

##### address

`string`

The address of the contract having the given signing key.

##### signingKey

`string`

The signing key to store.

#### Returns

`Promise`\<`void`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/ProofProvider.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ProofProvider

# Interface: ProofProvider\<K\>

Interface for a proof server running in a trusted environment.

## Type Parameters

### K

`K` *extends* `string`

The type of the circuit ID used by the provider.

## Methods

### proveTx()

> **proveTx**(`unprovenTx`, `proveTxConfig?`): `Promise`\<[`ProvenTransaction`](../type-aliases/ProvenTransaction.md)\>

Creates call proofs for an unproven transaction. The resulting transaction is unbalanced and
must be balanced using the [WalletProvider](WalletProvider.md) interface.
          contain a single contract call.

#### Parameters

##### unprovenTx

`UnprovenTransaction`

##### proveTxConfig?

[`ProveTxConfig`](ProveTxConfig.md)\<`K`\>

The configuration for the proof request to the proof provider. Empty in case
                     a deploy transaction is being proved with no user-defined timeout.

#### Returns

`Promise`\<[`ProvenTransaction`](../type-aliases/ProvenTransaction.md)\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/ProveTxConfig.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ProveTxConfig

# Interface: ProveTxConfig\<K\>

The configuration for the proof request to the proof provider.

## Type Parameters

### K

`K` *extends* `string`

## Properties

### timeout?

> `readonly` `optional` **timeout**: `number`

The timeout for the request.

***

### zkConfig?

> `readonly` `optional` **zkConfig**: [`ZKConfig`](ZKConfig.md)\<`K`\>

The zero-knowledge configuration for the circuit that was called in `tx`.
Undefined if `tx` is a deployment transaction.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/PublicDataProvider.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / PublicDataProvider

# Interface: PublicDataProvider

Interface for a public data service. This service retrieves public data from the blockchain.
TODO: Add timeouts or retry limits to 'watchFor' queries.

## Methods

### contractStateObservable()

> **contractStateObservable**(`address`, `config`): `Observable`\<`ContractState`\>

Creates a stream of contract states. The observable emits a value every time a state is either
created or updated at the given address.
Waits indefinitely for matching data to appear.

#### Parameters

##### address

`string`

The address of the contract of interest.

##### config

[`ContractStateObservableConfig`](../type-aliases/ContractStateObservableConfig.md)

The configuration for the observable.

#### Returns

`Observable`\<`ContractState`\>

***

### queryContractState()

> **queryContractState**(`contractAddress`, `config?`): `Promise`\<`ContractState` \| `null`\>

Retrieves the on-chain state of a contract. If no block hash or block height are provided, the
contract state at the address in the latest block is returned.
Immediately returns null if no matching data is found.

#### Parameters

##### contractAddress

`string`

The address of the contract of interest.

##### config?

The configuration of the query.
              If `undefined` returns the latest states.

[`BlockHeightConfig`](../type-aliases/BlockHeightConfig.md) | [`BlockHashConfig`](../type-aliases/BlockHashConfig.md)

#### Returns

`Promise`\<`ContractState` \| `null`\>

***

### queryDeployContractState()

> **queryDeployContractState**(`contractAddress`): `Promise`\<`ContractState` \| `null`\>

Retrieves the contract state included in the deployment of the contract at the given contract address.
Immediately returns null if no matching data is found.

#### Parameters

##### contractAddress

`string`

The address of the contract of interest.

#### Returns

`Promise`\<`ContractState` \| `null`\>

***

### queryUnshieldedBalances()

> **queryUnshieldedBalances**(`contractAddress`, `config?`): `Promise`\<[`UnshieldedBalances`](../type-aliases/UnshieldedBalances.md) \| `null`\>

Retrieves the unshielded balances associated with a specific contract address.

#### Parameters

##### contractAddress

`string`

The address of the contract of interest.

##### config?

The configuration of the query.
              If `undefined` returns the latest states.

[`BlockHeightConfig`](../type-aliases/BlockHeightConfig.md) | [`BlockHashConfig`](../type-aliases/BlockHashConfig.md)

#### Returns

`Promise`\<[`UnshieldedBalances`](../type-aliases/UnshieldedBalances.md) \| `null`\>

***

### queryZSwapAndContractState()

> **queryZSwapAndContractState**(`contractAddress`, `config?`): `Promise`\<\[`ZswapChainState`, `ContractState`\] \| `null`\>

Retrieves the zswap chain state (token balances) and the contract state of the contract at the
given address. Both states are retrieved in a single query to ensure consistency between the two.
Immediately returns null if no matching data is found.

#### Parameters

##### contractAddress

`string`

The address of the contract of interest.

##### config?

The configuration of the query.
              If `undefined` returns the latest states.

[`BlockHeightConfig`](../type-aliases/BlockHeightConfig.md) | [`BlockHashConfig`](../type-aliases/BlockHashConfig.md)

#### Returns

`Promise`\<\[`ZswapChainState`, `ContractState`\] \| `null`\>

***

### unshieldedBalancesObservable()

> **unshieldedBalancesObservable**(`address`, `config`): `Observable`\<[`UnshieldedBalances`](../type-aliases/UnshieldedBalances.md)\>

Retrieves an observable that tracks the unshielded balances for a specific contract address.

#### Parameters

##### address

`string`

The contract address for which unshielded balances are being observed.

##### config

[`ContractStateObservableConfig`](../type-aliases/ContractStateObservableConfig.md)

The configuration object for observing contract state changes.

#### Returns

`Observable`\<[`UnshieldedBalances`](../type-aliases/UnshieldedBalances.md)\>

An observable that emits the unshielded balances for the provided address.

***

### watchForContractState()

> **watchForContractState**(`contractAddress`): `Promise`\<`ContractState`\>

Retrieves the contract state of the contract with the given address.
Waits indefinitely for matching data to appear.

#### Parameters

##### contractAddress

`string`

The address of the contract of interest.

#### Returns

`Promise`\<`ContractState`\>

***

### watchForDeployTxData()

> **watchForDeployTxData**(`contractAddress`): `Promise`\<[`FinalizedTxData`](FinalizedTxData.md)\>

Retrieves data of the deployment transaction for the contract at the given contract address.

**IMPORTANT: This method waits indefinitely** until the deployment transaction appears on the
blockchain. It will never timeout or reject unless an error occurs.

Custom implementations MUST maintain this indefinite waiting behavior to ensure consistency
across all PublicDataProvider implementations. Do not implement timeouts in this method.

#### Parameters

##### contractAddress

`string`

The address of the contract of interest.

#### Returns

`Promise`\<[`FinalizedTxData`](FinalizedTxData.md)\>

A promise that resolves with finalized transaction data when the deployment appears on-chain.
         The promise never rejects due to timeout.

***

### watchForTxData()

> **watchForTxData**(`txId`): `Promise`\<[`FinalizedTxData`](FinalizedTxData.md)\>

Retrieves data of the transaction containing the call or deployment with the given identifier.

**IMPORTANT: This method waits indefinitely** until the transaction appears on the blockchain.
It will never timeout or reject unless an error occurs.

Custom implementations MUST maintain this indefinite waiting behavior to ensure consistency
across all PublicDataProvider implementations. Do not implement timeouts in this method.

Applications using this method should be aware that:
- The promise will not resolve until the transaction appears on-chain
- If a transaction is invalid and never appears, this will never return
- Consider using application-level timeouts or cancellation mechanisms if needed

#### Parameters

##### txId

`string`

The identifier of the call or deployment of interest.

#### Returns

`Promise`\<[`FinalizedTxData`](FinalizedTxData.md)\>

A promise that resolves with finalized transaction data when the transaction appears on-chain.
         The promise never rejects due to timeout.

***

### watchForUnshieldedBalances()

> **watchForUnshieldedBalances**(`contractAddress`): `Promise`\<[`UnshieldedBalances`](../type-aliases/UnshieldedBalances.md)\>

Monitors for any unshielded balances associated with a specific contract address.

#### Parameters

##### contractAddress

`string`

The address of the contract to monitor for unshielded balances.

#### Returns

`Promise`\<[`UnshieldedBalances`](../type-aliases/UnshieldedBalances.md)\>

A promise that resolves to the detected unshielded balances.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/WalletProvider.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / WalletProvider

# Interface: WalletProvider

Interface representing a WalletProvider that handles operations such as
transaction balancing and finalization, and provides access to cryptographic secret keys.

## Methods

### balanceTx()

> **balanceTx**(`tx`, `newCoins?`, `ttl?`): `Promise`\<[`BalancedProvingRecipe`](../type-aliases/BalancedProvingRecipe.md)\>

Balances a transaction

#### Parameters

##### tx

`UnprovenTransaction`

The transaction to balance.

##### newCoins?

`ShieldedCoinInfo`[]

##### ttl?

`Date`

#### Returns

`Promise`\<[`BalancedProvingRecipe`](../type-aliases/BalancedProvingRecipe.md)\>

***

### getCoinPublicKey()

> **getCoinPublicKey**(): `string`

#### Returns

`string`

***

### getEncryptionPublicKey()

> **getEncryptionPublicKey**(): `string`

#### Returns

`string`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/ZKConfig.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ZKConfig

# Interface: ZKConfig\<K\>

Contains all information required by the [ProofProvider](ProofProvider.md)

## Type Parameters

### K

`K` *extends* `string`

The type of the circuit ID.

## Properties

### circuitId

> `readonly` **circuitId**: `K`

A circuit identifier.

***

### proverKey

> `readonly` **proverKey**: [`ProverKey`](../type-aliases/ProverKey.md)

The prover key corresponding to [ZKConfig.circuitId](#circuitid).

***

### verifierKey

> `readonly` **verifierKey**: [`VerifierKey`](../type-aliases/VerifierKey.md)

The verifier key corresponding to [ZKConfig.circuitId](#circuitid).

***

### zkir

> `readonly` **zkir**: [`ZKIR`](../type-aliases/ZKIR.md)

The zero-knowledge intermediate representation corresponding to [ZKConfig.circuitId](#circuitid).

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/All.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / All

# Type Alias: All

> **All** = `object`

Streams all previous states of a contract.

## Properties

### type

> `readonly` **type**: `"all"`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/BlockHash.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / BlockHash

# Type Alias: BlockHash

> **BlockHash** = `string`

Block identifier

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/BlockHashConfig.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / BlockHashConfig

# Type Alias: BlockHashConfig

> **BlockHashConfig** = `object`

Starts a contract state stream at the given block hash.

## Properties

### blockHash

> `readonly` **blockHash**: `string`

The block height indicating where to begin the state stream.

***

### type

> `readonly` **type**: `"blockHash"`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/BlockHeightConfig.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / BlockHeightConfig

# Type Alias: BlockHeightConfig

> **BlockHeightConfig** = `object`

Starts a contract state stream at the given block height.

## Properties

### blockHeight

> `readonly` **blockHeight**: `number`

The block height indicating where to begin the state stream.

***

### type

> `readonly` **type**: `"blockHeight"`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/CircuitParameters.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / CircuitParameters

# Type Alias: CircuitParameters\<C, K\>

> **CircuitParameters**\<`C`, `K`\> = `Parameters`\<`C`\[`"impureCircuits"`\]\[`K`\]\> *extends* \[`CircuitContext`\<`any`\>, `...(infer A)`\] ? `A` : `never`

The parameter types of the circuits in a contract.

## Type Parameters

### C

`C` *extends* [`Contract`](../interfaces/Contract.md)

### K

`K` *extends* [`ImpureCircuitId`](ImpureCircuitId.md)\<`C`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/CircuitReturnType.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / CircuitReturnType

# Type Alias: CircuitReturnType\<C, K\>

> **CircuitReturnType**\<`C`, `K`\> = `ReturnType`\<`C`\[`"impureCircuits"`\]\[`K`\]\> *extends* `CircuitResults`\<`any`, infer U\> ? `U` : `never`

The return types of the circuits in a contract.

## Type Parameters

### C

`C` *extends* [`Contract`](../interfaces/Contract.md)

### K

`K` *extends* [`ImpureCircuitId`](ImpureCircuitId.md)\<`C`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/ContractStateObservableConfig.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ContractStateObservableConfig

# Type Alias: ContractStateObservableConfig

> **ContractStateObservableConfig** = [`TxIdConfig`](TxIdConfig.md) \| [`BlockHashConfig`](BlockHashConfig.md) \| [`BlockHeightConfig`](BlockHeightConfig.md) & `object` \| [`Latest`](Latest.md) \| [`All`](All.md)

The configuration for a contract state observable. The corresponding observables may begin at different
places (e.g. after a specific transaction identifier / block height) depending on the configuration, but
all state updates after the beginning are always included.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/Fees.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / Fees

# Type Alias: Fees

> **Fees** = `object`

Represents the fees associated with a particular entity or operation.

This type includes both the paid fees and the estimated fees. The paid fees represent
the amount that has already been settled, while the estimated fees provide a calculation
or projection of expected fees.

## Properties

### estimatedFees

> `readonly` **estimatedFees**: `string`

The estimated fees that are expected to be incurred.

***

### paidFees

> `readonly` **paidFees**: `string`

The fees that have already been paid.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/ImpureCircuit.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ImpureCircuit

# Type Alias: ImpureCircuit()\<PS\>

> **ImpureCircuit**\<`PS`\> = (`context`, ...`args`) => `CircuitResults`\<`PS`, `any`\>

A circuit which affects the public state.

## Type Parameters

### PS

`PS`

The private state modified by the contract witnesses.

## Parameters

### context

`CircuitContext`\<`PS`\>

### args

...`any`[]

## Returns

`CircuitResults`\<`PS`, `any`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/ImpureCircuitId.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ImpureCircuitId

# Type Alias: ImpureCircuitId\<C\>

> **ImpureCircuitId**\<`C`\> = keyof `C`\[`"impureCircuits"`\] & `string`

A union over the impure circuit identifiers of a contract.

## Type Parameters

### C

`C` *extends* [`Contract`](../interfaces/Contract.md) = [`Contract`](../interfaces/Contract.md)

The contract type for which we would like impure circuit IDs.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/ImpureCircuits.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ImpureCircuits

# Type Alias: ImpureCircuits\<PS\>

> **ImpureCircuits**\<`PS`\> = `Record`\<`string`, [`ImpureCircuit`](ImpureCircuit.md)\<`PS`\>\>

A collection of impure circuits defined in a contract.

## Type Parameters

### PS

`PS`

The private state modified by the contract witnesses.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/InitialStateParameters.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / InitialStateParameters

# Type Alias: InitialStateParameters\<C\>

> **InitialStateParameters**\<`C`\> = `Parameters`\<`C`\[`"initialState"`\]\> *extends* \[`ConstructorContext`\<`any`\>, `...(infer A)`\] ? `A` : `never`

The parameter type of the public state constructor.

## Type Parameters

### C

`C` *extends* [`Contract`](../interfaces/Contract.md)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/Latest.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / Latest

# Type Alias: Latest

> **Latest** = `object`

Streams all states of a contract starting with the most recent.

## Properties

### type

> `readonly` **type**: `"latest"`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/NothingToProve.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / NothingToProve

# Type Alias: NothingToProve\<TTransaction\>

> **NothingToProve**\<`TTransaction`\> = `object`

## Type Parameters

### TTransaction

`TTransaction`

## Properties

### transaction

> `readonly` **transaction**: `TTransaction`

***

### type

> `readonly` **type**: *typeof* [`NOTHING_TO_PROVE`](../variables/NOTHING_TO_PROVE.md)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/PrivateState.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / PrivateState

# Type Alias: PrivateState\<C\>

> **PrivateState**\<`C`\> = `C` *extends* [`Contract`](../interfaces/Contract.md)\<infer PS\> ? `PS` : `never`

Extracts the private state of a contract.

## Type Parameters

### C

`C` *extends* [`Contract`](../interfaces/Contract.md)

The contract for which we would like the private state.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/PrivateStateId.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / PrivateStateId

# Type Alias: PrivateStateId

> **PrivateStateId** = `string`

A type representing an ID used to store a contract's private state.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/ProvenTransaction.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ProvenTransaction

# Type Alias: ProvenTransaction

> **ProvenTransaction** = `Transaction`\<`SignatureEnabled`, `Proof`, `PreBinding`\>

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/ProverKey.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ProverKey

# Type Alias: ProverKey

> **ProverKey** = `Uint8Array` & `object`

A type representing a prover key derived from a contract circuit.

## Type Declaration

### ProverKey

> `readonly` **ProverKey**: unique `symbol`

Unique symbol brand.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/SegmentStatus.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / SegmentStatus

# Type Alias: SegmentStatus

> **SegmentStatus** = *typeof* [`SegmentSuccess`](../variables/SegmentSuccess.md) \| *typeof* [`SegmentFail`](../variables/SegmentFail.md)

Represents the result of a segment operation, which can either be a successful operation
(`SegmentSuccess`) or a failed operation (`SegmentFail`).

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/TransactionToProve.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / TransactionToProve

# Type Alias: TransactionToProve

> **TransactionToProve** = `object`

## Properties

### transaction

> `readonly` **transaction**: `UnprovenTransaction`

***

### type

> `readonly` **type**: *typeof* [`TRANSACTION_TO_PROVE`](../variables/TRANSACTION_TO_PROVE.md)

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/TxIdConfig.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / TxIdConfig

# Type Alias: TxIdConfig

> **TxIdConfig** = `object`

Starts a contract state stream at the given transaction identifier.

## Properties

### txId

> `readonly` **txId**: `TransactionId`

The transaction identifier indicating where to begin the state stream.

***

### type

> `readonly` **type**: `"txId"`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/TxStatus.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / TxStatus

# Type Alias: TxStatus

> **TxStatus** = *typeof* [`FailEntirely`](../variables/FailEntirely.md) \| *typeof* [`FailFallible`](../variables/FailFallible.md) \| *typeof* [`SucceedEntirely`](../variables/SucceedEntirely.md)

The status of a transaction.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/UnshieldedBalance.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / UnshieldedBalance

# Type Alias: UnshieldedBalance

> **UnshieldedBalance** = `object`

Represents an unshielded balance, which is a balance that is not shielded or encrypted.
This type is used to track the available funds in an account that are visible on the public ledger.

## Properties

### balance

> `readonly` **balance**: `bigint`

Represents the current number of funds available or held in an account.

***

### tokenType

> `readonly` **tokenType**: `RawTokenType`

Represents the type of token in the system.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/UnshieldedBalances.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / UnshieldedBalances

# Type Alias: UnshieldedBalances

> **UnshieldedBalances** = [`UnshieldedBalance`](UnshieldedBalance.md)[]

Represents a collection of unshielded balances, which are balances that are not shielded or encrypted.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/UnshieldedUtxo.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / UnshieldedUtxo

# Type Alias: UnshieldedUtxo

> **UnshieldedUtxo** = `object`

Represents an unshielded UTXO (Unspent Transaction Output).
Unshielded UTXOs are outputs that have not been shielded or encrypted, making them visible on the public ledger.

## Properties

### intentHash

> `readonly` **intentHash**: `IntentHash`

The identifier of the intent associated with the unshielded UTXO.
This is used to track the intent behind the creation or use of the UTXO.

***

### owner

> `readonly` **owner**: `ContractAddress`

The unique identifier of the unshielded UTXO.

***

### tokenType

> `readonly` **tokenType**: `RawTokenType`

The type of token associated with the unshielded UTXO.
This indicates the kind of asset or currency represented by the UTXO.

***

### value

> `readonly` **value**: `bigint`

The value of the unshielded UTXO, represented as a bigint.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/UnshieldedUtxos.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / UnshieldedUtxos

# Type Alias: UnshieldedUtxos

> **UnshieldedUtxos** = `object`

Represents a collection of unshielded UTXOs, which are unspent transaction outputs that are not shielded.
This type is used to manage and track the state of unshielded UTXOs.

## Properties

### created

> `readonly` **created**: readonly [`UnshieldedUtxo`](UnshieldedUtxo.md)[]

Represents the unshielded UTXOs that have been created but not yet spent.

***

### spent

> `readonly` **spent**: readonly [`UnshieldedUtxo`](UnshieldedUtxo.md)[]

Represents the unshielded UTXOs that have been spent.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/VerifierKey.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / VerifierKey

# Type Alias: VerifierKey

> **VerifierKey** = `Uint8Array` & `object`

A type representing a verifier key derived from a contract circuit.

## Type Declaration

### VerifierKey

> `readonly` **VerifierKey**: unique `symbol`

Unique symbol brand.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/Witness.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / Witness

# Type Alias: Witness()\<PS\>

> **Witness**\<`PS`\> = (`context`, ...`rest`) => \[`PS`, `any`\]

A type representing a witness in a contract.

## Type Parameters

### PS

`PS`

The private state modified by the witness.

## Parameters

### context

`WitnessContext`\<`any`, `PS`\>

### rest

...`any`[]

## Returns

\[`PS`, `any`\]

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/Witnesses.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / Witnesses

# Type Alias: Witnesses\<PS\>

> **Witnesses**\<`PS`\> = `Record`\<`string`, [`Witness`](Witness.md)\<`PS`\>\>

A type representing all of a contract's witnesses.

## Type Parameters

### PS

`PS` = `any`

The private state modified by the contract witnesses.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/ZKIR.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ZKIR

# Type Alias: ZKIR

> **ZKIR** = `Uint8Array` & `object`

A type representing a zero-knowledge circuit intermediate representation derived from a contract circuit.

## Type Declaration

### ZKIR

> `readonly` **ZKIR**: unique `symbol`

Unique symbol brand.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/variables/FailEntirely.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / FailEntirely

# Variable: FailEntirely

> `const` **FailEntirely**: `"FailEntirely"`

Indicates that the transaction is invalid.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/variables/FailFallible.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / FailFallible

# Variable: FailFallible

> `const` **FailFallible**: `"FailFallible"`

Indicates that the transaction is valid but the portion of the transcript
that is allowed to fail (the portion after a checkpoint) did fail. All effects
from the guaranteed part of the transaction are kept but the effects from the
fallible part of the transaction are discarded.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/variables/NOTHING_TO_PROVE.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / NOTHING\_TO\_PROVE

# Variable: NOTHING\_TO\_PROVE

> `const` **NOTHING\_TO\_PROVE**: `"NothingToProve"` = `'NothingToProve'`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/variables/SegmentFail.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / SegmentFail

# Variable: SegmentFail

> `const` **SegmentFail**: `"SegmentFail"`

Indicates that the segment update is invalid.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/variables/SegmentSuccess.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / SegmentSuccess

# Variable: SegmentSuccess

> `const` **SegmentSuccess**: `"SegmentSuccess"`

Indicates that the segment is valid.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/variables/SucceedEntirely.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / SucceedEntirely

# Variable: SucceedEntirely

> `const` **SucceedEntirely**: `"SucceedEntirely"`

Indicates that the guaranteed and fallible portions of the transaction were
successful.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/variables/TRANSACTION_TO_PROVE.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / TRANSACTION\_TO\_PROVE

# Variable: TRANSACTION\_TO\_PROVE

> `const` **TRANSACTION\_TO\_PROVE**: `"TransactionToProve"` = `'TransactionToProve'`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/assertDefined.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / assertDefined

# Function: assertDefined()

> **assertDefined**\<`A`\>(`value`, `message?`): `asserts value is NonNullable<A>`

Asserts that the given value is non-nullable.

## Type Parameters

### A

`A`

## Parameters

### value

The value to test for nullability.

`A` | `null` | `undefined`

### message?

`string`

The error message to use if an error is thrown.

## Returns

`asserts value is NonNullable<A>`

## Throws

Error If the value is nullable.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/assertIsContractAddress.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / assertIsContractAddress

# Function: assertIsContractAddress()

> **assertIsContractAddress**(`contractAddress`): `asserts contractAddress is string`

**`Internal`**

Asserts that a string represents a hex-encoded contract address.

## Parameters

### contractAddress

`string`

The source string.

## Returns

`asserts contractAddress is string`

## Throws

`TypeError`
`contractAddress` is not a correctly formatted ContractAddress.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/assertIsHex.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / assertIsHex

# Function: assertIsHex()

> **assertIsHex**(`source`, `byteLen?`): `asserts source is string`

Asserts that a string represents a hex-encoded sequence of bytes.

## Parameters

### source

`string`

The source string.

### byteLen?

`number`

An optional number of bytes that `source` should represent. If not specified
then any number of bytes can be represented by `source`.

## Returns

`asserts source is string`

## Throws

`Error`
`byteLen` is \<= zero. Valid hex-strings will be required to have at least one byte.

## Throws

`TypeError`
`source` is not a hex-encoded string because it:
- is empty,
- contains invalid or incomplete characters, or
- does not represent `byteLen` bytes.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/assertUndefined.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / assertUndefined

# Function: assertUndefined()

> **assertUndefined**\<`A`\>(`value`, `message?`): asserts value is null \| undefined

Asserts that the given value is null or undefined.

## Type Parameters

### A

`A`

## Parameters

### value

The value to test for nullability.

`A` | `null` | `undefined`

### message?

`string`

The error message to use if an error is thrown.

## Returns

asserts value is null \| undefined

## Throws

Error If the value is not undefined or null

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/fromHex.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / fromHex

# Function: fromHex()

> **fromHex**(`str`): `Buffer`

Converts a hex string into a byte string.

## Parameters

### str

`string`

The hex string to decode.

## Returns

`Buffer`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/isHex.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / isHex

# Function: isHex()

> **isHex**(`source`, `byteLen?`): `boolean`

Determines if a string represents a hex-encoded sequence of bytes.

## Parameters

### source

`string`

The source string.

### byteLen?

`number`

An optional number of bytes that `source` should represent. If not specified
then any number of bytes can be represented by `source`.

## Returns

`boolean`

`true` if the `source` string is parsable as a hex-string, of non-zero length, and
of the optional byte length of `byteLen`; otherwise `false`.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/parseCoinPublicKeyToHex.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / parseCoinPublicKeyToHex

# Function: parseCoinPublicKeyToHex()

> **parseCoinPublicKeyToHex**(`possibleBech32`, `zswapNetworkId`): `string`

Parses a coin public key (in Bech32m format or hex) into a hex formatted string.

## Parameters

### possibleBech32

`string`

The input string, which can be a Bech32m-encoded coin public key or a hex string.

### zswapNetworkId

`string`

The network ID used for decoding the Bech32m formatted string.

## Returns

`string`

The hex string representation of the coin public key.

## Throws

`Error`
If the input string is not a valid hex string or a valid Bech32m-encoded coin public key.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/parseEncPublicKeyToHex.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / parseEncPublicKeyToHex

# Function: parseEncPublicKeyToHex()

> **parseEncPublicKeyToHex**(`possibleBech32`, `zswapNetworkId`): `string`

Parses an encryption public key (in Bech32m or hex format) into a hex formatted string.

## Parameters

### possibleBech32

`string`

The input string, which can be a Bech32m-encoded encryption public key or a hex string.

### zswapNetworkId

`string`

The network ID used for decoding the Bech32m formatted string.

## Returns

`string`

The hex string representation of the encryption public key.

## Throws

`Error`
If the input string is not a valid hex string or a valid Bech32m-encoded encryption public key.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/parseHex.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / parseHex

# Function: parseHex()

> **parseHex**(`source`): [`ParsedHexString`](../type-aliases/ParsedHexString.md)

Parses a string as a hex-encoded string.

## Parameters

### source

`string`

The source string to parse.

## Returns

[`ParsedHexString`](../type-aliases/ParsedHexString.md)

A [ParsedHexString](../type-aliases/ParsedHexString.md) describing the parsed elements of `source`.

## Examples

```ts
parseHex('Hello') =>
  {
    hasPrefix: false,
    incompleteChars: 'Hello'
  }
```

```ts
parseHex('ab12e') =>
  {
    hasPrefix: false,
    byteChars: 'ab12'
    incompleteChars: 'e'
  }
```

```ts
parseHex('0xab12') =>
  {
    hasPrefix: true,
    byteChars: 'ab12'
    incompleteChars: ''
  }
```

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/toHex.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / toHex

# Function: toHex()

> **toHex**(`bytes`): `string`

Converts a byte string into a hex string.

## Parameters

### bytes

`Uint8Array`

The byte string to encode.

## Returns

`string`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/ttlOneHour.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / ttlOneHour

# Function: ttlOneHour()

> **ttlOneHour**(): `Date`

## Returns

`Date`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-utils/type-aliases/ParsedHexString.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / ParsedHexString

# Type Alias: ParsedHexString

> **ParsedHexString** = `object`

The result of parsing a string as a hex-encoded string.

## Properties

### byteChars

> `readonly` **byteChars**: `string`

The captured sequence of _whole_ bytes found in the source string.

***

### hasPrefix

> `readonly` **hasPrefix**: `boolean`

A flag indicating if the hex-string has a `'0x'` prefix.

***

### incompleteChars

> `readonly` **incompleteChars**: `string`

The remaining characters of incomplete bytes and/or the non hexadecimal characters found
in the source string.

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-utils/README.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-utils

# @midnight-ntwrk/midnight-js-utils

## Type Aliases

- [ParsedHexString](type-aliases/ParsedHexString.md)

## Functions

- [assertDefined](functions/assertDefined.md)
- [assertIsContractAddress](functions/assertIsContractAddress.md)
- [assertIsHex](functions/assertIsHex.md)
- [assertUndefined](functions/assertUndefined.md)
- [fromHex](functions/fromHex.md)
- [isHex](functions/isHex.md)
- [parseCoinPublicKeyToHex](functions/parseCoinPublicKeyToHex.md)
- [parseEncPublicKeyToHex](functions/parseEncPublicKeyToHex.md)
- [parseHex](functions/parseHex.md)
- [toHex](functions/toHex.md)
- [ttlOneHour](functions/ttlOneHour.md)

================
File: docs/api/midnight-js/packages.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](README.md)

***

# Midnight.js API Reference v3.0.0-alpha.9

## Packages

- [@midnight-ntwrk/midnight-js-contracts - v3.0.0-alpha.9](@midnight-ntwrk/midnight-js-contracts/README.md)
- [@midnight-ntwrk/midnight-js-fetch-zk-config-provider - v3.0.0-alpha.9](@midnight-ntwrk/midnight-js-fetch-zk-config-provider/README.md)
- [@midnight-ntwrk/midnight-js-http-client-proof-provider - v3.0.0-alpha.9](@midnight-ntwrk/midnight-js-http-client-proof-provider/README.md)
- [@midnight-ntwrk/midnight-js-indexer-public-data-provider - v3.0.0-alpha.9](@midnight-ntwrk/midnight-js-indexer-public-data-provider/README.md)
- [@midnight-ntwrk/midnight-js-level-private-state-provider - v3.0.0-alpha.9](@midnight-ntwrk/midnight-js-level-private-state-provider/README.md)
- [@midnight-ntwrk/midnight-js-logger-provider - v3.0.0-alpha.9](@midnight-ntwrk/midnight-js-logger-provider/README.md)
- [@midnight-ntwrk/midnight-js-network-id - v3.0.0-alpha.9](@midnight-ntwrk/midnight-js-network-id/README.md)
- [@midnight-ntwrk/midnight-js-node-zk-config-provider - v3.0.0-alpha.9](@midnight-ntwrk/midnight-js-node-zk-config-provider/README.md)
- [@midnight-ntwrk/midnight-js-types - v3.0.0-alpha.9](@midnight-ntwrk/midnight-js-types/README.md)
- [@midnight-ntwrk/midnight-js-utils - v3.0.0-alpha.9](@midnight-ntwrk/midnight-js-utils/README.md)

================
File: docs/api/midnight-js/README.md
================
**Midnight.js API Reference v3.0.0-alpha.9**

***

# Midnight.js

Midnight.js is a Typescript-based application development framework for the 
Midnight blockchain. Analogous to [Web3.js](https://web3js.org/) for Ethereum, or
[polkadot.js](https://polkadot.js.org/) for Polkadot, it contains utilities for:

- Creating and submitting transactions
- Interacting with wallets
- Querying for block and state information
- Subscribing to chain events

Due to the privacy-preservation properties of the Midnight system, Midnight.js also 
contains a number of utilities that are unique to it:

- Executing smart contracts locally
- Incorporating private state into contract execution
- Persisting, querying, and updating private state
- Creating and verifying zero-knowledge proofs

## Package structure

- `types` - Contains types and interfaces common to all other packages.
- `contracts` - Contains utilities for interacting with Midnight smart contracts.
- `indexer-public-data-provider` - Contains a cross-environment implementation of a Midnight indexer client.
- `node-zk-config-provider` - Contains a file system based Node.js utility for retrieving zero-knowledge artifacts.
- `fetch-zk-config-provider` - Contains a [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) based cross-environment utility for retrieving zero-knowledge artifacts.
- `network-id` - Contains utilities for setting the network id used by `ledger`, `zswap`, and `compact-runtime` dependencies.
- `http-client-proof-provider` - Contains a cross-environment implementation of a proof-server client.
- `level-private-state-provider` - Contains a cross-environment implementation of a persistent private state store based on [Level](https://github.com/Level/level).

================
File: docs/api/testkit-js/classes/DynamicProofServerContainer.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

A proof server container that is started and stopped dynamically by the test
suite on random port.

## Implements

- [`ProofServerContainer`](../interfaces/ProofServerContainer.md)

## Properties

### dockerEnv

> **dockerEnv**: `StartedDockerComposeEnvironment`

The Docker Compose environment running the container

## Methods

### getMappedPort()

> **getMappedPort**(): `number`

Gets the mapped port number for the container.

#### Returns

`number`

The mapped port number

***

### getUrl()

> **getUrl**(): `string`

Gets the URL where the proof server can be accessed.

#### Returns

`string`

The URL of the proof server

#### Implementation of

[`ProofServerContainer`](../interfaces/ProofServerContainer.md).[`getUrl`](../interfaces/ProofServerContainer.md#geturl)

***

### stop()

> **stop**(): `Promise`\<`void`\>

Stops the proof server container.

#### Returns

`Promise`\<`void`\>

A promise that resolves when the container is stopped

#### Implementation of

[`ProofServerContainer`](../interfaces/ProofServerContainer.md).[`stop`](../interfaces/ProofServerContainer.md#stop)

***

### start()

> `static` **start**(`logger`, `maybeUID?`, `maybeNetworkId?`): `Promise`\<`DynamicProofServerContainer`\>

Starts a new proof server container.

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

##### maybeUID?

`string`

Optional unique identifier for the container

##### maybeNetworkId?

`string`

Optional network ID for the container

#### Returns

`Promise`\<`DynamicProofServerContainer`\>

A promise that resolves to the new container instance

================
File: docs/api/testkit-js/classes/EnvVarRemoteTestEnvironment.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Test environment that configures services using environment variables.
Allows specifying custom endpoints through environment variables.

## Extends

- [`RemoteTestEnvironment`](RemoteTestEnvironment.md)

## Constructors

### Constructor

> **new EnvVarRemoteTestEnvironment**(`logger`): `EnvVarRemoteTestEnvironment`

Creates a new TestEnvironment instance.

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`EnvVarRemoteTestEnvironment`

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`constructor`](RemoteTestEnvironment.md#constructor)

## Methods

### getEnvironmentConfiguration()

> **getEnvironmentConfiguration**(): [`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Returns the configuration for environment services based on environment variables.
Required environment variables:
- MN_TEST_NETWORK_ID: Network identifier (e.g., 'testnet', 'devnet')
- MN_TEST_INDEXER: GraphQL API endpoint for the indexer
- MN_TEST_INDEXER_WS: WebSocket endpoint for the indexer
- MN_TEST_NODE: RPC endpoint for the blockchain node
Optional environment variables:
- MN_TEST_FAUCET: API endpoint for requesting test tokens

#### Returns

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Object containing service URLs from environment variables

#### Throws

If any required environment variable is not set

#### Overrides

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`getEnvironmentConfiguration`](RemoteTestEnvironment.md#getenvironmentconfiguration)

***

### getMidnightWalletProvider()

> **getMidnightWalletProvider**(): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

Starts a single wallet instance.

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

A promise that resolves to the started wallet

#### Throws

If no wallet could be started

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`getMidnightWalletProvider`](RemoteTestEnvironment.md#getmidnightwalletprovider)

***

### healthCheck()

> **healthCheck**(): `Promise`\<`void`\>

Performs a health check for the environment.
Checks the health of the node, indexer, and optionally the faucet services.

#### Returns

`Promise`\<`void`\>

A promise that resolves when the health check is complete.

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`healthCheck`](RemoteTestEnvironment.md#healthcheck)

***

### shutdown()

> **shutdown**(`saveWalletState?`): `Promise`\<`void`\>

Shuts down the test environment by closing all walletProviders and stopping the proof server.

#### Parameters

##### saveWalletState?

`boolean`

#### Returns

`Promise`\<`void`\>

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`shutdown`](RemoteTestEnvironment.md#shutdown)

***

### start()

> **start**(`maybeProofServerContainer?`): `Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

Starts the test environment by initializing the proof server and environment configuration.

#### Parameters

##### maybeProofServerContainer?

[`ProofServerContainer`](../interfaces/ProofServerContainer.md)

Optional proof server container to use instead of creating a new one

#### Returns

`Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

The environment configuration

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`start`](RemoteTestEnvironment.md#start)

***

### startMidnightWalletProviders()

> **startMidnightWalletProviders**(`amount`, `seeds`): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Creates and starts the specified number of wallet providers.

#### Parameters

##### amount

`number` = `1`

##### seeds

`string`[] | `undefined`

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Array of started wallet providers

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`startMidnightWalletProviders`](RemoteTestEnvironment.md#startmidnightwalletproviders)

================
File: docs/api/testkit-js/classes/FaucetClient.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Client for interacting with the Midnight faucet service.
Provides functionality to request test tokens for wallet addresses.

## Constructors

### Constructor

> **new FaucetClient**(`faucetUrl`, `logger`): `FaucetClient`

Creates a new FaucetClient instance.

#### Parameters

##### faucetUrl

`string`

The URL of the faucet service endpoint

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`FaucetClient`

## Properties

### faucetUrl

> `readonly` **faucetUrl**: `string`

## Methods

### health()

> **health**(): `Promise`\<`void` \| `AxiosResponse`\<`any`, `any`, \{ \}\>\>

Checks the health status of the faucet service.
Makes a GET request to the health endpoint of the faucet service.

#### Returns

`Promise`\<`void` \| `AxiosResponse`\<`any`, `any`, \{ \}\>\>

A promise that resolves to the response of the health check or logs an error if the request fails

***

### requestTokens()

> **requestTokens**(`walletAddress`): `Promise`\<`void`\>

Requests test tokens from the faucet for a specified wallet address.
Makes a POST request to the faucet service with the wallet address.

#### Parameters

##### walletAddress

`string`

The address to receive the test tokens

#### Returns

`Promise`\<`void`\>

A promise that resolves when the request is complete

#### Throws

Will log but not throw if the request fails

================
File: docs/api/testkit-js/classes/GzipFile.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

A class for compressing and decompressing files using gzip.

## Constructors

### Constructor

> **new GzipFile**(`inputFile`, `outputFile`): `GzipFile`

Creates a new GzipFile instance.

#### Parameters

##### inputFile

`string`

The path to the input file to compress/decompress

##### outputFile

`string`

The path where the compressed file will be saved

#### Returns

`GzipFile`

## Properties

### inputFile

> **inputFile**: `string`

The path to the input file

***

### outputFile

> **outputFile**: `string`

The path to the output file

## Methods

### compress()

> **compress**(): `Promise`\<`void`\>

Compresses the input file using gzip compression.

#### Returns

`Promise`\<`void`\>

A promise that resolves when compression is complete

#### Throws

If there is an error during compression

***

### decompress()

> **decompress**(): `Promise`\<`string`\>

Decompresses the input gzip file and returns its contents as a string.

#### Returns

`Promise`\<`string`\>

A promise that resolves with the decompressed file contents as a string

#### Throws

If there is an error during decompression

================
File: docs/api/testkit-js/classes/IndexerClient.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

## Constructors

### Constructor

> **new IndexerClient**(`indexerUrl`, `logger`): `IndexerClient`

Creates an instance of IndexerClient.

#### Parameters

##### indexerUrl

`string`

The URL of the indexer service.

##### logger

`Logger`

The logger instance for logging information.

#### Returns

`IndexerClient`

## Properties

### indexerUrl

> `readonly` **indexerUrl**: `string`

## Methods

### health()

> **health**(): `Promise`\<`void` \| `AxiosResponse`\<`any`, `any`, \{ \}\>\>

Checks the health status of the indexer service.
Makes a GET request to the status endpoint of the indexer service.

#### Returns

`Promise`\<`void` \| `AxiosResponse`\<`any`, `any`, \{ \}\>\>

A promise that resolves to the response of the health check or logs an error if the request fails.

================
File: docs/api/testkit-js/classes/LocalTestConfiguration.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Configuration class for local test environment implementing EnvironmentConfiguration

## Implements

- [`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

## Constructors

### Constructor

> **new LocalTestConfiguration**(`ports`): `LocalTestConfiguration`

Creates a new LocalTestConfiguration instance

#### Parameters

##### ports

[`ComponentPortsConfiguration`](../type-aliases/ComponentPortsConfiguration.md)

Object containing port numbers for each component

#### Returns

`LocalTestConfiguration`

## Properties

### faucet

> `readonly` **faucet**: `string` \| `undefined`

Optional URL for the faucet service to obtain test tokens

#### Implementation of

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md).[`faucet`](../interfaces/EnvironmentConfiguration.md#faucet)

***

### indexer

> `readonly` **indexer**: `string`

URL of the indexer HTTP endpoint

#### Implementation of

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md).[`indexer`](../interfaces/EnvironmentConfiguration.md#indexer)

***

### indexerWS

> `readonly` **indexerWS**: `string`

WebSocket URL for the indexer service

#### Implementation of

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md).[`indexerWS`](../interfaces/EnvironmentConfiguration.md#indexerws)

***

### networkId

> `readonly` **networkId**: `string`

Network identifier

#### Implementation of

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md).[`networkId`](../interfaces/EnvironmentConfiguration.md#networkid)

***

### node

> `readonly` **node**: `string`

URL of the blockchain node

#### Implementation of

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md).[`node`](../interfaces/EnvironmentConfiguration.md#node)

***

### nodeWS

> `readonly` **nodeWS**: `string`

WebSocket URL for the blockchain node

#### Implementation of

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md).[`nodeWS`](../interfaces/EnvironmentConfiguration.md#nodews)

***

### proofServer

> `readonly` **proofServer**: `string`

URL of the proof generation server

#### Implementation of

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md).[`proofServer`](../interfaces/EnvironmentConfiguration.md#proofserver)

***

### walletNetworkId

> `readonly` **walletNetworkId**: `NetworkId`

Wallet Network identifier

#### Implementation of

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md).[`walletNetworkId`](../interfaces/EnvironmentConfiguration.md#walletnetworkid)

================
File: docs/api/testkit-js/classes/LocalTestEnvironment.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Test environment for local development using Docker containers
Manages containers for node, indexer and proof server components

## Extends

- [`TestEnvironment`](TestEnvironment.md)

## Constructors

### Constructor

> **new LocalTestEnvironment**(`logger`): `LocalTestEnvironment`

Creates a new LocalTestEnvironment instance

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`LocalTestEnvironment`

#### Overrides

[`TestEnvironment`](TestEnvironment.md).[`constructor`](TestEnvironment.md#constructor)

## Properties

### dockerEnv

> **dockerEnv**: `StartedDockerComposeEnvironment`

***

### genesisMintWalletSeed

> `readonly` **genesisMintWalletSeed**: `string`[]

***

### MAX\_NUMBER\_OF\_WALLETS

> `readonly` `static` **MAX\_NUMBER\_OF\_WALLETS**: `4` = `4`

## Methods

### getEnvironmentConfiguration()

> **getEnvironmentConfiguration**(): [`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Returns the configuration for the testnet environment services.

#### Returns

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Object containing URLs for testnet services:
- indexer: GraphQL API endpoint for the indexer
- indexerWS: WebSocket endpoint for the indexer
- node: RPC endpoint for the blockchain node
- faucet: API endpoint for requesting test tokens
- proofServer: URL for the proof generation server

#### Overrides

[`TestEnvironment`](TestEnvironment.md).[`getEnvironmentConfiguration`](TestEnvironment.md#getenvironmentconfiguration)

***

### getMidnightWalletProvider()

> **getMidnightWalletProvider**(): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

Starts a single wallet instance.

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

A promise that resolves to the started wallet

#### Throws

If no wallet could be started

#### Inherited from

[`TestEnvironment`](TestEnvironment.md).[`getMidnightWalletProvider`](TestEnvironment.md#getmidnightwalletprovider)

***

### shutdown()

> **shutdown**(`saveWalletState?`): `Promise`\<`void`\>

Shuts down the test environment, closing walletProviders and stopping containers

#### Parameters

##### saveWalletState?

`boolean`

#### Returns

`Promise`\<`void`\>

#### Overrides

[`TestEnvironment`](TestEnvironment.md).[`shutdown`](TestEnvironment.md#shutdown)

***

### start()

> **start**(`maybeProofServerContainer?`): `Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

Starts the test environment by creating and configuring Docker containers

#### Parameters

##### maybeProofServerContainer?

[`ProofServerContainer`](../interfaces/ProofServerContainer.md)

Optional proof server container

#### Returns

`Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

The environment configuration

#### Throws

If trying to inject proof server container when starting new environment

#### Overrides

[`TestEnvironment`](TestEnvironment.md).[`start`](TestEnvironment.md#start)

***

### startMidnightWalletProviders()

> **startMidnightWalletProviders**(`amount`, `seeds`): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Creates and starts the specified number of wallet providers

#### Parameters

##### amount

`number` = `1`

##### seeds

`string`[] | `undefined`

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

A promise that resolves to an array of started wallets

#### Throws

If requested amount exceeds maximum supported walletProviders

#### Overrides

[`TestEnvironment`](TestEnvironment.md).[`startMidnightWalletProviders`](TestEnvironment.md#startmidnightwalletproviders)

***

### startWithInjectedEnvironment()

> **startWithInjectedEnvironment**(`dockerEnv`, `ports`): `Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

Instead of starting the test environment by building the docker containers
from the default configuration files in this package, start the test environment
by passing an existing StartedDockerComposeEnvironment along with the
ports for the containers in the environment.

#### Parameters

##### dockerEnv

`StartedDockerComposeEnvironment`

A started docker compose environment

##### ports

[`ComponentPortsConfiguration`](../type-aliases/ComponentPortsConfiguration.md)

The ports of the containers in the given environment

#### Returns

`Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

The environment configuration

================
File: docs/api/testkit-js/classes/MidnightWalletProvider.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Provider class that implements wallet functionality for the Midnight network.
Handles transaction balancing, submission, and wallet state management.

## Implements

- `MidnightProvider`
- `WalletProvider`

## Properties

### dustSecretKey

> `readonly` **dustSecretKey**: `DustSecretKey`

***

### env

> `readonly` **env**: [`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

***

### logger

> **logger**: `Logger`

***

### wallet

> `readonly` **wallet**: `WalletFacade`

***

### zswapSecretKeys

> `readonly` **zswapSecretKeys**: `ZswapSecretKeys`

## Methods

### balanceTx()

> **balanceTx**(`tx`, `_newCoins`, `ttl`): `Promise`\<`BalancedProvingRecipe`\>

Balances a transaction

#### Parameters

##### tx

`UnprovenTransaction`

The transaction to balance.

##### \_newCoins

`ShieldedCoinInfo`[]

##### ttl

`Date` = `...`

#### Returns

`Promise`\<`BalancedProvingRecipe`\>

#### Implementation of

`WalletProvider.balanceTx`

***

### getCoinPublicKey()

> **getCoinPublicKey**(): `string`

#### Returns

`string`

#### Implementation of

`WalletProvider.getCoinPublicKey`

***

### getEncryptionPublicKey()

> **getEncryptionPublicKey**(): `string`

#### Returns

`string`

#### Implementation of

`WalletProvider.getEncryptionPublicKey`

***

### start()

> **start**(`waitForFundsInWallet`, `tokenType`): `Promise`\<`void`\>

#### Parameters

##### waitForFundsInWallet

`boolean` = `true`

##### tokenType

`TokenType` = `...`

#### Returns

`Promise`\<`void`\>

***

### stop()

> **stop**(): `Promise`\<`void`\>

#### Returns

`Promise`\<`void`\>

***

### submitTx()

> **submitTx**(`tx`): `Promise`\<`string`\>

Submit a transaction to the network to be consensed upon.

#### Parameters

##### tx

`FinalizedTransaction`

The finalized transaction to submit.

#### Returns

`Promise`\<`string`\>

The transaction identifier of the submitted transaction.

#### Implementation of

`MidnightProvider.submitTx`

***

### build()

> `static` **build**(`logger`, `env`, `seed?`): `Promise`\<`MidnightWalletProvider`\>

#### Parameters

##### logger

`Logger`

##### env

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

##### seed?

`string`

#### Returns

`Promise`\<`MidnightWalletProvider`\>

***

### withWallet()

> `static` **withWallet**(`logger`, `env`, `wallet`, `zswapSecretKeys`, `dustSecretKey`): `Promise`\<`MidnightWalletProvider`\>

#### Parameters

##### logger

`Logger`

##### env

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

##### wallet

`WalletFacade`

##### zswapSecretKeys

`ZswapSecretKeys`

##### dustSecretKey

`DustSecretKey`

#### Returns

`Promise`\<`MidnightWalletProvider`\>

================
File: docs/api/testkit-js/classes/NodeClient.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Client for interacting with a Midnight node's JSON-RPC API

## Constructors

### Constructor

> **new NodeClient**(`nodeURL`, `logger`): `NodeClient`

Creates a new NodeClient instance

#### Parameters

##### nodeURL

`string`

URL of the Midnight node

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`NodeClient`

## Properties

### nodeURL

> `readonly` **nodeURL**: `string`

## Methods

### contractState()

> **contractState**(`contractAddress`): `Promise`\<`ContractState` \| `null`\>

Fetches the state of a contract

#### Parameters

##### contractAddress

`string`

Address of the contract

#### Returns

`Promise`\<`ContractState` \| `null`\>

Contract state or null if not found

***

### health()

> **health**(): `Promise`\<`void` \| `AxiosResponse`\<`any`, `any`, \{ \}\>\>

Checks the health status of the node.
Makes a GET request to the health endpoint of the node.

#### Returns

`Promise`\<`void` \| `AxiosResponse`\<`any`, `any`, \{ \}\>\>

A promise that resolves to the response of the health check or logs an error if the request fails.

***

### ledgerState()

> **ledgerState**(`blockHash`): `Promise`\<`LedgerState`\>

Fetches the ledger state at a given block

#### Parameters

##### blockHash

`string`

Hash of the block

#### Returns

`Promise`\<`LedgerState`\>

Ledger state

***

### ledgerStateBlob()

> **ledgerStateBlob**(`blockHash`): `Promise`\<`Uint8Array`\<`ArrayBufferLike`\>\>

Fetches the raw ledger state blob at a given block

#### Parameters

##### blockHash

`string`

Hash of the block

#### Returns

`Promise`\<`Uint8Array`\<`ArrayBufferLike`\>\>

Raw ledger state data

#### Throws

If no ledger state is found

***

### ledgerVersion()

> **ledgerVersion**(`blockHash`): `Promise`\<`string`\>

Fetches the ledger version at a given block

#### Parameters

##### blockHash

`string`

Hash of the block

#### Returns

`Promise`\<`string`\>

Ledger version

#### Throws

If no ledger version is found

================
File: docs/api/testkit-js/classes/ProofServerClient.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

## Constructors

### Constructor

> **new ProofServerClient**(`proofServer`, `logger`): `ProofServerClient`

Creates an instance of ProofServerClient.

#### Parameters

##### proofServer

`string`

The URL of the proof server service.

##### logger

`Logger`

The logger instance for logging information.

#### Returns

`ProofServerClient`

## Properties

### proofServer

> `readonly` **proofServer**: `string`

## Methods

### health()

> **health**(): `Promise`\<`void` \| `AxiosResponse`\<`any`, `any`, \{ \}\>\>

Checks the health status of the indexer service.
Makes a GET request to the status endpoint of the indexer service.

#### Returns

`Promise`\<`void` \| `AxiosResponse`\<`any`, `any`, \{ \}\>\>

A promise that resolves to the response of the health check or logs an error if the request fails.

***

### proveTx()

> **proveTx**(`data?`, `config?`): `Promise`\<`void` \| `AxiosResponse`\<`any`, `any`, \{ \}\>\>

Proves a transaction by sending a POST request to the proof server.

#### Parameters

##### data?

`ArrayBuffer`

serialized transaction data

##### config?

`AxiosRequestConfig` = `...`

Axios request configuration

#### Returns

`Promise`\<`void` \| `AxiosResponse`\<`any`, `any`, \{ \}\>\>

================
File: docs/api/testkit-js/classes/QanetTestEnvironment.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Test environment configuration for the Midnight QA network.
Provides URLs and endpoints for QA network services.

## Extends

- [`RemoteTestEnvironment`](RemoteTestEnvironment.md)

## Constructors

### Constructor

> **new QanetTestEnvironment**(`logger`): `QanetTestEnvironment`

Creates a new TestEnvironment instance.

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`QanetTestEnvironment`

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`constructor`](RemoteTestEnvironment.md#constructor)

## Methods

### getEnvironmentConfiguration()

> **getEnvironmentConfiguration**(): [`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Returns the configuration for the QA network environment services.

#### Returns

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Object containing URLs for QA network services:
- indexer: GraphQL API endpoint for the indexer
- indexerWS: WebSocket endpoint for the indexer
- node: RPC endpoint for the blockchain node
- faucet: API endpoint for requesting test tokens
- proofServer: URL for the proof generation server

#### Overrides

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`getEnvironmentConfiguration`](RemoteTestEnvironment.md#getenvironmentconfiguration)

***

### getMidnightWalletProvider()

> **getMidnightWalletProvider**(): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

Starts a single wallet instance.

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

A promise that resolves to the started wallet

#### Throws

If no wallet could be started

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`getMidnightWalletProvider`](RemoteTestEnvironment.md#getmidnightwalletprovider)

***

### healthCheck()

> **healthCheck**(): `Promise`\<`void`\>

Performs a health check for the environment.
Checks the health of the node, indexer, and optionally the faucet services.

#### Returns

`Promise`\<`void`\>

A promise that resolves when the health check is complete.

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`healthCheck`](RemoteTestEnvironment.md#healthcheck)

***

### shutdown()

> **shutdown**(`saveWalletState?`): `Promise`\<`void`\>

Shuts down the test environment by closing all walletProviders and stopping the proof server.

#### Parameters

##### saveWalletState?

`boolean`

#### Returns

`Promise`\<`void`\>

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`shutdown`](RemoteTestEnvironment.md#shutdown)

***

### start()

> **start**(`maybeProofServerContainer?`): `Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

Starts the test environment by initializing the proof server and environment configuration.

#### Parameters

##### maybeProofServerContainer?

[`ProofServerContainer`](../interfaces/ProofServerContainer.md)

Optional proof server container to use instead of creating a new one

#### Returns

`Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

The environment configuration

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`start`](RemoteTestEnvironment.md#start)

***

### startMidnightWalletProviders()

> **startMidnightWalletProviders**(`amount`, `seeds`): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Creates and starts the specified number of wallet providers.

#### Parameters

##### amount

`number` = `1`

##### seeds

`string`[] | `undefined`

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Array of started wallet providers

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`startMidnightWalletProviders`](RemoteTestEnvironment.md#startmidnightwalletproviders)

================
File: docs/api/testkit-js/classes/RemoteTestEnvironment.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Base class for remote test environments that connect to external network services.
Provides functionality for managing walletProviders and a proof server container.

## Extends

- [`TestEnvironment`](TestEnvironment.md)

## Extended by

- [`EnvVarRemoteTestEnvironment`](EnvVarRemoteTestEnvironment.md)
- [`QanetTestEnvironment`](QanetTestEnvironment.md)
- [`Testnet2TestEnvironment`](Testnet2TestEnvironment.md)

## Constructors

### Constructor

> **new RemoteTestEnvironment**(`logger`): `RemoteTestEnvironment`

Creates a new TestEnvironment instance.

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`RemoteTestEnvironment`

#### Inherited from

[`TestEnvironment`](TestEnvironment.md).[`constructor`](TestEnvironment.md#constructor)

## Methods

### getEnvironmentConfiguration()

> `abstract` **getEnvironmentConfiguration**(): [`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Abstract method that must be implemented by subclasses to provide environment configuration.

#### Returns

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Configuration object containing service URLs and endpoints

#### Overrides

[`TestEnvironment`](TestEnvironment.md).[`getEnvironmentConfiguration`](TestEnvironment.md#getenvironmentconfiguration)

***

### getMidnightWalletProvider()

> **getMidnightWalletProvider**(): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

Starts a single wallet instance.

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

A promise that resolves to the started wallet

#### Throws

If no wallet could be started

#### Inherited from

[`TestEnvironment`](TestEnvironment.md).[`getMidnightWalletProvider`](TestEnvironment.md#getmidnightwalletprovider)

***

### healthCheck()

> **healthCheck**(): `Promise`\<`void`\>

Performs a health check for the environment.
Checks the health of the node, indexer, and optionally the faucet services.

#### Returns

`Promise`\<`void`\>

A promise that resolves when the health check is complete.

***

### shutdown()

> **shutdown**(`saveWalletState?`): `Promise`\<`void`\>

Shuts down the test environment by closing all walletProviders and stopping the proof server.

#### Parameters

##### saveWalletState?

`boolean`

#### Returns

`Promise`\<`void`\>

#### Overrides

[`TestEnvironment`](TestEnvironment.md).[`shutdown`](TestEnvironment.md#shutdown)

***

### start()

> **start**(`maybeProofServerContainer?`): `Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

Starts the test environment by initializing the proof server and environment configuration.

#### Parameters

##### maybeProofServerContainer?

[`ProofServerContainer`](../interfaces/ProofServerContainer.md)

Optional proof server container to use instead of creating a new one

#### Returns

`Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

The environment configuration

#### Overrides

[`TestEnvironment`](TestEnvironment.md).[`start`](TestEnvironment.md#start)

***

### startMidnightWalletProviders()

> **startMidnightWalletProviders**(`amount`, `seeds`): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Creates and starts the specified number of wallet providers.

#### Parameters

##### amount

`number` = `1`

##### seeds

`string`[] | `undefined`

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Array of started wallet providers

#### Overrides

[`TestEnvironment`](TestEnvironment.md).[`startMidnightWalletProviders`](TestEnvironment.md#startmidnightwalletproviders)

================
File: docs/api/testkit-js/classes/StaticProofServerContainer.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

A proof server that is currently running on a specific port.
Used for connecting to an existing proof server instance.

## Implements

- [`ProofServerContainer`](../interfaces/ProofServerContainer.md)

## Constructors

### Constructor

> **new StaticProofServerContainer**(`port`): `StaticProofServerContainer`

Creates a new StaticProofServerContainer instance.

#### Parameters

##### port

`number` = `6300`

The port number where the proof server is running (default: 6300)

#### Returns

`StaticProofServerContainer`

## Properties

### port

> **port**: `number`

The port number where the proof server is running

## Methods

### getUrl()

> **getUrl**(): `string`

Gets the URL where the proof server can be accessed.

#### Returns

`string`

The URL of the proof server

#### Implementation of

[`ProofServerContainer`](../interfaces/ProofServerContainer.md).[`getUrl`](../interfaces/ProofServerContainer.md#geturl)

***

### stop()

> **stop**(): `Promise`\<`void`\>

No-op stop method since this represents an external proof server.

#### Returns

`Promise`\<`void`\>

A resolved promise

#### Implementation of

[`ProofServerContainer`](../interfaces/ProofServerContainer.md).[`stop`](../interfaces/ProofServerContainer.md#stop)

================
File: docs/api/testkit-js/classes/TestEnvironment.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Abstract base class for test environments.
Provides common functionality for managing test wallets and environments.

## Extended by

- [`LocalTestEnvironment`](LocalTestEnvironment.md)
- [`RemoteTestEnvironment`](RemoteTestEnvironment.md)

## Constructors

### Constructor

> **new TestEnvironment**(`logger`): `TestEnvironment`

Creates a new TestEnvironment instance.

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`TestEnvironment`

## Methods

### getEnvironmentConfiguration()

> `abstract` **getEnvironmentConfiguration**(): [`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

#### Returns

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

***

### getMidnightWalletProvider()

> **getMidnightWalletProvider**(): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

Starts a single wallet instance.

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

A promise that resolves to the started wallet

#### Throws

If no wallet could be started

***

### shutdown()

> `abstract` **shutdown**(`saveWalletState?`): `Promise`\<`void`\>

Shuts down the test environment and cleans up resources.

#### Parameters

##### saveWalletState?

`boolean`

Optional flag to save the wallet state before shutdown

#### Returns

`Promise`\<`void`\>

A promise that resolves when shutdown is complete

***

### start()

> `abstract` **start**(`maybeProofServerContainer?`): `Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

Start the test environment.

#### Parameters

##### maybeProofServerContainer?

[`ProofServerContainer`](../interfaces/ProofServerContainer.md)

If defined, a container representing an already
                                 running proof server. If undefined, a proof server
                                 will be started automatically.

#### Returns

`Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

A promise that resolves to the environment configuration

***

### startMidnightWalletProviders()

> `abstract` **startMidnightWalletProviders**(`amount?`, `seeds?`): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Starts multiple wallet instances.

#### Parameters

##### amount?

`number`

Optional number of wallet instances to start

##### seeds?

`string`[]

Optional array of seeds for the wallets

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

A promise that resolves to an array of started wallets

================
File: docs/api/testkit-js/classes/Testnet2TestEnvironment.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Test environment configuration for the Midnight testnet network.
Provides URLs and endpoints for testnet services.

## Extends

- [`RemoteTestEnvironment`](RemoteTestEnvironment.md)

## Constructors

### Constructor

> **new Testnet2TestEnvironment**(`logger`): `Testnet2TestEnvironment`

Creates a new TestEnvironment instance.

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`Testnet2TestEnvironment`

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`constructor`](RemoteTestEnvironment.md#constructor)

## Methods

### getEnvironmentConfiguration()

> **getEnvironmentConfiguration**(): [`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Returns the configuration for the testnet environment services.

#### Returns

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Object containing URLs for testnet services:
- indexer: GraphQL API endpoint for the indexer
- indexerWS: WebSocket endpoint for the indexer
- node: RPC endpoint for the blockchain node
- faucet: API endpoint for requesting test tokens
- proofServer: URL for the proof generation server

#### Overrides

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`getEnvironmentConfiguration`](RemoteTestEnvironment.md#getenvironmentconfiguration)

***

### getMidnightWalletProvider()

> **getMidnightWalletProvider**(): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

Starts a single wallet instance.

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

A promise that resolves to the started wallet

#### Throws

If no wallet could be started

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`getMidnightWalletProvider`](RemoteTestEnvironment.md#getmidnightwalletprovider)

***

### healthCheck()

> **healthCheck**(): `Promise`\<`void`\>

Performs a health check for the environment.
Checks the health of the node, indexer, and optionally the faucet services.

#### Returns

`Promise`\<`void`\>

A promise that resolves when the health check is complete.

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`healthCheck`](RemoteTestEnvironment.md#healthcheck)

***

### shutdown()

> **shutdown**(`saveWalletState?`): `Promise`\<`void`\>

Shuts down the test environment by closing all walletProviders and stopping the proof server.

#### Parameters

##### saveWalletState?

`boolean`

#### Returns

`Promise`\<`void`\>

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`shutdown`](RemoteTestEnvironment.md#shutdown)

***

### start()

> **start**(`maybeProofServerContainer?`): `Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

Starts the test environment by initializing the proof server and environment configuration.

#### Parameters

##### maybeProofServerContainer?

[`ProofServerContainer`](../interfaces/ProofServerContainer.md)

Optional proof server container to use instead of creating a new one

#### Returns

`Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

The environment configuration

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`start`](RemoteTestEnvironment.md#start)

***

### startMidnightWalletProviders()

> **startMidnightWalletProviders**(`amount`, `seeds`): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Creates and starts the specified number of wallet providers.

#### Parameters

##### amount

`number` = `1`

##### seeds

`string`[] | `undefined`

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Array of started wallet providers

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`startMidnightWalletProviders`](RemoteTestEnvironment.md#startmidnightwalletproviders)

================
File: docs/api/testkit-js/classes/WalletBuilder.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

## Constructors

### Constructor

> **new WalletBuilder**(): `WalletBuilder`

#### Returns

`WalletBuilder`

## Methods

### buildAndStartWallet()

> `static` **buildAndStartWallet**(`envConfig`, `seed?`): `Promise`\<`WalletFacade`\>

#### Parameters

##### envConfig

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

##### seed?

`string`

#### Returns

`Promise`\<`WalletFacade`\>

***

### buildDustWallet()

> `static` **buildDustWallet**(`config`, `seed`, `networkId`, `dustOptions`): `DustWallet`

#### Parameters

##### config

`DefaultV1Configuration`

##### seed

`Uint8Array`

##### networkId

`NetworkId`

##### dustOptions

###### additionalFeeOverhead

`bigint` = `500_000_000_000_000_000_000n`

###### feeBlocksMargin

`number` = `5`

###### ledgerParams

`LedgerParameters` = `...`

#### Returns

`DustWallet`

***

### buildShieldedWallet()

> `static` **buildShieldedWallet**(`config`, `seed`): `ShieldedWallet`

#### Parameters

##### config

`DefaultV1Configuration`

##### seed

`Uint8Array`

#### Returns

`ShieldedWallet`

***

### buildUnshieldedWallet()

> `static` **buildUnshieldedWallet**(`config`, `seed`, `networkId`): `Promise`\<`UnshieldedWallet`\>

#### Parameters

##### config

`DefaultV1Configuration`

##### seed

`Uint8Array`

##### networkId

`NetworkId`

#### Returns

`Promise`\<`UnshieldedWallet`\>

***

### buildWallet()

> `static` **buildWallet**(`envConfig`, `shieldedSeed`, `unshieldedSeed`, `dustSeed`): `Promise`\<`WalletFacade`\>

#### Parameters

##### envConfig

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

##### shieldedSeed

`Uint8Array`

##### unshieldedSeed

`Uint8Array`

##### dustSeed

`Uint8Array`

#### Returns

`Promise`\<`WalletFacade`\>

***

### restoreShieldedWallet()

> `static` **restoreShieldedWallet**(`config`, `serializedState`): `Promise`\<`ShieldedWallet`\>

#### Parameters

##### config

`DefaultV1Configuration`

##### serializedState

`string`

#### Returns

`Promise`\<`ShieldedWallet`\>

***

### startWallet()

> `static` **startWallet**(`wallet`, `shieldedSeed`, `dustSeed`): `Promise`\<`WalletFacade`\>

#### Parameters

##### wallet

`WalletFacade`

##### shieldedSeed

`Uint8Array`

##### dustSeed

`Uint8Array`

#### Returns

`Promise`\<`WalletFacade`\>

================
File: docs/api/testkit-js/classes/WalletSaveStateProvider.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Provider class for saving and loading wallet state to/from compressed files

## Constructors

### Constructor

> **new WalletSaveStateProvider**(`logger`, `seed`, `directoryPath?`, `filename?`): `WalletSaveStateProvider`

Creates a new WalletSaveStateProvider instance

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

##### seed

`string`

##### directoryPath?

`string` = `DEFAULT_WALLET_STATE_DIRECTORY`

Directory path for wallet state files

##### filename?

`string` = `...`

Filename for the wallet state file

#### Returns

`WalletSaveStateProvider`

## Properties

### directoryPath

> **directoryPath**: `string`

Absolute path to the directory containing wallet state files

***

### filePath

> **filePath**: `string`

Full path including filename for the wallet state file

***

### logger

> **logger**: `Logger`

Logger instance for recording operations

## Methods

### load()

> **load**(): `Promise`\<`string`\>

Loads and decompresses the wallet state from a file

#### Returns

`Promise`\<`string`\>

A promise that resolves with the decompressed wallet state as a string

#### Throws

If there is an error reading or decompressing the file

***

### save()

> **save**(`wallet`): `Promise`\<`void`\>

Saves the wallet state to a compressed file

#### Parameters

##### wallet

The wallet instance to save state from

`ShieldedWallet` | `UnshieldedWallet`

#### Returns

`Promise`\<`void`\>

A promise that resolves when the save is complete

================
File: docs/api/testkit-js/functions/createDefaultTestLogger.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **createDefaultTestLogger**(): `Logger`\<`never`, `boolean`\>

## Returns

`Logger`\<`never`, `boolean`\>

================
File: docs/api/testkit-js/functions/createLogger.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **createLogger**(`fileName`, `dir`): `Logger`\<`never`, `boolean`\>

## Parameters

### fileName

`string`

### dir

`string` = `...`

## Returns

`Logger`\<`never`, `boolean`\>

================
File: docs/api/testkit-js/functions/delay.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **delay**(`ms`): `Promise`\<`unknown`\>

Creates a Promise that resolves after a specified delay.

## Parameters

### ms

`number`

The delay duration in milliseconds.

## Returns

`Promise`\<`unknown`\>

A Promise that resolves after the specified delay.

## Example

```ts
// Wait for 1 second
await delay(1000);
```

================
File: docs/api/testkit-js/functions/expectFoundAndDeployedStatesEqual.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **expectFoundAndDeployedStatesEqual**\<`C`\>(`providers`, `deployTxData`, `foundDeployTxData`, `privateStateId?`, `initialPrivateState?`): `Promise`\<`void`\>

## Type Parameters

### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

## Parameters

### providers

`MidnightProviders`\<`ImpureCircuitId`\<`C`\>, `string`, `unknown`\>

### deployTxData

`FinalizedDeployTxData`\<`C`\>

### foundDeployTxData

`FinalizedDeployTxDataBase`\<`C`\>

### privateStateId?

`string`

### initialPrivateState?

`PrivateState`\<`C`\>

## Returns

`Promise`\<`void`\>

================
File: docs/api/testkit-js/functions/expectFoundAndDeployedTxDataEqual.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **expectFoundAndDeployedTxDataEqual**\<`C`\>(`deployTxData`, `foundDeployTxData`): `void`

## Type Parameters

### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

## Parameters

### deployTxData

`FinalizedDeployTxData`\<`C`\>

### foundDeployTxData

`FinalizedDeployTxDataBase`\<`C`\>

## Returns

`void`

================
File: docs/api/testkit-js/functions/expectFoundAndDeployedTxPrivateDataEqual.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **expectFoundAndDeployedTxPrivateDataEqual**\<`C`\>(`deployTxData`, `foundDeployTxData`): `void`

## Type Parameters

### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

## Parameters

### deployTxData

`FinalizedDeployTxData`\<`C`\>

### foundDeployTxData

`FinalizedDeployTxDataBase`\<`C`\>

## Returns

`void`

================
File: docs/api/testkit-js/functions/expectFoundAndDeployedTxPublicDataEqual.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **expectFoundAndDeployedTxPublicDataEqual**\<`C`\>(`deployTxData`, `foundDeployTxData`): `void`

## Type Parameters

### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

## Parameters

### deployTxData

`FinalizedDeployTxData`\<`C`\>

### foundDeployTxData

`FinalizedDeployTxDataBase`\<`C`\>

## Returns

`void`

================
File: docs/api/testkit-js/functions/expectSuccessfulCallTx.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **expectSuccessfulCallTx**\<`C`, `ICK`\>(`providers`, `callTxData`, `callTxOptions?`, `nextPrivateState?`): `Promise`\<`void`\>

## Type Parameters

### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

### ICK

`ICK` *extends* `string`

## Parameters

### providers

`MidnightProviders`\<`ImpureCircuitId`\<`C`\>, `string`, `unknown`\>

### callTxData

`FinalizedCallTxData`\<`C`, `ICK`\>

### callTxOptions?

`CallTxOptions`\<`C`, `ICK`\>

### nextPrivateState?

`PrivateState`\<`C`\>

## Returns

`Promise`\<`void`\>

================
File: docs/api/testkit-js/functions/expectSuccessfulDeployTx.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **expectSuccessfulDeployTx**\<`C`\>(`providers`, `deployTxData`, `deployTxOptions?`): `Promise`\<`void`\>

## Type Parameters

### C

`C` *extends* `Contract`\<`any`, `Witnesses`\<`any`\>\>

## Parameters

### providers

`MidnightProviders`\<`ImpureCircuitId`\<`C`\>, `string`, `unknown`\>

### deployTxData

`FinalizedDeployTxData`\<`C`\>

### deployTxOptions?

`DeployContractOptions`\<`C`\> | `DeployTxOptions`\<`C`\>

## Returns

`Promise`\<`void`\>

================
File: docs/api/testkit-js/functions/expectSuccessfulTxData.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **expectSuccessfulTxData**(`finalizedTxData`): `void`

## Parameters

### finalizedTxData

`FinalizedTxData`

## Returns

`void`

================
File: docs/api/testkit-js/functions/extractHostnameAndPort.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **extractHostnameAndPort**(`url`): `string`

## Parameters

### url

`string`

## Returns

`string`

================
File: docs/api/testkit-js/functions/getContainersConfiguration.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **getContainersConfiguration**(): [`ContainersConfiguration`](../interfaces/ContainersConfiguration.md)

## Returns

[`ContainersConfiguration`](../interfaces/ContainersConfiguration.md)

================
File: docs/api/testkit-js/functions/getInitialShieldedState.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **getInitialShieldedState**(`wallet`): `Promise`\<`ShieldedWalletState`\<`string`, `FinalizedTransaction`\>\>

## Parameters

### wallet

`ShieldedWallet`

## Returns

`Promise`\<`ShieldedWalletState`\<`string`, `FinalizedTransaction`\>\>

================
File: docs/api/testkit-js/functions/getInitialState.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **getInitialState**(`wallet`): `Promise`\<`ShieldedWalletState`\<`string`, `FinalizedTransaction`\> \| `State`\>

## Parameters

### wallet

`ShieldedWallet` | `UnshieldedWallet`

## Returns

`Promise`\<`ShieldedWalletState`\<`string`, `FinalizedTransaction`\> \| `State`\>

================
File: docs/api/testkit-js/functions/getInitialUnshieldedState.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **getInitialUnshieldedState**(`wallet`): `Promise`\<`State`\>

## Parameters

### wallet

`UnshieldedWallet`

## Returns

`Promise`\<`State`\>

================
File: docs/api/testkit-js/functions/getTestEnvironment.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **getTestEnvironment**(`logger`): [`TestEnvironment`](../classes/TestEnvironment.md)

Returns the appropriate test environment based on the MN_TEST_ENVIRONMENT variable.

## Parameters

### logger

`Logger`

The logger instance to be used by the test environment.

## Returns

[`TestEnvironment`](../classes/TestEnvironment.md)

The selected test environment instance.

================
File: docs/api/testkit-js/functions/getWalletStateFilename.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **getWalletStateFilename**(`seed`): `string`

Generates a filename for the wallet state file based on environment and optional seed

## Parameters

### seed

`string` | `undefined`

## Returns

`string`

Generated filename for the wallet state

================
File: docs/api/testkit-js/functions/initializeMidnightProviders.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **initializeMidnightProviders**\<`ICK`, `PS`\>(`midnightWalletProvider`, `environmentConfiguration`, `contractConfiguration`): `MidnightProviders`\<`ICK`, `string`, `PS`\>

Configures and returns the required providers for a Midnight contract.

## Type Parameters

### ICK

`ICK` *extends* `string`

Type parameter for the input circuit key string

### PS

`PS`

Type parameter for the private state

## Parameters

### midnightWalletProvider

[`MidnightWalletProvider`](../classes/MidnightWalletProvider.md)

The midnightWalletProvider provider instance to use for transactions

### environmentConfiguration

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Configuration for the environment including indexer and proof server details

### contractConfiguration

[`ContractConfiguration`](../interfaces/ContractConfiguration.md)

Configuration specific to the contract including storage names and ZK config path

## Returns

`MidnightProviders`\<`ICK`, `string`, `PS`\>

An object containing all configured providers:
  - privateStateProvider: For managing private contract state
  - publicDataProvider: For accessing public blockchain data
  - zkConfigProvider: For zero-knowledge proof configurations
  - proofProvider: For generating and verifying proofs
  - walletProvider: For midnightWalletProvider operations
  - midnightProvider: For Midnight-specific operations

================
File: docs/api/testkit-js/functions/inMemoryPrivateStateProvider.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **inMemoryPrivateStateProvider**\<`PSI`, `PS`\>(): `PrivateStateProvider`\<`PSI`, `PS`\>

A simple in-memory implementation of private state provider. Makes it easy to capture and rewrite private state from deploy.

## Type Parameters

### PSI

`PSI` *extends* `string`

Type of the private state identifier.

### PS

`PS` *extends* `unknown`

Type of the private state.

## Returns

`PrivateStateProvider`\<`PSI`, `PS`\>

An in-memory private state provider.

================
File: docs/api/testkit-js/functions/setContainersConfiguration.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **setContainersConfiguration**(`containersConfig`): `void`

## Parameters

### containersConfig

[`ContainersConfiguration`](../interfaces/ContainersConfiguration.md)

## Returns

`void`

================
File: docs/api/testkit-js/functions/stateValueEqual.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **stateValueEqual**(`a`, `b`): `boolean`

## Parameters

### a

`StateValue`

### b

`StateValue`

## Returns

`boolean`

================
File: docs/api/testkit-js/functions/syncWallet.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **syncWallet**(`wallet`, `throttleTime`, `timeout`): `Promise`\<`FacadeState`\>

## Parameters

### wallet

`WalletFacade`

### throttleTime

`number` = `2_000`

### timeout

`number` = `90_000`

## Returns

`Promise`\<`FacadeState`\>

================
File: docs/api/testkit-js/functions/txsEqual.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **txsEqual**\<`S`, `P`, `B`\>(`a`, `b`): `boolean`

## Type Parameters

### S

`S` *extends* `Signaturish`

### P

`P` *extends* `Proofish`

### B

`B` *extends* `Bindingish`

## Parameters

### a

`Transaction`\<`S`, `P`, `B`\>

### b

`Transaction`\<`S`, `P`, `B`\>

## Returns

`boolean`

================
File: docs/api/testkit-js/functions/waitForFunds.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **waitForFunds**(`wallet`, `env`, `tokenType`, `fundFromFaucet`): `Promise`\<`bigint` \| `FacadeState`\>

## Parameters

### wallet

`WalletFacade`

### env

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

### tokenType

`TokenType` = `...`

### fundFromFaucet

`boolean` = `false`

## Returns

`Promise`\<`bigint` \| `FacadeState`\>

================
File: docs/api/testkit-js/interfaces/ContainerEndpoints.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Network endpoint configuration for a container

## Properties

### name

> **name**: `string`

Name of the container

***

### port

> **port**: `number`

Port number the container listens on

***

### waitStrategy

> **waitStrategy**: `WaitStrategy`

TestContainers WaitStrategy to use for container start

================
File: docs/api/testkit-js/interfaces/ContainersConfiguration.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Top-level configuration for all test containers

## Properties

### log

> **log**: [`LogConfiguration`](LogConfiguration.md)

Logging configuration

***

### proofServer

> **proofServer**: [`ProofServerContainerConfiguration`](ProofServerContainerConfiguration.md)

Proof server container configuration

***

### standalone

> **standalone**: [`StandaloneContainersConfiguration`](StandaloneContainersConfiguration.md)

Standalone mode containers configuration

================
File: docs/api/testkit-js/interfaces/ContractConfiguration.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Configuration interface for Midnight contracts.

## Properties

### privateStateStoreName

> `readonly` **privateStateStoreName**: `string`

Name of the store used for persisting private state data.
This is used as a base name - a signing key store will also be created with "-signing-keys" appended.

***

### zkConfigPath

> `readonly` **zkConfigPath**: `string`

File system path to the zero-knowledge proof configuration files.
This should point to the directory containing the circuit verification keys and other ZK artifacts.

================
File: docs/api/testkit-js/interfaces/EnvironmentConfiguration.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Configuration interface for the test environment services

## Properties

### faucet

> `readonly` **faucet**: `string` \| `undefined`

Optional URL for the faucet service to obtain test tokens

***

### indexer

> `readonly` **indexer**: `string`

URL of the indexer HTTP endpoint

***

### indexerWS

> `readonly` **indexerWS**: `string`

WebSocket URL for the indexer service

***

### networkId

> `readonly` **networkId**: `string`

Network identifier

***

### node

> `readonly` **node**: `string`

URL of the blockchain node

***

### nodeWS

> `readonly` **nodeWS**: `string`

WebSocket URL for the blockchain node

***

### proofServer

> `readonly` **proofServer**: `string`

URL of the proof generation server

***

### walletNetworkId

> `readonly` **walletNetworkId**: `NetworkId`

Wallet Network identifier

================
File: docs/api/testkit-js/interfaces/LogConfiguration.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Configuration for test logging

## Properties

### fileName

> **fileName**: `string`

Name of the log file

***

### level

> **level**: `string`

Log level (e.g. 'info', 'debug', etc)

***

### path

> **path**: `string`

Directory path where log files will be written

================
File: docs/api/testkit-js/interfaces/ProofServerContainer.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Interface representing a proof server container that can be started and stopped.

## Methods

### getUrl()

> **getUrl**(): `string`

Gets the URL where the proof server can be accessed.

#### Returns

`string`

The URL of the proof server

***

### stop()

> **stop**(): `Promise`\<`void`\>

Stops the proof server container.

#### Returns

`Promise`\<`void`\>

A promise that resolves when the container is stopped

================
File: docs/api/testkit-js/interfaces/ProofServerContainerConfiguration.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Configuration for a proof server container instance

## Properties

### container

> **container**: [`ContainerEndpoints`](ContainerEndpoints.md)

Network endpoint configuration for the container

***

### fileName

> **fileName**: `string`

Name of the container configuration file

***

### path

> **path**: `string`

Directory path where container configuration is located

================
File: docs/api/testkit-js/interfaces/StandaloneContainerNames.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Container endpoint configurations for standalone mode services

## Properties

### indexer

> **indexer**: [`ContainerEndpoints`](ContainerEndpoints.md)

Indexer service container configuration

***

### node

> **node**: [`ContainerEndpoints`](ContainerEndpoints.md)

Blockchain node container configuration

***

### proofServer

> **proofServer**: [`ContainerEndpoints`](ContainerEndpoints.md)

Proof server container configuration

================
File: docs/api/testkit-js/interfaces/StandaloneContainersConfiguration.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

Configuration for standalone mode containers

## Properties

### container

> **container**: [`StandaloneContainerNames`](StandaloneContainerNames.md)

Container endpoint configurations

***

### fileName

> **fileName**: `string`

Name of the container configuration file

***

### path

> **path**: `string`

Directory path where container configuration is located

================
File: docs/api/testkit-js/type-aliases/ComponentPortsConfiguration.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> **ComponentPortsConfiguration** = `object`

Configuration for component ports in the local test environment

## Properties

### indexer

> **indexer**: `number`

***

### node

> **node**: `number`

***

### proofServer

> **proofServer**: `number`

================
File: docs/api/testkit-js/variables/DEFAULT_WALLET_STATE_DIRECTORY.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> `const` **DEFAULT\_WALLET\_STATE\_DIRECTORY**: `"./.states"`

Default directory path for storing wallet state files

================
File: docs/api/testkit-js/variables/defaultContainersConfiguration.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> `const` **defaultContainersConfiguration**: [`ContainersConfiguration`](../interfaces/ContainersConfiguration.md)

================
File: docs/api/testkit-js/variables/DustOptions.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> `const` **DustOptions**: `object`

## Type Declaration

### additionalFeeOverhead

> **additionalFeeOverhead**: `bigint` = `500_000_000_000_000_000_000n`

### feeBlocksMargin

> **feeBlocksMargin**: `number` = `5`

### ledgerParams

> **ledgerParams**: `LedgerParameters`

================
File: docs/api/testkit-js/variables/latestContainersConfiguration.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> `const` **latestContainersConfiguration**: [`ContainersConfiguration`](../interfaces/ContainersConfiguration.md)

================
File: docs/api/testkit-js/variables/logger.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> `const` **logger**: `Logger`\<`never`, `boolean`\>

================
File: docs/api/testkit-js/variables/MINUTE.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](../README.md)

***

> `const` **MINUTE**: `60000` = `60_000`

================
File: docs/api/testkit-js/globals.md
================
[**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**](README.md)

***

## Classes

- [DynamicProofServerContainer](classes/DynamicProofServerContainer.md)
- [EnvVarRemoteTestEnvironment](classes/EnvVarRemoteTestEnvironment.md)
- [FaucetClient](classes/FaucetClient.md)
- [GzipFile](classes/GzipFile.md)
- [IndexerClient](classes/IndexerClient.md)
- [LocalTestConfiguration](classes/LocalTestConfiguration.md)
- [LocalTestEnvironment](classes/LocalTestEnvironment.md)
- [MidnightWalletProvider](classes/MidnightWalletProvider.md)
- [NodeClient](classes/NodeClient.md)
- [ProofServerClient](classes/ProofServerClient.md)
- [QanetTestEnvironment](classes/QanetTestEnvironment.md)
- [RemoteTestEnvironment](classes/RemoteTestEnvironment.md)
- [StaticProofServerContainer](classes/StaticProofServerContainer.md)
- [TestEnvironment](classes/TestEnvironment.md)
- [Testnet2TestEnvironment](classes/Testnet2TestEnvironment.md)
- [WalletBuilder](classes/WalletBuilder.md)
- [WalletSaveStateProvider](classes/WalletSaveStateProvider.md)

## Interfaces

- [ContainerEndpoints](interfaces/ContainerEndpoints.md)
- [ContainersConfiguration](interfaces/ContainersConfiguration.md)
- [ContractConfiguration](interfaces/ContractConfiguration.md)
- [EnvironmentConfiguration](interfaces/EnvironmentConfiguration.md)
- [LogConfiguration](interfaces/LogConfiguration.md)
- [ProofServerContainer](interfaces/ProofServerContainer.md)
- [ProofServerContainerConfiguration](interfaces/ProofServerContainerConfiguration.md)
- [StandaloneContainerNames](interfaces/StandaloneContainerNames.md)
- [StandaloneContainersConfiguration](interfaces/StandaloneContainersConfiguration.md)

## Type Aliases

- [ComponentPortsConfiguration](type-aliases/ComponentPortsConfiguration.md)

## Variables

- [DEFAULT\_WALLET\_STATE\_DIRECTORY](variables/DEFAULT_WALLET_STATE_DIRECTORY.md)
- [defaultContainersConfiguration](variables/defaultContainersConfiguration.md)
- [DustOptions](variables/DustOptions.md)
- [latestContainersConfiguration](variables/latestContainersConfiguration.md)
- [logger](variables/logger.md)
- [MINUTE](variables/MINUTE.md)

## Functions

- [createDefaultTestLogger](functions/createDefaultTestLogger.md)
- [createLogger](functions/createLogger.md)
- [delay](functions/delay.md)
- [expectFoundAndDeployedStatesEqual](functions/expectFoundAndDeployedStatesEqual.md)
- [expectFoundAndDeployedTxDataEqual](functions/expectFoundAndDeployedTxDataEqual.md)
- [expectFoundAndDeployedTxPrivateDataEqual](functions/expectFoundAndDeployedTxPrivateDataEqual.md)
- [expectFoundAndDeployedTxPublicDataEqual](functions/expectFoundAndDeployedTxPublicDataEqual.md)
- [expectSuccessfulCallTx](functions/expectSuccessfulCallTx.md)
- [expectSuccessfulDeployTx](functions/expectSuccessfulDeployTx.md)
- [expectSuccessfulTxData](functions/expectSuccessfulTxData.md)
- [extractHostnameAndPort](functions/extractHostnameAndPort.md)
- [getContainersConfiguration](functions/getContainersConfiguration.md)
- [getInitialShieldedState](functions/getInitialShieldedState.md)
- [getInitialState](functions/getInitialState.md)
- [getInitialUnshieldedState](functions/getInitialUnshieldedState.md)
- [getTestEnvironment](functions/getTestEnvironment.md)
- [getWalletStateFilename](functions/getWalletStateFilename.md)
- [initializeMidnightProviders](functions/initializeMidnightProviders.md)
- [inMemoryPrivateStateProvider](functions/inMemoryPrivateStateProvider.md)
- [setContainersConfiguration](functions/setContainersConfiguration.md)
- [stateValueEqual](functions/stateValueEqual.md)
- [syncWallet](functions/syncWallet.md)
- [txsEqual](functions/txsEqual.md)
- [waitForFunds](functions/waitForFunds.md)

================
File: docs/api/testkit-js/README.md
================
**@midnight-ntwrk/testkit-js v3.0.0-alpha.9**

***

# What is this?
A comprehensive testing solution for your Midnight.JS applications, providing seamless integration with various test environments.

This package was created for the [Midnight network](https://midnight.network). 

Please visit the [Midnight Developer Hub](https://midnight.network/developer-hub) to learn more.

# Use only in Midnight test environments
Image exclusively for Midnight test environments use.  

# Agree to Terms
By downloading and using this image, you agree to [Midnights Terms and Conditions](https://midnight.network/static/terms.pdf), which includes the [Privacy Policy](https://midnight.network/static/privacy-policy.pdf).

# License
The software provided herein is licensed under the [Apache License V2.0](http://www.apache.org/licenses/LICENSE-2.0).

## Table of Contents
1. [Installation](#installation)
2. [Getting Started](#getting-started)
3. [Features](#Features)
4. [Limitations](#Limitations)
5. [Examples of Usage](#Examples-of-Usage)

---

## Installation
Before using the testing library, ensure you have the following prerequisites:
1. Node.js and yarn installed
2. Docker Desktop (optional for local dockerized tests)
3. Midnight.JS project set up

Install the testing library by running the following command in your terminal:
```
yarn add -D @midnight-ntwrk/testkit-js
```

## Getting Started
To use the testing library, create a new file called `midnight.test.js` in the `__tests__` directory of your project. In this file, import the necessary dependencies:
```typescript
import { getTestEnvironment } from '@midnight-ntwrk/testkit-js';

beforeAll(async () => {
  testEnvironment = getTestEnvironment(logger);
  environmentConfiguration = await testEnvironment.start();
  walletProvider = await testEnvironment.getMidnightWalletProvider();
});

afterAll(async () => {
  await testEnvironment.shutdown();
});
```

---

## Features

Set of functions that simplify testing of DApps in Midnight

- [x] Standard Dockerized environment setup - both live and local
- [x] Predefined Midnight environments configuration 
- [x] Proof server control
- [x] Wallets management
- [x] Fund wallets
- [x] Check system health

---

## Environment variables

### Storage Password (Automatic Setup):
- **MIDNIGHT_STORAGE_PASSWORD** is automatically set by testkit-js if not already defined
- Default test value: `testkit-default-storage-password-for-testing-only`
- This ensures encrypted storage works in test environments without manual configuration
- For production or custom testing, set your own password before importing testkit-js

### Environment selection:
- MN_TEST_ENVIRONMENT controls the environment to be used for testing. It can take one of these values:
   - undeployed
   - devnet
   - testnet
   - env-var-remote

If **MN_TEST_ENVIRONMENT** is not set, the default value will be `undeployed`.
If **MN_TEST_ENVIRONMENT** is set to `undeployed`, the testing environment will be deployed locally using Docker.
If **MN_TEST_ENVIRONMENT** is set to `devnet`,`testnet, env-var-remote` the testing environment will the corresponding live network, with proof server setup using predefined NETWORK_ID.
If **MN_TEST_ENVIRONMENT** is set to `env-var-remote`, below environment variables must be set:
  - *MN_TEST_NETWORK_ID* - Proof server NETWORK_ID
  - *MN_TEST_INDEXER* - Indexer URL
  - *MN_TEST_INDEXER_WS* - Indexer WebSocket URL
  - *MN_TEST_NODE* - Node URL
  - *MN_TEST_FAUCET* - Faucet URL

### Wallet setup:
- MN_TEST_WALLET_SEED can be used to set a specific seed phrase for the wallet. If not set, a random seed phrase will be used.

---

## Limitations

- Localnet wallets limit count is 4

---

## Examples of Usage

### 1. Selecting Different Environments

You can control the test environment using the `MN_TEST_ENVIRONMENT` environment variable. Here's how you can set it:

```typescript
const testEnvironment = getTestEnvironment(logger);
environmentConfiguration = await testEnvironment.start();
```

```shell
# Example: Set the environment variable before initializing the test environment
MN_TEST_ENVIRONMENT='devnet'; yarn test
```

This allows you to easily switch between predefined environments like `devnet`, `testnet`, and others.
Default (undefined) value is `undeployed` which will deploy the testing environment locally using Docker.

---

### 2. Creating and Managing Wallets

Here's an example of creating wallets in your test environment:

```typescript
// Example: Create multiple wallets in a test environment
const testEnvironment = getTestEnvironment(logger);
await testEnvironment.start();

// Create 2 wallets
const wallets = await testEnvironment.startMidnightWalletProviders(2);

// Verify wallet properties
expect(wallets).toHaveLength(2);
wallets.forEach(async (wallet) => {
  expect(wallet.coinPublicKey).not.toBeUndefined();
});

// Shutdown the environment after testing
await testEnvironment.shutdown();
```

This demonstrates how to create wallets and verify their properties, such as the `coinPublicKey`.

---

### 3. Setting Wallet Seeds

If you need to use specific wallet seeds for testing, you can do the following:

```typescript
// Example: Create a wallet with a predefined seed phrase
const wallet = await testEnvironment.getMidnightWalletProvider();

expect(wallet.coinPublicKey).not.toBeUndefined();
```

```shell
# Example: Set the environment variable before initializing the test environment
MN_TEST_WALLET_SEED='00000000000000000000000000000042'; yarn test
```

This allows you to test specific scenarios using known wallet seeds.

---

### 4. Handling Environment Configuration

You can also customize the test environment configuration by modifying the `defaultContainersConfiguration` object:

```typescript
import {
  defaultContainersConfiguration,
  getContainersConfiguration,
  setContainersConfiguration
} from '../configuration';

// Example: Modify default environment configuration before starting
const config: ContainersConfiguration = {
  ...defaultContainersConfiguration,
  proofServer: {
    ...defaultContainersConfiguration.proofServer,
    fileName: 'proof-server.yml'
  }
};
setContainersConfiguration(config);
```

This gives developers flexibility in configuring the test environment according to their needs.

---

### 5. Error Handling

Here's an example of handling errors when setting up wallets:

```typescript
// Example: Test for maximum wallet limit exceeded
process.env.MN_TEST_ENVIRONMENT = undefined; // Use local environment
const testEnvironment = getTestEnvironment(logger);
await testEnvironment.start();

try {
  await testEnvironment.startMidnightWalletProviders(5); // Assuming max is 4
} catch (error) {
  expect(error.message).toContain('Maximum supported number of wallets for this environment reached');
}

await testEnvironment.shutdown();
```

This demonstrates how to handle cases where the wallet limit is exceeded.

---

### 6. Advanced Usage with Proof Server

Here's an example of integrating with the proof server:

```typescript
// Example: Start a proof server with networkd ID = testnet and ID = 123
const proofServer = await DynamicProofServerContainer.start(logger, '123', 'testnet');

//stop the proof server
await proofServer.stop();
```

This shows how to integrate with and customize the proof server for testing.

---

### 7. Customized test environments

Library is provided with set of predefined environment configurations i.e.:

- LocalTestEnvironment 
- Testnet2TestEnvironment

By using `getTestEnvironment(logger);` based on environment variable MN_TEST_ENVIRONMENT test environment configuration is provided.
However, you can either create your own class defining the environment endpoints or use below enviroment variables.

Here's an example of fully customized endpoints of the test environment, that you can provide using environment variables:

```shell
MN_TEST_ENVIRONMENT="env-var-remote" \
MN_TEST_NETWORK_ID="undeployed" \
MN_TEST_INDEXER="http://localhost:3085/api/" \
MN_TEST_INDEXER_WS="ws://localhost:3085/ws/" \
MN_TEST_NODE="http://localhost:3086" \
yarn test

```

---

### 8. System health check before tests

For the remote test environemnts (testnet-02, ...) simple health check is performed for each of the components to check their state before test.

================
File: testkit-js/compose.yml
================
services:
  proof-server:
    image: 'ghcr.io/midnight-ntwrk/proof-server:6.1.0-alpha.6'
    container_name: proof-server_$TESTCONTAINERS_UID
    command: ['midnight-proof-server -v']
    ports:
      - '6300'
    environment:
      RUST_BACKTRACE: 'full'
    healthcheck:
      test: ['CMD', 'curl', '-f', 'http://localhost:6300/version']
      interval: 10s
      timeout: 5s
      retries: 20
      start_period: 10s

  indexer:
    image: 'ghcr.io/midnight-ntwrk/indexer-standalone:3.0.0-alpha.17'
    container_name: indexer_$TESTCONTAINERS_UID
    ports:
      - '8088'
    environment:
      RUST_LOG: 'indexer=debug,chain_indexer=debug,indexer_api=debug,wallet_indexer=debug,indexer_common=debug,fastrace_opentelemetry=off,info'
      APP__INFRA__NODE__URL: 'ws://node:9944'
      APP__APPLICATION__NETWORK_ID: 'undeployed'
      APP__INFRA__STORAGE__PASSWORD: 'indexer'
      APP__INFRA__PUB_SUB__PASSWORD: 'indexer'
      APP__INFRA__LEDGER_STATE_STORAGE__PASSWORD: 'indexer'
      APP__INFRA__SECRET: '303132333435363738393031323334353637383930313233343536373839303132'

    healthcheck:
      test: ['CMD-SHELL', 'cat /var/run/indexer-standalone/running']
      interval: 10s
      timeout: 5s
      retries: 20
      start_period: 10s
    depends_on:
      node:
        condition: service_healthy

  node:
    image: 'ghcr.io/midnight-ntwrk/midnight-node:0.18.0-rc.7'
    container_name: node_$TESTCONTAINERS_UID
    ports:
      - '9944'
    healthcheck:
      test: ['CMD', 'curl', '-f', 'http://localhost:9944/health']
      interval: 2s
      timeout: 5s
      retries: 20
      start_period: 5s
    environment:
      CFG_PRESET: 'dev'
      SIDECHAIN_BLOCK_BENEFICIARY: '04bcf7ad3be7a5c790460be82a713af570f22e0f801f6659ab8e84a52be6969e'

================
File: compact-js/compact-js/package.json
================
{
  "name": "@midnight-ntwrk/compact-js",
  "version": "2.3.0",
  "description": "Typescript-based execution environment for smart contracts compiled with the Compact language",
  "type": "module",
  "exports": {
    "./package.json": "./package.json",
    ".": "./src/index.ts",
    "./effect": "./src/effect/index.ts",
    "./effect/*": "./src/effect/*.ts",
    "./effect/internal/*": null
  },
  "dependencies": {
    "@effect/platform": "^0.92.1",
    "@midnight-ntwrk/compact-runtime": "0.11.0-rc.1",
    "@midnight-ntwrk/ledger": "npm:@midnight-ntwrk/ledger-v6@6.1.0-alpha.5",
    "@midnight-ntwrk/platform-js": "^2.1.0",
    "effect": "^3.18.4"
  },
  "devDependencies": {
    "@effect/cluster": "^0.50.4",
    "@effect/experimental": "^0.57.0",
    "@effect/platform-node": "^0.98.3",
    "@effect/platform-node-shared": "^0.53.0",
    "@effect/rpc": "^0.72.0",
    "@effect/sql": "^0.48.0",
    "@effect/vitest": "^0.27.0",
    "@effect/workflow": "^0.12.0",
    "@midnight-ntwrk/compact-js-node": "workspace:*",
    "@midnight-ntwrk/midnight-js-compact": "workspace:*"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/midnight-ntwrk/artifacts.git"
  },
  "packageManager": "yarn@4.10.3",
  "author": "IOHK",
  "license": "Apache-2.0",
  "scripts": {
    "build": "yarn build-compact && yarn build-esm && build-utils pack-v3",
    "build-esm": "tsc -b tsconfig.build.json",
    "build-compact": "(shx --negate test -d ./test/contract/managed && yarn compact || true)",
    "clean": "shx rm -rf ./build ./dist ./.tsbuildinfo ./reports ./coverage",
    "test": "yarn build-compact && vitest run && tstyche",
    "deploy": "shx rm -rf ./dist/src && (cd ./dist; npm publish)",
    "compact": "yarn fetch-compactc && yarn compact-counter && yarn compact-unshielded",
    "compact-counter": "run-compactc ./test/contract/counter.compact ./test/contract/managed/counter",
    "compact-unshielded": "run-compactc ./test/contract/unshielded.compact ./test/contract/managed/unshielded"
  },
  "files": [
    "dist/"
  ]
}

================
File: compact-js/compact-js-command/package.json
================
{
  "name": "@midnight-ntwrk/compact-js-command",
  "version": "2.3.0",
  "description": "Command line utilities for working with smart contracts compiled with the Compact language",
  "type": "module",
  "exports": {
    "./package.json": "./package.json",
    ".": "./src/index.ts",
    "./effect": "./src/effect/index.ts",
    "./effect/*": "./src/effect/*.ts",
    "./effect/internal/*": null
  },
  "dependencies": {
    "@effect/cli": "^0.71.0",
    "@effect/cluster": "^0.50.4",
    "@effect/experimental": "^0.57.0",
    "@effect/platform": "^0.92.1",
    "@effect/platform-node": "^0.98.3",
    "@effect/platform-node-shared": "^0.53.0",
    "@effect/printer": "^0.46.0",
    "@effect/printer-ansi": "^0.46.0",
    "@effect/rpc": "^0.72.0",
    "@effect/sql": "^0.48.0",
    "@effect/typeclass": "^0.37.0",
    "@effect/workflow": "^0.12.0",
    "@midnight-ntwrk/compact-js": "^2.3.0",
    "@midnight-ntwrk/compact-js-node": "^2.3.0",
    "@midnight-ntwrk/compact-runtime": "0.11.0-rc.1",
    "@midnight-ntwrk/ledger": "npm:@midnight-ntwrk/ledger-v6@6.1.0-alpha.5",
    "@midnight-ntwrk/platform-js": "^2.1.0",
    "@midnight-ntwrk/wallet-sdk-address-format": "3.0.0-beta.4",
    "effect": "^3.18.4",
    "json5": "^2.2.3",
    "ts-node": "^10.9.2"
  },
  "devDependencies": {
    "@effect/vitest": "^0.27.0",
    "@midnight-ntwrk/midnight-js-compact": "workspace:*"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/midnight-ntwrk/artifacts.git"
  },
  "packageManager": "yarn@4.10.3",
  "author": "IOHK",
  "license": "Apache-2.0",
  "scripts": {
    "build": "yarn build-esm && build-utils pack-v3",
    "build-esm": "tsc -b tsconfig.build.json",
    "clean": "shx rm -rf ./build ./dist ./.tsbuildinfo ./reports ./coverage",
    "test": "vitest run",
    "cmd": "NODE_OPTIONS='--loader ts-node/esm --no-warnings' ts-node ./src/index.ts",
    "deploy": "shx rm -rf ./dist/src && (cd ./dist; npm publish)"
  },
  "files": [
    "dist/"
  ]
}

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/ProvingRecipe.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ProvingRecipe

# Type Alias: ProvingRecipe\<TTransaction\>

> **ProvingRecipe**\<`TTransaction`\> = [`TransactionToProve`](TransactionToProve.md) \| [`BalanceTransactionToProve`](BalanceTransactionToProve.md)\<`TTransaction`\> \| [`NothingToProve`](NothingToProve.md)\<`TTransaction`\>

## Type Parameters

### TTransaction

`TTransaction`

================
File: docs/api/midnight-js/@midnight-ntwrk/midnight-js-types/README.md
================
[**Midnight.js API Reference v3.0.0-alpha.9**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-types

# @midnight-ntwrk/midnight-js-types

## Enumerations

- [LogLevel](enumerations/LogLevel.md)

## Classes

- [InvalidProtocolSchemeError](classes/InvalidProtocolSchemeError.md)
- [ZKConfigProvider](classes/ZKConfigProvider.md)

## Interfaces

- [Contract](interfaces/Contract.md)
- [FinalizedTxData](interfaces/FinalizedTxData.md)
- [LoggerProvider](interfaces/LoggerProvider.md)
- [MidnightProvider](interfaces/MidnightProvider.md)
- [MidnightProviders](interfaces/MidnightProviders.md)
- [PrivateStateProvider](interfaces/PrivateStateProvider.md)
- [ProofProvider](interfaces/ProofProvider.md)
- [ProveTxConfig](interfaces/ProveTxConfig.md)
- [PublicDataProvider](interfaces/PublicDataProvider.md)
- [WalletProvider](interfaces/WalletProvider.md)
- [ZKConfig](interfaces/ZKConfig.md)

## Type Aliases

- [All](type-aliases/All.md)
- [BalancedProvingRecipe](type-aliases/BalancedProvingRecipe.md)
- [BalanceTransactionToProve](type-aliases/BalanceTransactionToProve.md)
- [BlockHash](type-aliases/BlockHash.md)
- [BlockHashConfig](type-aliases/BlockHashConfig.md)
- [BlockHeightConfig](type-aliases/BlockHeightConfig.md)
- [CircuitParameters](type-aliases/CircuitParameters.md)
- [CircuitReturnType](type-aliases/CircuitReturnType.md)
- [ContractStateObservableConfig](type-aliases/ContractStateObservableConfig.md)
- [Fees](type-aliases/Fees.md)
- [ImpureCircuit](type-aliases/ImpureCircuit.md)
- [ImpureCircuitId](type-aliases/ImpureCircuitId.md)
- [ImpureCircuits](type-aliases/ImpureCircuits.md)
- [InitialStateParameters](type-aliases/InitialStateParameters.md)
- [Latest](type-aliases/Latest.md)
- [NothingToProve](type-aliases/NothingToProve.md)
- [PrivateState](type-aliases/PrivateState.md)
- [PrivateStateId](type-aliases/PrivateStateId.md)
- [ProvenTransaction](type-aliases/ProvenTransaction.md)
- [ProverKey](type-aliases/ProverKey.md)
- [ProvingRecipe](type-aliases/ProvingRecipe.md)
- [SegmentStatus](type-aliases/SegmentStatus.md)
- [TransactionToProve](type-aliases/TransactionToProve.md)
- [TxIdConfig](type-aliases/TxIdConfig.md)
- [TxStatus](type-aliases/TxStatus.md)
- [UnshieldedBalance](type-aliases/UnshieldedBalance.md)
- [UnshieldedBalances](type-aliases/UnshieldedBalances.md)
- [UnshieldedUtxo](type-aliases/UnshieldedUtxo.md)
- [UnshieldedUtxos](type-aliases/UnshieldedUtxos.md)
- [VerifierKey](type-aliases/VerifierKey.md)
- [Witness](type-aliases/Witness.md)
- [Witnesses](type-aliases/Witnesses.md)
- [ZKIR](type-aliases/ZKIR.md)

## Variables

- [BALANCE\_TRANSACTION\_TO\_PROVE](variables/BALANCE_TRANSACTION_TO_PROVE.md)
- [FailEntirely](variables/FailEntirely.md)
- [FailFallible](variables/FailFallible.md)
- [NOTHING\_TO\_PROVE](variables/NOTHING_TO_PROVE.md)
- [SegmentFail](variables/SegmentFail.md)
- [SegmentSuccess](variables/SegmentSuccess.md)
- [SucceedEntirely](variables/SucceedEntirely.md)
- [TRANSACTION\_TO\_PROVE](variables/TRANSACTION_TO_PROVE.md)

## Functions

- [createProverKey](functions/createProverKey.md)
- [createVerifierKey](functions/createVerifierKey.md)
- [createZKIR](functions/createZKIR.md)
- [getImpureCircuitIds](functions/getImpureCircuitIds.md)

================
File: packages/contracts/src/submit-tx.ts
================
/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ShieldedCoinInfo } from '@midnight-ntwrk/compact-runtime';
import {
  type FinalizedTransaction,
  type Transaction,
  type UnprovenTransaction,
} from '@midnight-ntwrk/ledger-v6';
import {
  BALANCE_TRANSACTION_TO_PROVE,
  type BalancedProvingRecipe,
  type BalanceTransactionToProve,
  type Contract,
  type FinalizedTxData,
  type ImpureCircuitId,
  NOTHING_TO_PROVE,
  type NothingToProve,
  type ProvenTransaction,
  TRANSACTION_TO_PROVE,
  type ZKConfig
} from '@midnight-ntwrk/midnight-js-types';
import fs from 'fs';
import path from 'path';

import { type ContractProviders } from './contract-providers';

declare const __DEBUG__: boolean;

/**
 * Configuration for {@link submitTx}.
 */
export type SubmitTxOptions<ICK extends ImpureCircuitId> = {
  /**
   * The transaction to prove, balance, and submit.
   */
  readonly unprovenTx: UnprovenTransaction;
  /**
   * Any new coins created during the construction of the transaction. Only defined
   * if the transaction being submitted is a call or deploy transaction.
   */
  readonly newCoins?: ShieldedCoinInfo[];
  /**
   * A circuit identifier to use to fetch the ZK artifacts needed to prove the
   * transaction. Only defined if a call transaction is being submitted.
   */
  readonly circuitId?: ICK;
}

/**
 * Providers required to submit an unproven deployment transaction. Since {@link submitTx} doesn't
 * manipulate private state, the private state provider can be omitted.
 */
export type SubmitTxProviders<C extends Contract, ICK extends ImpureCircuitId<C>> = Omit<
  ContractProviders<C, ICK>,
  'privateStateProvider'
>;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function logTransaction(circuitId: string | undefined, tx: Transaction<any, any, any>) {
  if (!__DEBUG__) {
    return;
  }

  const debug = process.env.MN_DEBUG?.toLowerCase();
  if (debug !== 'true') {
    return;
  }

  try {
    console.log(`Submit tx: ${circuitId} : ${tx}`);
    const serialized = tx.serialize();
    const logsDir = path.join(process.cwd(), 'logs', 'transactions');

    if (!fs.existsSync(logsDir)) {
      fs.mkdirSync(logsDir, { recursive: true });
    }

    const filename = `tx-${Date.now()}-${circuitId}`;
    const filepath = path.join(logsDir, filename + '.bin');
    const filepathString = path.join(logsDir, filename + '.txt');

    fs.writeFileSync(filepath, serialized);
    fs.writeFileSync(filepathString, tx.toString());

    console.log(`Transaction serialized and written to: ${filepath}`);
  } catch (error) {
    console.error('Failed to write debug transaction logs:', error instanceof Error ? error.message : String(error));
  }
}

async function proveTransaction<C extends Contract, ICK extends ImpureCircuitId<C>>(recipe: BalancedProvingRecipe, providers: SubmitTxProviders<C, ICK>, proveTxConfig: {
  zkConfig: ZKConfig<ICK>
} | undefined) {
  let toSubmit: ProvenTransaction;
  switch (recipe.type) {
    case TRANSACTION_TO_PROVE: {
      toSubmit = await providers.proofProvider.proveTx(recipe.transaction, proveTxConfig);
      break;
    }

    case BALANCE_TRANSACTION_TO_PROVE: {
      const recipeBalance = recipe as BalanceTransactionToProve<UnprovenTransaction>;
      const merged = recipeBalance.transactionToBalance.merge(recipeBalance.transactionToProve);
      toSubmit = await providers.proofProvider.proveTx(merged, proveTxConfig);
      break;
    }

    case NOTHING_TO_PROVE: {
      // unsafe cast, but it looks like these types are not proper
      toSubmit = (recipe as NothingToProve<FinalizedTransaction>).transaction as unknown as ProvenTransaction;
      break;
    }

    default:
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      throw new Error(`Unknown recipe type: ${(recipe as any).type}`);
  }
  return toSubmit;
}

async function submitTxCore<C extends Contract, ICK extends ImpureCircuitId<C>>(
  providers: SubmitTxProviders<C, ICK>,
  options: SubmitTxOptions<ICK>
): Promise<string> {
  const proveTxConfig = options.circuitId
    ? { zkConfig: await providers.zkConfigProvider.get(options.circuitId) }
    : undefined;
  const recipe = await providers.walletProvider.balanceTx(options.unprovenTx, options.newCoins);
  const toSubmit = await proveTransaction(recipe, providers, proveTxConfig);
  const bound = toSubmit.bind();
  if (__DEBUG__) {
    logTransaction(options.circuitId, bound);
  }
  return providers.midnightProvider.submitTx(bound);
}

/**
 * Proves, balances, and submits an unproven deployment or call transaction using
 * the given providers, according to the given options.
 *
 * ## Blocking Behavior
 *
 * This method **waits indefinitely** for the transaction to appear on the blockchain via
 * `providers.publicDataProvider.watchForTxData(txId)`. It will not return until:
 * - The transaction is successfully included in the blockchain, OR
 * - An error occurs during proving, balancing, or submission
 *
 * ## Conditions When Transaction May Not Appear
 *
 * A submitted transaction may fail to appear on-chain if:
 * - Transaction is invalid in ways not detected during local validation
 * - Network issues prevent propagation to validators
 * - Transaction is rejected by validator consensus
 * - Insufficient fees or resources
 * - Contract state has changed making the transaction invalid
 *
 * ## Implications of Aborting This Method
 *
 * If the application terminates this method before it returns:
 * - Transaction may still be pending/processing on-chain
 * - **Private state updates are NOT stored** (even if transaction later succeeds on-chain)
 * - **Signing keys are NOT updated** (for deploy/replace authority transactions)
 * - Application state will be out of sync with blockchain state
 * - Manual recovery may be required to reconcile state
 *
 * **Recommendation**: Use {@link submitTxAsync} for non-blocking submission with manual
 * finalization handling and timeout control.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @returns A promise that resolves with the finalized transaction data for the invocation,
 *          or rejects if an error occurs along the way.
 */
export const submitTx = async <C extends Contract, ICK extends ImpureCircuitId<C>>(
  providers: SubmitTxProviders<C, ICK>,
  options: SubmitTxOptions<ICK>
): Promise<FinalizedTxData> => {
  const txId = await submitTxCore(providers, options);
  return providers.publicDataProvider.watchForTxData(txId);
};

/**
 * Proves, balances, and submits an unproven deployment or call transaction using
 * the given providers, according to the given options. Unlike {@link submitTx},
 * this function returns immediately after submission without waiting for finalization.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @returns A promise that resolves with the transaction ID immediately after submission,
 *          or rejects if an error occurs during preparation or submission.
 *          To watch for finalization, use providers.publicDataProvider.watchForTxData(txId).
 */
export const submitTxAsync = async <C extends Contract, ICK extends ImpureCircuitId<C>>(
  providers: SubmitTxProviders<C, ICK>,
  options: SubmitTxOptions<ICK>
): Promise<string> => {
  return submitTxCore(providers, options);
};

================
File: packages/contracts/package.json
================
{
  "name": "@midnight-ntwrk/midnight-js-contracts",
  "version": "3.0.0-alpha.9",
  "description": "MidnightJS module for interacting with contracts",
  "main": "dist/index.cjs",
  "module": "dist/index.mjs",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "types": {
        "import": "./dist/index.d.mts",
        "require": "./dist/index.d.cts"
      },
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    }
  },
  "repository": "git@github.com:midnight-ntwrk/artifacts",
  "packageManager": "yarn@4.10.3",
  "author": "IOHK",
  "license": "Apache-2.0",
  "scripts": {
    "clean": "rm -rf dist tsconfig.build.tsbuildinfo .rollup.cache reports coverage",
    "build": "rollup -c rollup.config.mjs",
    "test": "vitest run",
    "test-no-utils": "vitest run --exclude src/test/*.test.ts",
    "deploy": "yarn npm publish"
  },
  "dependencies": {
    "@midnight-ntwrk/midnight-js-network-id": "workspace:*",
    "@midnight-ntwrk/midnight-js-types": "workspace:*",
    "@midnight-ntwrk/midnight-js-utils": "workspace:*"
  },
  "files": [
    "dist/"
  ],
  "devDependencies": {
    "@fast-check/vitest": "^0.2.1",
    "vitest": "^4.0.0"
  },
  "stableVersion": "3.0.0"
}

================
File: packages/fetch-zk-config-provider/package.json
================
{
  "name": "@midnight-ntwrk/midnight-js-fetch-zk-config-provider",
  "version": "3.0.0-alpha.9",
  "description": "MidnightJS module for retrieving proving and verifying keys and ZK intermediate representation",
  "main": "dist/index.cjs",
  "module": "dist/index.mjs",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "types": {
        "import": "./dist/index.d.mts",
        "require": "./dist/index.d.cts"
      },
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    }
  },
  "repository": "git@github.com:midnight-ntwrk/artifacts",
  "packageManager": "yarn@4.10.3",
  "author": "IOHK",
  "license": "Apache-2.0",
  "scripts": {
    "clean": "rm -rf dist tsconfig.build.tsbuildinfo .rollup.cache reports coverage",
    "build": "rollup -c rollup.config.mjs",
    "test": "vitest run",
    "deploy": "yarn npm publish"
  },
  "dependencies": {
    "@midnight-ntwrk/midnight-js-types": "workspace:*",
    "cross-fetch": "^4.1.0"
  },
  "files": [
    "dist/"
  ],
  "devDependencies": {
    "@types/express": "^5.0.0",
    "express": "^5.0.0"
  },
  "stableVersion": "3.0.0"
}

================
File: packages/network-id/package.json
================
{
  "name": "@midnight-ntwrk/midnight-js-network-id",
  "version": "3.0.0-alpha.9",
  "description": "Package for setting the network ID of runtime and ledger WASM API",
  "main": "dist/index.cjs",
  "module": "dist/index.mjs",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "types": {
        "import": "./dist/index.d.mts",
        "require": "./dist/index.d.cts"
      },
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    }
  },
  "repository": "git@github.com:midnight-ntwrk/artifacts",
  "packageManager": "yarn@4.10.3",
  "author": "IOHK",
  "license": "Apache-2.0",
  "scripts": {
    "clean": "rm -rf dist tsconfig.build.tsbuildinfo .rollup.cache",
    "build": "rollup -c rollup.config.mjs",
    "test": "vitest run --passWithNoTests",
    "deploy": "yarn npm publish"
  },
  "files": [
    "dist/"
  ],
  "stableVersion": "3.0.0"
}

================
File: packages/types/package.json
================
{
  "name": "@midnight-ntwrk/midnight-js-types",
  "version": "3.0.0-alpha.9",
  "description": "Shared data types and interfaces for MidnightJS modules",
  "main": "dist/index.cjs",
  "module": "dist/index.mjs",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "types": {
        "import": "./dist/index.d.mts",
        "require": "./dist/index.d.cts"
      },
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    }
  },
  "repository": "git@github.com:midnight-ntwrk/artifacts",
  "packageManager": "yarn@4.10.3",
  "author": "IOHK",
  "license": "Apache-2.0",
  "scripts": {
    "clean": "rm -rf dist tsconfig.build.tsbuildinfo .rollup.cache",
    "build": "rollup -c rollup.config.mjs",
    "test": "vitest run --passWithNoTests",
    "deploy": "yarn npm publish"
  },
  "files": [
    "dist/"
  ],
  "dependencies": {
    "rxjs": "^7.5.0"
  },
  "stableVersion": "3.0.0"
}

================
File: testkit-js/testkit-js-e2e/package.json
================
{
  "name": "@midnight-ntwrk/testkit-js-e2e",
  "version": "3.0.0-alpha.9",
  "description": "E2E tests for Midnight JS packages",
  "main": "dist/index.cjs",
  "module": "dist/index.mjs",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "types": {
        "import": "./dist/index.d.mts",
        "require": "./dist/index.d.cts"
      },
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    }
  },
  "repository": "git@github.com:midnight-ntwrk/artifacts",
  "packageManager": "yarn@4.10.3",
  "author": "IOHK",
  "license": "Apache-2.0",
  "scripts": {
    "clean": "rm -rf dist reports coverage logs tsconfig.build.tsbuildinfo .rollup.cache managed midnight-level-db",
    "build": "yarn compact && yarn build-core && yarn compact-copy",
    "build-core": "rollup -c rollup.config.mjs",
    "build-dev": "turbo build && yarn build",
    "e2e": "docker compose -f ../compose.yml pull && DEBUG='testcontainers:compose' NODE_OPTIONS=--experimental-vm-modules vitest --config vitest.config.ts run",
    "e2e-debug": "docker compose -f ../compose.yml pull && DEBUG='testcontainers:containers' NODE_OPTIONS=--experimental-vm-modules vitest --config vitest.config.ts run",
    "e2e-testnet": "MN_TEST_ENVIRONMENT=testnet-02 DEBUG='testcontainers:compose' NODE_OPTIONS=--experimental-vm-modules vitest --config vitest.config.ts run",
    "e2e-single": "docker compose -f ../compose.yml pull && DEBUG='testcontainers:*' NODE_OPTIONS=--experimental-vm-modules vitest --config vitest.single.config.ts run",
    "compact-copy": "mkdir -p ./dist/contract/ && cp -Rf ./src/contract/managed ./dist/contract",
    "compact": "yarn fetch-compactc && yarn compact-counter && yarn compact-simple && yarn compact-counter-clone && yarn compact-block-time && yarn compact-unshielded",
    "compact-counter": "run-compactc src/contract/counter.compact ./src/contract/managed/counter",
    "compact-simple": "run-compactc src/contract/simple.compact ./src/contract/managed/simple",
    "compact-counter-clone": "run-compactc src/contract/counter-clone.compact ./src/contract/managed/counter-clone",
    "compact-block-time": "run-compactc src/contract/block-time.compact ./src/contract/managed/block-time",
    "compact-unshielded": "run-compactc src/contract/unshielded.compact ./src/contract/managed/unshielded",
    "deploy": "yarn npm publish"
  },
  "dependencies": {
    "@midnight-ntwrk/midnight-js-compact": "workspace:*",
    "@midnight-ntwrk/midnight-js-contracts": "workspace:*",
    "@midnight-ntwrk/midnight-js-http-client-proof-provider": "workspace:*",
    "@midnight-ntwrk/midnight-js-indexer-public-data-provider": "workspace:*",
    "@midnight-ntwrk/midnight-js-network-id": "workspace:*",
    "@midnight-ntwrk/midnight-js-node-zk-config-provider": "workspace:*",
    "@midnight-ntwrk/midnight-js-types": "workspace:*",
    "@midnight-ntwrk/midnight-js-utils": "workspace:*",
    "@midnight-ntwrk/testkit-js": "workspace:*",
    "buffer": "^6.0.3",
    "cross-fetch": "^4.0.0",
    "rxjs": "^7.8.1",
    "ws": "^8.14.2"
  },
  "devDependencies": {
    "@types/ws": "^8.18.1",
    "@vitest/runner": "^4.0.0",
    "allure-commandline": "^2.34.1",
    "allure-js-commons": "^3.3.0",
    "allure-vitest": "^3.3.0",
    "axios": "^1.11.0",
    "pino": "^10.0.0",
    "pino-pretty": "^13.0.0",
    "rxjs": "^7.8.2",
    "vite-tsconfig-paths": "^5.1.4",
    "vitest": "^4.0.0"
  },
  "files": [
    "dist/"
  ],
  "stableVersion": "3.0.0"
}

================
File: CHANGELOG.md
================
## 3.0.0-alpha.9 (2025-12-03)

* feat: enhance transaction documentation with execution phases and failure behavior ([a274ecc](https://github.com/midnight-ntwrk/artifacts/commit/a274ecc))
* feat: enhance transaction handling documentation for indefinite waiting behavior ([69606e7](https://github.com/midnight-ntwrk/artifacts/commit/69606e7))
* feat: enhance transaction handling documentation for indefinite waiting behavior ([944a242](https://github.com/midnight-ntwrk/artifacts/commit/944a242))
* feat: move @midnight-ntwrk/midnight-js-compact to devDependencies (#361) ([b5771d1](https://github.com/midnight-ntwrk/artifacts/commit/b5771d1)), closes [#361](https://github.com/midnight-ntwrk/artifacts/issues/361)
* chore: update proof-server, indexer, and node images to latest alpha versions ([759a061](https://github.com/midnight-ntwrk/artifacts/commit/759a061))



## 3.0.0-alpha.8 (2025-12-01)

* feat: move @midnight-ntwrk/midnight-js-compact to devDependencies (#361) ([625854b](https://github.com/midnight-ntwrk/artifacts/commit/625854b)), closes [#361](https://github.com/midnight-ntwrk/artifacts/issues/361)



## 3.0.0-alpha.7 (2025-11-28)

* feat: add testkit-js password handling ([0e293a9](https://github.com/midnight-ntwrk/artifacts/commit/0e293a9))
* feat: async submit tx and call (#348) ([a37e96f](https://github.com/midnight-ntwrk/artifacts/commit/a37e96f)), closes [#348](https://github.com/midnight-ntwrk/artifacts/issues/348)
* feat: encrypt storage ([ae863fe](https://github.com/midnight-ntwrk/artifacts/commit/ae863fe))
* feat: encrypt storage ([420a64d](https://github.com/midnight-ntwrk/artifacts/commit/420a64d))
* feat: remove debug code on build on CI ([082f1db](https://github.com/midnight-ntwrk/artifacts/commit/082f1db))
* chore: add 'release' to commitlint configuration ([d48f6c6](https://github.com/midnight-ntwrk/artifacts/commit/d48f6c6))
* chore: update build script to copy run-compactc.cjs to dist and remove it from files ([96e8187](https://github.com/midnight-ntwrk/artifacts/commit/96e8187))
* chore: update license to Apache-2.0 and adjust run-compactc path in package.json ([adf794d](https://github.com/midnight-ntwrk/artifacts/commit/adf794d))
* chore: update run-compactc path in yarn.lock to point to dist ([05eb923](https://github.com/midnight-ntwrk/artifacts/commit/05eb923))
* chore(docs): unify commit message format for API documentation updates ([96b8504](https://github.com/midnight-ntwrk/artifacts/commit/96b8504))
* chore(docs): unify commit message format for API documentation updates ([6a3e6c0](https://github.com/midnight-ntwrk/artifacts/commit/6a3e6c0))



## 3.0.0-alpha.6 (2025-11-26)

* fix: cleaner types in wallet provider (#346) ([e08e655](https://github.com/midnight-ntwrk/artifacts/commit/e08e655)), closes [#346](https://github.com/midnight-ntwrk/artifacts/issues/346)
* fix(deps): update dependency superjson to v2.2.5 (#276) ([18d26ec](https://github.com/midnight-ntwrk/artifacts/commit/18d26ec)), closes [#276](https://github.com/midnight-ntwrk/artifacts/issues/276)
* chore: indexer-standalone:3.0.0-alpha.10 ([1f53a0a](https://github.com/midnight-ntwrk/artifacts/commit/1f53a0a))
* chore: indexer-standalone:3.0.0-alpha.11 ([b4f5347](https://github.com/midnight-ntwrk/artifacts/commit/b4f5347))
* chore: midnight-node:0.18.0-rc.6 ([11af678](https://github.com/midnight-ntwrk/artifacts/commit/11af678))
* chore: tweak testkit-js default configuration ([f2ef937](https://github.com/midnight-ntwrk/artifacts/commit/f2ef937))
* chore(deps): bump @babel/helpers (#323) ([accc449](https://github.com/midnight-ntwrk/artifacts/commit/accc449)), closes [#323](https://github.com/midnight-ntwrk/artifacts/issues/323)
* chore(deps): bump actions/checkout from 4 to 5 (#288) ([2f583a6](https://github.com/midnight-ntwrk/artifacts/commit/2f583a6)), closes [#288](https://github.com/midnight-ntwrk/artifacts/issues/288)
* chore(deps): bump actions/checkout from 5 to 6 (#341) ([002ea41](https://github.com/midnight-ntwrk/artifacts/commit/002ea41)), closes [#341](https://github.com/midnight-ntwrk/artifacts/issues/341)
* chore(deps): bump actions/setup-node from 4 to 6 (#287) ([31416b6](https://github.com/midnight-ntwrk/artifacts/commit/31416b6)), closes [#287](https://github.com/midnight-ntwrk/artifacts/issues/287)
* chore(deps): bump actions/upload-artifact from 4.4.3 to 5.0.0 (#255) ([1946bdd](https://github.com/midnight-ntwrk/artifacts/commit/1946bdd)), closes [#255](https://github.com/midnight-ntwrk/artifacts/issues/255)
* chore(deps): bump body-parser (#351) ([f9177fa](https://github.com/midnight-ntwrk/artifacts/commit/f9177fa)), closes [#351](https://github.com/midnight-ntwrk/artifacts/issues/351)
* chore(deps): bump ctrf-io/github-test-reporter from 1.0.25 to 1.0.26 (#269) ([ce3ee9a](https://github.com/midnight-ntwrk/artifacts/commit/ce3ee9a)), closes [#269](https://github.com/midnight-ntwrk/artifacts/issues/269)
* chore(deps): bump EnricoMi/publish-unit-test-result-action (#271) ([2fc8ab7](https://github.com/midnight-ntwrk/artifacts/commit/2fc8ab7)), closes [#271](https://github.com/midnight-ntwrk/artifacts/issues/271)
* chore(deps): bump js-yaml in the npm_and_yarn group across 1 directory (#307) ([002595a](https://github.com/midnight-ntwrk/artifacts/commit/002595a)), closes [#307](https://github.com/midnight-ntwrk/artifacts/issues/307)
* chore(deps): bump mikepenz/action-junit-report from 6.0.0 to 6.0.1 (#270) ([095db97](https://github.com/midnight-ntwrk/artifacts/commit/095db97)), closes [#270](https://github.com/midnight-ntwrk/artifacts/issues/270)
* chore(deps): update actions/github-script action to v8 (#260) ([05d59ee](https://github.com/midnight-ntwrk/artifacts/commit/05d59ee)), closes [#260](https://github.com/midnight-ntwrk/artifacts/issues/260)
* chore(deps): update dependency @effect/experimental to ^0.57.0 (#283) ([2a07c17](https://github.com/midnight-ntwrk/artifacts/commit/2a07c17)), closes [#283](https://github.com/midnight-ntwrk/artifacts/issues/283)
* chore(deps): update dependency @effect/experimental to v0.57.1 (#293) ([ac23fd6](https://github.com/midnight-ntwrk/artifacts/commit/ac23fd6)), closes [#293](https://github.com/midnight-ntwrk/artifacts/issues/293)
* chore(deps): update dependency @effect/experimental to v0.57.3 (#321) ([9cf1c39](https://github.com/midnight-ntwrk/artifacts/commit/9cf1c39)), closes [#321](https://github.com/midnight-ntwrk/artifacts/issues/321)
* chore(deps): update dependency @effect/experimental to v0.57.4 (#331) ([caf7cab](https://github.com/midnight-ntwrk/artifacts/commit/caf7cab)), closes [#331](https://github.com/midnight-ntwrk/artifacts/issues/331)
* chore(deps): update dependency @effect/platform-node-shared to ^0.53.0 (#285) ([5e39e51](https://github.com/midnight-ntwrk/artifacts/commit/5e39e51)), closes [#285](https://github.com/midnight-ntwrk/artifacts/issues/285)
* chore(deps): update dependency @effect/rpc to ^0.72.0 (#286) ([97f4499](https://github.com/midnight-ntwrk/artifacts/commit/97f4499)), closes [#286](https://github.com/midnight-ntwrk/artifacts/issues/286)
* chore(deps): update dependency @effect/rpc to v0.72.2 (#332) ([0955da1](https://github.com/midnight-ntwrk/artifacts/commit/0955da1)), closes [#332](https://github.com/midnight-ntwrk/artifacts/issues/332)
* chore(deps): update dependency @effect/sql to ^0.48.0 (#305) ([fcca1cf](https://github.com/midnight-ntwrk/artifacts/commit/fcca1cf)), closes [#305](https://github.com/midnight-ntwrk/artifacts/issues/305)
* chore(deps): update dependency @effect/vitest to ^0.27.0 (#306) ([d71fc79](https://github.com/midnight-ntwrk/artifacts/commit/d71fc79)), closes [#306](https://github.com/midnight-ntwrk/artifacts/issues/306)
* chore(deps): update dependency @effect/workflow to ^0.12.0 (#310) ([5890e15](https://github.com/midnight-ntwrk/artifacts/commit/5890e15)), closes [#310](https://github.com/midnight-ntwrk/artifacts/issues/310)
* chore(deps): update dependency @fast-check/vitest to v0.2.3 (#273) ([6c0bcd2](https://github.com/midnight-ntwrk/artifacts/commit/6c0bcd2)), closes [#273](https://github.com/midnight-ntwrk/artifacts/issues/273)
* chore(deps): update dependency @tsconfig/node22 to v22.0.3 (#294) ([a796bba](https://github.com/midnight-ntwrk/artifacts/commit/a796bba)), closes [#294](https://github.com/midnight-ntwrk/artifacts/issues/294)
* chore(deps): update dependency @tsconfig/node22 to v22.0.3 (#299) ([e9fb568](https://github.com/midnight-ntwrk/artifacts/commit/e9fb568)), closes [#299](https://github.com/midnight-ntwrk/artifacts/issues/299)
* chore(deps): update dependency @tsconfig/node24 to v24.0.3 (#324) ([0fb07fe](https://github.com/midnight-ntwrk/artifacts/commit/0fb07fe)), closes [#324](https://github.com/midnight-ntwrk/artifacts/issues/324)
* chore(deps): update dependency @types/express to v5.0.5 (#258) ([5163a92](https://github.com/midnight-ntwrk/artifacts/commit/5163a92)), closes [#258](https://github.com/midnight-ntwrk/artifacts/issues/258)
* chore(deps): update dependency @types/node to v24.10.1 (#289) ([6e85b88](https://github.com/midnight-ntwrk/artifacts/commit/6e85b88)), closes [#289](https://github.com/midnight-ntwrk/artifacts/issues/289)
* chore(deps): update dependency @types/node to v24.10.1 (#300) ([38a6171](https://github.com/midnight-ntwrk/artifacts/commit/38a6171)), closes [#300](https://github.com/midnight-ntwrk/artifacts/issues/300)
* chore(deps): update dependency allure-vitest to v3.4.2 (#274) ([cd15b40](https://github.com/midnight-ntwrk/artifacts/commit/cd15b40)), closes [#274](https://github.com/midnight-ntwrk/artifacts/issues/274)
* chore(deps): update dependency axios to v1.13.1 (#257) ([7cc7f95](https://github.com/midnight-ntwrk/artifacts/commit/7cc7f95)), closes [#257](https://github.com/midnight-ntwrk/artifacts/issues/257)
* chore(deps): update dependency axios to v1.13.2 (#278) ([47b4852](https://github.com/midnight-ntwrk/artifacts/commit/47b4852)), closes [#278](https://github.com/midnight-ntwrk/artifacts/issues/278)
* chore(deps): update dependency glob to v11.1.0 [security] (#322) ([c47d222](https://github.com/midnight-ntwrk/artifacts/commit/c47d222)), closes [#322](https://github.com/midnight-ntwrk/artifacts/issues/322)
* chore(deps): update dependency jsdom to v27.2.0 (#311) ([e078405](https://github.com/midnight-ntwrk/artifacts/commit/e078405)), closes [#311](https://github.com/midnight-ntwrk/artifacts/issues/311)
* chore(deps): update dependency lint-staged to v16.2.7 (#330) ([5ef8afb](https://github.com/midnight-ntwrk/artifacts/commit/5ef8afb)), closes [#330](https://github.com/midnight-ntwrk/artifacts/issues/330)
* chore(deps): update dependency node to v24 (#259) ([e7d1a0f](https://github.com/midnight-ntwrk/artifacts/commit/e7d1a0f)), closes [#259](https://github.com/midnight-ntwrk/artifacts/issues/259)
* chore(deps): update dependency node to v24.11.1 (#290) ([0cab0c1](https://github.com/midnight-ntwrk/artifacts/commit/0cab0c1)), closes [#290](https://github.com/midnight-ntwrk/artifacts/issues/290)
* chore(deps): update dependency pino to v10 (#245) ([773ee91](https://github.com/midnight-ntwrk/artifacts/commit/773ee91)), closes [#245](https://github.com/midnight-ntwrk/artifacts/issues/245)
* chore(deps): update dependency rollup to v4.53.3 (#327) ([fcba43c](https://github.com/midnight-ntwrk/artifacts/commit/fcba43c)), closes [#327](https://github.com/midnight-ntwrk/artifacts/issues/327)
* chore(deps): update dependency testcontainers to v11.8.1 (#328) ([ed6173b](https://github.com/midnight-ntwrk/artifacts/commit/ed6173b)), closes [#328](https://github.com/midnight-ntwrk/artifacts/issues/328)
* chore(deps): update dependency typescript-eslint to v8.46.3 (#275) ([b5feb2e](https://github.com/midnight-ntwrk/artifacts/commit/b5feb2e)), closes [#275](https://github.com/midnight-ntwrk/artifacts/issues/275)
* chore(deps): update dependency typescript-eslint to v8.46.4 (#291) ([325f10b](https://github.com/midnight-ntwrk/artifacts/commit/325f10b)), closes [#291](https://github.com/midnight-ntwrk/artifacts/issues/291)
* chore(deps): update dependency typescript-eslint to v8.46.4 (#301) ([e6ae05e](https://github.com/midnight-ntwrk/artifacts/commit/e6ae05e)), closes [#301](https://github.com/midnight-ntwrk/artifacts/issues/301)
* chore(deps): update graphqlcodegenerator monorepo (#292) ([59458d6](https://github.com/midnight-ntwrk/artifacts/commit/59458d6)), closes [#292](https://github.com/midnight-ntwrk/artifacts/issues/292)
* chore(deps): update graphqlcodegenerator monorepo (major) (#246) ([cece16c](https://github.com/midnight-ntwrk/artifacts/commit/cece16c)), closes [#246](https://github.com/midnight-ntwrk/artifacts/issues/246)
* chore(deps): update graphqlcodegenerator monorepo to v5.1.3 (#298) ([643111f](https://github.com/midnight-ntwrk/artifacts/commit/643111f)), closes [#298](https://github.com/midnight-ntwrk/artifacts/issues/298)
* chore(deps): update vitest monorepo to v4 ([bf72e9a](https://github.com/midnight-ntwrk/artifacts/commit/bf72e9a))
* chore(deps): update vitest monorepo to v4.0.10 (#313) ([56d4304](https://github.com/midnight-ntwrk/artifacts/commit/56d4304)), closes [#313](https://github.com/midnight-ntwrk/artifacts/issues/313)
* chore(deps): update vitest monorepo to v4.0.9 (#303) ([6d3e9b9](https://github.com/midnight-ntwrk/artifacts/commit/6d3e9b9)), closes [#303](https://github.com/midnight-ntwrk/artifacts/issues/303)
* chore(release): bump version to 3.0.0-alpha.2 (#279) ([6ba77cc](https://github.com/midnight-ntwrk/artifacts/commit/6ba77cc)), closes [#279](https://github.com/midnight-ntwrk/artifacts/issues/279)
* chore(release): bump version to 3.0.0-alpha.4 (#335) ([fd89509](https://github.com/midnight-ntwrk/artifacts/commit/fd89509)), closes [#335](https://github.com/midnight-ntwrk/artifacts/issues/335)
* chore(release): bump version to 3.0.0-alpha.5 (#345) ([6f2736c](https://github.com/midnight-ntwrk/artifacts/commit/6f2736c)), closes [#345](https://github.com/midnight-ntwrk/artifacts/issues/345)
* feat: automated indexer schema update ([bd287f7](https://github.com/midnight-ntwrk/artifacts/commit/bd287f7))
* feat: change assertions ([1e7db4e](https://github.com/midnight-ntwrk/artifacts/commit/1e7db4e))
* feat: clean wallet provider (#342) ([f3f2601](https://github.com/midnight-ntwrk/artifacts/commit/f3f2601)), closes [#342](https://github.com/midnight-ntwrk/artifacts/issues/342)
* feat: delta should be undefined if balance is 0 ([0b0bf30](https://github.com/midnight-ntwrk/artifacts/commit/0b0bf30))
* feat: fix broken api docs generation ([e7bfafd](https://github.com/midnight-ntwrk/artifacts/commit/e7bfafd))
* feat: fix docs generation ([9c700c0](https://github.com/midnight-ntwrk/artifacts/commit/9c700c0))
* feat: fix esm and cjs packaging ([3d224d4](https://github.com/midnight-ntwrk/artifacts/commit/3d224d4))
* feat: fix workflows - replace istanbul with nyc ([e79010d](https://github.com/midnight-ntwrk/artifacts/commit/e79010d))
* feat: handle BalanceTransactionToProve (#320) ([ccb24ca](https://github.com/midnight-ntwrk/artifacts/commit/ccb24ca)), closes [#320](https://github.com/midnight-ntwrk/artifacts/issues/320)
* feat: lockfile ([3a2e77e](https://github.com/midnight-ntwrk/artifacts/commit/3a2e77e))
* feat: release 3.0.0-alpha.3 (#318) ([585edd2](https://github.com/midnight-ntwrk/artifacts/commit/585edd2)), closes [#318](https://github.com/midnight-ntwrk/artifacts/issues/318)
* feat: release script (#308) ([19d918c](https://github.com/midnight-ntwrk/artifacts/commit/19d918c)), closes [#308](https://github.com/midnight-ntwrk/artifacts/issues/308)
* feat: remove Allure server reporting from CI configuration ([3465190](https://github.com/midnight-ntwrk/artifacts/commit/3465190))
* feat: remove obsolete steps from the release script (#317) ([bbd5dd7](https://github.com/midnight-ntwrk/artifacts/commit/bbd5dd7)), closes [#317](https://github.com/midnight-ntwrk/artifacts/issues/317)
* feat: replace compactc ([0fb103e](https://github.com/midnight-ntwrk/artifacts/commit/0fb103e))
* feat: replace compactc ([90f579f](https://github.com/midnight-ntwrk/artifacts/commit/90f579f))
* feat: update @midnight-ntwrk/wallet-sdk-facade to 1.0.0-beta.10 ([8d5136f](https://github.com/midnight-ntwrk/artifacts/commit/8d5136f))
* feat: update cd workflow (#265) ([df3a423](https://github.com/midnight-ntwrk/artifacts/commit/df3a423)), closes [#265](https://github.com/midnight-ntwrk/artifacts/issues/265)
* feat: update components ([1f06ec0](https://github.com/midnight-ntwrk/artifacts/commit/1f06ec0))
* feat: update indexer TxId mapping ([9ed2fef](https://github.com/midnight-ntwrk/artifacts/commit/9ed2fef))
* feat: update mock ([afb9bdf](https://github.com/midnight-ntwrk/artifacts/commit/afb9bdf))
* feat: update node imports and tweak config ([034a4cb](https://github.com/midnight-ntwrk/artifacts/commit/034a4cb))
* feat: update submit tx ([7ceba12](https://github.com/midnight-ntwrk/artifacts/commit/7ceba12))
* feat: update tests ([6d46777](https://github.com/midnight-ntwrk/artifacts/commit/6d46777))
* feat: update the FinalizedTxData to store all transaction identifiers ([df58c30](https://github.com/midnight-ntwrk/artifacts/commit/df58c30))
* feat: update wallet (#297) ([3b2f5dc](https://github.com/midnight-ntwrk/artifacts/commit/3b2f5dc)), closes [#297](https://github.com/midnight-ntwrk/artifacts/issues/297)
* Midnight JS API documentation update - created by Midnight CI Github Action (#309) ([e1214db](https://github.com/midnight-ntwrk/artifacts/commit/e1214db)), closes [#309](https://github.com/midnight-ntwrk/artifacts/issues/309)
* Midnight JS API documentation update - created by Midnight CI Github Action (#319) ([5995325](https://github.com/midnight-ntwrk/artifacts/commit/5995325)), closes [#319](https://github.com/midnight-ntwrk/artifacts/issues/319)
* Midnight JS API documentation update - created by Midnight CI Github Action (#326) ([7eca2f4](https://github.com/midnight-ntwrk/artifacts/commit/7eca2f4)), closes [#326](https://github.com/midnight-ntwrk/artifacts/issues/326)
* Midnight JS API documentation update - created by Midnight CI Github Action (#344) ([63f1578](https://github.com/midnight-ntwrk/artifacts/commit/63f1578)), closes [#344](https://github.com/midnight-ntwrk/artifacts/issues/344)
* Midnight JS API documentation update - created by Midnight CI Github Action (#347) ([77d468e](https://github.com/midnight-ntwrk/artifacts/commit/77d468e)), closes [#347](https://github.com/midnight-ntwrk/artifacts/issues/347)
* Use 'createCircuitContext' constructor from runtime. Add support for parsing Uint8Array circuit resu ([5d4ff2c](https://github.com/midnight-ntwrk/artifacts/commit/5d4ff2c)), closes [#268](https://github.com/midnight-ntwrk/artifacts/issues/268)



## 3.0.0-alpha.5 (2025-11-24)

* Midnight JS API documentation update - created by Midnight CI Github Action (#309) ([e1214db](https://github.com/midnight-ntwrk/artifacts/commit/e1214db)), closes [#309](https://github.com/midnight-ntwrk/artifacts/issues/309)
* Midnight JS API documentation update - created by Midnight CI Github Action (#319) ([5995325](https://github.com/midnight-ntwrk/artifacts/commit/5995325)), closes [#319](https://github.com/midnight-ntwrk/artifacts/issues/319)
* Midnight JS API documentation update - created by Midnight CI Github Action (#326) ([7eca2f4](https://github.com/midnight-ntwrk/artifacts/commit/7eca2f4)), closes [#326](https://github.com/midnight-ntwrk/artifacts/issues/326)
* Midnight JS API documentation update - created by Midnight CI Github Action (#344) ([63f1578](https://github.com/midnight-ntwrk/artifacts/commit/63f1578)), closes [#344](https://github.com/midnight-ntwrk/artifacts/issues/344)
* Use 'createCircuitContext' constructor from runtime. Add support for parsing Uint8Array circuit resu ([5d4ff2c](https://github.com/midnight-ntwrk/artifacts/commit/5d4ff2c)), closes [#268](https://github.com/midnight-ntwrk/artifacts/issues/268)
* feat: automated indexer schema update ([bd287f7](https://github.com/midnight-ntwrk/artifacts/commit/bd287f7))
* feat: change assertions ([1e7db4e](https://github.com/midnight-ntwrk/artifacts/commit/1e7db4e))
* feat: clean wallet provider (#342) ([f3f2601](https://github.com/midnight-ntwrk/artifacts/commit/f3f2601)), closes [#342](https://github.com/midnight-ntwrk/artifacts/issues/342)
* feat: delta should be undefined if balance is 0 ([0b0bf30](https://github.com/midnight-ntwrk/artifacts/commit/0b0bf30))
* feat: fix broken api docs generation ([e7bfafd](https://github.com/midnight-ntwrk/artifacts/commit/e7bfafd))
* feat: fix docs generation ([9c700c0](https://github.com/midnight-ntwrk/artifacts/commit/9c700c0))
* feat: fix esm and cjs packaging ([3d224d4](https://github.com/midnight-ntwrk/artifacts/commit/3d224d4))
* feat: fix workflows - replace istanbul with nyc ([e79010d](https://github.com/midnight-ntwrk/artifacts/commit/e79010d))
* feat: handle BalanceTransactionToProve (#320) ([ccb24ca](https://github.com/midnight-ntwrk/artifacts/commit/ccb24ca)), closes [#320](https://github.com/midnight-ntwrk/artifacts/issues/320)
* feat: lockfile ([3a2e77e](https://github.com/midnight-ntwrk/artifacts/commit/3a2e77e))
* feat: release 3.0.0-alpha.3 (#318) ([585edd2](https://github.com/midnight-ntwrk/artifacts/commit/585edd2)), closes [#318](https://github.com/midnight-ntwrk/artifacts/issues/318)
* feat: release script (#308) ([19d918c](https://github.com/midnight-ntwrk/artifacts/commit/19d918c)), closes [#308](https://github.com/midnight-ntwrk/artifacts/issues/308)
* feat: remove Allure server reporting from CI configuration ([3465190](https://github.com/midnight-ntwrk/artifacts/commit/3465190))
* feat: remove obsolete steps from the release script (#317) ([bbd5dd7](https://github.com/midnight-ntwrk/artifacts/commit/bbd5dd7)), closes [#317](https://github.com/midnight-ntwrk/artifacts/issues/317)
* feat: replace compactc ([0fb103e](https://github.com/midnight-ntwrk/artifacts/commit/0fb103e))
* feat: replace compactc ([90f579f](https://github.com/midnight-ntwrk/artifacts/commit/90f579f))
* feat: update cd workflow (#265) ([df3a423](https://github.com/midnight-ntwrk/artifacts/commit/df3a423)), closes [#265](https://github.com/midnight-ntwrk/artifacts/issues/265)
* feat: update components ([1f06ec0](https://github.com/midnight-ntwrk/artifacts/commit/1f06ec0))
* feat: update indexer TxId mapping ([9ed2fef](https://github.com/midnight-ntwrk/artifacts/commit/9ed2fef))
* feat: update mock ([afb9bdf](https://github.com/midnight-ntwrk/artifacts/commit/afb9bdf))
* feat: update node imports and tweak config ([034a4cb](https://github.com/midnight-ntwrk/artifacts/commit/034a4cb))
* feat: update submit tx ([7ceba12](https://github.com/midnight-ntwrk/artifacts/commit/7ceba12))
* feat: update tests ([6d46777](https://github.com/midnight-ntwrk/artifacts/commit/6d46777))
* feat: update the FinalizedTxData to store all transaction identifiers ([df58c30](https://github.com/midnight-ntwrk/artifacts/commit/df58c30))
* feat: update wallet (#297) ([3b2f5dc](https://github.com/midnight-ntwrk/artifacts/commit/3b2f5dc)), closes [#297](https://github.com/midnight-ntwrk/artifacts/issues/297)
* chore: indexer-standalone:3.0.0-alpha.10 ([1f53a0a](https://github.com/midnight-ntwrk/artifacts/commit/1f53a0a))
* chore: indexer-standalone:3.0.0-alpha.11 ([b4f5347](https://github.com/midnight-ntwrk/artifacts/commit/b4f5347))
* chore: midnight-node:0.18.0-rc.6 ([11af678](https://github.com/midnight-ntwrk/artifacts/commit/11af678))
* chore: tweak testkit-js default configuration ([f2ef937](https://github.com/midnight-ntwrk/artifacts/commit/f2ef937))
* chore(deps): bump @babel/helpers (#323) ([accc449](https://github.com/midnight-ntwrk/artifacts/commit/accc449)), closes [#323](https://github.com/midnight-ntwrk/artifacts/issues/323)
* chore(deps): bump actions/checkout from 4 to 5 (#288) ([2f583a6](https://github.com/midnight-ntwrk/artifacts/commit/2f583a6)), closes [#288](https://github.com/midnight-ntwrk/artifacts/issues/288)
* chore(deps): bump actions/setup-node from 4 to 6 (#287) ([31416b6](https://github.com/midnight-ntwrk/artifacts/commit/31416b6)), closes [#287](https://github.com/midnight-ntwrk/artifacts/issues/287)
* chore(deps): bump actions/upload-artifact from 4.4.3 to 5.0.0 (#255) ([1946bdd](https://github.com/midnight-ntwrk/artifacts/commit/1946bdd)), closes [#255](https://github.com/midnight-ntwrk/artifacts/issues/255)
* chore(deps): bump ctrf-io/github-test-reporter from 1.0.25 to 1.0.26 (#269) ([ce3ee9a](https://github.com/midnight-ntwrk/artifacts/commit/ce3ee9a)), closes [#269](https://github.com/midnight-ntwrk/artifacts/issues/269)
* chore(deps): bump EnricoMi/publish-unit-test-result-action (#271) ([2fc8ab7](https://github.com/midnight-ntwrk/artifacts/commit/2fc8ab7)), closes [#271](https://github.com/midnight-ntwrk/artifacts/issues/271)
* chore(deps): bump js-yaml in the npm_and_yarn group across 1 directory (#307) ([002595a](https://github.com/midnight-ntwrk/artifacts/commit/002595a)), closes [#307](https://github.com/midnight-ntwrk/artifacts/issues/307)
* chore(deps): bump mikepenz/action-junit-report from 6.0.0 to 6.0.1 (#270) ([095db97](https://github.com/midnight-ntwrk/artifacts/commit/095db97)), closes [#270](https://github.com/midnight-ntwrk/artifacts/issues/270)
* chore(deps): update actions/github-script action to v8 (#260) ([05d59ee](https://github.com/midnight-ntwrk/artifacts/commit/05d59ee)), closes [#260](https://github.com/midnight-ntwrk/artifacts/issues/260)
* chore(deps): update dependency @effect/experimental to ^0.57.0 (#283) ([2a07c17](https://github.com/midnight-ntwrk/artifacts/commit/2a07c17)), closes [#283](https://github.com/midnight-ntwrk/artifacts/issues/283)
* chore(deps): update dependency @effect/experimental to v0.57.1 (#293) ([ac23fd6](https://github.com/midnight-ntwrk/artifacts/commit/ac23fd6)), closes [#293](https://github.com/midnight-ntwrk/artifacts/issues/293)
* chore(deps): update dependency @effect/experimental to v0.57.3 (#321) ([9cf1c39](https://github.com/midnight-ntwrk/artifacts/commit/9cf1c39)), closes [#321](https://github.com/midnight-ntwrk/artifacts/issues/321)
* chore(deps): update dependency @effect/experimental to v0.57.4 (#331) ([caf7cab](https://github.com/midnight-ntwrk/artifacts/commit/caf7cab)), closes [#331](https://github.com/midnight-ntwrk/artifacts/issues/331)
* chore(deps): update dependency @effect/platform-node-shared to ^0.53.0 (#285) ([5e39e51](https://github.com/midnight-ntwrk/artifacts/commit/5e39e51)), closes [#285](https://github.com/midnight-ntwrk/artifacts/issues/285)
* chore(deps): update dependency @effect/rpc to ^0.72.0 (#286) ([97f4499](https://github.com/midnight-ntwrk/artifacts/commit/97f4499)), closes [#286](https://github.com/midnight-ntwrk/artifacts/issues/286)
* chore(deps): update dependency @effect/rpc to v0.72.2 (#332) ([0955da1](https://github.com/midnight-ntwrk/artifacts/commit/0955da1)), closes [#332](https://github.com/midnight-ntwrk/artifacts/issues/332)
* chore(deps): update dependency @effect/sql to ^0.48.0 (#305) ([fcca1cf](https://github.com/midnight-ntwrk/artifacts/commit/fcca1cf)), closes [#305](https://github.com/midnight-ntwrk/artifacts/issues/305)
* chore(deps): update dependency @effect/vitest to ^0.27.0 (#306) ([d71fc79](https://github.com/midnight-ntwrk/artifacts/commit/d71fc79)), closes [#306](https://github.com/midnight-ntwrk/artifacts/issues/306)
* chore(deps): update dependency @effect/workflow to ^0.12.0 (#310) ([5890e15](https://github.com/midnight-ntwrk/artifacts/commit/5890e15)), closes [#310](https://github.com/midnight-ntwrk/artifacts/issues/310)
* chore(deps): update dependency @fast-check/vitest to v0.2.3 (#273) ([6c0bcd2](https://github.com/midnight-ntwrk/artifacts/commit/6c0bcd2)), closes [#273](https://github.com/midnight-ntwrk/artifacts/issues/273)
* chore(deps): update dependency @tsconfig/node22 to v22.0.3 (#294) ([a796bba](https://github.com/midnight-ntwrk/artifacts/commit/a796bba)), closes [#294](https://github.com/midnight-ntwrk/artifacts/issues/294)
* chore(deps): update dependency @tsconfig/node22 to v22.0.3 (#299) ([e9fb568](https://github.com/midnight-ntwrk/artifacts/commit/e9fb568)), closes [#299](https://github.com/midnight-ntwrk/artifacts/issues/299)
* chore(deps): update dependency @tsconfig/node24 to v24.0.3 (#324) ([0fb07fe](https://github.com/midnight-ntwrk/artifacts/commit/0fb07fe)), closes [#324](https://github.com/midnight-ntwrk/artifacts/issues/324)
* chore(deps): update dependency @types/express to v5.0.5 (#258) ([5163a92](https://github.com/midnight-ntwrk/artifacts/commit/5163a92)), closes [#258](https://github.com/midnight-ntwrk/artifacts/issues/258)
* chore(deps): update dependency @types/node to v24.10.1 (#289) ([6e85b88](https://github.com/midnight-ntwrk/artifacts/commit/6e85b88)), closes [#289](https://github.com/midnight-ntwrk/artifacts/issues/289)
* chore(deps): update dependency @types/node to v24.10.1 (#300) ([38a6171](https://github.com/midnight-ntwrk/artifacts/commit/38a6171)), closes [#300](https://github.com/midnight-ntwrk/artifacts/issues/300)
* chore(deps): update dependency allure-vitest to v3.4.2 (#274) ([cd15b40](https://github.com/midnight-ntwrk/artifacts/commit/cd15b40)), closes [#274](https://github.com/midnight-ntwrk/artifacts/issues/274)
* chore(deps): update dependency axios to v1.13.1 (#257) ([7cc7f95](https://github.com/midnight-ntwrk/artifacts/commit/7cc7f95)), closes [#257](https://github.com/midnight-ntwrk/artifacts/issues/257)
* chore(deps): update dependency axios to v1.13.2 (#278) ([47b4852](https://github.com/midnight-ntwrk/artifacts/commit/47b4852)), closes [#278](https://github.com/midnight-ntwrk/artifacts/issues/278)
* chore(deps): update dependency glob to v11.1.0 [security] (#322) ([c47d222](https://github.com/midnight-ntwrk/artifacts/commit/c47d222)), closes [#322](https://github.com/midnight-ntwrk/artifacts/issues/322)
* chore(deps): update dependency jsdom to v27.2.0 (#311) ([e078405](https://github.com/midnight-ntwrk/artifacts/commit/e078405)), closes [#311](https://github.com/midnight-ntwrk/artifacts/issues/311)
* chore(deps): update dependency lint-staged to v16.2.7 (#330) ([5ef8afb](https://github.com/midnight-ntwrk/artifacts/commit/5ef8afb)), closes [#330](https://github.com/midnight-ntwrk/artifacts/issues/330)
* chore(deps): update dependency node to v24 (#259) ([e7d1a0f](https://github.com/midnight-ntwrk/artifacts/commit/e7d1a0f)), closes [#259](https://github.com/midnight-ntwrk/artifacts/issues/259)
* chore(deps): update dependency node to v24.11.1 (#290) ([0cab0c1](https://github.com/midnight-ntwrk/artifacts/commit/0cab0c1)), closes [#290](https://github.com/midnight-ntwrk/artifacts/issues/290)
* chore(deps): update dependency pino to v10 (#245) ([773ee91](https://github.com/midnight-ntwrk/artifacts/commit/773ee91)), closes [#245](https://github.com/midnight-ntwrk/artifacts/issues/245)
* chore(deps): update dependency rollup to v4.53.3 (#327) ([fcba43c](https://github.com/midnight-ntwrk/artifacts/commit/fcba43c)), closes [#327](https://github.com/midnight-ntwrk/artifacts/issues/327)
* chore(deps): update dependency testcontainers to v11.8.1 (#328) ([ed6173b](https://github.com/midnight-ntwrk/artifacts/commit/ed6173b)), closes [#328](https://github.com/midnight-ntwrk/artifacts/issues/328)
* chore(deps): update dependency typescript-eslint to v8.46.3 (#275) ([b5feb2e](https://github.com/midnight-ntwrk/artifacts/commit/b5feb2e)), closes [#275](https://github.com/midnight-ntwrk/artifacts/issues/275)
* chore(deps): update dependency typescript-eslint to v8.46.4 (#291) ([325f10b](https://github.com/midnight-ntwrk/artifacts/commit/325f10b)), closes [#291](https://github.com/midnight-ntwrk/artifacts/issues/291)
* chore(deps): update dependency typescript-eslint to v8.46.4 (#301) ([e6ae05e](https://github.com/midnight-ntwrk/artifacts/commit/e6ae05e)), closes [#301](https://github.com/midnight-ntwrk/artifacts/issues/301)
* chore(deps): update graphqlcodegenerator monorepo (#292) ([59458d6](https://github.com/midnight-ntwrk/artifacts/commit/59458d6)), closes [#292](https://github.com/midnight-ntwrk/artifacts/issues/292)
* chore(deps): update graphqlcodegenerator monorepo (major) (#246) ([cece16c](https://github.com/midnight-ntwrk/artifacts/commit/cece16c)), closes [#246](https://github.com/midnight-ntwrk/artifacts/issues/246)
* chore(deps): update graphqlcodegenerator monorepo to v5.1.3 (#298) ([643111f](https://github.com/midnight-ntwrk/artifacts/commit/643111f)), closes [#298](https://github.com/midnight-ntwrk/artifacts/issues/298)
* chore(deps): update vitest monorepo to v4 ([bf72e9a](https://github.com/midnight-ntwrk/artifacts/commit/bf72e9a))
* chore(deps): update vitest monorepo to v4.0.10 (#313) ([56d4304](https://github.com/midnight-ntwrk/artifacts/commit/56d4304)), closes [#313](https://github.com/midnight-ntwrk/artifacts/issues/313)
* chore(deps): update vitest monorepo to v4.0.9 (#303) ([6d3e9b9](https://github.com/midnight-ntwrk/artifacts/commit/6d3e9b9)), closes [#303](https://github.com/midnight-ntwrk/artifacts/issues/303)
* chore(release): bump version to 3.0.0-alpha.2 (#279) ([6ba77cc](https://github.com/midnight-ntwrk/artifacts/commit/6ba77cc)), closes [#279](https://github.com/midnight-ntwrk/artifacts/issues/279)
* chore(release): bump version to 3.0.0-alpha.4 (#335) ([fd89509](https://github.com/midnight-ntwrk/artifacts/commit/fd89509)), closes [#335](https://github.com/midnight-ntwrk/artifacts/issues/335)
* fix(deps): update dependency superjson to v2.2.5 (#276) ([18d26ec](https://github.com/midnight-ntwrk/artifacts/commit/18d26ec)), closes [#276](https://github.com/midnight-ntwrk/artifacts/issues/276)



## 3.0.0-alpha.4 (2025-11-21)

* chore: indexer-standalone:3.0.0-alpha.10 ([1f53a0a](https://github.com/midnight-ntwrk/artifacts/commit/1f53a0a))
* chore: indexer-standalone:3.0.0-alpha.11 ([b4f5347](https://github.com/midnight-ntwrk/artifacts/commit/b4f5347))
* chore: midnight-node:0.18.0-rc.6 ([11af678](https://github.com/midnight-ntwrk/artifacts/commit/11af678))
* chore: tweak testkit-js default configuration ([f2ef937](https://github.com/midnight-ntwrk/artifacts/commit/f2ef937))
* chore(deps): bump @babel/helpers (#323) ([accc449](https://github.com/midnight-ntwrk/artifacts/commit/accc449)), closes [#323](https://github.com/midnight-ntwrk/artifacts/issues/323)
* chore(deps): bump actions/checkout from 4 to 5 (#288) ([2f583a6](https://github.com/midnight-ntwrk/artifacts/commit/2f583a6)), closes [#288](https://github.com/midnight-ntwrk/artifacts/issues/288)
* chore(deps): bump actions/setup-node from 4 to 6 (#287) ([31416b6](https://github.com/midnight-ntwrk/artifacts/commit/31416b6)), closes [#287](https://github.com/midnight-ntwrk/artifacts/issues/287)
* chore(deps): bump actions/upload-artifact from 4.4.3 to 5.0.0 (#255) ([1946bdd](https://github.com/midnight-ntwrk/artifacts/commit/1946bdd)), closes [#255](https://github.com/midnight-ntwrk/artifacts/issues/255)
* chore(deps): bump ctrf-io/github-test-reporter from 1.0.25 to 1.0.26 (#269) ([ce3ee9a](https://github.com/midnight-ntwrk/artifacts/commit/ce3ee9a)), closes [#269](https://github.com/midnight-ntwrk/artifacts/issues/269)
* chore(deps): bump EnricoMi/publish-unit-test-result-action (#271) ([2fc8ab7](https://github.com/midnight-ntwrk/artifacts/commit/2fc8ab7)), closes [#271](https://github.com/midnight-ntwrk/artifacts/issues/271)
* chore(deps): bump js-yaml in the npm_and_yarn group across 1 directory (#307) ([002595a](https://github.com/midnight-ntwrk/artifacts/commit/002595a)), closes [#307](https://github.com/midnight-ntwrk/artifacts/issues/307)
* chore(deps): bump mikepenz/action-junit-report from 6.0.0 to 6.0.1 (#270) ([095db97](https://github.com/midnight-ntwrk/artifacts/commit/095db97)), closes [#270](https://github.com/midnight-ntwrk/artifacts/issues/270)
* chore(deps): update actions/github-script action to v8 (#260) ([05d59ee](https://github.com/midnight-ntwrk/artifacts/commit/05d59ee)), closes [#260](https://github.com/midnight-ntwrk/artifacts/issues/260)
* chore(deps): update dependency @effect/experimental to ^0.57.0 (#283) ([2a07c17](https://github.com/midnight-ntwrk/artifacts/commit/2a07c17)), closes [#283](https://github.com/midnight-ntwrk/artifacts/issues/283)
* chore(deps): update dependency @effect/experimental to v0.57.1 (#293) ([ac23fd6](https://github.com/midnight-ntwrk/artifacts/commit/ac23fd6)), closes [#293](https://github.com/midnight-ntwrk/artifacts/issues/293)
* chore(deps): update dependency @effect/experimental to v0.57.3 (#321) ([9cf1c39](https://github.com/midnight-ntwrk/artifacts/commit/9cf1c39)), closes [#321](https://github.com/midnight-ntwrk/artifacts/issues/321)
* chore(deps): update dependency @effect/experimental to v0.57.4 (#331) ([caf7cab](https://github.com/midnight-ntwrk/artifacts/commit/caf7cab)), closes [#331](https://github.com/midnight-ntwrk/artifacts/issues/331)
* chore(deps): update dependency @effect/platform-node-shared to ^0.53.0 (#285) ([5e39e51](https://github.com/midnight-ntwrk/artifacts/commit/5e39e51)), closes [#285](https://github.com/midnight-ntwrk/artifacts/issues/285)
* chore(deps): update dependency @effect/rpc to ^0.72.0 (#286) ([97f4499](https://github.com/midnight-ntwrk/artifacts/commit/97f4499)), closes [#286](https://github.com/midnight-ntwrk/artifacts/issues/286)
* chore(deps): update dependency @effect/rpc to v0.72.2 (#332) ([0955da1](https://github.com/midnight-ntwrk/artifacts/commit/0955da1)), closes [#332](https://github.com/midnight-ntwrk/artifacts/issues/332)
* chore(deps): update dependency @effect/sql to ^0.48.0 (#305) ([fcca1cf](https://github.com/midnight-ntwrk/artifacts/commit/fcca1cf)), closes [#305](https://github.com/midnight-ntwrk/artifacts/issues/305)
* chore(deps): update dependency @effect/vitest to ^0.27.0 (#306) ([d71fc79](https://github.com/midnight-ntwrk/artifacts/commit/d71fc79)), closes [#306](https://github.com/midnight-ntwrk/artifacts/issues/306)
* chore(deps): update dependency @effect/workflow to ^0.12.0 (#310) ([5890e15](https://github.com/midnight-ntwrk/artifacts/commit/5890e15)), closes [#310](https://github.com/midnight-ntwrk/artifacts/issues/310)
* chore(deps): update dependency @fast-check/vitest to v0.2.3 (#273) ([6c0bcd2](https://github.com/midnight-ntwrk/artifacts/commit/6c0bcd2)), closes [#273](https://github.com/midnight-ntwrk/artifacts/issues/273)
* chore(deps): update dependency @tsconfig/node22 to v22.0.3 (#294) ([a796bba](https://github.com/midnight-ntwrk/artifacts/commit/a796bba)), closes [#294](https://github.com/midnight-ntwrk/artifacts/issues/294)
* chore(deps): update dependency @tsconfig/node22 to v22.0.3 (#299) ([e9fb568](https://github.com/midnight-ntwrk/artifacts/commit/e9fb568)), closes [#299](https://github.com/midnight-ntwrk/artifacts/issues/299)
* chore(deps): update dependency @tsconfig/node24 to v24.0.3 (#324) ([0fb07fe](https://github.com/midnight-ntwrk/artifacts/commit/0fb07fe)), closes [#324](https://github.com/midnight-ntwrk/artifacts/issues/324)
* chore(deps): update dependency @types/express to v5.0.5 (#258) ([5163a92](https://github.com/midnight-ntwrk/artifacts/commit/5163a92)), closes [#258](https://github.com/midnight-ntwrk/artifacts/issues/258)
* chore(deps): update dependency @types/node to v24.10.1 (#289) ([6e85b88](https://github.com/midnight-ntwrk/artifacts/commit/6e85b88)), closes [#289](https://github.com/midnight-ntwrk/artifacts/issues/289)
* chore(deps): update dependency @types/node to v24.10.1 (#300) ([38a6171](https://github.com/midnight-ntwrk/artifacts/commit/38a6171)), closes [#300](https://github.com/midnight-ntwrk/artifacts/issues/300)
* chore(deps): update dependency allure-vitest to v3.4.2 (#274) ([cd15b40](https://github.com/midnight-ntwrk/artifacts/commit/cd15b40)), closes [#274](https://github.com/midnight-ntwrk/artifacts/issues/274)
* chore(deps): update dependency axios to v1.13.1 (#257) ([7cc7f95](https://github.com/midnight-ntwrk/artifacts/commit/7cc7f95)), closes [#257](https://github.com/midnight-ntwrk/artifacts/issues/257)
* chore(deps): update dependency axios to v1.13.2 (#278) ([47b4852](https://github.com/midnight-ntwrk/artifacts/commit/47b4852)), closes [#278](https://github.com/midnight-ntwrk/artifacts/issues/278)
* chore(deps): update dependency glob to v11.1.0 [security] (#322) ([c47d222](https://github.com/midnight-ntwrk/artifacts/commit/c47d222)), closes [#322](https://github.com/midnight-ntwrk/artifacts/issues/322)
* chore(deps): update dependency jsdom to v27.2.0 (#311) ([e078405](https://github.com/midnight-ntwrk/artifacts/commit/e078405)), closes [#311](https://github.com/midnight-ntwrk/artifacts/issues/311)
* chore(deps): update dependency lint-staged to v16.2.7 (#330) ([5ef8afb](https://github.com/midnight-ntwrk/artifacts/commit/5ef8afb)), closes [#330](https://github.com/midnight-ntwrk/artifacts/issues/330)
* chore(deps): update dependency node to v24 (#259) ([e7d1a0f](https://github.com/midnight-ntwrk/artifacts/commit/e7d1a0f)), closes [#259](https://github.com/midnight-ntwrk/artifacts/issues/259)
* chore(deps): update dependency node to v24.11.1 (#290) ([0cab0c1](https://github.com/midnight-ntwrk/artifacts/commit/0cab0c1)), closes [#290](https://github.com/midnight-ntwrk/artifacts/issues/290)
* chore(deps): update dependency pino to v10 (#245) ([773ee91](https://github.com/midnight-ntwrk/artifacts/commit/773ee91)), closes [#245](https://github.com/midnight-ntwrk/artifacts/issues/245)
* chore(deps): update dependency rollup to v4.53.3 (#327) ([fcba43c](https://github.com/midnight-ntwrk/artifacts/commit/fcba43c)), closes [#327](https://github.com/midnight-ntwrk/artifacts/issues/327)
* chore(deps): update dependency testcontainers to v11.8.1 (#328) ([ed6173b](https://github.com/midnight-ntwrk/artifacts/commit/ed6173b)), closes [#328](https://github.com/midnight-ntwrk/artifacts/issues/328)
* chore(deps): update dependency typescript-eslint to v8.46.3 (#275) ([b5feb2e](https://github.com/midnight-ntwrk/artifacts/commit/b5feb2e)), closes [#275](https://github.com/midnight-ntwrk/artifacts/issues/275)
* chore(deps): update dependency typescript-eslint to v8.46.4 (#291) ([325f10b](https://github.com/midnight-ntwrk/artifacts/commit/325f10b)), closes [#291](https://github.com/midnight-ntwrk/artifacts/issues/291)
* chore(deps): update dependency typescript-eslint to v8.46.4 (#301) ([e6ae05e](https://github.com/midnight-ntwrk/artifacts/commit/e6ae05e)), closes [#301](https://github.com/midnight-ntwrk/artifacts/issues/301)
* chore(deps): update graphqlcodegenerator monorepo (#292) ([59458d6](https://github.com/midnight-ntwrk/artifacts/commit/59458d6)), closes [#292](https://github.com/midnight-ntwrk/artifacts/issues/292)
* chore(deps): update graphqlcodegenerator monorepo (major) (#246) ([cece16c](https://github.com/midnight-ntwrk/artifacts/commit/cece16c)), closes [#246](https://github.com/midnight-ntwrk/artifacts/issues/246)
* chore(deps): update graphqlcodegenerator monorepo to v5.1.3 (#298) ([643111f](https://github.com/midnight-ntwrk/artifacts/commit/643111f)), closes [#298](https://github.com/midnight-ntwrk/artifacts/issues/298)
* chore(deps): update vitest monorepo to v4 ([bf72e9a](https://github.com/midnight-ntwrk/artifacts/commit/bf72e9a))
* chore(deps): update vitest monorepo to v4.0.10 (#313) ([56d4304](https://github.com/midnight-ntwrk/artifacts/commit/56d4304)), closes [#313](https://github.com/midnight-ntwrk/artifacts/issues/313)
* chore(deps): update vitest monorepo to v4.0.9 (#303) ([6d3e9b9](https://github.com/midnight-ntwrk/artifacts/commit/6d3e9b9)), closes [#303](https://github.com/midnight-ntwrk/artifacts/issues/303)
* chore(release): bump version to 3.0.0-alpha.2 (#279) ([6ba77cc](https://github.com/midnight-ntwrk/artifacts/commit/6ba77cc)), closes [#279](https://github.com/midnight-ntwrk/artifacts/issues/279)
* Midnight JS API documentation update - created by Midnight CI Github Action (#309) ([e1214db](https://github.com/midnight-ntwrk/artifacts/commit/e1214db)), closes [#309](https://github.com/midnight-ntwrk/artifacts/issues/309)
* Midnight JS API documentation update - created by Midnight CI Github Action (#319) ([5995325](https://github.com/midnight-ntwrk/artifacts/commit/5995325)), closes [#319](https://github.com/midnight-ntwrk/artifacts/issues/319)
* Midnight JS API documentation update - created by Midnight CI Github Action (#326) ([7eca2f4](https://github.com/midnight-ntwrk/artifacts/commit/7eca2f4)), closes [#326](https://github.com/midnight-ntwrk/artifacts/issues/326)
* Use 'createCircuitContext' constructor from runtime. Add support for parsing Uint8Array circuit resu ([5d4ff2c](https://github.com/midnight-ntwrk/artifacts/commit/5d4ff2c)), closes [#268](https://github.com/midnight-ntwrk/artifacts/issues/268)
* feat: automated indexer schema update ([bd287f7](https://github.com/midnight-ntwrk/artifacts/commit/bd287f7))
* feat: change assertions ([1e7db4e](https://github.com/midnight-ntwrk/artifacts/commit/1e7db4e))
* feat: delta should be undefined if balance is 0 ([0b0bf30](https://github.com/midnight-ntwrk/artifacts/commit/0b0bf30))
* feat: fix broken api docs generation ([e7bfafd](https://github.com/midnight-ntwrk/artifacts/commit/e7bfafd))
* feat: fix docs generation ([9c700c0](https://github.com/midnight-ntwrk/artifacts/commit/9c700c0))
* feat: fix esm and cjs packaging ([3d224d4](https://github.com/midnight-ntwrk/artifacts/commit/3d224d4))
* feat: fix workflows - replace istanbul with nyc ([e79010d](https://github.com/midnight-ntwrk/artifacts/commit/e79010d))
* feat: handle BalanceTransactionToProve (#320) ([ccb24ca](https://github.com/midnight-ntwrk/artifacts/commit/ccb24ca)), closes [#320](https://github.com/midnight-ntwrk/artifacts/issues/320)
* feat: lockfile ([3a2e77e](https://github.com/midnight-ntwrk/artifacts/commit/3a2e77e))
* feat: release 3.0.0-alpha.3 (#318) ([585edd2](https://github.com/midnight-ntwrk/artifacts/commit/585edd2)), closes [#318](https://github.com/midnight-ntwrk/artifacts/issues/318)
* feat: release script (#308) ([19d918c](https://github.com/midnight-ntwrk/artifacts/commit/19d918c)), closes [#308](https://github.com/midnight-ntwrk/artifacts/issues/308)
* feat: remove Allure server reporting from CI configuration ([3465190](https://github.com/midnight-ntwrk/artifacts/commit/3465190))
* feat: remove obsolete steps from the release script (#317) ([bbd5dd7](https://github.com/midnight-ntwrk/artifacts/commit/bbd5dd7)), closes [#317](https://github.com/midnight-ntwrk/artifacts/issues/317)
* feat: replace compactc ([0fb103e](https://github.com/midnight-ntwrk/artifacts/commit/0fb103e))
* feat: replace compactc ([90f579f](https://github.com/midnight-ntwrk/artifacts/commit/90f579f))
* feat: update cd workflow (#265) ([df3a423](https://github.com/midnight-ntwrk/artifacts/commit/df3a423)), closes [#265](https://github.com/midnight-ntwrk/artifacts/issues/265)
* feat: update components ([1f06ec0](https://github.com/midnight-ntwrk/artifacts/commit/1f06ec0))
* feat: update indexer TxId mapping ([9ed2fef](https://github.com/midnight-ntwrk/artifacts/commit/9ed2fef))
* feat: update mock ([afb9bdf](https://github.com/midnight-ntwrk/artifacts/commit/afb9bdf))
* feat: update node imports and tweak config ([034a4cb](https://github.com/midnight-ntwrk/artifacts/commit/034a4cb))
* feat: update submit tx ([7ceba12](https://github.com/midnight-ntwrk/artifacts/commit/7ceba12))
* feat: update tests ([6d46777](https://github.com/midnight-ntwrk/artifacts/commit/6d46777))
* feat: update the FinalizedTxData to store all transaction identifiers ([df58c30](https://github.com/midnight-ntwrk/artifacts/commit/df58c30))
* feat: update wallet (#297) ([3b2f5dc](https://github.com/midnight-ntwrk/artifacts/commit/3b2f5dc)), closes [#297](https://github.com/midnight-ntwrk/artifacts/issues/297)
* fix(deps): update dependency superjson to v2.2.5 (#276) ([18d26ec](https://github.com/midnight-ntwrk/artifacts/commit/18d26ec)), closes [#276](https://github.com/midnight-ntwrk/artifacts/issues/276)



## 3.0.0-alpha.3 (2025-11-17)

* chore(deps): bump actions/checkout from 4 to 5 (#288) ([2f583a6](https://github.com/midnight-ntwrk/artifacts/commit/2f583a6)), closes [#288](https://github.com/midnight-ntwrk/artifacts/issues/288)
* chore(deps): bump actions/setup-node from 4 to 6 (#287) ([31416b6](https://github.com/midnight-ntwrk/artifacts/commit/31416b6)), closes [#287](https://github.com/midnight-ntwrk/artifacts/issues/287)
* chore(deps): bump actions/upload-artifact from 4.4.3 to 5.0.0 (#255) ([1946bdd](https://github.com/midnight-ntwrk/artifacts/commit/1946bdd)), closes [#255](https://github.com/midnight-ntwrk/artifacts/issues/255)
* chore(deps): bump ctrf-io/github-test-reporter from 1.0.25 to 1.0.26 (#269) ([ce3ee9a](https://github.com/midnight-ntwrk/artifacts/commit/ce3ee9a)), closes [#269](https://github.com/midnight-ntwrk/artifacts/issues/269)
* chore(deps): bump EnricoMi/publish-unit-test-result-action (#271) ([2fc8ab7](https://github.com/midnight-ntwrk/artifacts/commit/2fc8ab7)), closes [#271](https://github.com/midnight-ntwrk/artifacts/issues/271)
* chore(deps): bump js-yaml in the npm_and_yarn group across 1 directory (#307) ([002595a](https://github.com/midnight-ntwrk/artifacts/commit/002595a)), closes [#307](https://github.com/midnight-ntwrk/artifacts/issues/307)
* chore(deps): bump mikepenz/action-junit-report from 6.0.0 to 6.0.1 (#270) ([095db97](https://github.com/midnight-ntwrk/artifacts/commit/095db97)), closes [#270](https://github.com/midnight-ntwrk/artifacts/issues/270)
* chore(deps): update actions/github-script action to v8 (#260) ([05d59ee](https://github.com/midnight-ntwrk/artifacts/commit/05d59ee)), closes [#260](https://github.com/midnight-ntwrk/artifacts/issues/260)
* chore(deps): update dependency @effect/experimental to ^0.57.0 (#283) ([2a07c17](https://github.com/midnight-ntwrk/artifacts/commit/2a07c17)), closes [#283](https://github.com/midnight-ntwrk/artifacts/issues/283)
* chore(deps): update dependency @effect/experimental to v0.57.1 (#293) ([ac23fd6](https://github.com/midnight-ntwrk/artifacts/commit/ac23fd6)), closes [#293](https://github.com/midnight-ntwrk/artifacts/issues/293)
* chore(deps): update dependency @effect/platform-node-shared to ^0.53.0 (#285) ([5e39e51](https://github.com/midnight-ntwrk/artifacts/commit/5e39e51)), closes [#285](https://github.com/midnight-ntwrk/artifacts/issues/285)
* chore(deps): update dependency @effect/rpc to ^0.72.0 (#286) ([97f4499](https://github.com/midnight-ntwrk/artifacts/commit/97f4499)), closes [#286](https://github.com/midnight-ntwrk/artifacts/issues/286)
* chore(deps): update dependency @effect/sql to ^0.48.0 (#305) ([fcca1cf](https://github.com/midnight-ntwrk/artifacts/commit/fcca1cf)), closes [#305](https://github.com/midnight-ntwrk/artifacts/issues/305)
* chore(deps): update dependency @effect/vitest to ^0.27.0 (#306) ([d71fc79](https://github.com/midnight-ntwrk/artifacts/commit/d71fc79)), closes [#306](https://github.com/midnight-ntwrk/artifacts/issues/306)
* chore(deps): update dependency @fast-check/vitest to v0.2.3 (#273) ([6c0bcd2](https://github.com/midnight-ntwrk/artifacts/commit/6c0bcd2)), closes [#273](https://github.com/midnight-ntwrk/artifacts/issues/273)
* chore(deps): update dependency @tsconfig/node22 to v22.0.3 (#294) ([a796bba](https://github.com/midnight-ntwrk/artifacts/commit/a796bba)), closes [#294](https://github.com/midnight-ntwrk/artifacts/issues/294)
* chore(deps): update dependency @tsconfig/node22 to v22.0.3 (#299) ([e9fb568](https://github.com/midnight-ntwrk/artifacts/commit/e9fb568)), closes [#299](https://github.com/midnight-ntwrk/artifacts/issues/299)
* chore(deps): update dependency @types/express to v5.0.5 (#258) ([5163a92](https://github.com/midnight-ntwrk/artifacts/commit/5163a92)), closes [#258](https://github.com/midnight-ntwrk/artifacts/issues/258)
* chore(deps): update dependency @types/node to v24.10.1 (#289) ([6e85b88](https://github.com/midnight-ntwrk/artifacts/commit/6e85b88)), closes [#289](https://github.com/midnight-ntwrk/artifacts/issues/289)
* chore(deps): update dependency @types/node to v24.10.1 (#300) ([38a6171](https://github.com/midnight-ntwrk/artifacts/commit/38a6171)), closes [#300](https://github.com/midnight-ntwrk/artifacts/issues/300)
* chore(deps): update dependency allure-vitest to v3.4.2 (#274) ([cd15b40](https://github.com/midnight-ntwrk/artifacts/commit/cd15b40)), closes [#274](https://github.com/midnight-ntwrk/artifacts/issues/274)
* chore(deps): update dependency axios to v1.13.1 (#257) ([7cc7f95](https://github.com/midnight-ntwrk/artifacts/commit/7cc7f95)), closes [#257](https://github.com/midnight-ntwrk/artifacts/issues/257)
* chore(deps): update dependency axios to v1.13.2 (#278) ([47b4852](https://github.com/midnight-ntwrk/artifacts/commit/47b4852)), closes [#278](https://github.com/midnight-ntwrk/artifacts/issues/278)
* chore(deps): update dependency node to v24 (#259) ([e7d1a0f](https://github.com/midnight-ntwrk/artifacts/commit/e7d1a0f)), closes [#259](https://github.com/midnight-ntwrk/artifacts/issues/259)
* chore(deps): update dependency node to v24.11.1 (#290) ([0cab0c1](https://github.com/midnight-ntwrk/artifacts/commit/0cab0c1)), closes [#290](https://github.com/midnight-ntwrk/artifacts/issues/290)
* chore(deps): update dependency pino to v10 (#245) ([773ee91](https://github.com/midnight-ntwrk/artifacts/commit/773ee91)), closes [#245](https://github.com/midnight-ntwrk/artifacts/issues/245)
* chore(deps): update dependency typescript-eslint to v8.46.3 (#275) ([b5feb2e](https://github.com/midnight-ntwrk/artifacts/commit/b5feb2e)), closes [#275](https://github.com/midnight-ntwrk/artifacts/issues/275)
* chore(deps): update dependency typescript-eslint to v8.46.4 (#291) ([325f10b](https://github.com/midnight-ntwrk/artifacts/commit/325f10b)), closes [#291](https://github.com/midnight-ntwrk/artifacts/issues/291)
* chore(deps): update dependency typescript-eslint to v8.46.4 (#301) ([e6ae05e](https://github.com/midnight-ntwrk/artifacts/commit/e6ae05e)), closes [#301](https://github.com/midnight-ntwrk/artifacts/issues/301)
* chore(deps): update graphqlcodegenerator monorepo (#292) ([59458d6](https://github.com/midnight-ntwrk/artifacts/commit/59458d6)), closes [#292](https://github.com/midnight-ntwrk/artifacts/issues/292)
* chore(deps): update graphqlcodegenerator monorepo (major) (#246) ([cece16c](https://github.com/midnight-ntwrk/artifacts/commit/cece16c)), closes [#246](https://github.com/midnight-ntwrk/artifacts/issues/246)
* chore(deps): update graphqlcodegenerator monorepo to v5.1.3 (#298) ([643111f](https://github.com/midnight-ntwrk/artifacts/commit/643111f)), closes [#298](https://github.com/midnight-ntwrk/artifacts/issues/298)
* chore(deps): update vitest monorepo to v4 ([bf72e9a](https://github.com/midnight-ntwrk/artifacts/commit/bf72e9a))
* chore(deps): update vitest monorepo to v4.0.9 (#303) ([6d3e9b9](https://github.com/midnight-ntwrk/artifacts/commit/6d3e9b9)), closes [#303](https://github.com/midnight-ntwrk/artifacts/issues/303)
* chore(release): bump version to 3.0.0-alpha.2 (#279) ([6ba77cc](https://github.com/midnight-ntwrk/artifacts/commit/6ba77cc)), closes [#279](https://github.com/midnight-ntwrk/artifacts/issues/279)
* Midnight JS API documentation update - created by Midnight CI Github Action (#309) ([e1214db](https://github.com/midnight-ntwrk/artifacts/commit/e1214db)), closes [#309](https://github.com/midnight-ntwrk/artifacts/issues/309)
* Use 'createCircuitContext' constructor from runtime. Add support for parsing Uint8Array circuit resu ([5d4ff2c](https://github.com/midnight-ntwrk/artifacts/commit/5d4ff2c)), closes [#268](https://github.com/midnight-ntwrk/artifacts/issues/268)
* feat: automated indexer schema update ([bd287f7](https://github.com/midnight-ntwrk/artifacts/commit/bd287f7))
* feat: change assertions ([1e7db4e](https://github.com/midnight-ntwrk/artifacts/commit/1e7db4e))
* feat: delta should be undefined if balance is 0 ([0b0bf30](https://github.com/midnight-ntwrk/artifacts/commit/0b0bf30))
* feat: fix broken api docs generation ([e7bfafd](https://github.com/midnight-ntwrk/artifacts/commit/e7bfafd))
* feat: fix docs generation ([9c700c0](https://github.com/midnight-ntwrk/artifacts/commit/9c700c0))
* feat: fix esm and cjs packaging ([3d224d4](https://github.com/midnight-ntwrk/artifacts/commit/3d224d4))
* feat: fix workflows - replace istanbul with nyc ([e79010d](https://github.com/midnight-ntwrk/artifacts/commit/e79010d))
* feat: lockfile ([3a2e77e](https://github.com/midnight-ntwrk/artifacts/commit/3a2e77e))
* feat: release script (#308) ([19d918c](https://github.com/midnight-ntwrk/artifacts/commit/19d918c)), closes [#308](https://github.com/midnight-ntwrk/artifacts/issues/308)
* feat: remove Allure server reporting from CI configuration ([3465190](https://github.com/midnight-ntwrk/artifacts/commit/3465190))
* feat: replace compactc ([0fb103e](https://github.com/midnight-ntwrk/artifacts/commit/0fb103e))
* feat: replace compactc ([90f579f](https://github.com/midnight-ntwrk/artifacts/commit/90f579f))
* feat: update cd workflow (#265) ([df3a423](https://github.com/midnight-ntwrk/artifacts/commit/df3a423)), closes [#265](https://github.com/midnight-ntwrk/artifacts/issues/265)
* feat: update components ([1f06ec0](https://github.com/midnight-ntwrk/artifacts/commit/1f06ec0))
* feat: update indexer TxId mapping ([9ed2fef](https://github.com/midnight-ntwrk/artifacts/commit/9ed2fef))
* feat: update mock ([afb9bdf](https://github.com/midnight-ntwrk/artifacts/commit/afb9bdf))
* feat: update node imports and tweak config ([034a4cb](https://github.com/midnight-ntwrk/artifacts/commit/034a4cb))
* feat: update submit tx ([7ceba12](https://github.com/midnight-ntwrk/artifacts/commit/7ceba12))
* feat: update tests ([6d46777](https://github.com/midnight-ntwrk/artifacts/commit/6d46777))
* feat: update the FinalizedTxData to store all transaction identifiers ([df58c30](https://github.com/midnight-ntwrk/artifacts/commit/df58c30))
* feat: update wallet (#297) ([3b2f5dc](https://github.com/midnight-ntwrk/artifacts/commit/3b2f5dc)), closes [#297](https://github.com/midnight-ntwrk/artifacts/issues/297)
* fix(deps): update dependency superjson to v2.2.5 (#276) ([18d26ec](https://github.com/midnight-ntwrk/artifacts/commit/18d26ec)), closes [#276](https://github.com/midnight-ntwrk/artifacts/issues/276)



## 3.0.0-alpha.2 (2025-11-05)

* chore(deps): bump actions/upload-artifact from 4.4.3 to 5.0.0 (#255) ([1946bdd](https://github.com/midnight-ntwrk/artifacts/commit/1946bdd)), closes [#255](https://github.com/midnight-ntwrk/artifacts/issues/255)
* chore(deps): bump ctrf-io/github-test-reporter from 1.0.25 to 1.0.26 (#269) ([ce3ee9a](https://github.com/midnight-ntwrk/artifacts/commit/ce3ee9a)), closes [#269](https://github.com/midnight-ntwrk/artifacts/issues/269)
* chore(deps): bump EnricoMi/publish-unit-test-result-action (#271) ([2fc8ab7](https://github.com/midnight-ntwrk/artifacts/commit/2fc8ab7)), closes [#271](https://github.com/midnight-ntwrk/artifacts/issues/271)
* chore(deps): bump mikepenz/action-junit-report from 6.0.0 to 6.0.1 (#270) ([095db97](https://github.com/midnight-ntwrk/artifacts/commit/095db97)), closes [#270](https://github.com/midnight-ntwrk/artifacts/issues/270)
* chore(deps): update actions/github-script action to v8 (#260) ([05d59ee](https://github.com/midnight-ntwrk/artifacts/commit/05d59ee)), closes [#260](https://github.com/midnight-ntwrk/artifacts/issues/260)
* chore(deps): update dependency @fast-check/vitest to v0.2.3 (#273) ([6c0bcd2](https://github.com/midnight-ntwrk/artifacts/commit/6c0bcd2)), closes [#273](https://github.com/midnight-ntwrk/artifacts/issues/273)
* chore(deps): update dependency @types/express to v5.0.5 (#258) ([5163a92](https://github.com/midnight-ntwrk/artifacts/commit/5163a92)), closes [#258](https://github.com/midnight-ntwrk/artifacts/issues/258)
* chore(deps): update dependency allure-vitest to v3.4.2 (#274) ([cd15b40](https://github.com/midnight-ntwrk/artifacts/commit/cd15b40)), closes [#274](https://github.com/midnight-ntwrk/artifacts/issues/274)
* chore(deps): update dependency axios to v1.13.1 (#257) ([7cc7f95](https://github.com/midnight-ntwrk/artifacts/commit/7cc7f95)), closes [#257](https://github.com/midnight-ntwrk/artifacts/issues/257)
* chore(deps): update dependency node to v24 (#259) ([e7d1a0f](https://github.com/midnight-ntwrk/artifacts/commit/e7d1a0f)), closes [#259](https://github.com/midnight-ntwrk/artifacts/issues/259)
* chore(deps): update dependency pino to v10 (#245) ([773ee91](https://github.com/midnight-ntwrk/artifacts/commit/773ee91)), closes [#245](https://github.com/midnight-ntwrk/artifacts/issues/245)
* chore(deps): update dependency typescript-eslint to v8.46.3 (#275) ([b5feb2e](https://github.com/midnight-ntwrk/artifacts/commit/b5feb2e)), closes [#275](https://github.com/midnight-ntwrk/artifacts/issues/275)
* fix(deps): update dependency superjson to v2.2.5 (#276) ([18d26ec](https://github.com/midnight-ntwrk/artifacts/commit/18d26ec)), closes [#276](https://github.com/midnight-ntwrk/artifacts/issues/276)
* feat: change assertions ([1e7db4e](https://github.com/midnight-ntwrk/artifacts/commit/1e7db4e))
* feat: fix esm and cjs packaging ([3d224d4](https://github.com/midnight-ntwrk/artifacts/commit/3d224d4))
* feat: update cd workflow (#265) ([df3a423](https://github.com/midnight-ntwrk/artifacts/commit/df3a423)), closes [#265](https://github.com/midnight-ntwrk/artifacts/issues/265)
* feat: update components ([1f06ec0](https://github.com/midnight-ntwrk/artifacts/commit/1f06ec0))
* feat: update indexer TxId mapping ([9ed2fef](https://github.com/midnight-ntwrk/artifacts/commit/9ed2fef))
* feat: update mock ([afb9bdf](https://github.com/midnight-ntwrk/artifacts/commit/afb9bdf))
* feat: update submit tx ([7ceba12](https://github.com/midnight-ntwrk/artifacts/commit/7ceba12))
* feat: update tests ([6d46777](https://github.com/midnight-ntwrk/artifacts/commit/6d46777))
* feat: update the FinalizedTxData to store all transaction identifiers ([df58c30](https://github.com/midnight-ntwrk/artifacts/commit/df58c30))
* Use 'createCircuitContext' constructor from runtime. Add support for parsing Uint8Array circuit resu ([5d4ff2c](https://github.com/midnight-ntwrk/artifacts/commit/5d4ff2c)), closes [#268](https://github.com/midnight-ntwrk/artifacts/issues/268)

## 3.0.0-alpha.1 (2025-10-29)

* chore: Bump major version number on Platform.js and Compact.js (#118) ([6a53094](https://github.com/midnight-ntwrk/artifacts/commit/6a53094)), closes [#118](https://github.com/midnight-ntwrk/artifacts/issues/118)
* chore: commit staged changes across repos ([4fa5b3b](https://github.com/midnight-ntwrk/artifacts/commit/4fa5b3b))
* chore: conventional commits (#154) ([f562ac1](https://github.com/midnight-ntwrk/artifacts/commit/f562ac1)), closes [#154](https://github.com/midnight-ntwrk/artifacts/issues/154)
* chore: enhance commitlint configuration for better validation (#184) ([a7659a2](https://github.com/midnight-ntwrk/artifacts/commit/a7659a2)), closes [#184](https://github.com/midnight-ntwrk/artifacts/issues/184)
* chore: Integrate Compact.js 2.3, Platform.js 2.1 (#214) ([fa7ca01](https://github.com/midnight-ntwrk/artifacts/commit/fa7ca01)), closes [#214](https://github.com/midnight-ntwrk/artifacts/issues/214)
* chore: multlple compactc versions support (#63) ([dd8071b](https://github.com/midnight-ntwrk/artifacts/commit/dd8071b)), closes [#63](https://github.com/midnight-ntwrk/artifacts/issues/63)
* chore: package validation (#156) ([bcf83fa](https://github.com/midnight-ntwrk/artifacts/commit/bcf83fa)), closes [#156](https://github.com/midnight-ntwrk/artifacts/issues/156)
* chore: refactor tests to exclude edge cases from pbt (#142) ([7edd198](https://github.com/midnight-ntwrk/artifacts/commit/7edd198)), closes [#142](https://github.com/midnight-ntwrk/artifacts/issues/142)
* chore: release v2.1.0 ([0ddc623](https://github.com/midnight-ntwrk/artifacts/commit/0ddc623))
* chore: update CHANGELOG for version 2.1.0 with new features, changes, and security updates ([46071cc](https://github.com/midnight-ntwrk/artifacts/commit/46071cc))
* chore: update commitlint configuration for subject and type rules (#168) ([a2f2956](https://github.com/midnight-ntwrk/artifacts/commit/a2f2956)), closes [#168](https://github.com/midnight-ntwrk/artifacts/issues/168)
* chore: update CompactC to 0.26.0 and compact-runtime to 0.9.0 (#170) ([a4b1564](https://github.com/midnight-ntwrk/artifacts/commit/a4b1564)), closes [#170](https://github.com/midnight-ntwrk/artifacts/issues/170)
* chore(compact-js): Add detail to the Compact.js `README.md` files (#159) ([2ce6e1e](https://github.com/midnight-ntwrk/artifacts/commit/2ce6e1e)), closes [#159](https://github.com/midnight-ntwrk/artifacts/issues/159)
* chore(compact-js): Ensure that unshielded inputs, outputs, and spends are included in the public tra ([7699071](https://github.com/midnight-ntwrk/artifacts/commit/7699071)), closes [#171](https://github.com/midnight-ntwrk/artifacts/issues/171)
* chore(compact-js): Refactor command and CLI option usage (#157) ([2df3189](https://github.com/midnight-ntwrk/artifacts/commit/2df3189)), closes [#157](https://github.com/midnight-ntwrk/artifacts/issues/157)
* chore(compact-js/platform-js): Fix up package version numbers (#150) ([32356c3](https://github.com/midnight-ntwrk/artifacts/commit/32356c3)), closes [#150](https://github.com/midnight-ntwrk/artifacts/issues/150)
* chore(deps): bump actions/download-artifact from 5.0.0 to 6.0.0 (#254) ([e94ef4e](https://github.com/midnight-ntwrk/artifacts/commit/e94ef4e)), closes [#254](https://github.com/midnight-ntwrk/artifacts/issues/254)
* chore(deps): bump actions/github-script from 7.1.0 to 8.0.0 (#174) ([a606204](https://github.com/midnight-ntwrk/artifacts/commit/a606204)), closes [#174](https://github.com/midnight-ntwrk/artifacts/issues/174)
* chore(deps): bump actions/setup-node from 4.1.0 to 5.0.0 (#120) ([e445cfc](https://github.com/midnight-ntwrk/artifacts/commit/e445cfc)), closes [#120](https://github.com/midnight-ntwrk/artifacts/issues/120)
* chore(deps): bump actions/setup-node from 5.0.0 to 6.0.0 (#218) ([cdb1ad5](https://github.com/midnight-ntwrk/artifacts/commit/cdb1ad5)), closes [#218](https://github.com/midnight-ntwrk/artifacts/issues/218)
* chore(deps): bump apache/skywalking-eyes (#138) ([1c61af3](https://github.com/midnight-ntwrk/artifacts/commit/1c61af3)), closes [#138](https://github.com/midnight-ntwrk/artifacts/issues/138)
* chore(deps): bump ctrf-io/github-test-reporter from 1.0.22 to 1.0.25 (#207) ([b7aee79](https://github.com/midnight-ntwrk/artifacts/commit/b7aee79)), closes [#207](https://github.com/midnight-ntwrk/artifacts/issues/207)
* chore(deps): bump docker/login-action from 3.3.0 to 3.5.0 (#121) ([4604977](https://github.com/midnight-ntwrk/artifacts/commit/4604977)), closes [#121](https://github.com/midnight-ntwrk/artifacts/issues/121)
* chore(deps): bump docker/login-action from 3.5.0 to 3.6.0 (#176) ([0b8182a](https://github.com/midnight-ntwrk/artifacts/commit/0b8182a)), closes [#176](https://github.com/midnight-ntwrk/artifacts/issues/176)
* chore(deps): bump mikepenz/action-junit-report from 5.6.2 to 6.0.0 (#208) ([ffcab76](https://github.com/midnight-ntwrk/artifacts/commit/ffcab76)), closes [#208](https://github.com/midnight-ntwrk/artifacts/issues/208)
* chore(deps): bump MishaKav/jest-coverage-comment from 1.0.28 to 1.0.29 (#175) ([262874d](https://github.com/midnight-ntwrk/artifacts/commit/262874d)), closes [#175](https://github.com/midnight-ntwrk/artifacts/issues/175)
* chore(deps): bump tar-fs from 2.1.3 to 2.1.4 in the npm_and_yarn group across 1 directory (#160) ([1dcde4c](https://github.com/midnight-ntwrk/artifacts/commit/1dcde4c)), closes [#160](https://github.com/midnight-ntwrk/artifacts/issues/160)
* chore(deps): bump vite in the npm_and_yarn group across 1 directory (#128) ([e86d9d4](https://github.com/midnight-ntwrk/artifacts/commit/e86d9d4)), closes [#128](https://github.com/midnight-ntwrk/artifacts/issues/128)
* chore(deps): remove outdated @opentelemetry/semantic-conventions entry from yarn.lock (#158) ([cbbfdf3](https://github.com/midnight-ntwrk/artifacts/commit/cbbfdf3)), closes [#158](https://github.com/midnight-ntwrk/artifacts/issues/158)
* chore(deps): update commitlint monorepo to v20 (#234) ([8b46863](https://github.com/midnight-ntwrk/artifacts/commit/8b46863)), closes [#234](https://github.com/midnight-ntwrk/artifacts/issues/234)
* chore(deps): update dependency @d2t/vitest-ctrf-json-reporter to v1.2.0 (#76) ([54d3e6e](https://github.com/midnight-ntwrk/artifacts/commit/54d3e6e)), closes [#76](https://github.com/midnight-ntwrk/artifacts/issues/76)
* chore(deps): update dependency @d2t/vitest-ctrf-json-reporter to v1.3.0 (#163) ([c4b0515](https://github.com/midnight-ntwrk/artifacts/commit/c4b0515)), closes [#163](https://github.com/midnight-ntwrk/artifacts/issues/163)
* chore(deps): update dependency @effect/cluster to ^0.49.0 (#164) ([6a5189c](https://github.com/midnight-ntwrk/artifacts/commit/6a5189c)), closes [#164](https://github.com/midnight-ntwrk/artifacts/issues/164)
* chore(deps): update dependency @effect/cluster to ^0.50.0 (#190) ([b7a151f](https://github.com/midnight-ntwrk/artifacts/commit/b7a151f)), closes [#190](https://github.com/midnight-ntwrk/artifacts/issues/190)
* chore(deps): update dependency @effect/cluster to v0.49.6 (#177) ([98ddc2a](https://github.com/midnight-ntwrk/artifacts/commit/98ddc2a)), closes [#177](https://github.com/midnight-ntwrk/artifacts/issues/177)
* chore(deps): update dependency @effect/cluster to v0.50.6 (#215) ([62be37a](https://github.com/midnight-ntwrk/artifacts/commit/62be37a)), closes [#215](https://github.com/midnight-ntwrk/artifacts/issues/215)
* chore(deps): update dependency @effect/experimental to ^0.55.0 (#165) ([c4cb7df](https://github.com/midnight-ntwrk/artifacts/commit/c4cb7df)), closes [#165](https://github.com/midnight-ntwrk/artifacts/issues/165)
* chore(deps): update dependency @effect/experimental to ^0.56.0 (#191) ([3b36604](https://github.com/midnight-ntwrk/artifacts/commit/3b36604)), closes [#191](https://github.com/midnight-ntwrk/artifacts/issues/191)
* chore(deps): update dependency @effect/experimental to v0.54.6 (#105) ([20fd087](https://github.com/midnight-ntwrk/artifacts/commit/20fd087)), closes [#105](https://github.com/midnight-ntwrk/artifacts/issues/105)
* chore(deps): update dependency @effect/platform-node to ^0.98.0 (#195) ([478428d](https://github.com/midnight-ntwrk/artifacts/commit/478428d)), closes [#195](https://github.com/midnight-ntwrk/artifacts/issues/195)
* chore(deps): update dependency @effect/platform-node to v0.98.4 (#216) ([b7c6427](https://github.com/midnight-ntwrk/artifacts/commit/b7c6427)), closes [#216](https://github.com/midnight-ntwrk/artifacts/issues/216)
* chore(deps): update dependency @effect/platform-node-shared to ^0.50.0 (#167) ([156cc67](https://github.com/midnight-ntwrk/artifacts/commit/156cc67)), closes [#167](https://github.com/midnight-ntwrk/artifacts/issues/167)
* chore(deps): update dependency @effect/platform-node-shared to v0.51.6 (#220) ([48e4845](https://github.com/midnight-ntwrk/artifacts/commit/48e4845)), closes [#220](https://github.com/midnight-ntwrk/artifacts/issues/220)
* chore(deps): update dependency @effect/rpc to ^0.71.0 (#197) ([ed15a22](https://github.com/midnight-ntwrk/artifacts/commit/ed15a22)), closes [#197](https://github.com/midnight-ntwrk/artifacts/issues/197)
* chore(deps): update dependency @effect/rpc to v0.71.1 (#221) ([a59e94d](https://github.com/midnight-ntwrk/artifacts/commit/a59e94d)), closes [#221](https://github.com/midnight-ntwrk/artifacts/issues/221)
* chore(deps): update dependency @effect/sql to ^0.46.0 (#201) ([19e4843](https://github.com/midnight-ntwrk/artifacts/commit/19e4843)), closes [#201](https://github.com/midnight-ntwrk/artifacts/issues/201)
* chore(deps): update dependency @effect/sql to v0.44.2 (#106) ([2b712a4](https://github.com/midnight-ntwrk/artifacts/commit/2b712a4)), closes [#106](https://github.com/midnight-ntwrk/artifacts/issues/106)
* chore(deps): update dependency @effect/vitest to ^0.26.0 (#203) ([1ad7534](https://github.com/midnight-ntwrk/artifacts/commit/1ad7534)), closes [#203](https://github.com/midnight-ntwrk/artifacts/issues/203)
* chore(deps): update dependency @effect/workflow to v0.11.5 (#222) ([77db47e](https://github.com/midnight-ntwrk/artifacts/commit/77db47e)), closes [#222](https://github.com/midnight-ntwrk/artifacts/issues/222)
* chore(deps): update dependency @rollup/plugin-commonjs to v28.0.8 (#223) ([d726ed0](https://github.com/midnight-ntwrk/artifacts/commit/d726ed0)), closes [#223](https://github.com/midnight-ntwrk/artifacts/issues/223)
* chore(deps): update dependency @rollup/plugin-commonjs to v28.0.9 (#250) ([9c4a0c3](https://github.com/midnight-ntwrk/artifacts/commit/9c4a0c3)), closes [#250](https://github.com/midnight-ntwrk/artifacts/issues/250)
* chore(deps): update dependency @rollup/plugin-node-resolve to v16.0.2 (#186) ([b2b1ea8](https://github.com/midnight-ntwrk/artifacts/commit/b2b1ea8)), closes [#186](https://github.com/midnight-ntwrk/artifacts/issues/186)
* chore(deps): update dependency @rollup/plugin-node-resolve to v16.0.3 (#210) ([6f169ce](https://github.com/midnight-ntwrk/artifacts/commit/6f169ce)), closes [#210](https://github.com/midnight-ntwrk/artifacts/issues/210)
* chore(deps): update dependency @rollup/plugin-typescript to v12.3.0 (#244) ([dc34be4](https://github.com/midnight-ntwrk/artifacts/commit/dc34be4)), closes [#244](https://github.com/midnight-ntwrk/artifacts/issues/244)
* chore(deps): update dependency @types/express to v5.0.4 (#249) ([ade95a9](https://github.com/midnight-ntwrk/artifacts/commit/ade95a9)), closes [#249](https://github.com/midnight-ntwrk/artifacts/issues/249)
* chore(deps): update dependency @types/node to v22.18.0 (#77) ([aa69d17](https://github.com/midnight-ntwrk/artifacts/commit/aa69d17)), closes [#77](https://github.com/midnight-ntwrk/artifacts/issues/77)
* chore(deps): update dependency @types/node to v22.18.12 (#202) ([7505c36](https://github.com/midnight-ntwrk/artifacts/commit/7505c36)), closes [#202](https://github.com/midnight-ntwrk/artifacts/issues/202)
* chore(deps): update dependency @types/node to v22.18.6 (#132) ([81a9625](https://github.com/midnight-ntwrk/artifacts/commit/81a9625)), closes [#132](https://github.com/midnight-ntwrk/artifacts/issues/132)
* chore(deps): update dependency @types/node to v22.18.8 (#178) ([a51d3ce](https://github.com/midnight-ntwrk/artifacts/commit/a51d3ce)), closes [#178](https://github.com/midnight-ntwrk/artifacts/issues/178)
* chore(deps): update dependency @types/node to v22.18.9 (#189) ([a727ec0](https://github.com/midnight-ntwrk/artifacts/commit/a727ec0)), closes [#189](https://github.com/midnight-ntwrk/artifacts/issues/189)
* chore(deps): update dependency allure-vitest to v3.4.1 (#204) ([e46603c](https://github.com/midnight-ntwrk/artifacts/commit/e46603c)), closes [#204](https://github.com/midnight-ntwrk/artifacts/issues/204)
* chore(deps): update dependency axios to v1.12.0 [security] (#134) ([72be53f](https://github.com/midnight-ntwrk/artifacts/commit/72be53f)), closes [#134](https://github.com/midnight-ntwrk/artifacts/issues/134)
* chore(deps): update dependency eslint-plugin-unused-imports to v4.3.0 (#226) ([0f2ee49](https://github.com/midnight-ntwrk/artifacts/commit/0f2ee49)), closes [#226](https://github.com/midnight-ntwrk/artifacts/issues/226)
* chore(deps): update dependency jsdom to v27 (#235) ([7560020](https://github.com/midnight-ntwrk/artifacts/commit/7560020)), closes [#235](https://github.com/midnight-ntwrk/artifacts/issues/235)
* chore(deps): update dependency lint-staged to v16.1.6 (#71) ([220f3eb](https://github.com/midnight-ntwrk/artifacts/commit/220f3eb)), closes [#71](https://github.com/midnight-ntwrk/artifacts/issues/71)
* chore(deps): update dependency lint-staged to v16.2.4 (#205) ([9c087e1](https://github.com/midnight-ntwrk/artifacts/commit/9c087e1)), closes [#205](https://github.com/midnight-ntwrk/artifacts/issues/205)
* chore(deps): update dependency lint-staged to v16.2.5 (#224) ([4e2c00c](https://github.com/midnight-ntwrk/artifacts/commit/4e2c00c)), closes [#224](https://github.com/midnight-ntwrk/artifacts/issues/224)
* chore(deps): update dependency lint-staged to v16.2.6 (#236) ([ee57827](https://github.com/midnight-ntwrk/artifacts/commit/ee57827)), closes [#236](https://github.com/midnight-ntwrk/artifacts/issues/236)
* chore(deps): update dependency node to v22.19.0 (#78) ([914529c](https://github.com/midnight-ntwrk/artifacts/commit/914529c)), closes [#78](https://github.com/midnight-ntwrk/artifacts/issues/78)
* chore(deps): update dependency node to v22.21.0 (#211) ([3d87606](https://github.com/midnight-ntwrk/artifacts/commit/3d87606)), closes [#211](https://github.com/midnight-ntwrk/artifacts/issues/211)
* chore(deps): update dependency patch-package to v8.0.1 (#179) ([eea3885](https://github.com/midnight-ntwrk/artifacts/commit/eea3885)), closes [#179](https://github.com/midnight-ntwrk/artifacts/issues/179)
* chore(deps): update dependency pino to v9.14.0 (#212) ([43ca947](https://github.com/midnight-ntwrk/artifacts/commit/43ca947)), closes [#212](https://github.com/midnight-ntwrk/artifacts/issues/212)
* chore(deps): update dependency pino to v9.9.1 (#83) ([bb84a97](https://github.com/midnight-ntwrk/artifacts/commit/bb84a97)), closes [#83](https://github.com/midnight-ntwrk/artifacts/issues/83)
* chore(deps): update dependency pino-pretty to v13.1.1 (#84) ([357fdb6](https://github.com/midnight-ntwrk/artifacts/commit/357fdb6)), closes [#84](https://github.com/midnight-ntwrk/artifacts/issues/84)
* chore(deps): update dependency pino-pretty to v13.1.2 (#194) ([365f1f3](https://github.com/midnight-ntwrk/artifacts/commit/365f1f3)), closes [#194](https://github.com/midnight-ntwrk/artifacts/issues/194)
* chore(deps): update dependency rollup to v4.50.0 (#85) ([d885af8](https://github.com/midnight-ntwrk/artifacts/commit/d885af8)), closes [#85](https://github.com/midnight-ntwrk/artifacts/issues/85)
* chore(deps): update dependency rollup to v4.50.2 (#147) ([9a9cf98](https://github.com/midnight-ntwrk/artifacts/commit/9a9cf98)), closes [#147](https://github.com/midnight-ntwrk/artifacts/issues/147)
* chore(deps): update dependency rollup to v4.52.5 (#213) ([dfed54a](https://github.com/midnight-ntwrk/artifacts/commit/dfed54a)), closes [#213](https://github.com/midnight-ntwrk/artifacts/issues/213)
* chore(deps): update dependency testcontainers to v11.5.1 (#86) ([3c50c19](https://github.com/midnight-ntwrk/artifacts/commit/3c50c19)), closes [#86](https://github.com/midnight-ntwrk/artifacts/issues/86)
* chore(deps): update dependency testcontainers to v11.7.1 (#227) ([d7bb098](https://github.com/midnight-ntwrk/artifacts/commit/d7bb098)), closes [#227](https://github.com/midnight-ntwrk/artifacts/issues/227)
* chore(deps): update dependency testcontainers to v11.7.2 (#228) ([6fbbf82](https://github.com/midnight-ntwrk/artifacts/commit/6fbbf82)), closes [#228](https://github.com/midnight-ntwrk/artifacts/issues/228)
* chore(deps): update dependency turbo to v2.5.6 (#72) ([71f0072](https://github.com/midnight-ntwrk/artifacts/commit/71f0072)), closes [#72](https://github.com/midnight-ntwrk/artifacts/issues/72)
* chore(deps): update dependency turbo to v2.5.8 (#161) ([d5e854c](https://github.com/midnight-ntwrk/artifacts/commit/d5e854c)), closes [#161](https://github.com/midnight-ntwrk/artifacts/issues/161)
* chore(deps): update dependency typedoc to v0.28.12 (#73) ([2b31332](https://github.com/midnight-ntwrk/artifacts/commit/2b31332)), closes [#73](https://github.com/midnight-ntwrk/artifacts/issues/73)
* chore(deps): update dependency typedoc to v0.28.13 (#152) ([f1a7bf3](https://github.com/midnight-ntwrk/artifacts/commit/f1a7bf3)), closes [#152](https://github.com/midnight-ntwrk/artifacts/issues/152)
* chore(deps): update dependency typedoc to v0.28.14 (#200) ([a886000](https://github.com/midnight-ntwrk/artifacts/commit/a886000)), closes [#200](https://github.com/midnight-ntwrk/artifacts/issues/200)
* chore(deps): update dependency typedoc-plugin-markdown to v4.8.1 (#89) ([f79bebc](https://github.com/midnight-ntwrk/artifacts/commit/f79bebc)), closes [#89](https://github.com/midnight-ntwrk/artifacts/issues/89)
* chore(deps): update dependency typedoc-plugin-markdown to v4.9.0 (#230) ([6b07140](https://github.com/midnight-ntwrk/artifacts/commit/6b07140)), closes [#230](https://github.com/midnight-ntwrk/artifacts/issues/230)
* chore(deps): update dependency typescript to v5.9.2 (#90) ([5b5dc3d](https://github.com/midnight-ntwrk/artifacts/commit/5b5dc3d)), closes [#90](https://github.com/midnight-ntwrk/artifacts/issues/90)
* chore(deps): update dependency typescript to v5.9.3 (#183) ([b96170d](https://github.com/midnight-ntwrk/artifacts/commit/b96170d)), closes [#183](https://github.com/midnight-ntwrk/artifacts/issues/183)
* chore(deps): update dependency typescript-eslint to v8.42.0 (#91) ([ec535c8](https://github.com/midnight-ntwrk/artifacts/commit/ec535c8)), closes [#91](https://github.com/midnight-ntwrk/artifacts/issues/91)
* chore(deps): update dependency typescript-eslint to v8.46.2 (#231) ([2b974d8](https://github.com/midnight-ntwrk/artifacts/commit/2b974d8)), closes [#231](https://github.com/midnight-ntwrk/artifacts/issues/231)
* chore(deps): update eslint monorepo to v9.34.0 (#92) ([7ad8965](https://github.com/midnight-ntwrk/artifacts/commit/7ad8965)), closes [#92](https://github.com/midnight-ntwrk/artifacts/issues/92)
* chore(deps): update eslint monorepo to v9.38.0 (#232) ([f585086](https://github.com/midnight-ntwrk/artifacts/commit/f585086)), closes [#232](https://github.com/midnight-ntwrk/artifacts/issues/232)
* chore(deps): update yarn to v4.10.0 (#107) ([5a907a6](https://github.com/midnight-ntwrk/artifacts/commit/5a907a6)), closes [#107](https://github.com/midnight-ntwrk/artifacts/issues/107)
* chore(deps): update yarn to v4.10.3 (#162) ([034a4b9](https://github.com/midnight-ntwrk/artifacts/commit/034a4b9)), closes [#162](https://github.com/midnight-ntwrk/artifacts/issues/162)
* chore(deps): update yarn to v4.9.4 (#74) ([e978c67](https://github.com/midnight-ntwrk/artifacts/commit/e978c67)), closes [#74](https://github.com/midnight-ntwrk/artifacts/issues/74)
* chore(release): bump midnight-js and testkit-js packages to 3.0.0-alpha.1 ([d0380ef](https://github.com/midnight-ntwrk/artifacts/commit/d0380ef))
* chore(testkit-js): change way e2e tests are executed (#148) ([918dab0](https://github.com/midnight-ntwrk/artifacts/commit/918dab0)), closes [#148](https://github.com/midnight-ntwrk/artifacts/issues/148)
* feat: "Undeployed" typo ([b816a8e](https://github.com/midnight-ntwrk/artifacts/commit/b816a8e))
* feat: add docs for testkit-js ([2ab6dd4](https://github.com/midnight-ntwrk/artifacts/commit/2ab6dd4))
* feat: add unshielded address parsing ([5144503](https://github.com/midnight-ntwrk/artifacts/commit/5144503))
* feat: daily scans of main ([d04c1b3](https://github.com/midnight-ntwrk/artifacts/commit/d04c1b3))
* feat: fix and update checkmarx ([f87f615](https://github.com/midnight-ntwrk/artifacts/commit/f87f615))
* feat: fix docs api flow ([e1f5b10](https://github.com/midnight-ntwrk/artifacts/commit/e1f5b10))
* feat: fix prerelease workflow (#242) ([7934d2a](https://github.com/midnight-ntwrk/artifacts/commit/7934d2a)), closes [#242](https://github.com/midnight-ntwrk/artifacts/issues/242)
* feat: indexer chainState replaced with zswapState ([40f2253](https://github.com/midnight-ntwrk/artifacts/commit/40f2253))
* feat: less code now action is public ([25e975a](https://github.com/midnight-ntwrk/artifacts/commit/25e975a))
* feat: lockfile ([9d05a65](https://github.com/midnight-ntwrk/artifacts/commit/9d05a65))
* feat: Platform.js and Compact.js (#80) ([3a02d96](https://github.com/midnight-ntwrk/artifacts/commit/3a02d96)), closes [#80](https://github.com/midnight-ntwrk/artifacts/issues/80)
* feat: point to fork friendly action. Caution: uses pull_request_target. ([77e361d](https://github.com/midnight-ntwrk/artifacts/commit/77e361d))
* feat: resolve esm compatibility issue (#241) ([3acb59b](https://github.com/midnight-ntwrk/artifacts/commit/3acb59b)), closes [#241](https://github.com/midnight-ntwrk/artifacts/issues/241)
* feat: schedule checkmarx daily (at midnight of couese) and allow manual kick off of workflow ([7bed270](https://github.com/midnight-ntwrk/artifacts/commit/7bed270))
* feat: turn on dependabot ([9d37dc3](https://github.com/midnight-ntwrk/artifacts/commit/9d37dc3))
* feat: update indexer and node docker images ([d03f1e5](https://github.com/midnight-ntwrk/artifacts/commit/d03f1e5))
* feat: update node to 0.17.1-8d7c529d ([d95754b](https://github.com/midnight-ntwrk/artifacts/commit/d95754b))
* feat: update node to 0.18.0-rc.1 ([b6b734e](https://github.com/midnight-ntwrk/artifacts/commit/b6b734e))
* feat: update test and roll back one workaround ([47178a6](https://github.com/midnight-ntwrk/artifacts/commit/47178a6))
* feat: update tests ([a833408](https://github.com/midnight-ntwrk/artifacts/commit/a833408))
* feat: update tests ([a81a040](https://github.com/midnight-ntwrk/artifacts/commit/a81a040))
* feat: update unshielded tests ([86d5d20](https://github.com/midnight-ntwrk/artifacts/commit/86d5d20))
* feat: update wallet and remove workarounds ([c73eb95](https://github.com/midnight-ntwrk/artifacts/commit/c73eb95))
* feat: update wf ([6aec674](https://github.com/midnight-ntwrk/artifacts/commit/6aec674))
* feat: upgrade checkout action to latest version and pin to hash ([a4d2878](https://github.com/midnight-ntwrk/artifacts/commit/a4d2878))
* feat: upgrade checkout action to latest version and pin to hash ([71c3777](https://github.com/midnight-ntwrk/artifacts/commit/71c3777))
* feat: use latest checkmarx action ([a960114](https://github.com/midnight-ntwrk/artifacts/commit/a960114))
* feat(compact-js): Add contract maintenance operations to `ContractExecutable` (#182) ([4c06f48](https://github.com/midnight-ntwrk/artifacts/commit/4c06f48)), closes [#182](https://github.com/midnight-ntwrk/artifacts/issues/182)
* feat(compact-js): change import of json5 (#243) ([8d87ccd](https://github.com/midnight-ntwrk/artifacts/commit/8d87ccd)), closes [#243](https://github.com/midnight-ntwrk/artifacts/issues/243)
* feat(midnight-js): Migration to ledger 6 and add Unshielded Tokens (#125) ([aec8321](https://github.com/midnight-ntwrk/artifacts/commit/aec8321)), closes [#125](https://github.com/midnight-ntwrk/artifacts/issues/125) [#126](https://github.com/midnight-ntwrk/artifacts/issues/126) [#127](https://github.com/midnight-ntwrk/artifacts/issues/127) [#129](https://github.com/midnight-ntwrk/artifacts/issues/129) [#130](https://github.com/midnight-ntwrk/artifacts/issues/130)
* fix: add SARIF message validation for codeql-action compatibility ([5db5a41](https://github.com/midnight-ntwrk/artifacts/commit/5db5a41))
* fix: point to updated action: include upload of results. ([9affa42](https://github.com/midnight-ntwrk/artifacts/commit/9affa42))
* fix(deps): update dependency @apollo/client to v3.14.0 (#93) ([257650f](https://github.com/midnight-ntwrk/artifacts/commit/257650f)), closes [#93](https://github.com/midnight-ntwrk/artifacts/issues/93)
* fix(deps): update dependency @dao-xyz/borsh to v5.2.4 (#82) ([3a114f8](https://github.com/midnight-ntwrk/artifacts/commit/3a114f8)), closes [#82](https://github.com/midnight-ntwrk/artifacts/issues/82)
* fix(deps): update dependency @effect/cli to v0.69.2 (#108) ([45a4812](https://github.com/midnight-ntwrk/artifacts/commit/45a4812)), closes [#108](https://github.com/midnight-ntwrk/artifacts/issues/108)
* fix(deps): update dependency @effect/platform to v0.90.10 (#109) ([fcd9156](https://github.com/midnight-ntwrk/artifacts/commit/fcd9156)), closes [#109](https://github.com/midnight-ntwrk/artifacts/issues/109)
* fix(deps): update dependency @midnight-ntwrk/ledger to v6.1.0-alpha.3 ([c8b51a0](https://github.com/midnight-ntwrk/artifacts/commit/c8b51a0))
* fix(deps): update dependency @midnight-ntwrk/ledger to v6.1.0-alpha.4 (#225) ([de32378](https://github.com/midnight-ntwrk/artifacts/commit/de32378)), closes [#225](https://github.com/midnight-ntwrk/artifacts/issues/225)
* fix(deps): update dependency @scure/base to v1.2.6 (#240) ([63664b8](https://github.com/midnight-ntwrk/artifacts/commit/63664b8)), closes [#240](https://github.com/midnight-ntwrk/artifacts/issues/240)
* fix(deps): update dependency @scure/base to v2 (#248) ([a92d34b](https://github.com/midnight-ntwrk/artifacts/commit/a92d34b)), closes [#248](https://github.com/midnight-ntwrk/artifacts/issues/248)
* fix(deps): update dependency abstract-level to v3.1.1 (#181) ([bfbbb8a](https://github.com/midnight-ntwrk/artifacts/commit/bfbbb8a)), closes [#181](https://github.com/midnight-ntwrk/artifacts/issues/181)
* fix(deps): update dependency effect to v3.17.14 (#111) ([4b1bff2](https://github.com/midnight-ntwrk/artifacts/commit/4b1bff2)), closes [#111](https://github.com/midnight-ntwrk/artifacts/issues/111)
* fix(deps): update dependency fp-ts to v2.16.11 (#75) ([5567fd1](https://github.com/midnight-ntwrk/artifacts/commit/5567fd1)), closes [#75](https://github.com/midnight-ntwrk/artifacts/issues/75)
* fix(deps): update dependency superjson to v2.2.3 (#229) ([9584f7c](https://github.com/midnight-ntwrk/artifacts/commit/9584f7c)), closes [#229](https://github.com/midnight-ntwrk/artifacts/issues/229)
* fix(testkit): update healthcheck parameters for improved reliability (#169) ([713f5e8](https://github.com/midnight-ntwrk/artifacts/commit/713f5e8)), closes [#169](https://github.com/midnight-ntwrk/artifacts/issues/169)
* - uncomment tests to not have them omitted in future (#151) ([745435a](https://github.com/midnight-ntwrk/artifacts/commit/745435a)), closes [#151](https://github.com/midnight-ntwrk/artifacts/issues/151)
* (chore): Change `CD` workflows to publish only when changed (#112) ([6796358](https://github.com/midnight-ntwrk/artifacts/commit/6796358)), closes [#112](https://github.com/midnight-ntwrk/artifacts/issues/112)
* Add `CompiledContractReflection` service. Reflects over contract and circuit method declarations ([52372fa](https://github.com/midnight-ntwrk/artifacts/commit/52372fa))
* Add `NetworkIdMoniker`, a branded regex validated string ([d27a540](https://github.com/midnight-ntwrk/artifacts/commit/d27a540))
* Add dotenv configuration and set up Node.js environment ([8aab2a1](https://github.com/midnight-ntwrk/artifacts/commit/8aab2a1))
* Add happy path unit tests ([bbe1c49](https://github.com/midnight-ntwrk/artifacts/commit/bbe1c49))
* Add import sorting to eslint ([4163acd](https://github.com/midnight-ntwrk/artifacts/commit/4163acd))
* Add import sorting to eslint ([28d5b2b](https://github.com/midnight-ntwrk/artifacts/commit/28d5b2b))
* Add new `--output-result` option to the `circuit` command ([448f926](https://github.com/midnight-ntwrk/artifacts/commit/448f926))
* Add README for e2e tests ([3260704](https://github.com/midnight-ntwrk/artifacts/commit/3260704))
* Add support for block time access ([c72f0f4](https://github.com/midnight-ntwrk/artifacts/commit/c72f0f4))
* Add support for nested tuple types ([2963cd6](https://github.com/midnight-ntwrk/artifacts/commit/2963cd6))
* Add support for number/enum values ([a9e21cc](https://github.com/midnight-ntwrk/artifacts/commit/a9e21cc))
* Add support for object literals and Uint8Array ([bfb23ef](https://github.com/midnight-ntwrk/artifacts/commit/bfb23ef))
* Add TODOs and 1 test ([dc26eab](https://github.com/midnight-ntwrk/artifacts/commit/dc26eab))
* Add token ([ea30259](https://github.com/midnight-ntwrk/artifacts/commit/ea30259))
* Add unit tests for contracts package ([026d0df](https://github.com/midnight-ntwrk/artifacts/commit/026d0df))
* add unit tests to contracts package (#149) ([5b0d13f](https://github.com/midnight-ntwrk/artifacts/commit/5b0d13f)), closes [#149](https://github.com/midnight-ntwrk/artifacts/issues/149)
* added permisisons; ([bf8a32c](https://github.com/midnight-ntwrk/artifacts/commit/bf8a32c))
* Address review comments ([fa52946](https://github.com/midnight-ntwrk/artifacts/commit/fa52946))
* Allow support for Zswap local state (#144) ([cdf5825](https://github.com/midnight-ntwrk/artifacts/commit/cdf5825)), closes [#144](https://github.com/midnight-ntwrk/artifacts/issues/144)
* Block time hot fix (#139) ([978a9c2](https://github.com/midnight-ntwrk/artifacts/commit/978a9c2)), closes [#139](https://github.com/midnight-ntwrk/artifacts/issues/139)
* Bump actions/download-artifact from 4.1.8 to 5.0.0 ([15a8405](https://github.com/midnight-ntwrk/artifacts/commit/15a8405))
* Bump actions/setup-node from 4.1.0 to 4.4.0 ([a3e68ea](https://github.com/midnight-ntwrk/artifacts/commit/a3e68ea))
* Bump checkmarx/ast-github-action from 2.3.19 to 2.3.20 ([ebefc48](https://github.com/midnight-ntwrk/artifacts/commit/ebefc48))
* Bump checkmarx/ast-github-action from 2.3.21 to 2.3.24 ([024062f](https://github.com/midnight-ntwrk/artifacts/commit/024062f))
* Bump checkmarx/ast-github-action from 2.3.24 to 2.3.26 ([8e81f03](https://github.com/midnight-ntwrk/artifacts/commit/8e81f03))
* Bump ctrf-io/github-test-reporter from 1.0.21 to 1.0.22 (#64) ([02a909e](https://github.com/midnight-ntwrk/artifacts/commit/02a909e)), closes [#64](https://github.com/midnight-ntwrk/artifacts/issues/64)
* Bump docker/login-action from 3.3.0 to 3.5.0 ([4123943](https://github.com/midnight-ntwrk/artifacts/commit/4123943))
* Bump EnricoMi/publish-unit-test-result-action from 2.18.0 to 2.20.0 ([90c792b](https://github.com/midnight-ntwrk/artifacts/commit/90c792b))
* Bump github/codeql-action ([794b318](https://github.com/midnight-ntwrk/artifacts/commit/794b318))
* Bump github/codeql-action ([92e25bd](https://github.com/midnight-ntwrk/artifacts/commit/92e25bd))
* Bump mikepenz/action-junit-report from 5.1.0 to 5.6.2 ([6c65944](https://github.com/midnight-ntwrk/artifacts/commit/6c65944))
* Bump MishaKav/jest-coverage-comment from 1.0.27 to 1.0.28 ([db9f954](https://github.com/midnight-ntwrk/artifacts/commit/db9f954))
* Bump peter-evans/create-pull-request from 5.0.3 to 7.0.8 (#65) ([c98eb45](https://github.com/midnight-ntwrk/artifacts/commit/c98eb45)), closes [#65](https://github.com/midnight-ntwrk/artifacts/issues/65)
* Bump the npm_and_yarn group with 6 updates ([b47e888](https://github.com/midnight-ntwrk/artifacts/commit/b47e888))
* Change pre-commit to pre-push in husky ([a40d680](https://github.com/midnight-ntwrk/artifacts/commit/a40d680))
* Change the docker compose port configuration ([d383f60](https://github.com/midnight-ntwrk/artifacts/commit/d383f60))
* Cleanup of contracts types ([07cf742](https://github.com/midnight-ntwrk/artifacts/commit/07cf742))
* Drop the indentation used on writing the result file ([5b3266f](https://github.com/midnight-ntwrk/artifacts/commit/5b3266f))
* Ensure Schema based options/args report their names with errors ([5dce10d](https://github.com/midnight-ntwrk/artifacts/commit/5dce10d))
* exclude graphql generated files ([ebfbb30](https://github.com/midnight-ntwrk/artifacts/commit/ebfbb30))
* Execute linter against code base ([fbc8046](https://github.com/midnight-ntwrk/artifacts/commit/fbc8046))
* Fix broken reference ([e0b34de](https://github.com/midnight-ntwrk/artifacts/commit/e0b34de))
* Fix broken references ([df874e1](https://github.com/midnight-ntwrk/artifacts/commit/df874e1))
* Fix broken references ([24249d7](https://github.com/midnight-ntwrk/artifacts/commit/24249d7))
* Fix broken unit tests (binary state file and ContractAddress) ([df7de94](https://github.com/midnight-ntwrk/artifacts/commit/df7de94))
* Fix bug in `reportCausableError` to report correct `message` property on errors ([48f730a](https://github.com/midnight-ntwrk/artifacts/commit/48f730a))
* fix job triggers (#145) ([0e7013b](https://github.com/midnight-ntwrk/artifacts/commit/0e7013b)), closes [#145](https://github.com/midnight-ntwrk/artifacts/issues/145)
* Fix lint issues ([3b64c1d](https://github.com/midnight-ntwrk/artifacts/commit/3b64c1d))
* Initial commit ([e4f78f8](https://github.com/midnight-ntwrk/artifacts/commit/e4f78f8))
* Initial commit ([3ba407d](https://github.com/midnight-ntwrk/artifacts/commit/3ba407d))
* Midnight JS API documentation update - created by Midnight CI Github Action (#103) ([16c131e](https://github.com/midnight-ntwrk/artifacts/commit/16c131e)), closes [#103](https://github.com/midnight-ntwrk/artifacts/issues/103)
* Midnight JS API documentation update - created by Midnight CI Github Action (#104) ([07294c1](https://github.com/midnight-ntwrk/artifacts/commit/07294c1)), closes [#104](https://github.com/midnight-ntwrk/artifacts/issues/104)
* Midnight JS API documentation update - created by Midnight CI Github Action (#146) ([a7f1c9c](https://github.com/midnight-ntwrk/artifacts/commit/a7f1c9c)), closes [#146](https://github.com/midnight-ntwrk/artifacts/issues/146)
* Midnight JS API documentation update - created by Midnight CI Github Action (#238) ([79a933f](https://github.com/midnight-ntwrk/artifacts/commit/79a933f)), closes [#238](https://github.com/midnight-ntwrk/artifacts/issues/238)
* Midnight JS API documentation update - created by Midnight CI Github Action (#60) ([9856023](https://github.com/midnight-ntwrk/artifacts/commit/9856023)), closes [#60](https://github.com/midnight-ntwrk/artifacts/issues/60)
* Midnight JS API documentation update - created by Midnight CI Github Action (#98) ([7a3abad](https://github.com/midnight-ntwrk/artifacts/commit/7a3abad)), closes [#98](https://github.com/midnight-ntwrk/artifacts/issues/98)
* Optimize imports ([1c3577b](https://github.com/midnight-ntwrk/artifacts/commit/1c3577b))
* Optimize imports, deduplicate code ([eb31ce3](https://github.com/midnight-ntwrk/artifacts/commit/eb31ce3))
* Optimize imports, use types ([d2f2ae4](https://github.com/midnight-ntwrk/artifacts/commit/d2f2ae4))
* Provide _empty_ configuration object is one is not provided (forces config from environment or comma ([30ef3f9](https://github.com/midnight-ntwrk/artifacts/commit/30ef3f9))
* Remove obsolete workflows and secure existing ones ([43c023c](https://github.com/midnight-ntwrk/artifacts/commit/43c023c))
* Remove paid plugin ([52855fb](https://github.com/midnight-ntwrk/artifacts/commit/52855fb))
* Remove use of Ledger/Compact Runtime NetworkId in `platform-js` ([49113d6](https://github.com/midnight-ntwrk/artifacts/commit/49113d6))
* Rename 'zkconfig' assets to 'compiled' assets (ZK assets are only one type of asset) ([edab524](https://github.com/midnight-ntwrk/artifacts/commit/edab524))
* Revert change to `counter.compact` ([8729718](https://github.com/midnight-ntwrk/artifacts/commit/8729718))
* Update and optimize tests ([626b78b](https://github.com/midnight-ntwrk/artifacts/commit/626b78b))
* Update axios version ([6b3f25c](https://github.com/midnight-ntwrk/artifacts/commit/6b3f25c))
* Update CHANGELOG.md to reflect historic changes ([1085ef1](https://github.com/midnight-ntwrk/artifacts/commit/1085ef1))
* Update components to support `compact-runtime` v`0.9.0-rc.2` (bringing in `onchain-runtime-v1`) ([0751fdb](https://github.com/midnight-ntwrk/artifacts/commit/0751fdb))
* Update components to support `ledger@6`, fix breakages ([dc1528f](https://github.com/midnight-ntwrk/artifacts/commit/dc1528f))
* Update config, separate Allure for faster feedback ([24b067b](https://github.com/midnight-ntwrk/artifacts/commit/24b067b))
* Update ctrf plugin ([42bd100](https://github.com/midnight-ntwrk/artifacts/commit/42bd100))
* Update dependency @apollo/client to v3.13.9 ([ed1bff2](https://github.com/midnight-ntwrk/artifacts/commit/ed1bff2))
* Update dependency @fast-check/vitest to v0.2.2 ([49d3900](https://github.com/midnight-ntwrk/artifacts/commit/49d3900))
* Update dependency @tsconfig/node22 to v22.0.2 ([12ac5a6](https://github.com/midnight-ntwrk/artifacts/commit/12ac5a6))
* Update dependency @types/express to v5.0.3 ([b67e44d](https://github.com/midnight-ntwrk/artifacts/commit/b67e44d))
* Update dependency @types/ws to v8.18.1 ([7536e56](https://github.com/midnight-ntwrk/artifacts/commit/7536e56))
* Update dependency allure-vitest to v3.3.3 ([69905f5](https://github.com/midnight-ntwrk/artifacts/commit/69905f5))
* Update dependency eslint-config-prettier to v10.1.8 ([1df8725](https://github.com/midnight-ntwrk/artifacts/commit/1df8725))
* Update dependency eslint-plugin-prettier to v5.5.4 ([a0c25e0](https://github.com/midnight-ntwrk/artifacts/commit/a0c25e0))
* Update dependency graphql-ws to v6.0.6 ([f3de37c](https://github.com/midnight-ntwrk/artifacts/commit/f3de37c))
* Update deprecated merge-ctrf to ctrf package ([4b37c8d](https://github.com/midnight-ntwrk/artifacts/commit/4b37c8d))
* Update graphql codegen version ([74ce6e9](https://github.com/midnight-ntwrk/artifacts/commit/74ce6e9))
* Update mock types ([d6344c9](https://github.com/midnight-ntwrk/artifacts/commit/d6344c9))
* Update README.md to streamline development instructions and remove outdated sections ([70619e8](https://github.com/midnight-ntwrk/artifacts/commit/70619e8))
* Update to 'compactc' version 0.25.0 ([928cde1](https://github.com/midnight-ntwrk/artifacts/commit/928cde1))
* Update types ([7d2a92a](https://github.com/midnight-ntwrk/artifacts/commit/7d2a92a))
* Update types ([f855231](https://github.com/midnight-ntwrk/artifacts/commit/f855231))
* Update workflow configuration ([ed9c194](https://github.com/midnight-ntwrk/artifacts/commit/ed9c194))
* Update workflow permissions ([aef8c41](https://github.com/midnight-ntwrk/artifacts/commit/aef8c41))
* Update workflow permissions ([6d08059](https://github.com/midnight-ntwrk/artifacts/commit/6d08059))
* Use `CompiledContractReflection` in commands to parse any given arguments ([77cc579](https://github.com/midnight-ntwrk/artifacts/commit/77cc579))
* Working on unit tests ([8b6a217](https://github.com/midnight-ntwrk/artifacts/commit/8b6a217))
* refactor(compact-js): Add type handling for array types in `transformParams` (#192) ([6a76ef6](https://github.com/midnight-ntwrk/artifacts/commit/6a76ef6)), closes [#192](https://github.com/midnight-ntwrk/artifacts/issues/192)
* refactor(compact-js): Report type name for literal and reference types (#188) ([9c18c13](https://github.com/midnight-ntwrk/artifacts/commit/9c18c13)), closes [#188](https://github.com/midnight-ntwrk/artifacts/issues/188)
* feature: testkit-js (#130) ([b1bcb00](https://github.com/midnight-ntwrk/artifacts/commit/b1bcb00)), closes [#130](https://github.com/midnight-ntwrk/artifacts/issues/130)
* hotfix: CI configuration for API documentation generation (#59) ([98ab9f2](https://github.com/midnight-ntwrk/artifacts/commit/98ab9f2)), closes [#59](https://github.com/midnight-ntwrk/artifacts/issues/59)
* hotfix: CI trigger tweak for shared configuration (#129) ([1aa4c5f](https://github.com/midnight-ntwrk/artifacts/commit/1aa4c5f)), closes [#129](https://github.com/midnight-ntwrk/artifacts/issues/129)
* hotfix: proof provider - remove hardcoded binary files (#127) ([527cf7e](https://github.com/midnight-ntwrk/artifacts/commit/527cf7e)), closes [#127](https://github.com/midnight-ntwrk/artifacts/issues/127)
* hotfix: remove hardcoded COMPACTC_VERSION and add verbose information (#126) ([3327229](https://github.com/midnight-ntwrk/artifacts/commit/3327229)), closes [#126](https://github.com/midnight-ntwrk/artifacts/issues/126)
* release(Compact.js): Compact.js version 1.0 (#117) ([455b7f3](https://github.com/midnight-ntwrk/artifacts/commit/455b7f3)), closes [#117](https://github.com/midnight-ntwrk/artifacts/issues/117)
* release(Platform.js): Platform.js version `1.0` (#116) ([eb96d93](https://github.com/midnight-ntwrk/artifacts/commit/eb96d93)), closes [#116](https://github.com/midnight-ntwrk/artifacts/issues/116)
* docs: acknowledge original co-authors from repository migration ([0c34ecf](https://github.com/midnight-ntwrk/artifacts/commit/0c34ecf))
* docs: acknowledge original co-authors from repository migration ([8bf34b9](https://github.com/midnight-ntwrk/artifacts/commit/8bf34b9))
* docs: acknowledge original co-authors from repository migration ([363527a](https://github.com/midnight-ntwrk/artifacts/commit/363527a))

## 2.1.0 - 2025-10-08]

### Added
- **Block Time Access**: Added `secondsSinceLastEpoch` value to `QueryContext` in Compact programs to retrieve current block time within contracts
- **E2E Test Documentation**: Comprehensive README for end-to-end testing setup and usage
- **Enhanced Testing Framework**: New block time API tests and improved contract testing capabilities
- **Import Sorting**: ESLint configuration now includes automatic import sorting for better code organization

### Changed
- **Compactc**: Upgrade to 0.26.0
- **Compact-runtime**: Upgrade to 0.9.0
- **Compact Compiler**: Upgraded to Compact version 0.25.0 with improved contract compilation
- **Dependencies**: Major updates including:
  - GraphQL codegen and related packages
  - Axios version updates for security
  - Apollo Client to v3.13.9
  - Node.js type definitions to v22.0.2
  - ESLint and Prettier configurations
  - Vitest and testing utilities
- **Development Workflow**: Enhanced CI/CD with better test reporting and security scanning
- **Code Quality**: Improved TypeScript configurations and contract type definitions
- **Husky Configuration**: Changed from pre-commit to pre-push hooks for better developer experience

### Security
- **Workflow Hardening**: Removed obsolete workflows and updated GitHub Actions permissions
- **Dependency Security**: Applied security patches through comprehensive dependency updates
- **GitHub Actions**: Updated to latest secure versions including:
  - docker/login-action to 3.5.0
  - actions/setup-node to 4.4.0
  - actions/download-artifact to 5.0.0
  - checkmarx/ast-github-action to 2.3.24

### Fixed
- **Block Time Access**: Fix for `toLedgerState`, which erased the `block`
- **Configuration Issues**: Resolved Docker port conflicts and logger-provider path issues
- **Type Definitions**: Cleaned up contract types and improved test mocks
- **Workflow Permissions**: Updated GitHub Actions with proper security permissions
- **Dependencies**: Aligned versions across packages and resolved version conflicts
- **Documentation**: Fixed API documentation generation and TypeDoc configuration

### Developer Experience
- **Automated Dependency Management**: Enabled Dependabot and Renovate for automated updates
- **Better Test Reporting**: Integrated CTRF reporting for improved test feedback
- **Linting Improvements**: Enhanced ESLint rules with import sorting and unused import detection
- **CI/CD Optimization**: Faster feedback with optimized workflow configurations

## 2.0.2 - 2025-06-11

### Summary
- Add captcha header for faucet request
- Ensure segment number defaults to 0

## 2.0.1 - 2025-05-30

### Summary
- Consider EncPublicKey as Bech32m formatted strings
- Update zSwap-utils createUnprovenOutput to use segment 0

## 2.0.0 - 2025-05-12

### Summary
- Update typedoc.json
- Fix the broken compact package
- Fix the docs workflow
- Fix API docs
- Fix the docs workflow (again)
- Update dependency cross-fetch to v4.1.0
- Update dependency node to v22.14.0
- Pin dependencies
- Update dependency graphql to v16.10.0
- Update devDependencies (non-major)
- Update dependency @rollup/plugin-node-resolve to v16
- Update dependency @apollo/client to v3.13.6
- Update dependency graphql-ws to v6
- Update dependency express to v5
- API documentation update
- Update dependency node to v22.15.0
- Add BLS support
- Rename contract to contractAction in GraphQL schema
- Release 2.0.0-rc.1
- Update yarn to v4.9.1
- Bump @apollo/client to v3.13.8 and force import of only CJS modules
- Release 2.0.0-rc.2
- Add single test for Node.js compatibility
- Prepare release 2.0.0

## 1.0.0 - 2025-04-02

### Summary
- Introduces proper semantic versioning.
- Bech32m is now default and works with older wallets.
- Test framework is now public.
- Custom logging strategies are now supported.
- Works with the latest Node.js LTS.
- Dependencies updated to fix vulnerabilities.

================
File: packages/indexer-public-data-provider/package.json
================
{
  "name": "@midnight-ntwrk/midnight-js-indexer-public-data-provider",
  "version": "3.0.0-alpha.9",
  "description": "Implementation of public data provider based on the Midnight Pub-sub indexer",
  "main": "dist/index.cjs",
  "module": "dist/index.mjs",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "types": {
        "import": "./dist/index.d.mts",
        "require": "./dist/index.d.cts"
      },
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    }
  },
  "repository": "git@github.com:midnight-ntwrk/artifacts",
  "packageManager": "yarn@4.10.3",
  "author": "IOHK",
  "license": "Apache-2.0",
  "scripts": {
    "gen": "rm -rf gen && graphql-codegen",
    "clean": "rm -rf dist tsconfig.build.tsbuildinfo .rollup.cache",
    "build": "rollup -c rollup.config.mjs",
    "test": "vitest run",
    "deploy": "yarn npm publish"
  },
  "dependencies": {
    "@apollo/client": "^3.13.8",
    "@midnight-ntwrk/midnight-js-network-id": "workspace:*",
    "@midnight-ntwrk/midnight-js-types": "workspace:*",
    "@midnight-ntwrk/midnight-js-utils": "workspace:*",
    "buffer": "^6.0.3",
    "cross-fetch": "^4.1.0",
    "graphql": "^16.8.0",
    "graphql-ws": "^6.0.0",
    "isomorphic-ws": "^5.0.0",
    "rxjs": "^7.5.0",
    "ws": "^8.14.2",
    "zen-observable-ts": "^1.1.0"
  },
  "devDependencies": {
    "@graphql-codegen/cli": "^6.0.0",
    "@graphql-codegen/client-preset": "^5.0.0",
    "@graphql-codegen/typescript": "^5.0.0",
    "@graphql-codegen/typescript-operations": "^5.0.0",
    "@types/ws": "^8.18.0"
  },
  "files": [
    "dist/"
  ],
  "stableVersion": "3.0.0"
}

================
File: packages/level-private-state-provider/package.json
================
{
  "name": "@midnight-ntwrk/midnight-js-level-private-state-provider",
  "version": "3.0.0-alpha.9",
  "main": "dist/index.cjs",
  "module": "dist/index.mjs",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "types": {
        "import": "./dist/index.d.mts",
        "require": "./dist/index.d.cts"
      },
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    }
  },
  "author": "IOG",
  "repository": "git@github.com:midnight-ntwrk/artifacts",
  "packageManager": "yarn@4.10.3",
  "license": "Apache-2.0",
  "scripts": {
    "clean": "rm -rf dist tsconfig.build.tsbuildinfo .rollup.cache reports coverage",
    "build": "rollup -c rollup.config.mjs",
    "test": "vitest run",
    "deploy": "yarn npm publish"
  },
  "dependencies": {
    "@midnight-ntwrk/midnight-js-types": "workspace:*",
    "abstract-level": "^3.0.0",
    "buffer": "^6.0.3",
    "fp-ts": "^2.16.1",
    "io-ts": "^2.2.20",
    "level": "^10.0.0",
    "lodash": "^4.17.21",
    "superjson": "^2.0.0"
  },
  "devDependencies": {
    "@types/lodash": "^4.17.19"
  },
  "stableVersion": "3.0.0"
}

================
File: packages/logger-provider/package.json
================
{
  "name": "@midnight-ntwrk/midnight-js-logger-provider",
  "version": "3.0.0-alpha.9",
  "description": "MidnightJS module for configuring an application specific pino logger",
  "main": "dist/index.cjs",
  "module": "dist/index.mjs",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "types": {
        "import": "./dist/index.d.mts",
        "require": "./dist/index.d.cts"
      },
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    }
  },
  "author": "IOG",
  "repository": "git@github.com:midnight-ntwrk/artifacts",
  "packageManager": "yarn@4.10.3",
  "license": "Apache-2.0",
  "scripts": {
    "clean": "rm -rf dist tsconfig.build.tsbuildinfo .rollup.cache reports coverage",
    "build": "rollup -c rollup.config.mjs",
    "test": "vitest run",
    "deploy": "yarn npm publish"
  },
  "dependencies": {
    "@midnight-ntwrk/midnight-js-types": "workspace:*"
  },
  "files": [
    "dist/"
  ],
  "stableVersion": "3.0.0"
}

================
File: packages/node-zk-config-provider/package.json
================
{
  "name": "@midnight-ntwrk/midnight-js-node-zk-config-provider",
  "version": "3.0.0-alpha.9",
  "description": "MidnightJS module for reading proving and verifying keys and ZK intermediate representation",
  "main": "dist/index.cjs",
  "module": "dist/index.mjs",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "types": {
        "import": "./dist/index.d.mts",
        "require": "./dist/index.d.cts"
      },
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    }
  },
  "author": "IOG",
  "repository": "git@github.com:midnight-ntwrk/artifacts",
  "packageManager": "yarn@4.10.3",
  "license": "Apache-2.0",
  "scripts": {
    "clean": "rm -rf dist tsconfig.build.tsbuildinfo .rollup.cache reports coverage",
    "build": "rollup -c rollup.config.mjs",
    "test": "vitest run",
    "deploy": "yarn npm publish"
  },
  "dependencies": {
    "@midnight-ntwrk/midnight-js-types": "workspace:*"
  },
  "stableVersion": "3.0.0"
}

================
File: packages/utils/package.json
================
{
  "name": "@midnight-ntwrk/midnight-js-utils",
  "version": "3.0.0-alpha.9",
  "description": "Shared utilities for MidnightJS modules",
  "main": "dist/index.cjs",
  "module": "dist/index.mjs",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "types": {
        "import": "./dist/index.d.mts",
        "require": "./dist/index.d.cts"
      },
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    }
  },
  "repository": "git@github.com:midnight-ntwrk/artifacts",
  "packageManager": "yarn@4.10.3",
  "author": "IOHK",
  "license": "Apache-2.0",
  "scripts": {
    "clean": "rm -rf dist tsconfig.build.tsbuildinfo .rollup.cache reports coverage",
    "build": "rollup -c rollup.config.mjs",
    "test": "vitest run",
    "deploy": "yarn npm publish"
  },
  "files": [
    "dist/"
  ],
  "dependencies": {
    "@midnight-ntwrk/midnight-js-network-id": "workspace:*",
    "@scure/base": "^2.0.0"
  },
  "devDependencies": {
    "@types/node": "^24.0.0"
  },
  "stableVersion": "3.0.0"
}

================
File: testkit-js/testkit-js/package.json
================
{
  "name": "@midnight-ntwrk/testkit-js",
  "version": "3.0.0-alpha.9",
  "description": "Testing kit for Midnight JS packages",
  "main": "dist/index.cjs",
  "module": "dist/index.mjs",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "types": {
        "import": "./dist/index.d.mts",
        "require": "./dist/index.d.cts"
      },
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    }
  },
  "repository": "git@github.com:midnight-ntwrk/artifacts",
  "packageManager": "yarn@4.10.3",
  "author": "IOHK",
  "license": "Apache-2.0",
  "scripts": {
    "clean": "rm -rf dist reports coverage logs tsconfig.build.tsbuildinfo .rollup.cache managed midnight-level-db",
    "build": "rollup -c rollup.config.mjs",
    "build:markdown-docs": "typedoc --validation --plugin typedoc-plugin-markdown --options typedoc.json",
    "test": "yarn ut",
    "ut": "DEBUG='testcontainers:compose' NODE_OPTIONS=--experimental-vm-modules vitest --config vitest.package.ut.config.ts run",
    "it": "docker compose -f ../compose.yml pull && DEBUG='testcontainers:compose' NODE_OPTIONS=--experimental-vm-modules vitest --config vitest.package.it.config.ts run",
    "deploy": "yarn npm publish"
  },
  "dependencies": {
    "@midnight-ntwrk/midnight-js-compact": "workspace:*",
    "@midnight-ntwrk/midnight-js-contracts": "workspace:*",
    "@midnight-ntwrk/midnight-js-http-client-proof-provider": "workspace:*",
    "@midnight-ntwrk/midnight-js-indexer-public-data-provider": "workspace:*",
    "@midnight-ntwrk/midnight-js-level-private-state-provider": "workspace:*",
    "@midnight-ntwrk/midnight-js-network-id": "workspace:*",
    "@midnight-ntwrk/midnight-js-node-zk-config-provider": "workspace:*",
    "@midnight-ntwrk/midnight-js-types": "workspace:*",
    "@midnight-ntwrk/midnight-js-utils": "workspace:*",
    "buffer": "^6.0.3",
    "cross-fetch": "^4.0.0",
    "rxjs": "^7.8.1",
    "ws": "^8.14.2"
  },
  "devDependencies": {
    "@types/ws": "^8.18.1",
    "@vitest/runner": "^4.0.0",
    "allure-commandline": "^2.34.1",
    "allure-js-commons": "^3.3.0",
    "allure-vitest": "^3.3.0",
    "axios": "^1.12.0",
    "pino": "^10.0.0",
    "pino-pretty": "^13.0.0",
    "rxjs": "^7.8.2",
    "typedoc": "^0.28.5",
    "typedoc-plugin-markdown": "4.9.0",
    "vite-tsconfig-paths": "^5.1.4",
    "vitest": "^4.0.0"
  },
  "files": [
    "dist/"
  ],
  "stableVersion": "3.0.0"
}

================
File: packages/compact/package.json
================
{
  "name": "@midnight-ntwrk/midnight-js-compact",
  "description": "Compact fetcher",
  "repository": "git@github.com:midnight-ntwrk/artifacts",
  "author": "IOG",
  "engines": {
    "node": ">=22.0.0"
  },
  "license": "Apache-2.0",
  "version": "3.0.0-alpha.9",
  "type": "module",
  "bin": {
    "fetch-compactc": "dist/fetch-compact.mjs",
    "run-compactc": "dist/run-compactc.cjs"
  },
  "scripts": {
    "clean": "rm -rf dist tsconfig.build.tsbuildinfo tsconfig.tsbuildinfo managed dist",
    "build": "tsc -p tsconfig.build.json && cp src/run-compactc.cjs dist/",
    "lint": "eslint ./src",
    "typecheck": "tsc -p tsconfig.json",
    "deploy": "yarn npm publish"
  },
  "devDependencies": {
    "@types/node": "^24.0.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.8.2"
  },
  "files": [
    "dist/"
  ],
  "stableVersion": "3.0.0"
}

================
File: packages/http-client-proof-provider/package.json
================
{
  "name": "@midnight-ntwrk/midnight-js-http-client-proof-provider",
  "version": "3.0.0-alpha.9",
  "description": "Implementation of proof provider based on the Midnight ledger proof server",
  "main": "dist/index.cjs",
  "module": "dist/index.mjs",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "types": {
        "import": "./dist/index.d.mts",
        "require": "./dist/index.d.cts"
      },
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    }
  },
  "repository": "git@github.com:midnight-ntwrk/artifacts",
  "packageManager": "yarn@4.10.3",
  "author": "IOHK",
  "license": "Apache-2.0",
  "scripts": {
    "clean": "rm -rf dist tsconfig.build.tsbuildinfo .rollup.cache reports coverage logs",
    "compact": "yarn fetch-compactc && yarn compact-simple",
    "compact-simple": "run-compactc src/test/resources/simple.compact ./src/test/resources/managed/simple",
    "build": "yarn compact && rollup -c rollup.config.mjs",
    "test": "vitest run",
    "deploy": "yarn npm publish"
  },
  "files": [
    "dist/"
  ],
  "dependencies": {
    "@midnight-ntwrk/midnight-js-contracts": "workspace:*",
    "@midnight-ntwrk/midnight-js-network-id": "workspace:*",
    "@midnight-ntwrk/midnight-js-types": "workspace:*",
    "@midnight-ntwrk/midnight-js-utils": "workspace:*",
    "cross-fetch": "^4.1.0",
    "fetch-retry": "^6.0.0",
    "lodash": "^4.17.21"
  },
  "devDependencies": {
    "@midnight-ntwrk/midnight-js-compact": "workspace:*",
    "@types/lodash": "^4.17.19"
  },
  "stableVersion": "3.0.0"
}

================
File: package.json
================
{
  "name": "@midnight-ntwrk/midnight-js",
  "description": "Midnight application development framework",
  "version": "3.0.0-alpha.9",
  "packageManager": "yarn@4.10.3",
  "repository": "git@github.com:midnight-ntwrk/artifacts",
  "engines": {
    "node": ">=22"
  },
  "workspaces": [
    "packages/*",
    "compact-js/*",
    "platform-js/*",
    "testkit-js/*"
  ],
  "scripts": {
    "clean": "turbo run clean",
    "build": "turbo run build",
    "build:core": "turbo run build --filter='!@midnight-ntwrk/testkit-*'",
    "build:testkit": "turbo run build --filter='@midnight-ntwrk/testkit-*'",
    "clean-build": "turbo run clean-build",
    "test": "turbo run test",
    "test:unit": "turbo run test --filter='!@midnight-ntwrk/testkit-*'",
    "it": "turbo run it",
    "e2e": "turbo run e2e",
    "e2e-single": "turbo run e2e-single",
    "check": "turbo run check && yarn lint",
    "check:core": "turbo run check --filter='!@midnight-ntwrk/testkit-*' && yarn lint",
    "deploy": "turbo run deploy",
    "deploy:core": "turbo run deploy --filter='!@midnight-ntwrk/testkit-*'",
    "build:markdown-docs": "typedoc --validation --plugin typedoc-plugin-markdown --options typedoc.json",
    "lint": "eslint",
    "lint:fix": "NODE_OPTIONS=--max-old-space-size=16192 eslint ./packages --fix",
    "commit": "git-cz",
    "changelog": "conventional-changelog -p conventionalcommits -i CHANGELOG.md -s",
    "changelog:first": "conventional-changelog -p conventionalcommits -i CHANGELOG.md -s -r 0",
    "postinstall": "husky && patch-package",
    "prepublishOnly": "pinst --disable",
    "postpublish": "pinst --enable"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@midnight-ntwrk/compact-runtime": "0.11.0-rc.1",
    "@midnight-ntwrk/ledger-v6": "6.1.0-alpha.6",
    "@midnight-ntwrk/onchain-runtime-v1": "1.0.0-alpha.5",
    "@midnight-ntwrk/wallet-sdk-facade": "1.0.0-beta.11"
  },
  "devDependencies": {
    "@commitlint/cli": "^20.0.0",
    "@commitlint/config-conventional": "^20.0.0",
    "@d2t/vitest-ctrf-json-reporter": "^1.1.0",
    "@effect/build-utils": "^0.8.9",
    "@eslint/js": "^9.30.1",
    "@rollup/plugin-commonjs": "^28.0.9",
    "@rollup/plugin-node-resolve": "^16.0.3",
    "@rollup/plugin-replace": "^6.0.3",
    "@rollup/plugin-typescript": "^12.3.0",
    "@tsconfig/node24": "^24.0.0",
    "@types/node": "^24.0.0",
    "@vitest/coverage-v8": "^4.0.0",
    "@vitest/ui": "^4.0.0",
    "commitizen": "^4.3.0",
    "conventional-changelog-cli": "^5.0.0",
    "cz-conventional-changelog": "^3.3.0",
    "eslint": "^9.30.1",
    "eslint-config-prettier": "^10.1.5",
    "eslint-import-resolver-typescript": "^4.4.4",
    "eslint-plugin-import": "^2.32.0",
    "eslint-plugin-prettier": "^5.5.1",
    "eslint-plugin-simple-import-sort": "^12.1.1",
    "eslint-plugin-unused-imports": "^4.1.4",
    "glob": "^11.0.3",
    "husky": "^9.1.7",
    "jsdom": "^27.0.0",
    "lint-staged": "^16.1.2",
    "patch-package": "^8.0.1",
    "pinst": "^3.0.0",
    "prettier": "^3.6.2",
    "rollup": "^4.52.5",
    "rollup-plugin-dts": "^6.2.3",
    "rxjs": "^7.8.1",
    "shx": "^0.4.0",
    "testcontainers": "^11.2.0",
    "ts-node": "^10.9.2",
    "tstyche": "^4.3.0",
    "turbo": "^2.5.5",
    "typedoc": "^0.28.5",
    "typedoc-plugin-markdown": "4.9.0",
    "typescript": "^5.8.2",
    "typescript-eslint": "^8.35.1",
    "vitest": "^4.0.0"
  },
  "lint-staged": {
    "*.ts,!compact-js/**/*.ts": "eslint --cache --fix"
  },
  "config": {
    "commitizen": {
      "path": "cz-conventional-changelog"
    }
  },
  "stableVersion": "3.0.0"
}





================================================================
End of Codebase
================================================================
