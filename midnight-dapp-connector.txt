This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
docs/
  api/
    _media/
      SPECIFICATION.md
    type-aliases/
      APIError.md
      Configuration.md
      ConnectedAPI.md
      ConnectionStatus.md
      DesiredInput.md
      DesiredOutput.md
      ErrorCode.md
      ExecutionStatus.md
      HintUsage.md
      HistoryEntry.md
      InitialAPI.md
      Signature.md
      SignDataOptions.md
      TokenType.md
      TxStatus.md
      WalletConnectedAPI.md
    variables/
      ErrorCodes.md
    globals.md
    README.md
src/
  api.ts
  errors.ts
  globals.ts
  index.ts
.gitignore
.repomixignore
package.json
QUICKSTART.md
README.md
repomix.config.json
SPECIFICATION.md

================================================================
Files
================================================================

================
File: .repomixignore
================
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

================
File: repomix.config.json
================
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "midnight-dapp-connector.txt",
    "style": "plain",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "tokenCountTree": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false,
      "includeLogs": false,
      "includeLogsCount": 50
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}

================
File: docs/api/_media/SPECIFICATION.md
================
# DApp Connector API

DApps need an API to interact with wallets, so that users can confirm their transactions and use tokens in DApp interactions. What makes this line of interaction particularly important is an asymmetry in trust and data needed to actually implement useful interactions: wallet software is usually carefully selected and receives a lot of trust from its user, while DApps may be of varying quality, their goals will vary, as well as approach to overall security and privacy (including outright malicious intents). At the same time - many honest DApps, to provide good user experience or simply basic functionality for the kind of DApp, will require access to data, that users should not share lightly in many cases, like balances of (shielded) tokens or transactions found relevant for the wallet.

What raises additional concern to this API is potential presence of multiple browser extensions wanting to install their instances of the API in the DApp website, some of which might be malicious. 

## API Design

> [!note]
> Code snippets below are defined in TypeScript, this enables easy consistency check between the specification here, and definition in the DApp Connector API package: https://github.com/input-output-hk/midnight-dapp-connector-api / https://www.npmjs.com/package/@midnight-ntwrk/dapp-connector-api

> [!note] 
> In certain ways, the design of this API borrows from the [Cardano DApp Connector API defined in CIP-30](https://cips.cardano.org/cip/CIP-0030). This is a deliberate decision, to make the API look familiar to Cardano DApp developers.

### Initial API

The initial API of a wallet is an object containing information about the wallet, as well as a method allowing to connect to it or check if a connection is established.

```ts
import { type NetworkId } from '@midnight-ntwrk/midnight-js-network-id';

type InitialAPI = {
  /**
   * Wallet name, expected to be displayed to the user
   */  
  name: string;
  /**
   * Wallet icon, as an URL, either reference to a hosted resource, or a base64 encoded data URL
   */
  icon: string;
  /**
   * Version of the API implemented and installed, string containing a version of the API package @midnight-ntwrk/dapp-connector-api that was used in implementation
   */
  apiVersion: string;
  /**
   * Connect to wallet, hinting desired network id
   */
  connect: (networkId: string | NetworkId) => Promise<ConnectedAPI>;
};
```

Then, to allow DApp to access the API, Wallet installs its initial API under global `window.midnight` object:

```ts
declare global {
  interface Window {
    midnight?: {
      [key: string]: InitialAPI;
    };
  }
}
```

Here, some responsibilities lie on both DApp and Wallet:
1. The DApp should not rely on the contents of the key in the `midnight` object, as it can be arbitrary string and defined arbitrarily by the implementor. The wallet can use their name as the identifier, but a randomized string, like UUID is equally valid option.
2. In case multiple wallets install their API - the DApp should present the user with way to choose the wallet to use for the interaction
3. From DApp perspective, both name and icon are potentially malicious input, and thus - they should be sanitized before being presented to the user. In particular - the icon should always be rendered inside an `img` tag to prevent XSS from JavaScript embedded in SVG.
4. DApp should always check the `apiVersion` against supported range of versions (following semver semantics) and the DApp must not attempt to connect or present to the user initial APIs that are annotated with an unsupported API version.
5. Wallet must report exact version of the `@midnight-ntwrk/dapp-connector-api` package it implemented
6. If the Wallet implements multiple incompatible versions of the API simultanously (which is a possible case during transition period related to a hard-fork), Wallet must provide multiple entries in the `midnight` object.
7. For connecting:
   - The DApp must provide network id it wants to connect to
   - The DApp should not call `connect` method of the initial API multiple times unless necessary (e.g. to retry connection)
   - The wallet must reject connection request if it can't connect to the network with id provided by the DApp
   - The wallet may ask user for the scope of permissions provided to the DApp and indicate what network the DApp wants to connect to. It is up to the wallet implementation to decide how exactly and when exactly user is asked for confirmation
   - The wallet should expect multiple calls to the `connect` method and ensure they are properly separated from each other (specifically to allow re-connections)

### Connected API

Once connected, wallet provides connected API - one which allow for specific interaction with the wallet.

Main intention behind the connected API design is to enable many useful DApps, but also - to maintain separation of responsibilities between DApps and wallets. Wallets should not be concerned about preparing the right contract calls and preparing whole transaction as the DApp needs it, but also DApps should not be concerned with key management or wallet-specific operations like coin selection. For that reason, no API provides direct access to shielded coins or unshielded UTxOs, and instead DApps can ask wallet to prepare a transaction having specific effect using methods like `makeTransfer` or `makeIntent`. At the same time, main API allowing DApps to use tokens in contracts and have wallet pay fees is `balanceTransaction` - there, the DApp is expected to provide a transaction containing with desired effects (like contract calls, or some token outputs), and the wallet must ensure that fees are paid, as well as necessary inputs and outputs are provided to fully balance each token movement, so that DApp can focus solely on its desired effects.

The connected API consists of couple of parts, each always present, but its methods may throw an error indicating lack of permission:
```ts

type ShieldedBalance = {
  getShieldedBalances(): Promise<Record<TokenType, bigint>>;
};

type UnshishieldedBalance = {
  getUnshieldedBalances(): Promise<Record<TokenType, bigint>>;
};

type DustBalance = {
  getDustBalance(): Promise<bigint>;
}

type TxHistory = {
  getTxHistory(pageNumber: number, pageSize: number): Promise<HistoryEntry[]>;
};

type ShieldedAddress = {
  getShieldedAddresses(): Promise<{
    shieldedAddress: string;
    shieldedCoinPublicKey: string;
    shieldedEncryptionPublicKey: string;
  }>;
};

type UnshieldedAddress = {
  getUnshieldedAddress(): Promise<{
    unshieldedAddress: string;
  }>;
};

type DustAddress = {
  getDustAddress(): Promise<{dustAddress: string}>;
}

type InitActions = {
  /**
   * Take unsealed transaction (with proofs, with no signatures and with preimage 
   * data for cryptographic binding), pay fees, add necessary inputs and outputs 
   * to remove imbalances from it, returning a transaction ready for submission
   */
  balanceUnsealedTransaction(tx: string): Promise<{tx: string}>;
  /**
   * Take sealed transaction (with proofs, signatures and cryptographically bound), 
   * pay fees, add necessary inputs and outputs to remove imbalances from it, 
   * returning a transaction ready for submission
   */
  balanceSealedTransaction(tx: string): Promise<{tx: string}>;
  /**
   * Initialize a transfer transaction with desired outputs
   */
  makeTransfer(desiredOutputs: DesiredOutput[]): Promise<{tx: string}>;
  /**
   * Initialize a transaction with unbalanced intent containing desired inputs and outputs.
   * Primary use-case for this method is to create a transaction, which inits a swap
   * Options:
   * `intentId` - what id use for created intent:
   *              use 1 to ensure no transaction merging will result in actions executed before created intent in the same transaction
   *              use specific number within ledger limitations to make the intent have that segment id assigned
   *              use "random" to allow wallet to pick one in random (e.g. when creating intent for swap purposes)
   * `payFees` - whether wallet should pay fees for the issued transaction or not
   */
  makeIntent(desiredInputs: DesiredInput[], desiredOutputs: DesiredOutput[], options: {
    intentId: number | "random", 
    payFees: boolean
  }): Promise<{tx: string}>;
  /**
   * Sign provided data using key and format specified in the options, data to sign will be prepended with right prefix
   */
  signData(data: string, options: SignDataOptions): Promise<Signature>;
};

type Configuration = {
  /**  Indexer URI */
  indexerUri: string;
  /**  Indexer WebSocket URI */
  indexerWsUri: string;
  /**  Prover Server URI */
  proverServerUri: string;
  /**  Substrate URI */
  substrateNodeUri: string;

  /** Network id connected to - present here mostly for completness and to allow dapp validate it is connected to the network it wishes to */
  networkId: string | NetworkId;
};

type AccessConfiguration = {
  getConfiguration(): Promise<Configuration>;
  /**
   * Status of an existing connection to wallet
   */
  getConnectionStatus(): Promise<ConnectionStatus>;
}

type SubmitTransaction = {
    submitTransaction(tx: string): Promise<void>;
}

type WalletConnectedAPI = 
  & ShieldedBalance 
  & UnshieldedBalance 
  & DustBalance
  & TxHistory 
  & ShieldedAddress 
  & UnshieldedAddress 
  & DustAddress
  & InitActions 
  & AccessConfiguration 
  & SubmitTransactions

type ExecutionStatus = Record<number, "Success" | "Failure">;

type TxStatus =
  | {
      /**
       * Transaction included in chain and finalized
       */
      status: "finalized";
      executionStatus: ExecutionStatus;
    }
  | {
      /**
       * Transaction included in chain and not finalized yet
       */
      status: "confirmed";
      executionStatus: ExecutionStatus;
    }
  | {
      /**
       * Transaction sent to network but is not known to be either confirmed or discarded yet
       */
      status: "pending";
    }
  | {
      /**
       * Transaction failed to be included in chain, e.g. because of TTL or some validity checks
       */
      status: "discarded";
    };

type HistoryEntry = { 
    /**
     * Hex-encoded hash of transaction
     */
    txHash: string; 
    txStatus: TxStatus 
};

type DesiredOutput = {
  kind: "shielded" | "unshielded";
  type: TokenType;
  value: bigint;
  recipient: string;
};

type DesiredInput = {
  kind: "shielded" | "unshielded";
  type: TokenType;
  value: bigint;
};

type TokenType = string;

type SignDataOptions = {
  /**
   * How are data for signing encoded.
   * "hex" and "base64" mean binary data are encoded using one or the other format, 
   *   the wallet must decode them into binary sequence first
   * "text" means the data should be signed as provided in the string, but encoded into UTF-8 as a normalization step. 
   *   Conversion is necessary, because JS strings are UTF-16
   */
  encoding: "hex" | "base64" | "text"
  /**
   * What kind of key to use for signing
   */
  keyType: "unshielded";
};
type Signature = {
  /**
   * The data signed
   */
  data: string; 
  signature: string; 
  verifyingKey: string
}


type ConnectionStatus =
  | {
      /**
       * Connection is established to following network id
       */
      status: "connected";
      networkId: string | NetworkId;
    }
  | {
      /**
       * Connection is lost
       */
      status: "disconnected";
    };

type HintUsage = {
  hintUsage(methodNames: Array<keyof ConnectedAPI>): Promise<void>;
}

type ConnectedAPI = WalletConnectedAPI & HintUsage;

```

#### Permissions

1. The DApp should not assume presence of methods means granted permission - the DApp can call any method it needs for implementing desired functionality, but the Wallet may reject some (or all) of them according to its permission policy. To let DApp clearly distinguish when permission to use particular API was rejected, wallet must return `PermissionRejected` error for a particular method.
2. The DApp should not assume any particular permission system and its granularity being implemented. In particular - The DApp should use as little `ConnectedAPI` surface as possible for its functionality and follow the rules of progressive enhancement/graceful degradation when learning that certain methods are rejected. 
3. The DApp can use `hintUsage` method to hint to wallet what methods are expected be used in a certain context (be it whole session, single view, or a user flow - it is up to DApp). The wallet should expect multiple `hintUsage` calls as they may be related to different parts of a DApp. The wallet can use these calls as an opportunity to ask user for permissions. The wallet must resolve promise with a void value (`undefined`). The returned promise should be resolved only after the wallet finishes processing (including user interaction, if needed).

#### Initialization and configuration

1. The DApp should connect to indexer and proving server indicated by configuration, therefore wallet should not limit access to the `getConfiguration` method unless absolutely necessary.
2. The DApp can double check if `networkId` present in configuration matches the requested one
3. In the configuration object, the wallet must point to service deployments, which are compatible with network id present, and preferably are the same that the wallet itself uses for particular network.

#### Data

1. Wallet must provide data like token types and addresses in format compatible with network id present in the configuration object and following relevant specification, in particular:
    1.  contract addresses (where relevant) and token types follow format specified by ledger
    2.  wallet addresses follow format specified by wallet (Bech32m)
2. Wallet may reconcile data like balances from multiple accounts, in such case wallet must ensure data consistency, mostly related to reported balances, so that they can actually be used in a transaction, if only it fits single transaction and user does permit so.
3. Wallet implementing multiple account support must make it clear to the user, which accounts will be used for particular DApp interaction.
4. Wallet must ensure that balances reported in `getShieldedBalances` and `getUnshieldedBalances` methods are available balances, which means balances wallet is willing to allow spending in transactions. This allows DApps to rely on the balance checks (to certain extent at least, since race conditions are a possibility) in their logic.
5. The DApp can't assume balances, transactions, and the addresses returned by the API are directly related to each other. In particular - in many cases even when using a single BIP-44 account, the data served by an indexer and the wallet might differ because of wallet having more knowledge of its transactions.

#### Preparing and handling transactions

There exist 5 methods related to transactions: `makeTransfer`, `makeIntent`, `balanceSealedTransaction`, `balanceUnsealedTransaction` and `submitTransaction`. Their roles are following:
- `submitTransaction` - use wallet as a relayer to submit transaction to the network
- `balanceUnsealedTransaction` - it is the default method for DApp to use when interacting with contracts. The DApp is expected to create a transaction expressing desired outcomes - containing wanted contract calls (with accompanying token movements), or outputs from the transaction (expressing transfers to be made). Wallet will complement such transaction by collecting surplus of tokens present, providing necessary inputs and paying fees. The necessity for using `balanceUnsealedTransaction` arises from the intent structure and need to add outputs or inputs in the same intents contracts are called.
- `balanceSealedTransaction` - this method should be used to make wallet complement e.g. swap or pay fees for existing transaction
- `makeTransfer` - ask wallet to transfer provided amounts of tokens to provided recipients
- `makeIntent` - Midnight's transaction structure allows implementing atomic swaps through usage of intents and Zswap. `makeIntent` allows to create a purposefully imbalanced transaction (with surplus of tokens provided according to the `desiredInputs` balances and shaortage of tokens according to `desiredOutputs`), so that other party can issue a "mirrored" version of the call or be asked to balance such transaction (e.g. with the `balanceTransaction` method).

1. When a call returning transaction is made (in methods `balanceTransaction`, `makeTransfer` or `makeIntent`), wallet must return a transaction ready to be submitted to the network, that is one that is cryptographically bound, contains needed signatures, and contains needed proofs.
2. The DApp, when asking wallet to submit a transaction, must provide a transaction ready to be submitted to the network, that is one that is cryptographically bound, contains signatures, and contains proofs.
3. The DApp, when providing a transaction in method like `balanceTransaction` or `submitTransaction`, must provide a transaction compatible with the network it is connected to.


#### Signing

In order to make it impossible to sign transactions by accident, wallet receiving call to `signData` must prefix data with string `midnight_signed_message:<data_size>:`, where `<data_size>` is data size in bytes.

### Errors

Errors are modelled with a dedicated enumeration of codes:

```ts
const ErrorCodes = {
  /** The dapp connector wasn't able to process the request */
  InternalError: 'InternalError',
  /** The user rejected the request */
  Rejected: 'Rejected',
  /** Can be thrown in various circumstances, e.g. one being a malformed transaction */
  InvalidRequest: 'InvalidRequest',
  /** Permission to perform action was rejected. */
  PermissionRejected: 'PermissionRejected'
  /** The connection to the wallet was lost */
  Disconnected: 'Disconnected'
} as const;

type ErrorCode = (typeof ErrorCodes)[keyof typeof ErrorCodes];

type APIError = Error & {
  /** indication it is a DApp Connector Error */  
  type: 'DAppConnectorAPIError';
  /** The code of the error that's thrown */
  code: ErrorCode;
  /** The reason the error is thrown */
  reason: string;
}
```

Codes `InternalError` and `InvalidRequest` are rather simple in interpretation, along the lines of guidelines behind usage of 4xx and 5xx error codes in HTTP.
There is a notable difference in semantics between `Rejected` and `PermissionRejected` codes: `Rejected` indicates one-time rejection (e.g. user rejecting a transaction after seeing the real cost of it), while `PermissionRejected` indicates general preference to not permit particular action. Because of this - the connected DApp can expect, that once `PermissionRejected` is observed for a particular part of the API, it will keep being returned for the session (that is - until the browser window/tab with the DApp page is closed).

`APIError` type is not modelled as a class here, because it would be impossible to share single class definition between the DApp and the Wallet and in result - `instanceof` checks would not work as expected. Wallets can implement the type as a class extending native `Error`.

## Future direction

Although not part of the specification at this moment, there are some changes to the API considered to be added in the future. Some of them are quality-of-life improvements for DApp developers, others might enable new use cases or user experiences. 

### More chain-agnostic APIs

There exist APIs meant to be chain-agnostic, like one for issuing payments: https://github.com/ChainAgnostic/CAIPs/pull/358. Providing compatibility with them is expected to increase adoption and reduce friction.


### EIP-6963-like provider installation and discovery

Current specification based on shared global object offers simplicity and familiarity. Though it might cause synchronization issues when multiple wallets try to install their APIs. One possible solution, at a cost of increased complexity on the DApp side (likely asking for a dedicated client library) is for wallets to install their APIs using events, like in [EIP-6963](https://eips.ethereum.org/EIPS/eip-6963) or [CAIP-282](https://github.com/ChainAgnostic/CAIPs/pull/282). 

### Custom extensions

In many cases wallets might want to expose additional APIs, which are not part of the standard yet - for example to perform real-world testing and to gather feedback. For such cases extensions API similar to the one specified in [CIP-0030](https://cips.cardano.org/cip/CIP-0030) could be defined.

### Structured data signing

DApp connector's ability to sign arbitrary data is crucial to enable plenty of use-cases. It faces a significant user experience issue - many times the data being signed will not be human-readable, preventing user from assesing what exactly is being signed. To change that, Ethereum has adopted [EIP-712](https://eips.ethereum.org/EIPS/eip-712), Midnight's DApp connector could be extended to similar functionality.

### Event listener/observable API

In many cases, DApps might want to be notified when information relevant for them changes - e.g. a DEX might want to be notified whenever balances change. Providing push-based updates would be a welcome quality-of-life improvement. 

### Accounts

It seems that in many practical scenarios delivering good, seamless UX by the DApp needs information about accounts and being able to interact with them.

## Examples

### Connect

```ts
declare function semverMatch(version, expectedRange);
declare function askUserToSelect(wallets: InitialAPI[]): Promise<InitialAPI>;


async function connect(): Promise<ConnectedAPI> {
  const networkId = 'main';

  const compatibleWallets = Object.values(window.midnight ?? {})
    .filter((wallet) => semverMatch(wallet.apiVersion, '^1.0'));

  const selectedWallet = await askUserToSelect(compatibleWallets);
  const connectedWallet = await selectedWallet.connect(networkId);
  const connectionStatus = await connectedWallet.getConnectionStatus();
  assert(connectionstatus.networkId === networkId);
  return connectedWallet;
}
```

### Init a Night payment to an address

```ts
declare function getNightTokenType(): TokenType; // Such function will be provided e.g. by other libraries or the token type will become a well-known constant

const connectedWallet = await connect();
const tx = await connectedWallet.makeTransfer([{
  kind: "unshielded",
  type: getNightTokenType(),
  value: 10_000_000, //10 Night
  recipient: "mn_addr1asujt0dayj4pelgq97wv75hjhscqv9epmzzpapkf8sy8c87jhh9s6e0fs3"
}]);
await connectedWallet.submitTransaction(tx);

```

### Init and complement a swap of night into a shielded token

```ts
// Party #1
declare function getNightTokenType(): TokenType; // Such function will be provided e.g. by other libraries or the token type will become a well-known constant
declare function getFooTokenType(): TokenType;

const connectedWallet = await connect();
const shieldedAddress = (await connectedWallet.getShieldedAddresses()).shieldedAddress;
// This call will create a transaction with inputs and outputs structured so that there is:
// - surplus of 10 Night (inputs cover 10 Night, there might be some change output of Night created)
// - shortage of 50_000 Foo tokens (there is an output for 50_000 Foo tokens, but no inputs)
const tx = await connectedWallet.makeIntent([{
  kind: "unshielded",
  type: getNightTokenType(),
  value: 10_000_000, //10 Night
}], [{
  kind: "shielded",
  type: getFooTokenType(),
  value: 50_000,
  recipient: shieldedAddress
}]);
// Here, the `tx` can be submitted to some service, so that it becomes available to the other party


// Party #2
const tx = await fetchTransactionToMatch();
const connectedWallet = await connect();
// The the party #2 provides the 50_000 Foo tokens and creates self outputs for the surplus of 10 Night
const balancedTx = await connectedWallet.balanceSealedTransaction(tx);
await connectedWallet.submitTransaction(balancedTx);
```

================
File: docs/api/type-aliases/APIError.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / APIError

# Type Alias: APIError

> **APIError**: `Error` & `object`

Declaration of the error type thrown by the DApp Connector.

It is not a class extending the base `Error` type, because
it would make it difficult to implement in a way where `instanceof APIError` would work.
Instead a check like `error.type === 'DAppConnectorAPIError'` should be used.

## Type declaration

### code

> **code**: [`ErrorCode`](ErrorCode.md)

The code of the error that's thrown

### reason

> **reason**: `string`

The reason the error is thrown

### type

> **type**: `"DAppConnectorAPIError"`

indication it is a DApp Connector Error

================
File: docs/api/type-aliases/Configuration.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / Configuration

# Type Alias: Configuration

> **Configuration**: `object`

## Type declaration

### indexerUri

> **indexerUri**: `string`

Indexer URI

### indexerWsUri

> **indexerWsUri**: `string`

Indexer WebSocket URI

### networkId

> **networkId**: `string` \| `NetworkId`

Network id connected to - present here mostly for completness and to allow dapp validate it is connected to the network it wishes to

### proverServerUri

> **proverServerUri**: `string`

Prover Server URI

### substrateNodeUri

> **substrateNodeUri**: `string`

Substrate URI

================
File: docs/api/type-aliases/ConnectedAPI.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / ConnectedAPI

# Type Alias: ConnectedAPI

> **ConnectedAPI**: [`WalletConnectedAPI`](WalletConnectedAPI.md) & [`HintUsage`](HintUsage.md)

Connected API. It allows DApp to perform a range ofactions on the wallet after it is connected. Specifically the operations provided are:
- interaction with wallet - [WalletConnectedAPI](WalletConnectedAPI.md) covers those
- hint usage of methods to the wallet (to help with permissions management)

================
File: docs/api/type-aliases/ConnectionStatus.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / ConnectionStatus

# Type Alias: ConnectionStatus

> **ConnectionStatus**: \{ `networkId`: `string` \| `NetworkId`; `status`: `"connected"`; \} \| \{ `status`: `"disconnected"`; \}

Status of an existing connection to wallet
It either indicates that the connection is established to a specific network id, or that the connection is lost

## Type declaration

\{ `networkId`: `string` \| `NetworkId`; `status`: `"connected"`; \}

### networkId

> **networkId**: `string` \| `NetworkId`

### status

> **status**: `"connected"`

Connection is established to following network id

\{ `status`: `"disconnected"`; \}

### status

> **status**: `"disconnected"`

Connection is lost

================
File: docs/api/type-aliases/DesiredInput.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / DesiredInput

# Type Alias: DesiredInput

> **DesiredInput**: `object`

Desired input from an intent. It specifies the type of the input and the amount to provide.

## Type declaration

### kind

> **kind**: `"shielded"` \| `"unshielded"`

### type

> **type**: [`TokenType`](TokenType.md)

### value

> **value**: `bigint`

================
File: docs/api/type-aliases/DesiredOutput.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / DesiredOutput

# Type Alias: DesiredOutput

> **DesiredOutput**: `object`

Desired output from a transaction or intent. It specifies the type of the output, the amount and the recipient.
Recipient needs to be a properly formatted Bech32m address matching the kind of the token and network id the wallet is connected to.

## Type declaration

### kind

> **kind**: `"shielded"` \| `"unshielded"`

### recipient

> **recipient**: `string`

### type

> **type**: [`TokenType`](TokenType.md)

### value

> **value**: `bigint`

================
File: docs/api/type-aliases/ErrorCode.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / ErrorCode

# Type Alias: ErrorCode

> **ErrorCode**: *typeof* [`ErrorCodes`](../variables/ErrorCodes.md)\[keyof *typeof* [`ErrorCodes`](../variables/ErrorCodes.md)\]

All possible error codes gathered in a single union type. They are defined in [ErrorCodes](../variables/ErrorCodes.md).

================
File: docs/api/type-aliases/ExecutionStatus.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / ExecutionStatus

# Type Alias: ExecutionStatus

> **ExecutionStatus**: `Record`\<`number`, `"Success"` \| `"Failure"`\>

Execution status of a transaction.
It indicates which sections of a transaction were executed successfully or not.

================
File: docs/api/type-aliases/HintUsage.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / HintUsage

# Type Alias: HintUsage

> **HintUsage**: `object`

## Type declaration

### hintUsage()

Hint usage of methods to the wallet.

DApps should use this method to hint to the wallet what methods are expected to be used
in a certain context (be it whole session, single view, or a user flow - it is up to DApp).
The wallet can use these calls as an opportunity to ask user for permissions and in such case - resolve the promise only after the user has granted the permissions.

#### Parameters

##### methodNames

keyof [`WalletConnectedAPI`](WalletConnectedAPI.md)[]

#### Returns

`Promise`\<`void`\>

================
File: docs/api/type-aliases/HistoryEntry.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / HistoryEntry

# Type Alias: HistoryEntry

> **HistoryEntry**: `object`

Minimal information about a transaction relevant for the wallet.

## Type declaration

### txHash

> **txHash**: `string`

Hex-encoded hash of transaction

### txStatus

> **txStatus**: [`TxStatus`](TxStatus.md)

================
File: docs/api/type-aliases/InitialAPI.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / InitialAPI

# Type Alias: InitialAPI

> **InitialAPI**: `object`

Initial API for a wallet providing a DApp Connector API - it contains the information and methods allowing DApp to
chose and initiate a connection to the wallet.
Wallets inject their Initial API under the `window.midnight` object.
A single wallet can inject multiple instances of the Initial API, e.g. when supporting multiple versions.

## Type declaration

### apiVersion

> **apiVersion**: `string`

Version of the API implemented by this instance of the API, string containing a version of the API package @midnight-ntwrk/dapp-connector-api that was used in implementation
E.g. wallet implementing version 3.1.5 provides apiVersion with value '3.1.5'
This value lets DApps to differentiate between different versions of the API and implement appropriate logic for each version or not use some versions at all

### connect()

> **connect**: (`networkId`) => `Promise`\<[`ConnectedAPI`](ConnectedAPI.md)\>

Connect to wallet, hinting desired network id

#### Parameters

##### networkId

`string` | `NetworkId`

#### Returns

`Promise`\<[`ConnectedAPI`](ConnectedAPI.md)\>

### icon

> **icon**: `string`

Wallet icon, as an URL, either reference to a hosted resource, or a base64 encoded data URL. It is expected
to be displayed to the user. Because of this, DApps need to display the icon in a secure fashion to prevent XSS.
For example, displaying the icon using an `img` tag.

### name

> **name**: `string`

Wallet name, expected to be displayed to the user.
As such, DApps need to sanitize the name to prevent XSS when displaying it to the user. An example
of sanitization is displaying the name using a text node.

================
File: docs/api/type-aliases/Signature.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / Signature

# Type Alias: Signature

> **Signature**: `object`

Signature, accompanied by data signed and verifying key

## Type declaration

### data

> **data**: `string`

The data signed

### signature

> **signature**: `string`

### verifyingKey

> **verifyingKey**: `string`

================
File: docs/api/type-aliases/SignDataOptions.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / SignDataOptions

# Type Alias: SignDataOptions

> **SignDataOptions**: `object`

Options for signing data. It specified which key to use for signing and how the data to sign is encoded.

## Type declaration

### encoding

> **encoding**: `"hex"` \| `"base64"` \| `"text"`

How are data for signing encoded.
"hex" and "base64" mean binary data are encoded using one or the other format,
  the wallet must decode them into binary sequence first
"text" means the data should be signed as provided in the string, but encoded into UTF-8 as a normalization step.
  Conversion is necessary, because JS strings are UTF-16

### keyType

> **keyType**: `"unshielded"`

What kind of key to use for signing

================
File: docs/api/type-aliases/TokenType.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / TokenType

# Type Alias: TokenType

> **TokenType**: `string`

Type of a token. It will be a hex-encoded string relating to ledger's raw token type.

================
File: docs/api/type-aliases/TxStatus.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / TxStatus

# Type Alias: TxStatus

> **TxStatus**: \{ `executionStatus`: [`ExecutionStatus`](ExecutionStatus.md); `status`: `"finalized"`; \} \| \{ `executionStatus`: [`ExecutionStatus`](ExecutionStatus.md); `status`: `"confirmed"`; \} \| \{ `status`: `"pending"`; \} \| \{ `status`: `"discarded"`; \}

## Type declaration

\{ `executionStatus`: [`ExecutionStatus`](ExecutionStatus.md); `status`: `"finalized"`; \}

### executionStatus

> **executionStatus**: [`ExecutionStatus`](ExecutionStatus.md)

### status

> **status**: `"finalized"`

Transaction included in chain and finalized

\{ `executionStatus`: [`ExecutionStatus`](ExecutionStatus.md); `status`: `"confirmed"`; \}

### executionStatus

> **executionStatus**: [`ExecutionStatus`](ExecutionStatus.md)

### status

> **status**: `"confirmed"`

Transaction included in chain and not finalized yet

\{ `status`: `"pending"`; \}

### status

> **status**: `"pending"`

Transaction sent to network but is not known to be either confirmed or discarded yet

\{ `status`: `"discarded"`; \}

### status

> **status**: `"discarded"`

Transaction failed to be included in chain, e.g. because of TTL or some validity checks

================
File: docs/api/type-aliases/WalletConnectedAPI.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / WalletConnectedAPI

# Type Alias: WalletConnectedAPI

> **WalletConnectedAPI**: `object`

Wallet connected API. It is a subset of the Connected API defining all wallet-relevant methods.
Full Connected API also implements [HintUsage](HintUsage.md). The operations provided cover all necessary
functionality for a DApp to interact with the wallet:
- getting balances and addresses
- submitting transactions
- creating and balancing transactions
- initializing intents (for swaps)
- signing data

## Type declaration

### balanceSealedTransaction()

Take sealed transaction (with proofs, signatures and cryptographically bound),
pay fees, add necessary inputs and outputs to remove imbalances from it,
returning a transaction ready for submission

This method is mainly expected to be used by DApps when they operate on transactions created by the wallet or when the DApp wants to be sure that wallet performs balancing in a separate intent.
In such case, it is important to remember that some contracts might make use of fallible sections, in which case wallet won't be able to properly balance the transaction. In such cases, the DApp should use [balanceUnsealedTransaction](WalletConnectedAPI.md#balanceunsealedtransaction) instead.

In relation to Ledger API (`@midnight-ntwrk/ledger`), this method expects a serialized transaction of type `Transaction<SignatureEnabled, Proof, Binding>`

#### Parameters

##### tx

`string`

#### Returns

`Promise`\<\{ `tx`: `string`; \}\>

### balanceUnsealedTransaction()

Take unsealed transaction (with proofs, with no signatures and with preimage
data for cryptographic binding), pay fees, add necessary inputs and outputs
to remove imbalances from it, returning a transaction ready for submission

This method is expected to be used by DApps when interacting with contracts - in many cases when contracts interact with native tokens, where wallet may need to add inputs and outputs to an existing intent to properly balance the transaction.

In relation to Ledger API (`@midnight-ntwrk/ledger`), this method expects a serialized transaction of type `Transaction<SignatureErased, Proof, PreBinding>`

#### Parameters

##### tx

`string`

#### Returns

`Promise`\<\{ `tx`: `string`; \}\>

### getConfiguration()

Get the configuration of the services used by the wallet.

It is important for DApps to make use of those services whenever possible, as the wallet user might have some preferences in this regard, which e.g. improve privacy or performance.

#### Returns

`Promise`\<[`Configuration`](Configuration.md)\>

### getConnectionStatus()

Status of an existing connection to wallet

DApps can use this method to check if the connection is still valid.

#### Returns

`Promise`\<[`ConnectionStatus`](ConnectionStatus.md)\>

### getDustAddress()

Get the Dust address of the wallet. It is provided in Bech32m format.

#### Returns

`Promise`\<\{ `dustAddress`: `string`; \}\>

### getDustBalance()

Get the balance of Dust of the wallet. It reports both:
- the current balance (which may change over time due to generation mechanics)
- the cap (the maximum amount of Dust that can be generated from the current Night balance).

#### Returns

`Promise`\<\{ `balance`: `bigint`; `cap`: `bigint`; \}\>

### getShieldedAddresses()

Get the shielded addresses of the wallet. For convenience it also returns the coin public key and encryption public key.
All of them are provided in Bech32m format.

#### Returns

`Promise`\<\{ `shieldedAddress`: `string`; `shieldedCoinPublicKey`: `string`; `shieldedEncryptionPublicKey`: `string`; \}\>

### getShieldedBalances()

Get the balances of shielded tokens of the wallet. They are represented as a record, whose keys are token types.

#### Returns

`Promise`\<`Record`\<`string`, `bigint`\>\>

### getTxHistory()

Get the history of transactions of the wallet. Each history entry is a simplistic record of the fact that a transaction is relevant to the wallet.

#### Parameters

##### pageNumber

`number`

##### pageSize

`number`

#### Returns

`Promise`\<[`HistoryEntry`](HistoryEntry.md)[]\>

### getUnshieldedAddress()

Get the unshielded address of the wallet. It is provided in Bech32m format.

#### Returns

`Promise`\<\{ `unshieldedAddress`: `string`; \}\>

### getUnshieldedBalances()

Get the balances of unshielded tokens (potentially including Night) of the wallet. They are represented as a record, whose keys are token types.

#### Returns

`Promise`\<`Record`\<`string`, `bigint`\>\>

### makeIntent()

Initialize a transaction with unbalanced intent containing desired inputs and outputs.
Primary use-case for this method is to create a transaction, which inits a swap
Options:
`intentId` - what id use for created intent:
             use 1 to ensure no transaction merging will result in actions executed before created intent in the same transaction
             use specific number within ledger limitations to make the intent have that segment id assigned
             use "random" to allow wallet to pick one in random (e.g. when creating intent for swap purposes)
`payFees` - whether wallet should pay fees for the issued transaction or not

#### Parameters

##### desiredInputs

[`DesiredInput`](DesiredInput.md)[]

##### desiredOutputs

[`DesiredOutput`](DesiredOutput.md)[]

##### options

###### intentId

`number` \| `"random"`

###### payFees

`boolean`

#### Returns

`Promise`\<\{ `tx`: `string`; \}\>

### makeTransfer()

Initialize a transfer transaction with desired outputs

#### Parameters

##### desiredOutputs

[`DesiredOutput`](DesiredOutput.md)[]

#### Returns

`Promise`\<\{ `tx`: `string`; \}\>

### signData()

Sign provided data using key and format specified in the options, data to sign will be prepended with right prefix

#### Parameters

##### data

`string`

##### options

[`SignDataOptions`](SignDataOptions.md)

#### Returns

`Promise`\<[`Signature`](Signature.md)\>

### submitTransaction()

Submit a transaction to the network, effectively using wallet as a relayer.

The transaction received is expected to be balanced and "sealed" - it means it contains proofs, signatures and cryptographically bound (`Transaction<SignatureEnabled, Proof, Binding>` type from `@midnight-ntwrk/ledger`)

#### Parameters

##### tx

`string`

#### Returns

`Promise`\<`void`\>

================
File: docs/api/variables/ErrorCodes.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / ErrorCodes

# Variable: ErrorCodes

> `const` **ErrorCodes**: `object`

All possible error codes gathered in a single object.

## Type declaration

### Disconnected

> `readonly` **Disconnected**: `"Disconnected"` = `'Disconnected'`

The connection to the wallet was lost

### InternalError

> `readonly` **InternalError**: `"InternalError"` = `'InternalError'`

The dapp connector wasn't able to process the request

### InvalidRequest

> `readonly` **InvalidRequest**: `"InvalidRequest"` = `'InvalidRequest'`

Can be thrown in various circumstances, e.g. one being a malformed transaction

### PermissionRejected

> `readonly` **PermissionRejected**: `"PermissionRejected"` = `'PermissionRejected'`

Permission to perform action was rejected.

### Rejected

> `readonly` **Rejected**: `"Rejected"` = `'Rejected'`

The user rejected the request

================
File: docs/api/globals.md
================
[**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**](README.md)

***

# @midnight-ntwrk/dapp-connector-api v4.0.0-beta.1

## Type Aliases

- [APIError](type-aliases/APIError.md)
- [Configuration](type-aliases/Configuration.md)
- [ConnectedAPI](type-aliases/ConnectedAPI.md)
- [ConnectionStatus](type-aliases/ConnectionStatus.md)
- [DesiredInput](type-aliases/DesiredInput.md)
- [DesiredOutput](type-aliases/DesiredOutput.md)
- [ErrorCode](type-aliases/ErrorCode.md)
- [ExecutionStatus](type-aliases/ExecutionStatus.md)
- [HintUsage](type-aliases/HintUsage.md)
- [HistoryEntry](type-aliases/HistoryEntry.md)
- [InitialAPI](type-aliases/InitialAPI.md)
- [Signature](type-aliases/Signature.md)
- [SignDataOptions](type-aliases/SignDataOptions.md)
- [TokenType](type-aliases/TokenType.md)
- [TxStatus](type-aliases/TxStatus.md)
- [WalletConnectedAPI](type-aliases/WalletConnectedAPI.md)

## Variables

- [ErrorCodes](variables/ErrorCodes.md)

================
File: docs/api/README.md
================
**@midnight-ntwrk/dapp-connector-api v4.0.0-beta.1**

***

# Midnight DApp connector API

This API provides a comprehensive interface for the DApp - Wallet connection, defining the structure of the data and operations available.

The [Specification](_media/SPECIFICATION.md) document describes in more detail expected implementation and usage.

## Installation

The Midnight DApp connector API is available as an NPM package with the namespace `@midnight-ntwrk/dapp-connector-api`. It can be installed using any node package manager, such as Yarn. To install the package using Yarn, execute the following command:

`yarn add @midnight-ntwrk/dapp-connector-api`

## Package usage

The package provides the type declarations that are documented in the [documentation](type-aliases/InitialAPI.md) of this package.

The DApp connector API should be exposed through the global variable as follows:

`window.midnight.{someWalletIdString}`

In this way multiple wallets can inject their API without causing conflicts, and a DApp can select/ask the user 
to which wallet connection should be established.

## Initial API data and methods

| Name | Description |
|------|-------------|
| **name** | Wallet name, expected to be displayed to the user |
| **icon** | Wallet icon, as an URL, either reference to a hosted resource, or a base64 encoded data URL |
| **apiVersion** | Version of the API implemented by this instance of the API. E.g. wallet implementing version 3.1.5 provides apiVersion with value '3.1.5'. This value lets DApps to differentiate between different versions of the API and implement appropriate logic for each version or not use some versions at all |
| **connect** | Connect to wallet, hinting desired network id. Upon successful connection returns a promise with [ConnectedAPI](type-aliases/ConnectedAPI.md) |

## API usage

### Connecting to a wallet

DApp needs to select the wallet it wants to connect to and call the `connect(networkId)` method, then wait for the returned promise. 
The promise may resolve with a significant delay, as most wallets might want to display a dialog asking user for an authorization.

```ts
try {
  const desiredNetworkId = 'mainnet'
  const api = await window.midnight.{selectedWalletId}.connect('mainnet');

  // api is available here
} catch (error) {
  console.log('an error occurred', error);
}
```

### Getting information about the wallet before connection

#### Name and icon
To get the name of the wallet, use the `name` property in the implemented DApp connector API, it is similar with the icon:

```ts
const name = window.midnight.{walletName}.name;
const iconURL = window.midnight.{walletName}.icon;

console.log('Wallet name', name);
console.log('Wallet icon URL', iconURL);
```

Both fields are meant to be displayed to the user to help with wallet selection. The DApp needs to ensure proper 
escaping though to prevent XSS vulnerabilities, e.g. display icon only through an `img` tag and display the name 
using `Text` node.

#### API version
To get the API version, use the `apiVersion` property as follows:

```ts
const apiVersion = window.midnight.{walletName}.apiVersion;

console.log('API version', apiVersion);
```

The DApp needs to verify whether the version reported by wallet (which needs to be a version of this package) matches 
DApp's expectance (e.g. using semver check)

### Once connected

Once connected, the DApp can issue many different requests to the wallet as defined by the [ConnectedAPI](type-aliases/ConnectedAPI.md) type. The most important ones are:
- query wallet for information, like balances or addresses
- query wallet for configuration, so that the DApp can connect to the same instance of Indexer, Midnight Node or Proof Server
- ask wallet to make a transfer, balance a transaction, make an unbalanced intent (e.g. for a swap) or sign data 
- ask wallet to submit a transaction

#### Getting the configuration

Midnight wallet users can configure the node, indexer, and proving server URIs in the wallet settings. DApps are expected to follow these configurations, so that user preferences are respected, which is important from privacy standpoint.

The returned object has following properties:
| Name | Description |
|------|-------------|
| **indexerUri** | Indexer HTTP URI |
| **indexerWsUri** | Indexer WebSocket URI |
| **proverServerUri** | Prover Server URI |
| **substrateNodeUri** | Substrate URI |
| **networkId** | Network id connected to - present here mostly for completness and to allow dapp validate it is connected to the network it wishes to |

To get the service URI config, use the API as follows:

```ts
try {
  const connected = await window.midnight.{selectedWalletId}.connect();
  const serviceUriConfig = await connected.getConfiguration();

  console.log('serviceUriConfig', serviceUriConfig);
} catch (error) {
  console.log('an error occurred', error);
}
```

#### Reading wallet information 

There are many methods present for querying for wallet state. The most important ones are `getShieldedBalances`, `getUnshieldedBalances`, `getDustBalance`, `getShieldedAddresses`, `getUnshieldedAddress` and `getDustAddress`. They can be used like below. Keys and addresses will be provided in Bech32m format, while shielded and unshielded balances will return a record, whose keys are token types.

```ts
try {
  const connected = await window.midnight.{selectedWalletId}.connect();
  const addressesAndBalances = {
    shieldedBalances: await connected.getShieldedBalances(),
    unshieldedBalances: await connected.getUnshieldedBalances(),
    dustBalance: await connected.getDustBalance(),
    shieldedAddresses: await connected.getShieldedAddresses(),
    unshieldedAddress: await connected.getUnshieldedAddress(),
    dustAddress: await connected.getDustAddress(),
  }

  console.log('addressesAndBalances', addressesAndBalances);
} catch (error) {
  console.log('an error occurred', error);
}
```

#### Initiating a payment

If a DApp needs to initiate a payment, `makeTransfer` is the right method to use. It takes an array of outputs that need to be present in final transaction. For more details consult [InitActions type documentation](type-aliases/InitActions.md).

```ts
import {nativeToken} from '@midnight-ntwrk/ledger'

try {
  const connected = await window.midnight.{selectedWalletId}.connect();
  const transaction = await connected.makeTransfer([{
    kind: 'unshielded',
    tokenType: nativeToken().raw,
    value: 10n**6n,
    recipient: 'mn_addr1abcdef.....'
  }]);
} catch (error) {
  console.log('an error occurred', error);
}
```

#### Balancing a transaction, for paying fees or interacting with contracts

To balance transaction, begin by creating a transaction in your DApp. You can [follow the guide on how to create a transaction here](docs/develop/guides/wallet-dev-guide.mdx#working-with-transactions). 
This method is particularly useful for DApps calling contracts, as this is the best way to use native tokens 
in a DApp or make the user pay the fees for a contract call. Depending on a use case and state of transaction 
to be balanced there are two methods available: `balanceSealedTransaction` and `balanceUnsealedTransaction`. 
They indicate different methods wallet will use to deserialize the transaction and try to balance it. 
A transaction being result of a contract call most likely will need a call to `balanceUnsealedTransaction` 
whereas completing a swap (e.g. initiated by `makeIntent` call) will require call to `balanceSealedTransaction`.

```ts
try {
  // assuming we have a transaction at hand here
  const transaction;

  const result = await connected.balanceUnsealedTransaction(transaction);
  const resultTransaction = result.tx;
} catch (error) {
  console.log('an error occurred', error);
}
```

#### Submitting a transaction

With the balanced and proven transaction from above, you can now submit it.

```ts
try {
  const submittedTransaction = await connected.submitTransaction(resultTransaction);
} catch (error) {
  console.log('an error occurred', error);
}
```

## Examples
In this section, you'll find examples demonstrating how to fully utilize the DApp connector API.

### Connect

```ts
import { NetworkId } from '@midnight-ntwrk/midnight-js-network-id';

declare function semverMatch(version, expectedRange);
declare function askUserToSelect(wallets: InitialAPI[]): Promise<InitialAPI>;

async function connect(): Promise<ConnectedAPI> {
  const networkId = NetworkId.MainNet;

  const compatibleWallets = Object.values(window.midnight ?? {})
    .filter((wallet) => semverMatch(wallet.apiVersion, '^1.0'));

  const selectedWallet = await askUserToSelect(compatibleWallets);
  const connectedWallet = await selectedWallet.connect(networkId);
  const connectionStatus = await connectedWallet.getConnectionStatus();
  assert(connectionstatus.networkId === networkId);
  return connectedWallet;
}
```

### Init a Night payment to an address

```ts
import { nativeToken } from '@midnight-ntwrk/ledger';

const connectedWallet = await connect();
const tx = await connectedWallet.makeTransfer([{
  kind: "unshielded",
  type: nativeToken().raw,
  value: 10_000_000, //10 Night
  recipient: "mn_addr1asujt0dayj4pelgq97wv75hjhscqv9epmzzpapkf8sy8c87jhh9s6e0fs3"
}]);
await connectedWallet.submitTransaction(tx);

```

### Init and complement a swap of night into a shielded token

```ts
// Party #1
import { nativeToken } from '@midnight-ntwrk/ledger';

declare function getFooTokenType(): TokenType;

const connectedWallet = await connect();
const shieldedAddress = (await connectedWallet.getShieldedAddresses()).shieldedAddress;
// This call will create a transaction with inputs and outputs structured so that there is:
// - surplus of 10 Night (inputs cover 10 Night, there might be some change output of Night created)
// - shortage of 50_000 Foo tokens (there is an output for 50_000 Foo tokens, but no inputs)
const tx = await connectedWallet.makeIntent([{
  kind: "unshielded",
  type: nativeToken().raw,
  value: 10_000_000, //10 Night
}], [{
  kind: "shielded",
  type: getFooTokenType(),
  value: 50_000,
  recipient: shieldedAddress
}]);
// Here, the `tx` can be submitted to some service, so that it becomes available to the other party

// Party #2
const tx = await fetchTransactionToMatch();
const connectedWallet = await connect();
// The the party #2 provides the 50_000 Foo tokens and creates self outputs for the surplus of 10 Night
const balancedTx = await connectedWallet.balanceSealedTransaction(tx);
await connectedWallet.submitTransaction(balancedTx);
```

================
File: src/errors.ts
================
// This file is part of MIDNIGHT-DAPP-CONNECTOR-API.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * All possible error codes gathered in a single object.
 */
export const ErrorCodes = {
  /** The dapp connector wasn't able to process the request */
  InternalError: 'InternalError',
  /** The user rejected the request */
  Rejected: 'Rejected',
  /** Can be thrown in various circumstances, e.g. one being a malformed transaction */
  InvalidRequest: 'InvalidRequest',
  /** Permission to perform action was rejected. */
  PermissionRejected: 'PermissionRejected',
  /** The connection to the wallet was lost */
  Disconnected: 'Disconnected',
} as const;

/**
 * All possible error codes gathered in a single union type. They are defined in {@link ErrorCodes}.
 */
export type ErrorCode = (typeof ErrorCodes)[keyof typeof ErrorCodes];

/**
 * Declaration of the error type thrown by the DApp Connector.
 *
 * It is not a class extending the base `Error` type, because
 * it would make it difficult to implement in a way where `instanceof APIError` would work.
 * Instead a check like `error.type === 'DAppConnectorAPIError'` should be used.
 */
export type APIError = Error & {
  /** indication it is a DApp Connector Error */
  type: 'DAppConnectorAPIError';
  /** The code of the error that's thrown */
  code: ErrorCode;
  /** The reason the error is thrown */
  reason: string;
};

================
File: src/globals.ts
================
// This file is part of MIDNIGHT-DAPP-CONNECTOR-API.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { InitialAPI } from './api';

declare global {
  interface Window {
    midnight?: {
      [key: string]: InitialAPI;
    };
  }
}

export {};

================
File: src/index.ts
================
// This file is part of MIDNIGHT-DAPP-CONNECTOR-API.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * from './globals';
export * from './api';
export * from './errors';

================
File: .gitignore
================
# Yarn
.pnp.*
**/.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions
node_modules

# sbt
target
dist

# Others
.DS_Store
*.log
result
.idea/
.nix/
.env
.direnv/
.vscode/

================
File: QUICKSTART.md
================
# Midnight DApp connector API

Definition of the Midnight DApp connector interface.

## Structure

This package declares a set of [TypeScript](https://www.typescriptlang.org/) interfaces. All of them can be found in `src/` directory:
- `api.ts` - To the interface that's exposed to dapps
- `errors.ts` - Errors thrown from the exposed api

## Documentation

To generate documentation files in `docs` folder:

```shell
yarn build:docs
```

## Global Variables Exposure

This package declares a global variable in the `window.midnight.{walletName}` scope.

The package needs to be imported in the project or the (typeRoots)[https://www.typescriptlang.org/tsconfig#typeRoots] needs to be configured to load the global variable declaration.

================
File: SPECIFICATION.md
================
# DApp Connector API

DApps need an API to interact with wallets, so that users can confirm their transactions and use tokens in DApp interactions. What makes this line of interaction particularly important is an asymmetry in trust and data needed to actually implement useful interactions: wallet software is usually carefully selected and receives a lot of trust from its user, while DApps may be of varying quality, their goals will vary, as well as approach to overall security and privacy (including outright malicious intents). At the same time - many honest DApps, to provide good user experience or simply basic functionality for the kind of DApp, will require access to data, that users should not share lightly in many cases, like balances of (shielded) tokens or transactions found relevant for the wallet.

What raises additional concern to this API is potential presence of multiple browser extensions wanting to install their instances of the API in the DApp website, some of which might be malicious. 

## API Design

> [!note]
> Code snippets below are defined in TypeScript, this enables easy consistency check between the specification here, and definition in the DApp Connector API package: https://github.com/input-output-hk/midnight-dapp-connector-api / https://www.npmjs.com/package/@midnight-ntwrk/dapp-connector-api

> [!note] 
> In certain ways, the design of this API borrows from the [Cardano DApp Connector API defined in CIP-30](https://cips.cardano.org/cip/CIP-0030). This is a deliberate decision, to make the API look familiar to Cardano DApp developers.

### Initial API

The initial API of a wallet is an object containing information about the wallet, as well as a method allowing to connect to it or check if a connection is established.

```ts
import { type NetworkId } from '@midnight-ntwrk/midnight-js-network-id';

type InitialAPI = {
  /**
   * Wallet name, expected to be displayed to the user
   */  
  name: string;
  /**
   * Wallet icon, as an URL, either reference to a hosted resource, or a base64 encoded data URL
   */
  icon: string;
  /**
   * Version of the API implemented and installed, string containing a version of the API package @midnight-ntwrk/dapp-connector-api that was used in implementation
   */
  apiVersion: string;
  /**
   * Connect to wallet, hinting desired network id
   */
  connect: (networkId: string | NetworkId) => Promise<ConnectedAPI>;
};
```

Then, to allow DApp to access the API, Wallet installs its initial API under global `window.midnight` object:

```ts
declare global {
  interface Window {
    midnight?: {
      [key: string]: InitialAPI;
    };
  }
}
```

Here, some responsibilities lie on both DApp and Wallet:
1. The DApp should not rely on the contents of the key in the `midnight` object, as it can be arbitrary string and defined arbitrarily by the implementor. The wallet can use their name as the identifier, but a randomized string, like UUID is equally valid option.
2. In case multiple wallets install their API - the DApp should present the user with way to choose the wallet to use for the interaction
3. From DApp perspective, both name and icon are potentially malicious input, and thus - they should be sanitized before being presented to the user. In particular - the icon should always be rendered inside an `img` tag to prevent XSS from JavaScript embedded in SVG.
4. DApp should always check the `apiVersion` against supported range of versions (following semver semantics) and the DApp must not attempt to connect or present to the user initial APIs that are annotated with an unsupported API version.
5. Wallet must report exact version of the `@midnight-ntwrk/dapp-connector-api` package it implemented
6. If the Wallet implements multiple incompatible versions of the API simultanously (which is a possible case during transition period related to a hard-fork), Wallet must provide multiple entries in the `midnight` object.
7. For connecting:
   - The DApp must provide network id it wants to connect to
   - The DApp should not call `connect` method of the initial API multiple times unless necessary (e.g. to retry connection)
   - The wallet must reject connection request if it can't connect to the network with id provided by the DApp
   - The wallet may ask user for the scope of permissions provided to the DApp and indicate what network the DApp wants to connect to. It is up to the wallet implementation to decide how exactly and when exactly user is asked for confirmation
   - The wallet should expect multiple calls to the `connect` method and ensure they are properly separated from each other (specifically to allow re-connections)

### Connected API

Once connected, wallet provides connected API - one which allow for specific interaction with the wallet.

Main intention behind the connected API design is to enable many useful DApps, but also - to maintain separation of responsibilities between DApps and wallets. Wallets should not be concerned about preparing the right contract calls and preparing whole transaction as the DApp needs it, but also DApps should not be concerned with key management or wallet-specific operations like coin selection. For that reason, no API provides direct access to shielded coins or unshielded UTxOs, and instead DApps can ask wallet to prepare a transaction having specific effect using methods like `makeTransfer` or `makeIntent`. At the same time, main API allowing DApps to use tokens in contracts and have wallet pay fees is `balanceTransaction` - there, the DApp is expected to provide a transaction containing with desired effects (like contract calls, or some token outputs), and the wallet must ensure that fees are paid, as well as necessary inputs and outputs are provided to fully balance each token movement, so that DApp can focus solely on its desired effects.

The connected API consists of couple of parts, each always present, but its methods may throw an error indicating lack of permission:
```ts

type ShieldedBalance = {
  getShieldedBalances(): Promise<Record<TokenType, bigint>>;
};

type UnshishieldedBalance = {
  getUnshieldedBalances(): Promise<Record<TokenType, bigint>>;
};

type DustBalance = {
  getDustBalance(): Promise<bigint>;
}

type TxHistory = {
  getTxHistory(pageNumber: number, pageSize: number): Promise<HistoryEntry[]>;
};

type ShieldedAddress = {
  getShieldedAddresses(): Promise<{
    shieldedAddress: string;
    shieldedCoinPublicKey: string;
    shieldedEncryptionPublicKey: string;
  }>;
};

type UnshieldedAddress = {
  getUnshieldedAddress(): Promise<{
    unshieldedAddress: string;
  }>;
};

type DustAddress = {
  getDustAddress(): Promise<{dustAddress: string}>;
}

type InitActions = {
  /**
   * Take unsealed transaction (with proofs, with no signatures and with preimage 
   * data for cryptographic binding), pay fees, add necessary inputs and outputs 
   * to remove imbalances from it, returning a transaction ready for submission
   */
  balanceUnsealedTransaction(tx: string): Promise<{tx: string}>;
  /**
   * Take sealed transaction (with proofs, signatures and cryptographically bound), 
   * pay fees, add necessary inputs and outputs to remove imbalances from it, 
   * returning a transaction ready for submission
   */
  balanceSealedTransaction(tx: string): Promise<{tx: string}>;
  /**
   * Initialize a transfer transaction with desired outputs
   */
  makeTransfer(desiredOutputs: DesiredOutput[]): Promise<{tx: string}>;
  /**
   * Initialize a transaction with unbalanced intent containing desired inputs and outputs.
   * Primary use-case for this method is to create a transaction, which inits a swap
   * Options:
   * `intentId` - what id use for created intent:
   *              use 1 to ensure no transaction merging will result in actions executed before created intent in the same transaction
   *              use specific number within ledger limitations to make the intent have that segment id assigned
   *              use "random" to allow wallet to pick one in random (e.g. when creating intent for swap purposes)
   * `payFees` - whether wallet should pay fees for the issued transaction or not
   */
  makeIntent(desiredInputs: DesiredInput[], desiredOutputs: DesiredOutput[], options: {
    intentId: number | "random", 
    payFees: boolean
  }): Promise<{tx: string}>;
  /**
   * Sign provided data using key and format specified in the options, data to sign will be prepended with right prefix
   */
  signData(data: string, options: SignDataOptions): Promise<Signature>;
};

type Configuration = {
  /**  Indexer URI */
  indexerUri: string;
  /**  Indexer WebSocket URI */
  indexerWsUri: string;
  /**  Prover Server URI */
  proverServerUri: string;
  /**  Substrate URI */
  substrateNodeUri: string;

  /** Network id connected to - present here mostly for completness and to allow dapp validate it is connected to the network it wishes to */
  networkId: string | NetworkId;
};

type AccessConfiguration = {
  getConfiguration(): Promise<Configuration>;
  /**
   * Status of an existing connection to wallet
   */
  getConnectionStatus(): Promise<ConnectionStatus>;
}

type SubmitTransaction = {
    submitTransaction(tx: string): Promise<void>;
}

type WalletConnectedAPI = 
  & ShieldedBalance 
  & UnshieldedBalance 
  & DustBalance
  & TxHistory 
  & ShieldedAddress 
  & UnshieldedAddress 
  & DustAddress
  & InitActions 
  & AccessConfiguration 
  & SubmitTransactions

type ExecutionStatus = Record<number, "Success" | "Failure">;

type TxStatus =
  | {
      /**
       * Transaction included in chain and finalized
       */
      status: "finalized";
      executionStatus: ExecutionStatus;
    }
  | {
      /**
       * Transaction included in chain and not finalized yet
       */
      status: "confirmed";
      executionStatus: ExecutionStatus;
    }
  | {
      /**
       * Transaction sent to network but is not known to be either confirmed or discarded yet
       */
      status: "pending";
    }
  | {
      /**
       * Transaction failed to be included in chain, e.g. because of TTL or some validity checks
       */
      status: "discarded";
    };

type HistoryEntry = { 
    /**
     * Hex-encoded hash of transaction
     */
    txHash: string; 
    txStatus: TxStatus 
};

type DesiredOutput = {
  kind: "shielded" | "unshielded";
  type: TokenType;
  value: bigint;
  recipient: string;
};

type DesiredInput = {
  kind: "shielded" | "unshielded";
  type: TokenType;
  value: bigint;
};

type TokenType = string;

type SignDataOptions = {
  /**
   * How are data for signing encoded.
   * "hex" and "base64" mean binary data are encoded using one or the other format, 
   *   the wallet must decode them into binary sequence first
   * "text" means the data should be signed as provided in the string, but encoded into UTF-8 as a normalization step. 
   *   Conversion is necessary, because JS strings are UTF-16
   */
  encoding: "hex" | "base64" | "text"
  /**
   * What kind of key to use for signing
   */
  keyType: "unshielded";
};
type Signature = {
  /**
   * The data signed
   */
  data: string; 
  signature: string; 
  verifyingKey: string
}


type ConnectionStatus =
  | {
      /**
       * Connection is established to following network id
       */
      status: "connected";
      networkId: string | NetworkId;
    }
  | {
      /**
       * Connection is lost
       */
      status: "disconnected";
    };

type HintUsage = {
  hintUsage(methodNames: Array<keyof ConnectedAPI>): Promise<void>;
}

type ConnectedAPI = WalletConnectedAPI & HintUsage;

```

#### Permissions

1. The DApp should not assume presence of methods means granted permission - the DApp can call any method it needs for implementing desired functionality, but the Wallet may reject some (or all) of them according to its permission policy. To let DApp clearly distinguish when permission to use particular API was rejected, wallet must return `PermissionRejected` error for a particular method.
2. The DApp should not assume any particular permission system and its granularity being implemented. In particular - The DApp should use as little `ConnectedAPI` surface as possible for its functionality and follow the rules of progressive enhancement/graceful degradation when learning that certain methods are rejected. 
3. The DApp can use `hintUsage` method to hint to wallet what methods are expected be used in a certain context (be it whole session, single view, or a user flow - it is up to DApp). The wallet should expect multiple `hintUsage` calls as they may be related to different parts of a DApp. The wallet can use these calls as an opportunity to ask user for permissions. The wallet must resolve promise with a void value (`undefined`). The returned promise should be resolved only after the wallet finishes processing (including user interaction, if needed).

#### Initialization and configuration

1. The DApp should connect to indexer and proving server indicated by configuration, therefore wallet should not limit access to the `getConfiguration` method unless absolutely necessary.
2. The DApp can double check if `networkId` present in configuration matches the requested one
3. In the configuration object, the wallet must point to service deployments, which are compatible with network id present, and preferably are the same that the wallet itself uses for particular network.

#### Data

1. Wallet must provide data like token types and addresses in format compatible with network id present in the configuration object and following relevant specification, in particular:
    1.  contract addresses (where relevant) and token types follow format specified by ledger
    2.  wallet addresses follow format specified by wallet (Bech32m)
2. Wallet may reconcile data like balances from multiple accounts, in such case wallet must ensure data consistency, mostly related to reported balances, so that they can actually be used in a transaction, if only it fits single transaction and user does permit so.
3. Wallet implementing multiple account support must make it clear to the user, which accounts will be used for particular DApp interaction.
4. Wallet must ensure that balances reported in `getShieldedBalances` and `getUnshieldedBalances` methods are available balances, which means balances wallet is willing to allow spending in transactions. This allows DApps to rely on the balance checks (to certain extent at least, since race conditions are a possibility) in their logic.
5. The DApp can't assume balances, transactions, and the addresses returned by the API are directly related to each other. In particular - in many cases even when using a single BIP-44 account, the data served by an indexer and the wallet might differ because of wallet having more knowledge of its transactions.

#### Preparing and handling transactions

There exist 5 methods related to transactions: `makeTransfer`, `makeIntent`, `balanceSealedTransaction`, `balanceUnsealedTransaction` and `submitTransaction`. Their roles are following:
- `submitTransaction` - use wallet as a relayer to submit transaction to the network
- `balanceUnsealedTransaction` - it is the default method for DApp to use when interacting with contracts. The DApp is expected to create a transaction expressing desired outcomes - containing wanted contract calls (with accompanying token movements), or outputs from the transaction (expressing transfers to be made). Wallet will complement such transaction by collecting surplus of tokens present, providing necessary inputs and paying fees. The necessity for using `balanceUnsealedTransaction` arises from the intent structure and need to add outputs or inputs in the same intents contracts are called.
- `balanceSealedTransaction` - this method should be used to make wallet complement e.g. swap or pay fees for existing transaction
- `makeTransfer` - ask wallet to transfer provided amounts of tokens to provided recipients
- `makeIntent` - Midnight's transaction structure allows implementing atomic swaps through usage of intents and Zswap. `makeIntent` allows to create a purposefully imbalanced transaction (with surplus of tokens provided according to the `desiredInputs` balances and shaortage of tokens according to `desiredOutputs`), so that other party can issue a "mirrored" version of the call or be asked to balance such transaction (e.g. with the `balanceTransaction` method).

1. When a call returning transaction is made (in methods `balanceTransaction`, `makeTransfer` or `makeIntent`), wallet must return a transaction ready to be submitted to the network, that is one that is cryptographically bound, contains needed signatures, and contains needed proofs.
2. The DApp, when asking wallet to submit a transaction, must provide a transaction ready to be submitted to the network, that is one that is cryptographically bound, contains signatures, and contains proofs.
3. The DApp, when providing a transaction in method like `balanceTransaction` or `submitTransaction`, must provide a transaction compatible with the network it is connected to.


#### Signing

In order to make it impossible to sign transactions by accident, wallet receiving call to `signData` must prefix data with string `midnight_signed_message:<data_size>:`, where `<data_size>` is data size in bytes.

### Errors

Errors are modelled with a dedicated enumeration of codes:

```ts
const ErrorCodes = {
  /** The dapp connector wasn't able to process the request */
  InternalError: 'InternalError',
  /** The user rejected the request */
  Rejected: 'Rejected',
  /** Can be thrown in various circumstances, e.g. one being a malformed transaction */
  InvalidRequest: 'InvalidRequest',
  /** Permission to perform action was rejected. */
  PermissionRejected: 'PermissionRejected'
  /** The connection to the wallet was lost */
  Disconnected: 'Disconnected'
} as const;

type ErrorCode = (typeof ErrorCodes)[keyof typeof ErrorCodes];

type APIError = Error & {
  /** indication it is a DApp Connector Error */  
  type: 'DAppConnectorAPIError';
  /** The code of the error that's thrown */
  code: ErrorCode;
  /** The reason the error is thrown */
  reason: string;
}
```

Codes `InternalError` and `InvalidRequest` are rather simple in interpretation, along the lines of guidelines behind usage of 4xx and 5xx error codes in HTTP.
There is a notable difference in semantics between `Rejected` and `PermissionRejected` codes: `Rejected` indicates one-time rejection (e.g. user rejecting a transaction after seeing the real cost of it), while `PermissionRejected` indicates general preference to not permit particular action. Because of this - the connected DApp can expect, that once `PermissionRejected` is observed for a particular part of the API, it will keep being returned for the session (that is - until the browser window/tab with the DApp page is closed).

`APIError` type is not modelled as a class here, because it would be impossible to share single class definition between the DApp and the Wallet and in result - `instanceof` checks would not work as expected. Wallets can implement the type as a class extending native `Error`.

## Future direction

Although not part of the specification at this moment, there are some changes to the API considered to be added in the future. Some of them are quality-of-life improvements for DApp developers, others might enable new use cases or user experiences. 

### More chain-agnostic APIs

There exist APIs meant to be chain-agnostic, like one for issuing payments: https://github.com/ChainAgnostic/CAIPs/pull/358. Providing compatibility with them is expected to increase adoption and reduce friction.


### EIP-6963-like provider installation and discovery

Current specification based on shared global object offers simplicity and familiarity. Though it might cause synchronization issues when multiple wallets try to install their APIs. One possible solution, at a cost of increased complexity on the DApp side (likely asking for a dedicated client library) is for wallets to install their APIs using events, like in [EIP-6963](https://eips.ethereum.org/EIPS/eip-6963) or [CAIP-282](https://github.com/ChainAgnostic/CAIPs/pull/282). 

### Custom extensions

In many cases wallets might want to expose additional APIs, which are not part of the standard yet - for example to perform real-world testing and to gather feedback. For such cases extensions API similar to the one specified in [CIP-0030](https://cips.cardano.org/cip/CIP-0030) could be defined.

### Structured data signing

DApp connector's ability to sign arbitrary data is crucial to enable plenty of use-cases. It faces a significant user experience issue - many times the data being signed will not be human-readable, preventing user from assesing what exactly is being signed. To change that, Ethereum has adopted [EIP-712](https://eips.ethereum.org/EIPS/eip-712), Midnight's DApp connector could be extended to similar functionality.

### Event listener/observable API

In many cases, DApps might want to be notified when information relevant for them changes - e.g. a DEX might want to be notified whenever balances change. Providing push-based updates would be a welcome quality-of-life improvement. 

### Accounts

It seems that in many practical scenarios delivering good, seamless UX by the DApp needs information about accounts and being able to interact with them.

## Examples

### Connect

```ts
declare function semverMatch(version, expectedRange);
declare function askUserToSelect(wallets: InitialAPI[]): Promise<InitialAPI>;


async function connect(): Promise<ConnectedAPI> {
  const networkId = 'main';

  const compatibleWallets = Object.values(window.midnight ?? {})
    .filter((wallet) => semverMatch(wallet.apiVersion, '^1.0'));

  const selectedWallet = await askUserToSelect(compatibleWallets);
  const connectedWallet = await selectedWallet.connect(networkId);
  const connectionStatus = await connectedWallet.getConnectionStatus();
  assert(connectionstatus.networkId === networkId);
  return connectedWallet;
}
```

### Init a Night payment to an address

```ts
declare function getNightTokenType(): TokenType; // Such function will be provided e.g. by other libraries or the token type will become a well-known constant

const connectedWallet = await connect();
const tx = await connectedWallet.makeTransfer([{
  kind: "unshielded",
  type: getNightTokenType(),
  value: 10_000_000, //10 Night
  recipient: "mn_addr1asujt0dayj4pelgq97wv75hjhscqv9epmzzpapkf8sy8c87jhh9s6e0fs3"
}]);
await connectedWallet.submitTransaction(tx);

```

### Init and complement a swap of night into a shielded token

```ts
// Party #1
declare function getNightTokenType(): TokenType; // Such function will be provided e.g. by other libraries or the token type will become a well-known constant
declare function getFooTokenType(): TokenType;

const connectedWallet = await connect();
const shieldedAddress = (await connectedWallet.getShieldedAddresses()).shieldedAddress;
// This call will create a transaction with inputs and outputs structured so that there is:
// - surplus of 10 Night (inputs cover 10 Night, there might be some change output of Night created)
// - shortage of 50_000 Foo tokens (there is an output for 50_000 Foo tokens, but no inputs)
const tx = await connectedWallet.makeIntent([{
  kind: "unshielded",
  type: getNightTokenType(),
  value: 10_000_000, //10 Night
}], [{
  kind: "shielded",
  type: getFooTokenType(),
  value: 50_000,
  recipient: shieldedAddress
}]);
// Here, the `tx` can be submitted to some service, so that it becomes available to the other party


// Party #2
const tx = await fetchTransactionToMatch();
const connectedWallet = await connect();
// The the party #2 provides the 50_000 Foo tokens and creates self outputs for the surplus of 10 Night
const balancedTx = await connectedWallet.balanceSealedTransaction(tx);
await connectedWallet.submitTransaction(balancedTx);
```

================
File: src/api.ts
================
// This file is part of MIDNIGHT-DAPP-CONNECTOR-API.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * Initial API for a wallet providing a DApp Connector API - it contains the information and methods allowing DApp to
 * chose and initiate a connection to the wallet.
 * Wallets inject their Initial API under the `window.midnight` object.
 * A single wallet can inject multiple instances of the Initial API, e.g. when supporting multiple versions.
 */
export type InitialAPI = {
  /**
   * Wallet name, expected to be displayed to the user.
   * As such, DApps need to sanitize the name to prevent XSS when displaying it to the user. An example
   * of sanitization is displaying the name using a text node.
   */
  name: string;
  /**
   * Wallet icon, as an URL, either reference to a hosted resource, or a base64 encoded data URL. It is expected
   * to be displayed to the user. Because of this, DApps need to display the icon in a secure fashion to prevent XSS.
   * For example, displaying the icon using an `img` tag.
   */
  icon: string;
  /**
   * Version of the API implemented by this instance of the API, string containing a version of the API package @midnight-ntwrk/dapp-connector-api that was used in implementation
   * E.g. wallet implementing version 3.1.5 provides apiVersion with value '3.1.5'
   * This value lets DApps to differentiate between different versions of the API and implement appropriate logic for each version or not use some versions at all
   */
  apiVersion: string;
  /**
   * Connect to wallet, hinting desired network id
   */
  connect: (networkId: string) => Promise<ConnectedAPI>;
};

/**
 * Connected API. It allows DApp to perform a range ofactions on the wallet after it is connected. Specifically the operations provided are:
 * - interaction with wallet - {@link WalletConnectedAPI} covers those
 * - hint usage of methods to the wallet (to help with permissions management)
 */
export type ConnectedAPI = WalletConnectedAPI & HintUsage;

/**
 * Wallet connected API. It is a subset of the Connected API defining all wallet-relevant methods.
 * Full Connected API also implements {@link HintUsage}. The operations provided cover all necessary
 * functionality for a DApp to interact with the wallet:
 * - getting balances and addresses
 * - submitting transactions
 * - creating and balancing transactions
 * - initializing intents (for swaps)
 * - signing data
 */
export type WalletConnectedAPI = {
  /**
   * Get the balances of shielded tokens of the wallet. They are represented as a record, whose keys are token types.
   */
  getShieldedBalances(): Promise<Record<TokenType, bigint>>;
  /**
   * Get the balances of unshielded tokens (potentially including Night) of the wallet. They are represented as a record, whose keys are token types.
   */
  getUnshieldedBalances(): Promise<Record<TokenType, bigint>>;
  /**
   * Get the balance of Dust of the wallet. It reports both:
   * - the current balance (which may change over time due to generation mechanics)
   * - the cap (the maximum amount of Dust that can be generated from the current Night balance).
   */
  getDustBalance(): Promise<{ cap: bigint; balance: bigint }>;
  /**
   * Get the shielded addresses of the wallet. For convenience it also returns the coin public key and encryption public key.
   * All of them are provided in Bech32m format.
   */
  getShieldedAddresses(): Promise<{
    shieldedAddress: string;
    shieldedCoinPublicKey: string;
    shieldedEncryptionPublicKey: string;
  }>;
  /**
   * Get the unshielded address of the wallet. It is provided in Bech32m format.
   */
  getUnshieldedAddress(): Promise<{
    unshieldedAddress: string;
  }>;
  /**
   * Get the Dust address of the wallet. It is provided in Bech32m format.
   */
  getDustAddress(): Promise<{ dustAddress: string }>;
  /**
   * Get the history of transactions of the wallet. Each history entry is a simplistic record of the fact that a transaction is relevant to the wallet.
   */
  getTxHistory(pageNumber: number, pageSize: number): Promise<HistoryEntry[]>;
  /**
   * Take unsealed transaction (with proofs, with no signatures and with preimage
   * data for cryptographic binding), pay fees, add necessary inputs and outputs
   * to remove imbalances from it, returning a transaction ready for submission
   *
   * This method is expected to be used by DApps when interacting with contracts - in many cases when contracts interact with native tokens, where wallet may need to add inputs and outputs to an existing intent to properly balance the transaction.
   *
   * In relation to Ledger API (`@midnight-ntwrk/ledger`), this method expects a serialized transaction of type `Transaction<SignatureErased, Proof, PreBinding>`
   */
  balanceUnsealedTransaction(tx: string): Promise<{ tx: string }>;
  /**
   * Take sealed transaction (with proofs, signatures and cryptographically bound),
   * pay fees, add necessary inputs and outputs to remove imbalances from it,
   * returning a transaction ready for submission
   *
   * This method is mainly expected to be used by DApps when they operate on transactions created by the wallet or when the DApp wants to be sure that wallet performs balancing in a separate intent.
   * In such case, it is important to remember that some contracts might make use of fallible sections, in which case wallet won't be able to properly balance the transaction. In such cases, the DApp should use {@link balanceUnsealedTransaction} instead.
   *
   * In relation to Ledger API (`@midnight-ntwrk/ledger`), this method expects a serialized transaction of type `Transaction<SignatureEnabled, Proof, Binding>`
   */
  balanceSealedTransaction(tx: string): Promise<{ tx: string }>;
  /**
   * Initialize a transfer transaction with desired outputs
   */
  makeTransfer(desiredOutputs: DesiredOutput[]): Promise<{ tx: string }>;
  /**
   * Initialize a transaction with unbalanced intent containing desired inputs and outputs.
   * Primary use-case for this method is to create a transaction, which inits a swap
   * Options:
   * `intentId` - what id use for created intent:
   *              use 1 to ensure no transaction merging will result in actions executed before created intent in the same transaction
   *              use specific number within ledger limitations to make the intent have that segment id assigned
   *              use "random" to allow wallet to pick one in random (e.g. when creating intent for swap purposes)
   * `payFees` - whether wallet should pay fees for the issued transaction or not
   */
  makeIntent(
    desiredInputs: DesiredInput[],
    desiredOutputs: DesiredOutput[],
    options: {
      intentId: number | 'random';
      payFees: boolean;
    },
  ): Promise<{ tx: string }>;
  /**
   * Sign provided data using key and format specified in the options, data to sign will be prepended with right prefix
   */
  signData(data: string, options: SignDataOptions): Promise<Signature>;
  /**
   * Submit a transaction to the network, effectively using wallet as a relayer.
   *
   * The transaction received is expected to be balanced and "sealed" - it means it contains proofs, signatures and cryptographically bound (`Transaction<SignatureEnabled, Proof, Binding>` type from `@midnight-ntwrk/ledger`)
   */
  submitTransaction(tx: string): Promise<void>;
  /**
   * Get the configuration of the services used by the wallet.
   *
   * It is important for DApps to make use of those services whenever possible, as the wallet user might have some preferences in this regard, which e.g. improve privacy or performance.
   */
  getConfiguration(): Promise<Configuration>;
  /**
   * Status of an existing connection to wallet
   *
   * DApps can use this method to check if the connection is still valid.
   */
  getConnectionStatus(): Promise<ConnectionStatus>;
};

export type HintUsage = {
  /**
   * Hint usage of methods to the wallet.
   *
   * DApps should use this method to hint to the wallet what methods are expected to be used
   * in a certain context (be it whole session, single view, or a user flow - it is up to DApp).
   * The wallet can use these calls as an opportunity to ask user for permissions and in such case - resolve the promise only after the user has granted the permissions.
   */
  hintUsage(methodNames: Array<keyof WalletConnectedAPI>): Promise<void>;
};

export type Configuration = {
  /**  Indexer URI */
  indexerUri: string;
  /**  Indexer WebSocket URI */
  indexerWsUri: string;
  /**  Prover Server URI */
  proverServerUri: string;
  /**  Substrate URI */
  substrateNodeUri: string;

  /** Network id connected to - present here mostly for completness and to allow dapp validate it is connected to the network it wishes to */
  networkId: string;
};

/**
 * Execution status of a transaction.
 * It indicates which sections of a transaction were executed successfully or not.
 */
export type ExecutionStatus = Record<number, 'Success' | 'Failure'>;

export type TxStatus =
  | {
      /**
       * Transaction included in chain and finalized
       */
      status: 'finalized';
      executionStatus: ExecutionStatus;
    }
  | {
      /**
       * Transaction included in chain and not finalized yet
       */
      status: 'confirmed';
      executionStatus: ExecutionStatus;
    }
  | {
      /**
       * Transaction sent to network but is not known to be either confirmed or discarded yet
       */
      status: 'pending';
    }
  | {
      /**
       * Transaction failed to be included in chain, e.g. because of TTL or some validity checks
       */
      status: 'discarded';
    };

/**
 * Minimal information about a transaction relevant for the wallet.
 */
export type HistoryEntry = {
  /**
   * Hex-encoded hash of transaction
   */
  txHash: string;
  txStatus: TxStatus;
};

/**
 * Desired output from a transaction or intent. It specifies the type of the output, the amount and the recipient.
 * Recipient needs to be a properly formatted Bech32m address matching the kind of the token and network id the wallet is connected to.
 */
export type DesiredOutput = {
  kind: 'shielded' | 'unshielded';
  type: TokenType;
  value: bigint;
  recipient: string;
};

/**
 * Desired input from an intent. It specifies the type of the input and the amount to provide.
 */
export type DesiredInput = {
  kind: 'shielded' | 'unshielded';
  type: TokenType;
  value: bigint;
};

/**
 * Type of a token. It will be a hex-encoded string relating to ledger's raw token type.
 */
export type TokenType = string;

/**
 * Options for signing data. It specified which key to use for signing and how the data to sign is encoded.
 */
export type SignDataOptions = {
  /**
   * How are data for signing encoded.
   * "hex" and "base64" mean binary data are encoded using one or the other format,
   *   the wallet must decode them into binary sequence first
   * "text" means the data should be signed as provided in the string, but encoded into UTF-8 as a normalization step.
   *   Conversion is necessary, because JS strings are UTF-16
   */
  encoding: 'hex' | 'base64' | 'text';
  /**
   * What kind of key to use for signing
   */
  keyType: 'unshielded';
};

/**
 * Signature, accompanied by data signed and verifying key
 */
export type Signature = {
  /**
   * The data signed
   */
  data: string;
  signature: string;
  verifyingKey: string;
};

/**
 * Status of an existing connection to wallet
 * It either indicates that the connection is established to a specific network id, or that the connection is lost
 */
export type ConnectionStatus =
  | {
      /**
       * Connection is established to following network id
       */
      status: 'connected';
      networkId: string;
    }
  | {
      /**
       * Connection is lost
       */
      status: 'disconnected';
    };

================
File: README.md
================
# Midnight DApp connector API

This API provides a comprehensive interface for the DApp - Wallet connection, defining the structure of the data and operations available.

The [Specification](./SPECIFICATION.md) document describes in more detail expected implementation and usage.


## Installation

The Midnight DApp connector API is available as an NPM package with the namespace `@midnight-ntwrk/dapp-connector-api`. It can be installed using any node package manager, such as Yarn. To install the package using Yarn, execute the following command:

`yarn add @midnight-ntwrk/dapp-connector-api`

## Package usage

The package provides the type declarations that are documented in the [documentation](type-aliases/InitialAPI.md) of this package.

The DApp connector API should be exposed through the global variable as follows:

`window.midnight.{someWalletIdString}`

In this way multiple wallets can inject their API without causing conflicts, and a DApp can select/ask the user 
to which wallet connection should be established.


## Initial API data and methods

| Name | Description |
|------|-------------|
| **name** | Wallet name, expected to be displayed to the user |
| **icon** | Wallet icon, as an URL, either reference to a hosted resource, or a base64 encoded data URL |
| **apiVersion** | Version of the API implemented by this instance of the API. E.g. wallet implementing version 3.1.5 provides apiVersion with value '3.1.5'. This value lets DApps to differentiate between different versions of the API and implement appropriate logic for each version or not use some versions at all |
| **connect** | Connect to wallet, hinting desired network id. Upon successful connection returns a promise with [ConnectedAPI](type-aliases/ConnectedAPI.md) |


## API usage

### Connecting to a wallet

DApp needs to select the wallet it wants to connect to and call the `connect(networkId)` method, then wait for the returned promise. 
The promise may resolve with a significant delay, as most wallets might want to display a dialog asking user for an authorization.

```ts
try {
  const desiredNetworkId = 'mainnet'
  const api = await window.midnight.{selectedWalletId}.connect('mainnet');

  // api is available here
} catch (error) {
  console.log('an error occurred', error);
}
```


### Getting information about the wallet before connection

#### Name and icon
To get the name of the wallet, use the `name` property in the implemented DApp connector API, it is similar with the icon:

```ts
const name = window.midnight.{walletName}.name;
const iconURL = window.midnight.{walletName}.icon;

console.log('Wallet name', name);
console.log('Wallet icon URL', iconURL);
```

Both fields are meant to be displayed to the user to help with wallet selection. The DApp needs to ensure proper 
escaping though to prevent XSS vulnerabilities, e.g. display icon only through an `img` tag and display the name 
using `Text` node.

#### API version
To get the API version, use the `apiVersion` property as follows:

```ts
const apiVersion = window.midnight.{walletName}.apiVersion;

console.log('API version', apiVersion);
```

The DApp needs to verify whether the version reported by wallet (which needs to be a version of this package) matches 
DApp's expectance (e.g. using semver check)

### Once connected

Once connected, the DApp can issue many different requests to the wallet as defined by the [ConnectedAPI](type-aliases/ConnectedAPI.md) type. The most important ones are:
- query wallet for information, like balances or addresses
- query wallet for configuration, so that the DApp can connect to the same instance of Indexer, Midnight Node or Proof Server
- ask wallet to make a transfer, balance a transaction, make an unbalanced intent (e.g. for a swap) or sign data 
- ask wallet to submit a transaction

#### Getting the configuration

Midnight wallet users can configure the node, indexer, and proving server URIs in the wallet settings. DApps are expected to follow these configurations, so that user preferences are respected, which is important from privacy standpoint.

The returned object has following properties:
| Name | Description |
|------|-------------|
| **indexerUri** | Indexer HTTP URI |
| **indexerWsUri** | Indexer WebSocket URI |
| **proverServerUri** | Prover Server URI |
| **substrateNodeUri** | Substrate URI |
| **networkId** | Network id connected to - present here mostly for completness and to allow dapp validate it is connected to the network it wishes to |

To get the service URI config, use the API as follows:

```ts
try {
  const connected = await window.midnight.{selectedWalletId}.connect();
  const serviceUriConfig = await connected.getConfiguration();

  console.log('serviceUriConfig', serviceUriConfig);
} catch (error) {
  console.log('an error occurred', error);
}
```

#### Reading wallet information 

There are many methods present for querying for wallet state. The most important ones are `getShieldedBalances`, `getUnshieldedBalances`, `getDustBalance`, `getShieldedAddresses`, `getUnshieldedAddress` and `getDustAddress`. They can be used like below. Keys and addresses will be provided in Bech32m format, while shielded and unshielded balances will return a record, whose keys are token types.

```ts
try {
  const connected = await window.midnight.{selectedWalletId}.connect();
  const addressesAndBalances = {
    shieldedBalances: await connected.getShieldedBalances(),
    unshieldedBalances: await connected.getUnshieldedBalances(),
    dustBalance: await connected.getDustBalance(),
    shieldedAddresses: await connected.getShieldedAddresses(),
    unshieldedAddress: await connected.getUnshieldedAddress(),
    dustAddress: await connected.getDustAddress(),
  }

  console.log('addressesAndBalances', addressesAndBalances);
} catch (error) {
  console.log('an error occurred', error);
}
```

#### Initiating a payment

If a DApp needs to initiate a payment, `makeTransfer` is the right method to use. It takes an array of outputs that need to be present in final transaction. For more details consult [InitActions type documentation](type-aliases/InitActions.md).

```ts
import {nativeToken} from '@midnight-ntwrk/ledger'

try {
  const connected = await window.midnight.{selectedWalletId}.connect();
  const transaction = await connected.makeTransfer([{
    kind: 'unshielded',
    tokenType: nativeToken().raw,
    value: 10n**6n,
    recipient: 'mn_addr1abcdef.....'
  }]);
} catch (error) {
  console.log('an error occurred', error);
}
```

#### Balancing a transaction, for paying fees or interacting with contracts

To balance transaction, begin by creating a transaction in your DApp. You can [follow the guide on how to create a transaction here](docs/develop/guides/wallet-dev-guide.mdx#working-with-transactions). 
This method is particularly useful for DApps calling contracts, as this is the best way to use native tokens 
in a DApp or make the user pay the fees for a contract call. Depending on a use case and state of transaction 
to be balanced there are two methods available: `balanceSealedTransaction` and `balanceUnsealedTransaction`. 
They indicate different methods wallet will use to deserialize the transaction and try to balance it. 
A transaction being result of a contract call most likely will need a call to `balanceUnsealedTransaction` 
whereas completing a swap (e.g. initiated by `makeIntent` call) will require call to `balanceSealedTransaction`.

```ts
try {
  // assuming we have a transaction at hand here
  const transaction;

  const result = await connected.balanceUnsealedTransaction(transaction);
  const resultTransaction = result.tx;
} catch (error) {
  console.log('an error occurred', error);
}
```

#### Submitting a transaction

With the balanced and proven transaction from above, you can now submit it.

```ts
try {
  const submittedTransaction = await connected.submitTransaction(resultTransaction);
} catch (error) {
  console.log('an error occurred', error);
}
```


## Examples
In this section, you'll find examples demonstrating how to fully utilize the DApp connector API.

### Connect

```ts
import { NetworkId } from '@midnight-ntwrk/midnight-js-network-id';

declare function semverMatch(version, expectedRange);
declare function askUserToSelect(wallets: InitialAPI[]): Promise<InitialAPI>;


async function connect(): Promise<ConnectedAPI> {
  const networkId = NetworkId.MainNet;

  const compatibleWallets = Object.values(window.midnight ?? {})
    .filter((wallet) => semverMatch(wallet.apiVersion, '^1.0'));

  const selectedWallet = await askUserToSelect(compatibleWallets);
  const connectedWallet = await selectedWallet.connect(networkId);
  const connectionStatus = await connectedWallet.getConnectionStatus();
  assert(connectionstatus.networkId === networkId);
  return connectedWallet;
}
```

### Init a Night payment to an address

```ts
import { nativeToken } from '@midnight-ntwrk/ledger';

const connectedWallet = await connect();
const tx = await connectedWallet.makeTransfer([{
  kind: "unshielded",
  type: nativeToken().raw,
  value: 10_000_000, //10 Night
  recipient: "mn_addr1asujt0dayj4pelgq97wv75hjhscqv9epmzzpapkf8sy8c87jhh9s6e0fs3"
}]);
await connectedWallet.submitTransaction(tx);

```

### Init and complement a swap of night into a shielded token

```ts
// Party #1
import { nativeToken } from '@midnight-ntwrk/ledger';

declare function getFooTokenType(): TokenType;

const connectedWallet = await connect();
const shieldedAddress = (await connectedWallet.getShieldedAddresses()).shieldedAddress;
// This call will create a transaction with inputs and outputs structured so that there is:
// - surplus of 10 Night (inputs cover 10 Night, there might be some change output of Night created)
// - shortage of 50_000 Foo tokens (there is an output for 50_000 Foo tokens, but no inputs)
const tx = await connectedWallet.makeIntent([{
  kind: "unshielded",
  type: nativeToken().raw,
  value: 10_000_000, //10 Night
}], [{
  kind: "shielded",
  type: getFooTokenType(),
  value: 50_000,
  recipient: shieldedAddress
}]);
// Here, the `tx` can be submitted to some service, so that it becomes available to the other party


// Party #2
const tx = await fetchTransactionToMatch();
const connectedWallet = await connect();
// The the party #2 provides the 50_000 Foo tokens and creates self outputs for the surplus of 10 Night
const balancedTx = await connectedWallet.balanceSealedTransaction(tx);
await connectedWallet.submitTransaction(balancedTx);
```

### LICENSE

Apache 2.0.

### README.md

Provides a brief description for users and developers who want to understand the purpose, setup, and usage of the repository.

### SECURITY.md

Provides a brief description of the Midnight Foundation's security policy and how to properly disclose security issues.

### CONTRIBUTING.md

Provides guidelines for how people can contribute to the Midnight project.

### CODEOWNERS

Defines repository ownership rules.

### ISSUE_TEMPLATE

Provides templates for reporting various types of issues, such as: bug report, documentation improvement and feature request.

### PULL_REQUEST_TEMPLATE

Provides a template for a pull request.

### CLA Assistant

The Midnight Foundation appreciates contributions, and like many other open source projects asks contributors to sign a contributor
License Agreement before accepting contributions. We use CLA assistant (https://github.com/cla-assistant/cla-assistant) to streamline the CLA
signing process, enabling contributors to sign our CLAs directly within a GitHub pull request.

### Dependabot

The Midnight Foundation uses GitHub Dependabot feature to keep our projects dependencies up-to-date and address potential security vulnerabilities.

### Checkmarx

The Midnight Foundation uses Checkmarx for application security (AppSec) to identify and fix security vulnerabilities.
All repositories are scanned with Checkmarx's suite of tools including: Static Application Security Testing (SAST), Infrastructure as Code (IaC), Software Composition Analysis (SCA), API Security, Container Security and Supply Chain Scans (SCS).

### Unito

Facilitates two-way data synchronization, automated workflows and streamline processes between: Jira, GitHub issues and Github project Kanban board.

================
File: package.json
================
{
  "name": "@midnight-ntwrk/dapp-connector-api",
  "version": "4.0.0-beta.1",
  "packageManager": "yarn@4.12.0",
  "description": "Midnight DApp Connector API",
  "types": "dist/index.d.ts",
  "module": "dist/index.mjs",
  "main": "dist/index.mjs",
  "type": "module",
  "author": "Midnight Foundation",
  "license": "Apache-2.0",
  "exports": {
    ".": {
      "import": "./dist/index.mjs",
      "types": "./dist/index.d.ts"
    }
  },
  "files": [
    "dist",
    "package.json"
  ],
  "publishConfig": {
    "registry": "https://npm.pkg.github.com/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/midnight-ntwrk/artifacts.git"
  },
  "scripts": {
    "prepack": "yarn build",
    "deploy": "yarn npm publish",
    "build": "rm -rf ./dist && rollup -c ./rollup.config.mjs",
    "lint": "eslint src",
    "build:docs": "typedoc --validation --plugin typedoc-plugin-markdown --options typedoc.json"
  },
  "devDependencies": {
    "@eslint/js": "^9.18.0",
    "@rollup/plugin-commonjs": "^29.0.0",
    "@rollup/plugin-node-resolve": "^16.0.0",
    "@rollup/plugin-typescript": "^12.1.2",
    "@tsconfig/node22": "^22.0.0",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.1",
    "prettier": "^3.4.2",
    "rollup": "^4.30.1",
    "tslib": "^2.8.1",
    "typedoc": "^0.28.0",
    "typedoc-plugin-markdown": "^4.4.1",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  }
}





================================================================
End of Codebase
================================================================
