This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
docs/
  decisions/
    0000-use-markdown-architectural-decision-records.md
    0001-bloc-wallet-state.md
    0002-abstract-over-wallet.md
    0003-descaling-wallet.md
    0004-use-effect.md
    0005-using-tsc-to-build-projects.md
    0006-structure-for-flexibility-and-robustness.md
    index.md
    template.md
  Design.md
  wallet-component-diagram.svg
infra/
  compose/
    docker-compose-dynamic.yml
    docker-compose-remote-dynamic.yml
    docker-compose.yml
packages/
  abstractions/
    src/
      test/
        protocolVersion.test.ts
      index.ts
      NetworkId.ts
      ProtocolState.ts
      ProtocolVersion.ts
      SerializedTransaction.ts
      SerializedUnprovenTransaction.ts
      WalletSeed.ts
      WalletState.ts
    .prettierignore
    CHANGELOG.md
    eslint.config.mjs
    package.json
    tsconfig.build.json
    tsconfig.json
    tsconfig.publish.json
    tsconfig.test.json
    vitest.config.ts
  address-format/
    src/
      index.ts
    test/
      addresses.json
      bech32.test.ts
    .npmignore
    .prettierignore
    CHANGELOG.md
    eslint.config.mjs
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
    tsconfig.publish.json
    tsconfig.test.json
    vitest.config.ts
  capabilities/
    src/
      balancer/
        Balancer.ts
        CounterOffer.ts
        Imbalances.ts
        index.ts
      index.ts
    test/
      Balancer.test.ts
    .npmignore
    .prettierignore
    CHANGELOG.md
    eslint.config.mjs
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
    tsconfig.publish.json
    tsconfig.test.json
    vitest.config.ts
  docs-snippets/
    src/
      snippets/
        addresses.no-net.ts
        balancing.ts
        combined-transfer.ts
        designation.ts
        hd.no-net.ts
        initialization.ts
        shielded-transfer.ts
        swap.ts
        unshielded-transfer.ts
      test/
        __snapshots__/
          test-snippets.test.ts.snap
        test-snippets.test.ts
      utils.ts
    .prettierignore
    eslint.config.mjs
    package.json
    tsconfig.build.json
    tsconfig.json
    tsconfig.test.json
    vitest.config.ts
  dust-wallet/
    src/
      types/
        Dust.ts
        index.ts
        ledger.ts
        transaction.ts
      CoinsAndBalances.ts
      DustCoreWallet.ts
      DustWallet.ts
      index.ts
      Keys.ts
      RunningV1Variant.ts
      Serialization.ts
      Simulator.ts
      Submission.ts
      Sync.ts
      Transacting.ts
      Utils.ts
      V1Builder.ts
    test/
      DustWallet.test.ts
      UnshieldedKeyStore.ts
      utils.ts
    .prettierignore
    CHANGELOG.md
    eslint.config.mjs
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
    tsconfig.publish.json
    tsconfig.test.json
    vitest.config.ts
  e2e-tests/
    allure-results/
      categories.json
    project/
      build.properties
    scripts/
      conversion.mjs
    src/
      tests/
        balanceConstant.remote.test.ts
        balancing.undeployed.test.ts
        dust.undeployed.test.ts
        emptyWallet.universal.test.ts
        fundedWallet.undeployed.test.ts
        fundTestWallets.test.ts
        logger.ts
        multipleWallets.undeployed.test.ts
        nativeTokenTransfer.remote.test.ts
        smoke.undeployed.test.ts
        test-fixture.ts
        tokenTransfer.remote.test.ts
        tokenTransfer.undeployed.test.ts
        utils.ts
    .prettierignore
    eslint.config.mjs
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
    vitest.config.ts
  facade/
    src/
      index.ts
    test/
      dustDeregistration.test.ts
      dustRegistration.test.ts
      swap.test.ts
      transfer.test.ts
      utils.ts
    .npmignore
    .prettierignore
    CHANGELOG.md
    eslint.config.mjs
    package.json
    tsconfig.build.json
    tsconfig.json
    tsconfig.publish.json
    tsconfig.test.json
    tx.json
    vitest.config.ts
  hd/
    src/
      HDWallet.ts
      index.ts
      MnemonicUtils.ts
    test/
      tests.test.ts
    .npmignore
    .prettierignore
    CHANGELOG.md
    eslint.config.mjs
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
    tsconfig.publish.json
    tsconfig.test.json
    vitest.config.ts
  indexer-client/
    src/
      effect/
        test/
          httpQueryClient.spied.test.ts
          httpQueryClient.test.ts
          wsSubscriptionClient.spied.test.ts
          wsSubscriptionClient.test.ts
        ConnectionHelper.ts
        HttpQueryClient.ts
        index.ts
        Query.ts
        QueryClient.ts
        Subscription.ts
        SubscriptionClient.ts
        WsSubscriptionClient.ts
      graphql/
        generated/
          fragment-masking.ts
          gql.ts
          graphql.ts
          index.ts
        queries/
          test/
            BlockHash.test.ts
          BlockHash.ts
          Connect.ts
          Disconnect.ts
          index.ts
        subscriptions/
          test/
            ShieldedTransactions.test.ts
            UnshieldedTransactions.test.ts
            ZswapEvents.test.ts
          DustLedgerEvents.ts
          index.ts
          ShieldedTransactions.ts
          UnshieldedTransactions.ts
          ZswapEvents.ts
      index.ts
    .prettierignore
    CHANGELOG.md
    codegen.ts
    eslint.config.mjs
    indexer.gql
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
    tsconfig.publish.json
    tsconfig.test.json
    vitest.config.ts
  node-client/
    scripts/
      utils/
        command.ts
      generate-test-tx.ts
      generate-types.ts
    src/
      effect/
        test/
          gen-txs.ts
          PolkadotNodeClient.test.ts
        index.ts
        NodeClient.ts
        NodeClientError.ts
        PolkadotNodeClient.ts
        SubmissionEvent.ts
      gen/
        augment-api-errors.ts
        augment-api-query.ts
        augment-api-tx.ts
        augment-api.ts
      testing/
        index.ts
        normalize-txs.ts
        test-transactions.ts
      index.ts
    .gitignore
    .prettierignore
    CHANGELOG.md
    eslint.config.mjs
    package.json
    tsconfig.build.json
    tsconfig.json
    tsconfig.publish.json
    tsconfig.script.json
    tsconfig.test.json
    turbo.json
    vitest.config.ts
  prover-client/
    src/
      effect/
        test/
          httpProverClient.test.ts
        HttpProverClient.ts
        index.ts
        ProverClient.ts
      index.ts
    .npmignore
    .prettierignore
    CHANGELOG.md
    eslint.config.mjs
    package.json
    tsconfig.build.json
    tsconfig.json
    tsconfig.publish.json
    tsconfig.test.json
    vitest.config.ts
  runtime/
    src/
      abstractions/
        test/
          variant.test.ts
          variantBuilder.test.ts
          versionChangeType.test.ts
        index.ts
        StateChange.ts
        Variant.ts
        VariantBuilder.ts
        VersionChangeType.ts
        WalletLike.ts
        WalletRuntimeError.ts
      test/
        runtime.test.ts
        walletBuilder.test.ts
        walletBuilderType.test.ts
        walletState.test.ts
      testing/
        utils.ts
        variants.ts
      index.ts
      Runtime.ts
      WalletBuilder.ts
    .npmignore
    .prettierignore
    CHANGELOG.md
    eslint.config.mjs
    package.json
    tsconfig.build.json
    tsconfig.json
    tsconfig.publish.json
    tsconfig.test.json
    vitest.config.ts
  shielded-wallet/
    src/
      test/
        genTxs.ts
        testUtils.ts
      v1/
        test/
          coinsAndBalances.test.ts
          keys.test.ts
          proving.test.ts
          serialization.test.ts
          submission.test.ts
          sync.test.ts
          syncProgress.test.ts
          transacting.test.ts
          v1.test.ts
        CoinsAndBalances.ts
        CoreWallet.ts
        index.ts
        Keys.ts
        Proving.ts
        ProvingRecipe.ts
        RunningV1Variant.ts
        Serialization.ts
        Simulator.ts
        Submission.ts
        Sync.ts
        SyncProgress.ts
        Transacting.ts
        Transaction.ts
        TransactionHistory.ts
        TransactionImbalances.ts
        V1Builder.ts
        WalletError.ts
      index.ts
      ShieldedWallet.ts
    .npmignore
    .prettierignore
    CHANGELOG.md
    eslint.config.mjs
    package.json
    tsconfig.build.json
    tsconfig.json
    tsconfig.publish.json
    tsconfig.test.json
    vitest.config.ts
  unshielded-wallet/
    src/
      storage/
        index.ts
        InMemoryTransactionHistoryStorage.ts
        NoOpTransactionHistoryStorage.ts
        TransactionHistoryStorage.ts
      v1/
        test/
          testUtils.ts
          UnshieldedState.test.ts
        CoinsAndBalances.ts
        CoreWallet.ts
        index.ts
        Keys.ts
        RunningV1Variant.ts
        Serialization.ts
        Simulator.ts
        Sync.ts
        SyncProgress.ts
        SyncSchema.ts
        Transacting.ts
        Transaction.ts
        TransactionHistory.ts
        TransactionImbalances.ts
        UnshieldedState.ts
        V1Builder.ts
        WalletError.ts
      index.ts
      KeyStore.ts
      UnshieldedWallet.ts
    test/
      testUtils.ts
      UnshieldedWallet.test.ts
    .prettierignore
    CHANGELOG.md
    eslint.config.mjs
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
    tsconfig.publish.json
    tsconfig.test.json
    vitest.config.ts
  utilities/
    src/
      networking/
        ClientServerErrors.ts
        HttpURL.ts
        index.ts
        URLError.ts
        WsURL.ts
      test/
        hlist.test.ts
        observable.test.ts
        polyFunction.test.ts
      testing/
        compose.ts
        index.ts
        test-containers.ts
      ArrayOps.ts
      BlobOps.ts
      DateOps.ts
      EitherOps.ts
      Fluent.ts
      hlist.ts
      index.ts
      LedgerOps.ts
      ObservableOps.ts
      polyFunction.ts
      RecordOps.ts
      testUtils.ts
      types.ts
    .npmignore
    .prettierignore
    CHANGELOG.md
    eslint.config.mjs
    package.json
    tsconfig.build.json
    tsconfig.json
    tsconfig.publish.json
    tsconfig.test.json
    vitest.config.ts
  wallet-integration-tests/
    src/
      arbitraries.ts
    test/
      proving.test.ts
      serializationAndRestoration.test.ts
      simulation-mode.test.ts
      transacting.test.ts
      utils.ts
      walletSync.test.ts
    .prettierignore
    eslint.config.mjs
    package.json
    tsconfig.json
    tsconfig.test.json
    vitest.config.ts
.env.example
.gitignore
.repomixignore
DEV_GUIDE.md
package.json
README.md
repomix.config.json

================================================================
Files
================================================================

================
File: .repomixignore
================
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

================
File: repomix.config.json
================
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "midnight-wallet.txt",
    "style": "plain",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "tokenCountTree": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false,
      "includeLogs": false,
      "includeLogsCount": 50
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}

================
File: docs/decisions/0003-descaling-wallet.md
================
# Descaling Wallet

- Status: accepted
- Deciders: Andrzej Kopeć, Agron Murtezi
- Date: November 2024

Technical Story: related (but not exactly this) https://input-output.atlassian.net/browse/PM-9789

## Context and Problem Statement

With the team betting on Rust and TS as primary technologies Midnight is built with, there is less and less of Scala
code and Scala developers around. This renders initial approach (write as much application-level code in Scala as
possible, leaving to Rust and TS only what is somewhat necessary) no longer sustainable, posing serious risks related to
Wallet SDK development. Ultimately this led to a decision of removing Scala from Wallet SDK codebase (and in most part -
replacing it with TypeScript), but a remaining question is - how to perform this operation.

## Decision Drivers

- maintaining Wallet SDK functional without conversion being finished
- possibility of continuing feature development during the conversion
- possibility to pause the conversion in case of priority change
- possibility to introduce a new, modular set of Wallet SDK APIs

## Considered Options

- "Big-Bang" style of rewrite, with the team focusing solely on the rewrite
- "Strangler fig" pattern (https://martinfowler.com/bliki/StranglerFigApplication.html) executed in small, atomic steps,
  by limited number of people

## Decision Outcome

Chosen option: "Strangler fig", because it ticks all the boxes, allows the team to make progress with implementing new
functionality during the process. The details of the process are outlined below:

1. Restructure the Wallet SDK repository to be driven by TS tooling, using yarn workspaces and turborepo (or maybe
   pnpm?). sbt would be called by package.json scripts
2. Replace existing wallet package with a proxy one, defined in TypeScript. The Scala one gets renamed and all its
   exports are re-exported by the new TS package to maintain compatibility.
3. Move all Scala code into a single sbt project to not run into issues with package boundaries when needing to expose
   pieces of e.g. wallet-core as JS objects
4. Remove all instances of effect polymorphism/higher-kinded types, to make possible interoperatibility simpler
5. In the new TS package, introduce a new builder, at this point being a proxy to the existing one, but with an API
   following builder pattern.
6. For each capability/service present in Scala codebase:
   - allow to provide it externally by the new builder
   - expose existing implementation as a default one to provide
   - rewire Scala codebase to accept such instance from outside
7. For each capability/service accepted by the new builder:
   - rewrite/create test suite in TS for it
   - ensure the Scala implementation passes the test suite
   - rewrite the implementation into TS

### Positive Consequences

- Wallet SDK becomes a primarily TypeScript codebase, at some point reaching a clear state, where rewrites become
  isolated and relatively simple
- New APIs constructing wallet instance are introduced along the way
- Very early in the process there is introduced ability to implement new functionalities mostly in TypeScript

## Pros and Cons of the Options

### "Big Bang" rewrite

- Good, because there is less functionality to migrate from Scala to TS
- Bad, because feature development would need to stop to execute it effectively
- Bad, because it is a much more risky approach

### "Strangler fig"

- Good, because it does not disrupt feature development
- Good, because there is no risk of getting out of sync with main branch
- Bad, because codebase will depend on Scala for longer time

================
File: docs/decisions/0004-use-effect.md
================
# Use [Effect](https://effect.website/)

- Status: accepted
- Deciders: Tim Roberts, Andrzej Kopeć, Monika Jassove
- Date: November 2024

Technical Story: [Wallet Rewrite](https://shielded.atlassian.net/browse/PM-13769)

## Context and Problem Statement

With wallet rewrite to TypeScript, the need to keep internals purely functional remains - it makes testing, specifying
and reasoning about code easier, and allows for a more flexible design. There are many approaches towards writing
functional code in TypeScript though, with different drawbacks and strong sides.

## Decision Drivers <!-- optional -->

- Documentation
- Ecosystem
- Overlap with scope of helpers implemented in TS in other projects

## Considered Options

- fp-ts + io-ts + rx.js
- just rx.js + own helpers when needed (maybe extracting from other projects)
- Effect + (maybe) rx.js
- lodash/fp + rx.js

## Decision Outcome

Chosen option: "Effect", because it is the most complete offering at this moment. It is being steadily developed for
many years already, has single-shot effects, resource management, streams, schema (successor to io-ts) and a library of
common datatypes (successor to fp-ts).

### Positive Consequences <!-- optional -->

- Single, coherent set of packages to rely on for common operations
- Usage of established library

### Negative Consequences <!-- optional -->

- Need to expose additional flavours of some APIs without referring to Effect

## Pros and Cons of the Options <!-- optional -->

### fp-ts + io-ts + rx.js

- Bad, because of little cohesion
- Bad, because of poor DX

### just rx.js + own helpers when needed (maybe extracting from other projects)

- Good, because it is close to Vanilla JS
- Good, because of reduced number of dependencies
- Bad, because of need to write boilerplate
- Bad, because of lack of important primitives from the day 1 (like typed error handling or resource management)

### lodash/fp + rx.js

As above

================
File: docs/decisions/0005-using-tsc-to-build-projects.md
================
# Use TSC to build projects

- Status: proposed
- Deciders: Ian Gregson, Tim Roberts, Andrzej Kopeć, Agron Murtezi
- Date: July 2025

Technical Story: [PM-18147](https://shielded.atlassian.net/browse/PM-18147) <!-- optional -->

## Context and Problem Statement

Our projects are written in TypeScript to leverage type safety and improve developer productivity through IDE features
like "Go to Implementation" (e.g., Cmd+Click in VS Code).

Previously, we used Rollup to bundle our TypeScript code, but this caused issues where navigating to a symbol’s
implementation in the IDE opened the generated .d.ts declaration file instead of the source .ts file, despite generating
declaration maps (.d.ts.map).

This is because Rollup consolidates type declarations into a single index.d.ts file per project and bundles all .ts
files into a single .js file, breaking the source mapping for IDE navigation.

How can we configure our build process to ensure accurate IDE navigation to source files while maintaining TypeScript’s
benefits?

## Decision Drivers <!-- optional -->

- Developer experience, particularly accurate IDE navigation to source files
- Compatibility with TypeScript’s ecosystem and declaration maps
- Build performance and scalability
- Maintainability and simplicity of the build configuration

## Considered Options

- Continue using Rollup and try and fix the issue
- Use TypeScript Compiler (tsc) for building

## Decision Outcome

Chosen option: "Use TypeScript Compiler (tsc)", because it generates individual .d.ts and .d.ts.map files for each
source file, ensuring accurate IDE navigation to the original .ts files. It also provides the most robust integration
with TypeScript’s type system and declaration map features, improving developer productivity.

### Positive Consequences <!-- optional -->

- Improved IDE navigation: Cmd+Click reliably navigates to source .ts files
- Better alignment with TypeScript’s native tooling, reducing configuration complexity
- Enhanced maintainability due to standardized build process
- Incremental builds enabled by the composite setting in tsconfig.json, which generates a tsconfig.build.tsbuildinfo
  file, caching build information and skipping recompilation of unchanged source files for faster subsequent builds

### Negative Consequences <!-- optional -->

- Scala needs to read our existing Typescript code, it currently imports `address-format` and `capabilities`.
  Capabilities has multiple source files and the Scala generation requires that all javascript files are consolidated
  together and all types are consolidated together. Hence, capabilities requires us to maintain it's use of rollup.
  These issues will disppear shortly when Scala goes away.

## Pros and Cons of the Options <!-- optional -->

### Continue using Rollup with declaration maps

- Bad, needed to edit the package.json and have the types point to the actual typescript source files
- Bad, needed to introduce an additional `publish` directory to support a modified version of package.json for
  publishing
- Bad, needed to have the .d.ts file saved into the `publish` directory, otherwise it caused an IDE conflict if left in
  the `dist` directory

================
File: docs/decisions/0006-structure-for-flexibility-and-robustness.md
================
# Structure for flexibility and robustness with Variants, Builders and Facades

- Status: accepted
- Deciders: Andrzej Kopeć, Agron Murtezi, Tim Roberts
- Date: April 2025

Technical Story: [Wallet Rewrite](https://shielded.atlassian.net/browse/PM-13769)

## Context and Problem Statement

With the rewrite of Wallet from Scala into TypeScript, multiple questions emerged, aside from just rewritting needed
functionality:

- whether or not make some Rust code part of the wallet codebase?
- how to structure the code to provide a scalable basis for handling future hard-forks? Specifically - where and how to
  put abstractions so that each implementation of e.g. shielded tokens wallet can be provided in a separate, independent
  package, possibly even with a completely different API?
- how to structure the code to reduce cognitive load regarding all wallet functionality (unshielded tokens, shielded
  tokens, Dust...)
- how to structure the APIs so that the flexibility present internally can be accessed by the SDK users?

In Scala - a lot can be done with typeclasses, but in TypeScript - there is no direct replacement for this
functionality. Figuring out how to access needed implementation of a variant (implementation of a wallet compatible with
specific protocol version) and how to expose its API suddenly becomes a tricky problem.

## Decision Drivers

- Ability to scale the Wallet SDK codebase as new kinds of tokens and hard forks appear
- Ability to provide flexible APIs to support cases where adjustments are needed - e.g. faucet needs a coin selection
  allowing for maximum parallelism of transactions issued, or a wallet able to work with proof-erased transactions
- Ability to implement a facade API similar to the existing Scala one
- Maintain functional spirit of the codebase - specifically the separation between services (side-effecting, but not
  state-changing, implementations for interacting with outer world) and capabilities (pure implementations of
  functionalities, possibly returning new, updated Wallet state as a result of the operation) as indicated in
  [0002 Abstract over Wallet decision](./0002-abstract-over-wallet.md)
- Safely manage the state - specifically allow for implementation of the Bloc pattern as ADRs
  [0005](./0005-wallet-balance-observable.md) and [0001](./0001-bloc-wallet-state.md) indicate
- Get as much type-safety, as reasonably possible with TypeScript
- The implementation needs to feel somehow idiomatic in TypeScript

## Considered Options

There were different options considered at each axis.

### How to manage variant APIs

- Create a singular API, which all variants of a wallet would need to implement
- Let each variant implement its own API, let the facade code dispatch calls accordingly to the situation, providing
  single, unified API at the same time

### How to manage implementations of functionalities

- Gather all implementations through Effect's services, not separating capabilities and services
- Gather all implementations through a builder pattern independently from Effect's services, allowing to separate
  capabilities and services

### How to expose APIs and integrate them

- Expect Effect-based APIs at integration points, expose more idiomatic, Promise- and rx.js-based API at the facades
- Expect idiomatic, rx.js- and Promise-based API at integration points, expose such as well
- Expose and expect Effect-based APIs

## Decision Outcome

After some experiments and initial implementations, following options were chosen:

1. To not include any Rust code just yet. It might be reconsidered in the future, if a need arises or there is
   sufficient time to train TypeScript developers in Rust.
2. To manage variant APIs in a way, where each variant defines its own, very specific API. The class gathering different
   variants called `WalletBuilder` and its `Runtime` offer facilities to dispatch to either specific variant (e.g. when
   initializing wallet) as well as `current` one.
3. To manage implementations of services and capabilities through builder pattern. Mostly because of TypeScript's
   limitations (lack of higher-kinded types) Effect's services can't work with uninstantiated generic types.
4. To expose idiomatic rx.js- and Promise-based APIs, but expect integration through Effect APIs. Although it needs to
   be revisited, it is current status quo, and seems to be a good compromise, especially in the presence of
   [0004 Use Effect decision](./0004-use-effect.md).

### Positive Consequences

- Wallet SDK Codebase contains only TypeScript code, making it simpler to onboard new developers
- Domain wallet code from Scala ports really well
- Overall type-safety of the solution is at a really good level
- Using public APIs, it is possible to assemble a wallet operating with proof-erased transactions while maintaining the
  same code for transacting and state management
- Using public APIs, it is possible to override almost arbitrary aspect of wallet functionality through the usage of the
  builder pattern
- Facade API for the shielded wallet is really close to existing API
- Integrating purely functional updates (implemented by capabilities) on top of Effect's `SubscriptionRef` is trivial
  and idiomatic, while still allows for side-effecting operations if absolutely needed
- `WalletBuilder` and `Runtime` implementations are very generic and not tied to any specific functionalities other than
  the ability to gather variants and switch between them

### Negative Consequences

- Some of Wallet SDK code already is needed in Rust, which leads to some duplications
- Type machinery enabling the `Runtime` and `WalletBuilder` is relatively complex and relies on a lot of TypeScript's
  inferences
- Very generic and abstract code of the `Runtime` and `WalletBuilder` might be hard to approach at first
- There are overall multiple layers of abstractions introduced, which only start to make sense once everything is
  assembled

## Pros and Cons of the other Options

### Singular API to implement by all variants

An example of the idea:

```ts
// WalletAPI.ts
export interface WalletAPI {
  makeTransfer(params: { amount: bigint; recipient: string }): Promise<Transaction>;
}
// Variant1.ts
export class Variant1 implements WalletAPI {
  makeTransfer(params: { amount: bigint; recipient: string }): Promise<Transaction> {
    /* */
  }
}

// Variant2.ts
export class Variant2 implements WalletAPI {
  makeTransfer(params: { amount: bigint; recipient: string }): Promise<Transaction> {
    /**/
  }
}

// Wallet.ts
export const Wallet = new WalletBuilder<WalletAPI>().addVariant(Variant1).addVariant(Variant2);
```

- Good, because it is the reason of having interfaces
- Bad, because the API could not be type-safe
- Bad, because accomodating future variants would force past ones to be changed

### Gather all implementations through Effect's services, not separating capabilities and services

An example usage could look like this:

```ts
Wallet.makeTransfer({ amount: 42n, to: 'mn_shield-addr1foobar' }).pipe(
  Effect.provideLayer(TransactingService.layer()),
  Effect.provideLayer(WalletStateService.layer()),
);
```

- Good, because it is the idiomatic way of providing dependencies with Effect
- Bad, because it does not promote separating state, operations and side-effects
- Bad, because it does not allow to implement a flavour of wallet operating on proof-erased transactions

### Expect idiomatic, rx.js- and Promise-based API at integration points, expose such as well

For example:

```ts
interface SyncService<S, U> {
  sync(initialState: S): rx.Observable<U>;
}

interface WalletBuilder {
  withSync<U>(service: SyncService<State, U>): WalletBuilder;
  build(): Wallet;
}

interface Wallet {
  state$: rx.Observable<State>;
  makeTransfer(params: { amount: bigint; recipient: string }): Promise<Transaction>;
}
```

- Good, because it hides Effect's complexity from users
- Good, because it makes it easier for the users to provide their implementation
- Bad, because it works particularly bad with the Effect's resource management

### Expose and expect Effect-based APIs

For example:

```ts
interface SyncService<S, U> {
  sync(initialState: S): Stream.Stream<U, WalletError>;
}

interface WalletBuilder {
  withSync<U>(service: SyncService<State, U>): WalletBuilder;
  build(): Wallet;
}

interface Wallet {
  state$: Stream.Stream<State, WalletError>;
  makeTransfer(params: { amount: bigint; recipient: string }): Effect.Effect<Transaction>;
}
```

- Good, because it is the most coherent approach
- Good, because it allows fully leveraging Effect's strengths
- Bad, because it might be too unfamiliar for the users - Effect is quite popular, but not ubiquitous, and it introduces
  some idioms common to e.g. Scala, but somewhat foreign to idiomatic TypeScript

================
File: docs/wallet-component-diagram.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="1680" height="1512"><g id="Browser extension wallet Component Diagram"><g id="Browser extension wallet"><rect width="1128" height="800" rx="8" ry="8" fill-opacity="0.02" fill="#000000" stroke-opacity="1" stroke-width="2" stroke="#cfd2d2" opacity="1" x="32" y="680"></rect><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="15" font-weight="500" fill="#0c0d0d" opacity="1" x="48" y="711.375"><tspan dy="0" x="48">Browser extension wallet</tspan></text><g id="App" opacity="1"><text font-family="Courier New, monospace" font-size="12" text-anchor="middle" fill="#595f61" x="596" y="1468.6552734375"><tspan dy="0" x="596">App</tspan></text></g></g><g id="Proof server"><rect width="352" height="248" rx="8" ry="8" fill-opacity="0.02" fill="#000000" stroke-opacity="1" stroke-width="2" stroke="#cfd2d2" opacity="1" x="1248" y="400"></rect><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="15" font-weight="500" fill="#0c0d0d" opacity="1" x="1264" y="431.375"><tspan dy="0" x="1264">Proof server</tspan></text><g id="App in: other context" opacity="1"><text font-family="Courier New, monospace" font-size="12" text-anchor="middle" fill="#595f61" x="1424" y="636.6552734375"><tspan dy="0" x="1424">App in: other context</tspan></text></g></g><g id="Proof server"><rect width="448" height="368" rx="8" ry="8" fill-opacity="0.02" fill="#000000" stroke-opacity="1" stroke-width="2" stroke="#cfd2d2" opacity="1" x="1200" y="344"></rect><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="15" font-weight="500" fill="#0c0d0d" opacity="1" x="1216" y="375.375"><tspan dy="0" x="1216">Proof server</tspan></text><g opacity="1"><text font-family="IBM Plex Sans, Arial, sans-serif" font-size="14" text-anchor="middle" fill="#595f61" x="1424" y="677.2500000000001"><tspan dy="0" x="1424">Computes ZK proofs</tspan></text></g><g id="System in: other context" opacity="1"><text font-family="Courier New, monospace" font-size="12" text-anchor="middle" fill="#595f61" x="1424" y="700.6552734375"><tspan dy="0" x="1424">System in: other context</tspan></text></g></g><g id="Indexer"><rect width="352" height="248" rx="8" ry="8" fill-opacity="0.02" fill="#000000" stroke-opacity="1" stroke-width="2" stroke="#cfd2d2" opacity="1" x="1200" y="32"></rect><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="15" font-weight="500" fill="#0c0d0d" opacity="1" x="1216" y="63.375"><tspan dy="0" x="1216">Indexer</tspan></text><g opacity="1"><text font-family="IBM Plex Sans, Arial, sans-serif" font-size="10" text-anchor="middle" fill="#595f61" x="1376" y="237.75"><tspan dy="0" x="1376">Collects data for efficient querying by user-facing applications; enables</tspan></text><text font-family="IBM Plex Sans, Arial, sans-serif" font-size="10" text-anchor="middle" fill="#595f61" x="1375.9999999999998" y="249.75"><tspan dy="0" x="1375.9999999999998">lightweight wallets</tspan></text></g><g id="System in: other context" opacity="1"><text font-family="Courier New, monospace" font-size="12" text-anchor="middle" fill="#595f61" x="1376" y="268.6552734375"><tspan dy="0" x="1376">System in: other context</tspan></text></g></g><g id="proves token movements with"><polyline points="208,736 208,712 208.71,698.13 210.82,684.88 216.51,666.15 221.92,654.4 232.38,637.86 240.85,627.53 255.68,613.05 266.94,604.06 285.77,591.52 306.81,580.08 329.92,569.69 354.95,560.31 381.78,551.89 410.26,544.39 440.25,537.75 471.6,531.94 504.19,526.91 572.5,519 607.95,516.02 656.22,512.97 742.5899999999999,509.85 829.8199999999999,509.03 916.14,509.95 1011.41,512.36 1208.13,518.98 1296,520" fill="none" stroke-width="1" stroke="#adb3b3" opacity="1"></polyline></g><g id="proves token movements with"><rect width="118.848" height="38.2" x="638.5775556736496" y="492.3606975373187" rx="4" ry="4" fill-opacity="0.8" fill="#e5e7e8" stroke-opacity="1" stroke-width="1" stroke="#cfd2d2" opacity="0.8"></rect><g opacity="1" fill="#434647"><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="698.0015556736496" y="508.7106975373187"><tspan dy="0" x="698.0015556736496">proves token</tspan></text><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="698.0015556736496" y="524.7106975373188"><tspan dy="0" x="698.0015556736496">movements with</tspan></text></g></g><g id="Proves Dust payments with"><polyline points="984,736 984.31,702.28 986.75,683.6 991.48,665.93 998.35,649.26 1007.2,633.61 1012.32,626.16 1023.85,612.02 1036.97,598.9 1044.08,592.71 1059.3,581.1 1084.3400000000001,565.5699999999999 1111.56,552.3199999999999 1140.44,541.3299999999999 1170.46,532.62 1201.0900000000001,526.19 1231.81,522.02 1262.0900000000001,520.13 1296,520" fill="none" stroke-width="1" stroke="#adb3b3" opacity="1"></polyline></g><g id="Proves Dust payments with"><rect width="106.864" height="38.2" x="1034.6148488590024" y="544.6656007574658" rx="4" ry="4" fill-opacity="0.8" fill="#e5e7e8" stroke-opacity="1" stroke-width="1" stroke="#cfd2d2" opacity="0.8"></rect><g opacity="1" fill="#434647"><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="1088.0468488590027" y="561.0156007574659"><tspan dy="0" x="1088.0468488590027">Proves Dust</tspan></text><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="1088.0468488590025" y="577.0156007574659"><tspan dy="0" x="1088.0468488590025">payments with</tspan></text></g></g><g id="Learns its state with help of"><polyline points="272,736 272.15,705.77 273.35,693.2 277.34000000000003,674.03 283.84000000000003,654.56 292.73,634.81 303.90999999999997,614.84 317.26,594.6800000000001 338.24,567.61 356.19,547.21 382.89,519.97 404.83,499.56 436.41,472.47 461.7,452.3 497.34000000000003,425.7 534.91,399.5 574.14,373.84 614.76,348.8 656.5,324.5 699.0799999999999,301.04 753.0699999999999,273.06 796.54,251.88 850.77,227.07999999999998 893.75,208.70999999999998 946.49,187.76 997.67,169.24 1037.12,156.32 1084.1100000000001,142.69000000000005 1119.52,133.94000000000005 1160.5900000000001,125.87 1190.5700000000002,121.84000000000003 1217.7,120.07000000000005 1248,120" fill="none" stroke-width="1" stroke="#adb3b3" opacity="1"></polyline></g><g id="Learns its state with help of"><rect width="141.40200000000002" height="38.2" x="604.8457464310783" y="294.90594947691176" rx="4" ry="4" fill-opacity="0.8" fill="#e5e7e8" stroke-opacity="1" stroke-width="1" stroke="#cfd2d2" opacity="0.8"></rect><g opacity="1" fill="#434647"><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="675.5467464310783" y="311.2559494769118"><tspan dy="0" x="675.5467464310783">Learns its state with</tspan></text><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="675.5467464310783" y="327.2559494769118"><tspan dy="0" x="675.5467464310783">help of</tspan></text></g></g><g id="Learns its state from"><polyline points="488,736 488,712 488.69,700.02 490.72,687.62 496.19,668.26 504.42,648.1 515.25,627.23 528.52,605.76 544.0699999999999,583.77 561.74,561.36 581.36,538.64 602.79,515.7 633.88,484.94 658.88,461.86 685.15,438.89 712.53,416.13 750.47,386.26 779.8,364.35 819.77,335.98 850.19,315.46 891.03,289.28 931.8299999999999,264.69 972.24,241.89999999999998 1011.86,221.16000000000003 1040.8200000000002,207.07999999999998 1078.15,190.45 1104.97,179.73000000000002 1138.85,167.95 1162.6399999999999,161.12 1184.87,156.12 1205.38,153.05 1218.01,152.12 1248,152" fill="none" stroke-width="1" stroke="#adb3b3" opacity="1"></polyline></g><g id="Learns its state from"><rect width="109.97200000000001" height="38.2" x="738.052906380888" y="335.8532580929249" rx="4" ry="4" fill-opacity="0.8" fill="#e5e7e8" stroke-opacity="1" stroke-width="1" stroke="#cfd2d2" opacity="0.8"></rect><g opacity="1" fill="#434647"><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="793.038906380888" y="352.2032580929249"><tspan dy="0" x="793.038906380888">Learns its state</tspan></text><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="793.038906380888" y="368.2032580929249"><tspan dy="0" x="793.038906380888">from</tspan></text></g></g><g id="Learns its state with help of"><polyline points="920,736 920.51,699.22 922.01,684.98 926.02,661.12 929.8199999999999,643.73 937.09,615.74 953.06,565.02 973.29,510.87 997.15,455.23 1024,400 1041.27,367.87 1053.19,347.12 1077.8,307.79 1103.17,272.18 1116.04,256.07 1128.97,241.26999999999998 1141.94,227.88 1154.88,216.04000000000002 1167.78,205.86 1180.5700000000002,197.48000000000002 1193.23,191 1199.49,188.51999999999998 1211.87,185.14999999999998 1217.97,184.29000000000002 1248,184" fill="none" stroke-width="1" stroke="#adb3b3" opacity="1"></polyline></g><g id="Learns its state with help of"><rect width="141.40200000000002" height="38.2" x="947.5567603433095" y="392.7116907351587" rx="4" ry="4" fill-opacity="0.8" fill="#e5e7e8" stroke-opacity="1" stroke-width="1" stroke="#cfd2d2" opacity="0.8"></rect><g opacity="1" fill="#434647"><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="1018.2577603433095" y="409.0616907351587"><tspan dy="0" x="1018.2577603433095">Learns its state with</tspan></text><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="1018.2577603433095" y="425.0616907351587"><tspan dy="0" x="1018.2577603433095">help of</tspan></text></g></g><g id="Exchanges state and requests with"><polyline points="488,1288 488,1136" fill="none" stroke-width="1" stroke="#adb3b3" opacity="1"></polyline></g><g id="Exchanges state and requests with"><rect width="127.08000000000001" height="38.2" x="424.46" y="1192.9" rx="4" ry="4" fill-opacity="0.8" fill="#e5e7e8" stroke-opacity="1" stroke-width="1" stroke="#cfd2d2" opacity="0.8"></rect><g opacity="1" fill="#434647"><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="488" y="1209.25"><tspan dy="0" x="488">Exchanges state</tspan></text><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="488" y="1225.25"><tspan dy="0" x="488">and requests with</tspan></text></g></g><g id="Manages unshielded tokens (and Night) with"><polyline points="488,1008 488,864" fill="none" stroke-width="1" stroke="#adb3b3" opacity="1"></polyline></g><g id="Manages unshielded tokens (and Night) with"><rect width="129.85199999999998" height="54.2" x="423.074" y="908.9" rx="4" ry="4" fill-opacity="0.8" fill="#e5e7e8" stroke-opacity="1" stroke-width="1" stroke="#cfd2d2" opacity="0.8"></rect><g opacity="1" fill="#434647"><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="488" y="925.2500000000001"><tspan dy="0" x="488">Manages</tspan></text><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="488" y="941.2500000000001"><tspan dy="0" x="488">unshielded tokens</tspan></text><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="488" y="957.2500000000001"><tspan dy="0" x="488">(and Night) with</tspan></text></g></g><g id="Manages shielded tokens with"><polyline points="424,1008 424,984 423.09,971.03 420.46,960.53 416.29,952.23 410.75,945.9 404.02,941.29 396.25,938.1600000000001 387.63,936.25 368.5,935.14 337.65999999999997,936.55 317.68,936.6700000000001 308.37,935.75 299.75,933.8399999999999 291.98,930.71 285.25,926.1 279.71000000000004,919.77 275.53999999999996,911.47 272.90999999999997,900.97 272,888 272,864" fill="none" stroke-width="1" stroke="#adb3b3" opacity="1"></polyline></g><g id="Manages shielded tokens with"><rect width="127.276" height="38.2" x="284.3605430544968" y="916.9773234206601" rx="4" ry="4" fill-opacity="0.8" fill="#e5e7e8" stroke-opacity="1" stroke-width="1" stroke="#cfd2d2" opacity="0.8"></rect><g opacity="1" fill="#434647"><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="347.99854305449685" y="933.3273234206603"><tspan dy="0" x="347.99854305449685">Manages shielded</tspan></text><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="347.99854305449685" y="949.3273234206603"><tspan dy="0" x="347.99854305449685">tokens with</tspan></text></g></g><g id="Manages Dust with"><polyline points="552,1008 552,984 552.53,976.52 554.1,969.73 556.66,963.6 560.17,958.1 564.58,953.2 569.85,948.88 575.9300000000001,945.1 590.37,939.05 607.54,934.8199999999999 617.04,933.3199999999999 637.64,931.38 660.1,930.6800000000001 684.06,930.98 722.03,932.78 826.8399999999999,939.96 875.9,941.3199999999999 898.36,940.62 918.96,938.6800000000001 937.37,935.28 945.63,932.95 960.07,926.9 966.15,923.12 971.42,918.8 975.83,913.9 979.34,908.4 981.9,902.27 983.47,895.48 984,888 984,864" fill="none" stroke-width="1" stroke="#adb3b3" opacity="1"></polyline></g><g id="Manages Dust with"><rect width="133.548" height="22.2" x="701.2295349760969" y="924.8294130438734" rx="4" ry="4" fill-opacity="0.8" fill="#e5e7e8" stroke-opacity="1" stroke-width="1" stroke="#cfd2d2" opacity="0.8"></rect><g opacity="1" fill="#434647"><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="768.003534976097" y="941.1794130438735"><tspan dy="0" x="768.003534976097">Manages Dust with</tspan></text></g></g><g id="Learns Night UTXOs from"><polyline points="856,800 616,800" fill="none" stroke-width="1" stroke="#adb3b3" opacity="1"></polyline></g><g id="Learns Night UTXOs from"><rect width="139.596" height="38.2" x="666.202" y="780.9" rx="4" ry="4" fill-opacity="0.8" fill="#e5e7e8" stroke-opacity="1" stroke-width="1" stroke="#cfd2d2" opacity="0.8"></rect><g opacity="1" fill="#434647"><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="736" y="797.2500000000001"><tspan dy="0" x="736">Learns Night UTXOs</tspan></text><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="14" text-anchor="middle" x="736" y="813.2500000000001"><tspan dy="0" x="736">from</tspan></text></g></g><a href="https://app.icepanel.io/landscapes/yERCUolKk91aYF1pzsql/versions/latest/model/objects?object=hyjurnfxqh9&amp;focus=hyjurnfxqh9" id="Wallet SDK - Facade" target="_blank"><rect width="256" height="128" rx="8" ry="8" fill-opacity="0.8" fill="#f5f6f6" stroke-opacity="1" stroke-width="1" stroke="#adb3b3" opacity="1" x="360" y="1008"></rect><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="24" font-weight="500" text-anchor="middle" fill="#0c0d0d" opacity="1" x="488" y="1077"><tspan dy="0" x="488">Wallet SDK - Facade</tspan></text><g id="Component" opacity="1"><text font-family="Courier New, monospace" font-size="12" text-anchor="middle" fill="#595f61" x="488" y="1124.6552734375"><tspan dy="0" x="488">Component</tspan></text></g></a><a href="https://app.icepanel.io/landscapes/yERCUolKk91aYF1pzsql/versions/latest/model/objects?object=1b5euxd6q8n&amp;focus=1b5euxd6q8n" id="Wallet frontend" target="_blank"><rect width="256" height="128" rx="8" ry="8" fill-opacity="0.8" fill="#f5f6f6" stroke-opacity="1" stroke-width="1" stroke="#adb3b3" opacity="1" x="360" y="1288"></rect><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="24" font-weight="500" text-anchor="middle" fill="#0c0d0d" opacity="1" x="488.00000000000006" y="1357"><tspan dy="0" x="488.00000000000006">Wallet frontend</tspan></text><g id="Component" opacity="1"><text font-family="Courier New, monospace" font-size="12" text-anchor="middle" fill="#595f61" x="488" y="1404.6552734375"><tspan dy="0" x="488">Component</tspan></text></g></a><a href="https://app.icepanel.io/landscapes/yERCUolKk91aYF1pzsql/versions/latest/model/objects?object=wbd467n7bl&amp;focus=wbd467n7bl" id="API server" target="_blank"><rect width="256" height="128" rx="8" ry="8" fill-opacity="0.8" fill="#f5f6f6" stroke-opacity="1" stroke-width="1" stroke="#adb3b3" opacity="1" x="1296" y="456"></rect><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="24" font-weight="500" text-anchor="middle" fill="#0c0d0d" opacity="1" x="1424" y="525"><tspan dy="0" x="1424">API server</tspan></text><g id="Component" opacity="1"><text font-family="Courier New, monospace" font-size="12" text-anchor="middle" fill="#595f61" x="1424" y="572.6552734375"><tspan dy="0" x="1424">Component</tspan></text></g></a><a href="https://app.icepanel.io/landscapes/yERCUolKk91aYF1pzsql/versions/latest/model/objects?object=sgc9w5jbjv&amp;focus=sgc9w5jbjv" id="Wallet SDK - Shielded" target="_blank"><rect width="256" height="128" rx="8" ry="8" fill-opacity="0.8" fill="#f5f6f6" stroke-opacity="1" stroke-width="1" stroke="#adb3b3" opacity="1" x="80" y="736"></rect><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="24" font-weight="500" text-anchor="middle" fill="#0c0d0d" opacity="1" x="208" y="805.0000000000001"><tspan dy="0" x="208">Wallet SDK - Shielded</tspan></text><g id="Component" opacity="1"><text font-family="Courier New, monospace" font-size="12" text-anchor="middle" fill="#595f61" x="208" y="852.6552734375"><tspan dy="0" x="208">Component</tspan></text></g></a><a href="https://app.icepanel.io/landscapes/yERCUolKk91aYF1pzsql/versions/latest/model/objects?object=j7g9g6l7osm&amp;focus=j7g9g6l7osm" id="Wallet SDK - Unshielded" target="_blank"><rect width="256" height="128" rx="8" ry="8" fill-opacity="0.8" fill="#f5f6f6" stroke-opacity="1" stroke-width="1" stroke="#adb3b3" opacity="1" x="360" y="736"></rect><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="24" font-weight="500" text-anchor="middle" fill="#0c0d0d" opacity="1" x="488" y="792.0000000000001"><tspan dy="0" x="488">Wallet SDK -</tspan></text><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="24" font-weight="500" text-anchor="middle" fill="#0c0d0d" opacity="1" x="488" y="818.0000000000001"><tspan dy="0" x="488">Unshielded</tspan></text><g id="Component" opacity="1"><text font-family="Courier New, monospace" font-size="12" text-anchor="middle" fill="#595f61" x="488" y="852.6552734375"><tspan dy="0" x="488">Component</tspan></text></g></a><a href="https://app.icepanel.io/landscapes/yERCUolKk91aYF1pzsql/versions/latest/model/objects?object=srw3gwh3ma&amp;focus=srw3gwh3ma" id="Wallet SDK - Dust" target="_blank"><rect width="256" height="128" rx="8" ry="8" fill-opacity="0.8" fill="#f5f6f6" stroke-opacity="1" stroke-width="1" stroke="#adb3b3" opacity="1" x="856" y="736"></rect><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="24" font-weight="500" text-anchor="middle" fill="#0c0d0d" opacity="1" x="983.9999999999999" y="805.0000000000001"><tspan dy="0" x="983.9999999999999">Wallet SDK - Dust</tspan></text><g id="Component" opacity="1"><text font-family="Courier New, monospace" font-size="12" text-anchor="middle" fill="#595f61" x="984" y="852.6552734375"><tspan dy="0" x="984">Component</tspan></text></g></a><a href="https://app.icepanel.io/landscapes/yERCUolKk91aYF1pzsql/versions/latest/model/objects?object=04unafxnuq3t&amp;focus=04unafxnuq3t" id="Indexer API" target="_blank"><rect width="256" height="128" rx="8" ry="8" fill-opacity="0.8" fill="#f5f6f6" stroke-opacity="1" stroke-width="1" stroke="#adb3b3" opacity="1" x="1248" y="88"></rect><text font-family="IBM Plex Sans Medium, Arial, sans-serif" font-size="24" font-weight="500" text-anchor="middle" fill="#0c0d0d" opacity="1" x="1376.0000000000002" y="139"><tspan dy="0" x="1376.0000000000002">Indexer API</tspan></text><g opacity="1"><text font-family="IBM Plex Sans, Arial, sans-serif" font-size="14" text-anchor="middle" fill="#595f61" x="1375.9999999999998" y="173.24999999999997"><tspan dy="0" x="1375.9999999999998">API server</tspan></text></g><g id="App" opacity="1"><text font-family="Courier New, monospace" font-size="12" text-anchor="middle" fill="#595f61" x="1376" y="204.6552734375"><tspan dy="0" x="1376">App</tspan></text></g></a><g id="proves token movements with"><polygon points="1287.6269503878912,447.537864719631 1279.6269503878912,463.537864719631 1295.6269503878912,463.537864719631 1287.6269503878912,447.537864719631" fill="#adb3b3" opacity="1" transform="matrix(-0.011607275361060364,0.9999326333102108,-0.9999326333102108,-0.011607275361060364,1758.453556150604,-762.3455119922585)"></polygon><circle r="4" fill="#adb3b3" opacity="1" cx="208" cy="736"></circle></g><g id="Proves Dust payments with"><polygon points="1288.1225004116666,448.15358111911115 1280.1225004116666,464.15358111911115 1296.1225004116666,464.15358111911115 1288.1225004116666,448.15358111911115" fill="#adb3b3" opacity="1" transform="matrix(0.0038336492096778143,0.9999926515398686,-0.9999926515398686,0.0038336492096778143,1739.2120780747164,-769.8310983168997)"></polygon><circle r="4" fill="#adb3b3" opacity="1" cx="984" cy="736"></circle></g><g id="Learns its state with help of"><polygon points="1240.0738631497065,48.09249438865962 1232.0738631497065,64.09249438865962 1248.0738631497065,64.09249438865962 1240.0738631497065,48.09249438865962" fill="#adb3b3" opacity="1" transform="matrix(0.002310224858083656,0.9999973314269919,-0.9999973314269919,0.002310224858083656,1293.227516585819,-1120.181658398091)"></polygon><circle r="4" fill="#adb3b3" opacity="1" cx="272" cy="736"></circle></g><g id="Learns its state from"><polygon points="1240.1278495301244,80.16030823752773 1232.1278495301244,96.16030823752773 1248.1278495301244,96.16030823752773 1240.1278495301244,80.16030823752773" fill="#adb3b3" opacity="1" transform="matrix(0.004001301746289696,0.9999919947601257,-0.9999919947601257,0.004001301746289696,1323.1975408050844,-1088.4386675905478)"></polygon><circle r="4" fill="#adb3b3" opacity="1" cx="488" cy="736"></circle></g><g id="Learns its state with help of"><polygon points="1240.307890884804,112.38775439671579 1232.307890884804,128.3877543967158 1248.307890884804,128.3877543967158 1240.307890884804,112.38775439671579" fill="#adb3b3" opacity="1" transform="matrix(0.009656559392594436,0.9999533743433727,-0.9999533743433727,0.009656559392594436,1348.4054074304377,-1057.3353397403037)"></polygon><circle r="4" fill="#adb3b3" opacity="1" cx="920" cy="736"></circle></g><g id="Exchanges state and requests with"><polygon points="488,1136 480,1152 496,1152 488,1136" fill="#adb3b3" opacity="1" transform="matrix(1,0,0,1,0,0)"></polygon><polygon points="424,1208 416,1224 432,1224 424,1208" fill="#adb3b3" opacity="1" transform="matrix(-1,1.2246467991473532e-16,-1.2246467991473532e-16,-1,912.0000000000002,2496)"></polygon></g><g id="Manages unshielded tokens (and Night) with"><polygon points="488,864 480,880 496,880 488,864" fill="#adb3b3" opacity="1" transform="matrix(1,0,0,1,0,0)"></polygon><circle r="4" fill="#adb3b3" opacity="1" cx="488" cy="1008"></circle></g><g id="Manages shielded tokens with"><polygon points="272,864 264,880 280,880 272,864" fill="#adb3b3" opacity="1" transform="matrix(1,0,0,1,0,0)"></polygon><circle r="4" fill="#adb3b3" opacity="1" cx="424" cy="1008"></circle></g><g id="Manages Dust with"><polygon points="984,864 976,880 992,880 984,864" fill="#adb3b3" opacity="1" transform="matrix(1,0,0,1,0,0)"></polygon><circle r="4" fill="#adb3b3" opacity="1" cx="552" cy="1008"></circle></g><g id="Learns Night UTXOs from"><polygon points="560,792 552,808 568,808 560,792" fill="#adb3b3" opacity="1" transform="matrix(-1.8369701987210297e-16,-1,1,-1.8369701987210297e-16,-175.9999999999999,1360)"></polygon><circle r="4" fill="#adb3b3" opacity="1" cx="856" cy="800"></circle></g></g></svg>

================
File: packages/abstractions/src/test/protocolVersion.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Schema } from 'effect';
import { describe, expect, it } from 'vitest';
import * as ProtocolVersion from '../ProtocolVersion.js';

describe('ProtocolVersion', () => {
  describe('is', () => {
    it('should return true for valid values', () => {
      expect(ProtocolVersion.is(100n)).toBeTruthy();
      expect(ProtocolVersion.is(ProtocolVersion.ProtocolVersion(100n))).toBeTruthy();
    });

    it('should return false for invalid values', () => {
      expect(ProtocolVersion.is('some-string')).toBeFalsy();
      expect(ProtocolVersion.is(100)).toBeFalsy();
      expect(ProtocolVersion.is(100.0)).toBeFalsy();
      expect(ProtocolVersion.is({ protocolVersion: 100n })).toBeFalsy();
    });
  });

  it.each([ProtocolVersion.MinSupportedVersion, ProtocolVersion.MaxSupportedVersion])(
    'should be encodable and decodable',
    (input) => {
      const encodedString = Schema.encodeSync(ProtocolVersion.ProtocolVersionSchema)(input);

      expect(encodedString).toBe(Number(input).toString());

      const protocolVersion = Schema.decodeSync(ProtocolVersion.ProtocolVersionSchema)(encodedString);

      expect(ProtocolVersion.is(protocolVersion)).toBeTruthy();
      expect(protocolVersion).toBe(input);
    },
  );
});

================
File: packages/abstractions/src/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * as WalletSeed from './WalletSeed.js';
export * as WalletState from './WalletState.js';
export * from './SerializedTransaction.js';
export * from './SerializedUnprovenTransaction.js';
export * as ProtocolState from './ProtocolState.js';
export * as ProtocolVersion from './ProtocolVersion.js';
export * as NetworkId from './NetworkId.js';

================
File: packages/abstractions/src/NetworkId.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export const NetworkId = {
  MainNet: 'mainnet',
  TestNet: 'testnet',
  DevNet: 'devnet',
  QaNet: 'qanet',
  Undeployed: 'undeployed',
  Preview: 'preview',
  PreProd: 'preprod',
} as const;

export type NetworkId = (typeof NetworkId)[keyof typeof NetworkId];

================
File: packages/abstractions/src/ProtocolState.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ProtocolVersion from './ProtocolVersion.js';

/**
 * A type that associates some state with a given version of the Midnight protocol.
 *
 * @typeParam TState The type of state.
 */
export type ProtocolState<TState> = Readonly<{ version: ProtocolVersion.ProtocolVersion; state: TState }>;

export const state = <TState>(ps: ProtocolState<TState>): TState => ps.state;

================
File: packages/abstractions/src/ProtocolVersion.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as Brand from 'effect/Brand';
import * as Schema from 'effect/Schema';

/**
 * A branded `bigint` that represents a protocol version.
 */
export type ProtocolVersion = Brand.Branded<bigint, 'ProtocolVersion'>;

/**
 * Constructs a branded `bigint` represents a protocol version.
 */
export const ProtocolVersion = Brand.nominal<ProtocolVersion>();

export declare namespace ProtocolVersion {
  /**
   * A tuple type that represents a start and ending protocol version.
   */
  type Range = readonly [start: ProtocolVersion, end: ProtocolVersion];
}

/**
 * Creates a new protocol version range.
 *
 * @param start The start value.
 * @param end The end value.
 * @returns A {@link ProtocolVersion.Range} defined by `start` and `end`.
 *
 * @throws `TypeError`
 * Thrown when `start` is after `end`, or the difference between them is less than one.
 */
// TODO: make it possible to represent an open range on the end side to remove special "MaxSupportedVersion"
export const makeRange = (start: ProtocolVersion, end: ProtocolVersion): ProtocolVersion.Range => {
  if (end - start < 1) throw new TypeError('Invalid protocol version range.');
  return [start, end] as const;
};

/**
 * Determines if a given protocol version is within a given range.
 *
 * @param version The version to test.
 * @param range The {@link ProtocolVersion.Range} to test `version` against.
 * @returns `true` if `version` is within the range defined by `range`.
 */
export const withinRange = (version: ProtocolVersion, range: ProtocolVersion.Range): boolean => {
  const [min, max] = range;
  return version >= min && version < max;
};

/**
 * A schema that transforms a `bigint` into a {@link ProtocolVersion}.
 */
export const ProtocolVersionSchema = Schema.BigInt.pipe(Schema.fromBrand(ProtocolVersion));

/**
 * A type predicate that determines if a given value is a {@link ProtocolVersion}.
 *
 * @param u The value to test.
 * @returns `true` if `u` has the type {@link ProtocolVersion}.
 */
export const is = Schema.is(ProtocolVersionSchema);

/**
 * Represents the minimum supported protocol version.
 */
export const MinSupportedVersion = ProtocolVersion(0n);

/**
 * Represents the maximum supported protocol version.
 */
export const MaxSupportedVersion = ProtocolVersion(BigInt(Number.MAX_SAFE_INTEGER));

================
File: packages/abstractions/src/SerializedTransaction.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as Brand from 'effect/Brand';

/**
 * A branded `Uint8Array` representing serialized transaction data.
 */
export type SerializedTransaction = Brand.Branded<Uint8Array, 'SerializedTransaction'>;

/**
 * Constructs a branded `Uint8Array` representing serialized transaction data.
 */
export const SerializedTransaction = Brand.nominal<SerializedTransaction>();

================
File: packages/abstractions/src/SerializedUnprovenTransaction.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Brand } from 'effect';

/**
 * A branded `Uint8Array` representing serialized unproven transaction data.
 */
export type SerializedUnprovenTransaction = Brand.Branded<Uint8Array, 'SerializedUnprovenTransaction'>;

/**
 * Constructs a branded `Uint8Array` representing serialized unproven transaction data.
 */
export const SerializedUnprovenTransaction = Brand.nominal<SerializedUnprovenTransaction>();

================
File: packages/abstractions/src/WalletSeed.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as Brand from 'effect/Brand';
import * as Schema from 'effect/Schema';

/**
 * A branded `Uint8Array` that represents a BIP32 compatible seed phrase.
 */
export type WalletSeed = Brand.Branded<Uint8Array, 'WalletSeed'>;

/**
 * Constructs a branded `Uint8Array` representing a BIP32 compatible seed phrase.
 */
export const WalletSeed = Brand.nominal<WalletSeed>();

/**
 * A schema that transforms an array of numbers into a {@link WalletSeed}.
 */
export const WalletSeedSchema = Schema.Uint8Array.pipe(Schema.fromBrand(WalletSeed));

/**
 * A type predicate that determines if a given value is a {@link WalletSeed}.
 *
 * @param u The value to test.
 * @returns `true` if `u` has the type {@link WalletSeed}.
 */
export const is = Schema.is(WalletSeedSchema);

/**
 * Constructs a {@link WalletSeed} from a string representation of a BIP32 compatible seed phrase.
 *
 * @param strValue The string value.
 * @returns A {@link WalletSeed} created from `strValue`.
 */
export const fromString: (strValue: string) => WalletSeed = (strValue) => WalletSeed(Buffer.from(strValue, 'hex'));

================
File: packages/abstractions/src/WalletState.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as Brand from 'effect/Brand';
import * as Schema from 'effect/Schema';

/**
 * A branded `string` representing serialized (JSON) wallet state made up of local state, transaction history,
 * and block height.
 */
export type WalletState = Brand.Branded<string, 'WalletState'>;

/**
 * Constructs a branded `string` representing serialized (JSON) wallet state.
 */
export const WalletState = Brand.nominal<WalletState>();

/**
 * A schema that transforms a string into a {@link WalletState}.
 */
export const WalletStateSchema = Schema.String.pipe(Schema.fromBrand(WalletState));

/**
 * A type predicate that determines if a given value is a {@link WalletState}.
 *
 * @param u The value to test.
 * @returns `true` if `u` has the type {@link WalletState}.
 */
export const is = Schema.is(WalletStateSchema);

================
File: packages/abstractions/.prettierignore
================
dist/
coverage/
reports/

================
File: packages/abstractions/eslint.config.mjs
================
import { packageConfig } from '../../eslint.config.mjs';

export default packageConfig();

================
File: packages/abstractions/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/test/**/*.ts", "src/**/*.test.ts"]
}

================
File: packages/abstractions/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [{ "path": "./tsconfig.build.json" }, { "path": "./tsconfig.test.json" }]
}

================
File: packages/abstractions/tsconfig.publish.json
================
{
  "extends": "./tsconfig.build.json",
  "compilerOptions": {
    "sourceMap": false,
    "declarationMap": false
  }
}

================
File: packages/abstractions/tsconfig.test.json
================
{
  "extends": "./tsconfig.json",
  "include": ["test/**/*.ts", "src/**/*.ts"]
}

================
File: packages/abstractions/vitest.config.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/// <reference types="vitest" />
/// <reference types="vitest/globals" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage',
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }],
    ],
  },
});

================
File: packages/address-format/src/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { DustPublicKey, EncryptionSecretKey, UserAddress } from '@midnight-ntwrk/ledger-v6';
import { bech32m } from '@scure/base';
import * as subsquidScale from '@subsquid/scale-codec';

export const mainnet: unique symbol = Symbol('Mainnet');
export type NetworkId = string | typeof mainnet;
const NetworkId = {
  toString: (networkId: NetworkId): string => {
    return networkId === mainnet ? 'mainnet' : networkId;
  },
};

export type FormatContext = {
  networkId: NetworkId;
};

export type Field = {
  bytes: number;
  modulus: bigint;
};

export const BLSScalar: Field = {
  bytes: 32,
  modulus: BigInt('0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001'),
};

export const ScaleBigInt = {
  encode: (data: bigint): Buffer => {
    const sink = new subsquidScale.ByteSink();
    sink.compact(data);
    return Buffer.from(sink.toBytes());
  },
  decode: (repr: Uint8Array): bigint => {
    const src = new subsquidScale.Src(repr);
    const res = src.compact();
    src.assertEOF();
    return BigInt(res);
  },
};

export const Bech32mSymbol: unique symbol = Symbol('MidnightBech32m');
export type HasCodec<T> = { [Bech32mSymbol]: Bech32mCodec<T> };
export type CodecTarget<T> = T extends HasCodec<infer U> ? U : never;

export class MidnightBech32m {
  public static readonly prefix = 'mn';

  static encode<T extends HasCodec<T>>(networkId: NetworkId, item: T): MidnightBech32m {
    return item[Bech32mSymbol].encode(networkId, item);
  }

  static validateSegment(segmentName: string, segment: string): void {
    const result = /^[A-Za-z1-9-]+$/.test(segment);
    if (!result) {
      throw new Error(
        `Segment ${segmentName}: ${segment} contains disallowed characters. Allowed characters are only numbers, latin letters and a hyphen`,
      );
    }
  }

  static parse(bech32string: string): MidnightBech32m {
    const bech32parsed = bech32m.decodeToBytes(bech32string);
    const [prefix, type, network = mainnet] = bech32parsed.prefix.split('_');
    if (prefix != MidnightBech32m.prefix) {
      throw new Error(`Expected prefix ${MidnightBech32m.prefix}`);
    }
    MidnightBech32m.validateSegment('type', type);
    if (network != mainnet) {
      MidnightBech32m.validateSegment('network', network);
    }

    return new MidnightBech32m(type, network, Buffer.from(bech32parsed.bytes));
  }

  public readonly type: string;
  public readonly network: NetworkId;
  public readonly data: Buffer;

  constructor(type: string, network: NetworkId, data: Buffer) {
    this.data = data;
    this.network = network;
    this.type = type;
    MidnightBech32m.validateSegment('type', type);
    if (network != mainnet) {
      MidnightBech32m.validateSegment('network', network);
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  decode<TClass extends HasCodec<any>>(tclass: TClass, networkId: NetworkId): CodecTarget<TClass> {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return tclass[Bech32mSymbol].decode(networkId, this);
  }

  asString(): string {
    const networkSegment = this.network == mainnet ? '' : `_${this.network}`;
    return bech32m.encode(`${MidnightBech32m.prefix}_${this.type}${networkSegment}`, bech32m.toWords(this.data), false);
  }

  toString(): string {
    return this.asString();
  }
}

export class Bech32mCodec<T> {
  public readonly type: string;
  public readonly dataToBytes: (data: T) => Buffer;
  public readonly dataFromBytes: (bytes: Buffer) => T;

  constructor(type: string, dataToBytes: (data: T) => Buffer, dataFromBytes: (bytes: Buffer) => T) {
    this.dataFromBytes = dataFromBytes;
    this.dataToBytes = dataToBytes;
    this.type = type;
  }

  encode(networkId: NetworkId, data: T): MidnightBech32m {
    const context = Bech32mCodec.createContext(networkId);
    return new MidnightBech32m(this.type, context.networkId, this.dataToBytes(data));
  }

  decode(networkId: NetworkId, repr: MidnightBech32m): T {
    const context = Bech32mCodec.createContext(networkId);
    if (repr.type != this.type) {
      throw new Error(`Expected type ${this.type}, got ${repr.type}`);
    }
    if (context.networkId != repr.network) {
      throw new Error(
        `Expected ${NetworkId.toString(context.networkId)} address, got ${NetworkId.toString(repr.network)} one`,
      );
    }
    return this.dataFromBytes(repr.data);
  }

  static createContext(networkId: NetworkId): FormatContext {
    if (networkId === 'mainnet') {
      return { networkId: mainnet };
    } else {
      return { networkId };
    }
  }
}

export class ShieldedAddress {
  static readonly codec = new Bech32mCodec<ShieldedAddress>(
    'shield-addr',
    (addr) => Buffer.concat([addr.coinPublicKey.data, addr.encryptionPublicKey.data]),
    (bytes) => {
      const coinPublicKey = new ShieldedCoinPublicKey(bytes.subarray(0, ShieldedCoinPublicKey.keyLength));
      const encryptionPublicKey = new ShieldedEncryptionPublicKey(bytes.subarray(ShieldedCoinPublicKey.keyLength));
      return new ShieldedAddress(coinPublicKey, encryptionPublicKey);
    },
  );

  static readonly [Bech32mSymbol]: Bech32mCodec<ShieldedAddress> = ShieldedAddress.codec;
  readonly [Bech32mSymbol]: Bech32mCodec<ShieldedAddress> = ShieldedAddress.codec;

  public readonly coinPublicKey: ShieldedCoinPublicKey;
  public readonly encryptionPublicKey: ShieldedEncryptionPublicKey;

  constructor(coinPublicKey: ShieldedCoinPublicKey, encryptionPublicKey: ShieldedEncryptionPublicKey) {
    this.encryptionPublicKey = encryptionPublicKey;
    this.coinPublicKey = coinPublicKey;
  }

  coinPublicKeyString(): string {
    return this.coinPublicKey.data.toString('hex');
  }

  encryptionPublicKeyString(): string {
    return this.encryptionPublicKey.data.toString('hex');
  }

  equals(other: ShieldedAddress): boolean {
    return this.coinPublicKey.equals(other.coinPublicKey) && this.encryptionPublicKey.equals(other.encryptionPublicKey);
  }
}

export class ShieldedEncryptionSecretKey {
  static readonly codec = new Bech32mCodec<ShieldedEncryptionSecretKey>(
    'shield-esk',
    (esk) => Buffer.from(esk.zswap.yesIKnowTheSecurityImplicationsOfThis_serialize()),
    (repr) => new ShieldedEncryptionSecretKey(EncryptionSecretKey.deserialize(repr)),
  );

  // There are some bits in serialization of field elements and elliptic curve points, that are hard to replicate
  // Thus using zswap implementation directly for serialization purposes
  public readonly zswap: EncryptionSecretKey;

  constructor(zswap: EncryptionSecretKey) {
    this.zswap = zswap;
  }
}

export class ShieldedCoinPublicKey {
  static readonly keyLength = 32;

  static readonly codec: Bech32mCodec<ShieldedCoinPublicKey> = new Bech32mCodec(
    'shield-cpk',
    (cpk) => cpk.data,
    (repr) => new ShieldedCoinPublicKey(repr),
  );

  static fromHexString(hexString: string): ShieldedCoinPublicKey {
    return new ShieldedCoinPublicKey(Buffer.from(hexString, 'hex'));
  }

  public readonly data: Buffer;

  constructor(data: Buffer) {
    this.data = data;
    if (data.length != ShieldedCoinPublicKey.keyLength) {
      throw new Error('Coin public key needs to be 32 bytes long');
    }
  }
  toHexString(): string {
    return this.data.toString('hex');
  }

  equals(other: string): boolean;
  equals(other: ShieldedCoinPublicKey): boolean;
  equals(other: string | ShieldedCoinPublicKey): boolean {
    const otherKey = typeof other === 'string' ? ShieldedCoinPublicKey.fromHexString(other) : other;
    return otherKey.data.equals(this.data);
  }
}

export class ShieldedEncryptionPublicKey {
  static readonly keyLength = 32;

  static readonly codec: Bech32mCodec<ShieldedEncryptionPublicKey> = new Bech32mCodec(
    'shield-epk',
    (cpk) => cpk.data,
    (repr) => new ShieldedEncryptionPublicKey(repr),
  );

  static fromHexString(hexString: string): ShieldedEncryptionPublicKey {
    return new ShieldedEncryptionPublicKey(Buffer.from(hexString, 'hex'));
  }

  public readonly data: Buffer;

  constructor(data: Buffer) {
    this.data = data;
  }

  toHexString(): string {
    return this.data.toString('hex');
  }

  equals(other: string): boolean;
  equals(other: ShieldedEncryptionPublicKey): boolean;
  equals(other: string | ShieldedEncryptionPublicKey): boolean {
    const otherKey = typeof other === 'string' ? ShieldedEncryptionPublicKey.fromHexString(other) : other;
    return otherKey.data.equals(this.data);
  }
}

export class UnshieldedAddress {
  readonly data: Buffer;
  static readonly keyLength = 32;
  static readonly codec: Bech32mCodec<UnshieldedAddress> = new Bech32mCodec(
    'addr',
    (addr) => addr.data,
    (repr) => new UnshieldedAddress(repr),
  );

  static readonly [Bech32mSymbol]: Bech32mCodec<UnshieldedAddress> = UnshieldedAddress.codec;
  readonly [Bech32mSymbol]: Bech32mCodec<UnshieldedAddress> = UnshieldedAddress.codec;

  constructor(data: Buffer) {
    if (data.length != UnshieldedAddress.keyLength) {
      throw new Error('Unshielded address needs to be 32 bytes long');
    }

    this.data = data;
  }

  get hexString(): UserAddress {
    return this.data.toString('hex');
  }

  equals(other: string): boolean;
  equals(other: UnshieldedAddress): boolean;
  equals(other: string | UnshieldedAddress): boolean {
    const otherAddress = typeof other === 'string' ? new UnshieldedAddress(Buffer.from(other, 'hex')) : other;
    return otherAddress.data.equals(this.data);
  }
}

export class DustAddress {
  readonly data: bigint;

  static readonly codec: Bech32mCodec<DustAddress> = new Bech32mCodec(
    'dust',
    (daddr) => daddr.serialize(),
    (repr) => new DustAddress(ScaleBigInt.decode(repr)),
  );

  static readonly [Bech32mSymbol]: Bech32mCodec<DustAddress> = DustAddress.codec;
  readonly [Bech32mSymbol]: Bech32mCodec<DustAddress> = DustAddress.codec;

  static readonly encodePublicKey = (networkId: string, publicKey: DustPublicKey): string => {
    return DustAddress.codec.encode(networkId, new DustAddress(publicKey)).asString();
  };

  constructor(data: bigint) {
    if (data >= BLSScalar.modulus) {
      throw new Error('Dust address is too large');
    }
    this.data = data;
  }

  serialize(): Buffer {
    return ScaleBigInt.encode(this.data);
  }

  equals(other: bigint): boolean;
  equals(other: DustAddress): boolean;
  equals(other: bigint | DustAddress): boolean {
    const otherAddress = typeof other === 'bigint' ? other : other.data;
    return otherAddress === this.data;
  }
}

================
File: packages/address-format/test/addresses.json
================
[
  {
    "seed": "0000000000000000000000000000000000000000000000000000000000000000",
    "networkId": null,
    "shieldedAddress": {
      "hex": "064e092a80b33bee23404c46cfc48fec75a2356a9b01178dd6a62c29f5896f670300063c7753854aea18aa11f04d77b3c7eaa0918e4aa98d5eaf0704d8f4c2fc272899efbb8a71275f2a1aedd29f879021e0962b4730f9b47e1a",
      "bech32m": "mn_shield-addr1qe8qj25qkva7ug6qf3rvl3y0a366ydt2nvq30rwk5ckznavfdansxqqx83m48p22agv25y0sf4mm83l25zgcuj4f34027pcymr6v9lp89zv7lwu2wyn472s6ahfflpusy8sfv268xrumgls6lh0llz"
    },
    "shieldedESK": {
      "hex": "03003844311d8e3580e84bffb35e439848aa547de8a48e01b4f1c9d64596d886dae93887008530fd140e87c1b7df30bf6b5eb1a20082a63cf98a1a",
      "bech32m": "mn_shield-esk1qvqrs3p3rk8rtq8gf0lmxhjrnpy254raazjguqd578yav3vkmzrd46fcsuqg2v8azs8g0sdhmuct7667kx3qpq4x8nuc5xse56kk6"
    },
    "shieldedCPK": {
      "hex": "064e092a80b33bee23404c46cfc48fec75a2356a9b01178dd6a62c29f5896f67",
      "bech32m": "mn_shield-cpk1qe8qj25qkva7ug6qf3rvl3y0a366ydt2nvq30rwk5ckznavfdans20del8"
    }
  },
  {
    "seed": "0000000000000000000000000000000000000000000000000000000000000000",
    "networkId": "my-private-net",
    "shieldedAddress": {
      "hex": "064e092a80b33bee23404c46cfc48fec75a2356a9b01178dd6a62c29f5896f670300063c7753854aea18aa11f04d77b3c7eaa0918e4aa98d5eaf0704d8f4c2fc272899efbb8a71275f2a1aedd29f879021e0962b4730f9b47e1a",
      "bech32m": "mn_shield-addr_my-private-net1qe8qj25qkva7ug6qf3rvl3y0a366ydt2nvq30rwk5ckznavfdansxqqx83m48p22agv25y0sf4mm83l25zgcuj4f34027pcymr6v9lp89zv7lwu2wyn472s6ahfflpusy8sfv268xrumgls6dfm7kv"
    },
    "shieldedESK": {
      "hex": "03003844311d8e3580e84bffb35e439848aa547de8a48e01b4f1c9d64596d886dae93887008530fd140e87c1b7df30bf6b5eb1a20082a63cf98a1a",
      "bech32m": "mn_shield-esk_my-private-net1qvqrs3p3rk8rtq8gf0lmxhjrnpy254raazjguqd578yav3vkmzrd46fcsuqg2v8azs8g0sdhmuct7667kx3qpq4x8nuc5xsy7fzk6"
    },
    "shieldedCPK": {
      "hex": "064e092a80b33bee23404c46cfc48fec75a2356a9b01178dd6a62c29f5896f67",
      "bech32m": "mn_shield-cpk_my-private-net1qe8qj25qkva7ug6qf3rvl3y0a366ydt2nvq30rwk5ckznavfdansj6mrqy"
    }
  },
  {
    "seed": "0000000000000000000000000000000000000000000000000000000000000000",
    "networkId": "dev",
    "shieldedAddress": {
      "hex": "064e092a80b33bee23404c46cfc48fec75a2356a9b01178dd6a62c29f5896f670300063c7753854aea18aa11f04d77b3c7eaa0918e4aa98d5eaf0704d8f4c2fc272899efbb8a71275f2a1aedd29f879021e0962b4730f9b47e1a",
      "bech32m": "mn_shield-addr_dev1qe8qj25qkva7ug6qf3rvl3y0a366ydt2nvq30rwk5ckznavfdansxqqx83m48p22agv25y0sf4mm83l25zgcuj4f34027pcymr6v9lp89zv7lwu2wyn472s6ahfflpusy8sfv268xrumgls6dldmjp"
    },
    "shieldedESK": {
      "hex": "03003844311d8e3580e84bffb35e439848aa547de8a48e01b4f1c9d64596d886dae93887008530fd140e87c1b7df30bf6b5eb1a20082a63cf98a1a",
      "bech32m": "mn_shield-esk_dev1qvqrs3p3rk8rtq8gf0lmxhjrnpy254raazjguqd578yav3vkmzrd46fcsuqg2v8azs8g0sdhmuct7667kx3qpq4x8nuc5xss3ppf8"
    },
    "shieldedCPK": {
      "hex": "064e092a80b33bee23404c46cfc48fec75a2356a9b01178dd6a62c29f5896f67",
      "bech32m": "mn_shield-cpk_dev1qe8qj25qkva7ug6qf3rvl3y0a366ydt2nvq30rwk5ckznavfdanshcnmmw"
    }
  },
  {
    "seed": "0000000000000000000000000000000000000000000000000000000000000000",
    "networkId": "test",
    "shieldedAddress": {
      "hex": "064e092a80b33bee23404c46cfc48fec75a2356a9b01178dd6a62c29f5896f670300063c7753854aea18aa11f04d77b3c7eaa0918e4aa98d5eaf0704d8f4c2fc272899efbb8a71275f2a1aedd29f879021e0962b4730f9b47e1a",
      "bech32m": "mn_shield-addr_test1qe8qj25qkva7ug6qf3rvl3y0a366ydt2nvq30rwk5ckznavfdansxqqx83m48p22agv25y0sf4mm83l25zgcuj4f34027pcymr6v9lp89zv7lwu2wyn472s6ahfflpusy8sfv268xrumgls62hqz4u"
    },
    "shieldedESK": {
      "hex": "03003844311d8e3580e84bffb35e439848aa547de8a48e01b4f1c9d64596d886dae93887008530fd140e87c1b7df30bf6b5eb1a20082a63cf98a1a",
      "bech32m": "mn_shield-esk_test1qvqrs3p3rk8rtq8gf0lmxhjrnpy254raazjguqd578yav3vkmzrd46fcsuqg2v8azs8g0sdhmuct7667kx3qpq4x8nuc5xs0tfua8"
    },
    "shieldedCPK": {
      "hex": "064e092a80b33bee23404c46cfc48fec75a2356a9b01178dd6a62c29f5896f67",
      "bech32m": "mn_shield-cpk_test1qe8qj25qkva7ug6qf3rvl3y0a366ydt2nvq30rwk5ckznavfdanscta72e"
    }
  },
  {
    "seed": "0000000000000000000000000000000000000000000000000000000000000000",
    "networkId": "my-private-net-5",
    "shieldedAddress": {
      "hex": "064e092a80b33bee23404c46cfc48fec75a2356a9b01178dd6a62c29f5896f670300063c7753854aea18aa11f04d77b3c7eaa0918e4aa98d5eaf0704d8f4c2fc272899efbb8a71275f2a1aedd29f879021e0962b4730f9b47e1a",
      "bech32m": "mn_shield-addr_my-private-net-51qe8qj25qkva7ug6qf3rvl3y0a366ydt2nvq30rwk5ckznavfdansxqqx83m48p22agv25y0sf4mm83l25zgcuj4f34027pcymr6v9lp89zv7lwu2wyn472s6ahfflpusy8sfv268xrumgls62ktzmz"
    },
    "shieldedESK": {
      "hex": "03003844311d8e3580e84bffb35e439848aa547de8a48e01b4f1c9d64596d886dae93887008530fd140e87c1b7df30bf6b5eb1a20082a63cf98a1a",
      "bech32m": "mn_shield-esk_my-private-net-51qvqrs3p3rk8rtq8gf0lmxhjrnpy254raazjguqd578yav3vkmzrd46fcsuqg2v8azs8g0sdhmuct7667kx3qpq4x8nuc5xssva0e5"
    },
    "shieldedCPK": {
      "hex": "064e092a80b33bee23404c46cfc48fec75a2356a9b01178dd6a62c29f5896f67",
      "bech32m": "mn_shield-cpk_my-private-net-51qe8qj25qkva7ug6qf3rvl3y0a366ydt2nvq30rwk5ckznavfdans45shlk"
    }
  },
  {
    "seed": "0101010101010101010101010101010101010101010101010101010101010101",
    "networkId": null,
    "shieldedAddress": {
      "hex": "8f5b7ca223168e1d96820511305228b21b8d41223df2ac188c636533f085793e0300c26d501c90c3c717a43d21b66facfb6e30b32ab13a86aba90447c60164bebdc73d597d8939db382bca7a00bf9636a1a3d1158d9e2bbcb109",
      "bech32m": "mn_shield-addr13adheg3rz68pm95zq5gnq53gkgdc6sfz8he2cxyvvdjn8uy90ylqxqxzd4gpeyxrcut6g0fpkeh6e7mwxzej4vf6s646jpz8ccqkf04acu74jlvf88dns2720gqtl93k5x3az9vdnc4mevgfz4qnge"
    },
    "shieldedESK": {
      "hex": "03003873018cd24ef35e9acca82f0b4b98d1b76f7784be9f2e07496aacc9f0679de9e3c77f89dfc816f18e374ca33646c6b55dc5adf71975ebf80c",
      "bech32m": "mn_shield-esk1qvqrsucp3nfyau67ntx2stctfwvdrdm0w7zta8ewqayk4txf7pnem60rcalcnh7gzmccud6v5vmyd344thz6macewh4lsrqpgrqmr"
    },
    "shieldedCPK": {
      "hex": "8f5b7ca223168e1d96820511305228b21b8d41223df2ac188c636533f085793e",
      "bech32m": "mn_shield-cpk13adheg3rz68pm95zq5gnq53gkgdc6sfz8he2cxyvvdjn8uy90ylq08tn8t"
    }
  },
  {
    "seed": "0101010101010101010101010101010101010101010101010101010101010101",
    "networkId": "my-private-net",
    "shieldedAddress": {
      "hex": "8f5b7ca223168e1d96820511305228b21b8d41223df2ac188c636533f085793e0300c26d501c90c3c717a43d21b66facfb6e30b32ab13a86aba90447c60164bebdc73d597d8939db382bca7a00bf9636a1a3d1158d9e2bbcb109",
      "bech32m": "mn_shield-addr_my-private-net13adheg3rz68pm95zq5gnq53gkgdc6sfz8he2cxyvvdjn8uy90ylqxqxzd4gpeyxrcut6g0fpkeh6e7mwxzej4vf6s646jpz8ccqkf04acu74jlvf88dns2720gqtl93k5x3az9vdnc4mevgfst5jph"
    },
    "shieldedESK": {
      "hex": "03003873018cd24ef35e9acca82f0b4b98d1b76f7784be9f2e07496aacc9f0679de9e3c77f89dfc816f18e374ca33646c6b55dc5adf71975ebf80c",
      "bech32m": "mn_shield-esk_my-private-net1qvqrsucp3nfyau67ntx2stctfwvdrdm0w7zta8ewqayk4txf7pnem60rcalcnh7gzmccud6v5vmyd344thz6macewh4lsrquzs5mr"
    },
    "shieldedCPK": {
      "hex": "8f5b7ca223168e1d96820511305228b21b8d41223df2ac188c636533f085793e",
      "bech32m": "mn_shield-cpk_my-private-net13adheg3rz68pm95zq5gnq53gkgdc6sfz8he2cxyvvdjn8uy90ylqhjafcg"
    }
  },
  {
    "seed": "0101010101010101010101010101010101010101010101010101010101010101",
    "networkId": "dev",
    "shieldedAddress": {
      "hex": "8f5b7ca223168e1d96820511305228b21b8d41223df2ac188c636533f085793e0300c26d501c90c3c717a43d21b66facfb6e30b32ab13a86aba90447c60164bebdc73d597d8939db382bca7a00bf9636a1a3d1158d9e2bbcb109",
      "bech32m": "mn_shield-addr_dev13adheg3rz68pm95zq5gnq53gkgdc6sfz8he2cxyvvdjn8uy90ylqxqxzd4gpeyxrcut6g0fpkeh6e7mwxzej4vf6s646jpz8ccqkf04acu74jlvf88dns2720gqtl93k5x3az9vdnc4mevgfsazh96"
    },
    "shieldedESK": {
      "hex": "03003873018cd24ef35e9acca82f0b4b98d1b76f7784be9f2e07496aacc9f0679de9e3c77f89dfc816f18e374ca33646c6b55dc5adf71975ebf80c",
      "bech32m": "mn_shield-esk_dev1qvqrsucp3nfyau67ntx2stctfwvdrdm0w7zta8ewqayk4txf7pnem60rcalcnh7gzmccud6v5vmyd344thz6macewh4lsrqgdchy7"
    },
    "shieldedCPK": {
      "hex": "8f5b7ca223168e1d96820511305228b21b8d41223df2ac188c636533f085793e",
      "bech32m": "mn_shield-cpk_dev13adheg3rz68pm95zq5gnq53gkgdc6sfz8he2cxyvvdjn8uy90ylqjs43rz"
    }
  },
  {
    "seed": "0101010101010101010101010101010101010101010101010101010101010101",
    "networkId": "test",
    "shieldedAddress": {
      "hex": "8f5b7ca223168e1d96820511305228b21b8d41223df2ac188c636533f085793e0300c26d501c90c3c717a43d21b66facfb6e30b32ab13a86aba90447c60164bebdc73d597d8939db382bca7a00bf9636a1a3d1158d9e2bbcb109",
      "bech32m": "mn_shield-addr_test13adheg3rz68pm95zq5gnq53gkgdc6sfz8he2cxyvvdjn8uy90ylqxqxzd4gpeyxrcut6g0fpkeh6e7mwxzej4vf6s646jpz8ccqkf04acu74jlvf88dns2720gqtl93k5x3az9vdnc4mevgfh40wz8"
    },
    "shieldedESK": {
      "hex": "03003873018cd24ef35e9acca82f0b4b98d1b76f7784be9f2e07496aacc9f0679de9e3c77f89dfc816f18e374ca33646c6b55dc5adf71975ebf80c",
      "bech32m": "mn_shield-esk_test1qvqrsucp3nfyau67ntx2stctfwvdrdm0w7zta8ewqayk4txf7pnem60rcalcnh7gzmccud6v5vmyd344thz6macewh4lsrqhhs2s7"
    },
    "shieldedCPK": {
      "hex": "8f5b7ca223168e1d96820511305228b21b8d41223df2ac188c636533f085793e",
      "bech32m": "mn_shield-cpk_test13adheg3rz68pm95zq5gnq53gkgdc6sfz8he2cxyvvdjn8uy90ylqarm5j4"
    }
  },
  {
    "seed": "0101010101010101010101010101010101010101010101010101010101010101",
    "networkId": "my-private-net-5",
    "shieldedAddress": {
      "hex": "8f5b7ca223168e1d96820511305228b21b8d41223df2ac188c636533f085793e0300c26d501c90c3c717a43d21b66facfb6e30b32ab13a86aba90447c60164bebdc73d597d8939db382bca7a00bf9636a1a3d1158d9e2bbcb109",
      "bech32m": "mn_shield-addr_my-private-net-513adheg3rz68pm95zq5gnq53gkgdc6sfz8he2cxyvvdjn8uy90ylqxqxzd4gpeyxrcut6g0fpkeh6e7mwxzej4vf6s646jpz8ccqkf04acu74jlvf88dns2720gqtl93k5x3az9vdnc4mevgfh5ywve"
    },
    "shieldedESK": {
      "hex": "03003873018cd24ef35e9acca82f0b4b98d1b76f7784be9f2e07496aacc9f0679de9e3c77f89dfc816f18e374ca33646c6b55dc5adf71975ebf80c",
      "bech32m": "mn_shield-esk_my-private-net-51qvqrsucp3nfyau67ntx2stctfwvdrdm0w7zta8ewqayk4txf7pnem60rcalcnh7gzmccud6v5vmyd344thz6macewh4lsrqgsye5d"
    },
    "shieldedCPK": {
      "hex": "8f5b7ca223168e1d96820511305228b21b8d41223df2ac188c636533f085793e",
      "bech32m": "mn_shield-cpk_my-private-net-513adheg3rz68pm95zq5gnq53gkgdc6sfz8he2cxyvvdjn8uy90ylqsuka86"
    }
  },
  {
    "seed": "0202020202020202020202020202020202020202020202020202020202020202",
    "networkId": null,
    "shieldedAddress": {
      "hex": "e0ca5ed644b4364d281e6b19a2559026842f259738404ca52f6a8353d26944da0300609aed57bc74b93bbb2a460b71c44b80ec805dd21a62125e9d842c8794357e8964809bd1e277b040988799884ab806735c5ad04e5defb68e",
      "bech32m": "mn_shield-addr1ur99a4jyksmy62q7dvv6y4vsy6zz7fvh8pqyeff0d2p485nfgndqxqrqntk400r5hyamk2jxpdcugjuqajq9m5s6vgf9a8vy9jregdt739jgpx73ufmmqsycs7vcsj4cqee4ckksfew7ld5wckrj38"
    },
    "shieldedESK": {
      "hex": "030038b1921e53b8ad42cbd8bbc3250e28c6bf8935279b47ca3274f5d59c37d3b1a21fd8651b2d857ad398fd46be68f3fc9eb50eb40ee03a982705",
      "bech32m": "mn_shield-esk1qvqr3vvjrefm3t2ze0vthse9pc5vd0ufx5nek372xf60t4vuxlfmrgslmpj3ktv90tfe3l2xhe508ly7k58tgrhq82vzwpgcm00x9"
    },
    "shieldedCPK": {
      "hex": "e0ca5ed644b4364d281e6b19a2559026842f259738404ca52f6a8353d26944da",
      "bech32m": "mn_shield-cpk1ur99a4jyksmy62q7dvv6y4vsy6zz7fvh8pqyeff0d2p485nfgndq5lh0va"
    }
  },
  {
    "seed": "0202020202020202020202020202020202020202020202020202020202020202",
    "networkId": "my-private-net",
    "shieldedAddress": {
      "hex": "e0ca5ed644b4364d281e6b19a2559026842f259738404ca52f6a8353d26944da0300609aed57bc74b93bbb2a460b71c44b80ec805dd21a62125e9d842c8794357e8964809bd1e277b040988799884ab806735c5ad04e5defb68e",
      "bech32m": "mn_shield-addr_my-private-net1ur99a4jyksmy62q7dvv6y4vsy6zz7fvh8pqyeff0d2p485nfgndqxqrqntk400r5hyamk2jxpdcugjuqajq9m5s6vgf9a8vy9jregdt739jgpx73ufmmqsycs7vcsj4cqee4ckksfew7ld5w2ghncf"
    },
    "shieldedESK": {
      "hex": "030038b1921e53b8ad42cbd8bbc3250e28c6bf8935279b47ca3274f5d59c37d3b1a21fd8651b2d857ad398fd46be68f3fc9eb50eb40ee03a982705",
      "bech32m": "mn_shield-esk_my-private-net1qvqr3vvjrefm3t2ze0vthse9pc5vd0ufx5nek372xf60t4vuxlfmrgslmpj3ktv90tfe3l2xhe508ly7k58tgrhq82vzwpg93umx9"
    },
    "shieldedCPK": {
      "hex": "e0ca5ed644b4364d281e6b19a2559026842f259738404ca52f6a8353d26944da",
      "bech32m": "mn_shield-cpk_my-private-net1ur99a4jyksmy62q7dvv6y4vsy6zz7fvh8pqyeff0d2p485nfgndqv2p4n7"
    }
  },
  {
    "seed": "0202020202020202020202020202020202020202020202020202020202020202",
    "networkId": "dev",
    "shieldedAddress": {
      "hex": "e0ca5ed644b4364d281e6b19a2559026842f259738404ca52f6a8353d26944da0300609aed57bc74b93bbb2a460b71c44b80ec805dd21a62125e9d842c8794357e8964809bd1e277b040988799884ab806735c5ad04e5defb68e",
      "bech32m": "mn_shield-addr_dev1ur99a4jyksmy62q7dvv6y4vsy6zz7fvh8pqyeff0d2p485nfgndqxqrqntk400r5hyamk2jxpdcugjuqajq9m5s6vgf9a8vy9jregdt739jgpx73ufmmqsycs7vcsj4cqee4ckksfew7ld5w27pkuy"
    },
    "shieldedESK": {
      "hex": "030038b1921e53b8ad42cbd8bbc3250e28c6bf8935279b47ca3274f5d59c37d3b1a21fd8651b2d857ad398fd46be68f3fc9eb50eb40ee03a982705",
      "bech32m": "mn_shield-esk_dev1qvqr3vvjrefm3t2ze0vthse9pc5vd0ufx5nek372xf60t4vuxlfmrgslmpj3ktv90tfe3l2xhe508ly7k58tgrhq82vzwpg375cec"
    },
    "shieldedCPK": {
      "hex": "e0ca5ed644b4364d281e6b19a2559026842f259738404ca52f6a8353d26944da",
      "bech32m": "mn_shield-cpk_dev1ur99a4jyksmy62q7dvv6y4vsy6zz7fvh8pqyeff0d2p485nfgndqfgfdg5"
    }
  },
  {
    "seed": "0202020202020202020202020202020202020202020202020202020202020202",
    "networkId": "test",
    "shieldedAddress": {
      "hex": "e0ca5ed644b4364d281e6b19a2559026842f259738404ca52f6a8353d26944da0300609aed57bc74b93bbb2a460b71c44b80ec805dd21a62125e9d842c8794357e8964809bd1e277b040988799884ab806735c5ad04e5defb68e",
      "bech32m": "mn_shield-addr_test1ur99a4jyksmy62q7dvv6y4vsy6zz7fvh8pqyeff0d2p485nfgndqxqrqntk400r5hyamk2jxpdcugjuqajq9m5s6vgf9a8vy9jregdt739jgpx73ufmmqsycs7vcsj4cqee4ckksfew7ld5wdkv0me"
    },
    "shieldedESK": {
      "hex": "030038b1921e53b8ad42cbd8bbc3250e28c6bf8935279b47ca3274f5d59c37d3b1a21fd8651b2d857ad398fd46be68f3fc9eb50eb40ee03a982705",
      "bech32m": "mn_shield-esk_test1qvqr3vvjrefm3t2ze0vthse9pc5vd0ufx5nek372xf60t4vuxlfmrgslmpj3ktv90tfe3l2xhe508ly7k58tgrhq82vzwpgwyu9dc"
    },
    "shieldedCPK": {
      "hex": "e0ca5ed644b4364d281e6b19a2559026842f259738404ca52f6a8353d26944da",
      "bech32m": "mn_shield-cpk_test1ur99a4jyksmy62q7dvv6y4vsy6zz7fvh8pqyeff0d2p485nfgndqxm8ger"
    }
  },
  {
    "seed": "0202020202020202020202020202020202020202020202020202020202020202",
    "networkId": "my-private-net-5",
    "shieldedAddress": {
      "hex": "e0ca5ed644b4364d281e6b19a2559026842f259738404ca52f6a8353d26944da0300609aed57bc74b93bbb2a460b71c44b80ec805dd21a62125e9d842c8794357e8964809bd1e277b040988799884ab806735c5ad04e5defb68e",
      "bech32m": "mn_shield-addr_my-private-net-51ur99a4jyksmy62q7dvv6y4vsy6zz7fvh8pqyeff0d2p485nfgndqxqrqntk400r5hyamk2jxpdcugjuqajq9m5s6vgf9a8vy9jregdt739jgpx73ufmmqsycs7vcsj4cqee4ckksfew7ld5wdh8048"
    },
    "shieldedESK": {
      "hex": "030038b1921e53b8ad42cbd8bbc3250e28c6bf8935279b47ca3274f5d59c37d3b1a21fd8651b2d857ad398fd46be68f3fc9eb50eb40ee03a982705",
      "bech32m": "mn_shield-esk_my-private-net-51qvqr3vvjrefm3t2ze0vthse9pc5vd0ufx5nek372xf60t4vuxlfmrgslmpj3ktv90tfe3l2xhe508ly7k58tgrhq82vzwpg3rgkft"
    },
    "shieldedCPK": {
      "hex": "e0ca5ed644b4364d281e6b19a2559026842f259738404ca52f6a8353d26944da",
      "bech32m": "mn_shield-cpk_my-private-net-51ur99a4jyksmy62q7dvv6y4vsy6zz7fvh8pqyeff0d2p485nfgndqty2pvv"
    }
  },
  {
    "seed": "0404040404040404040404040404040404040404040404040404040404040404",
    "networkId": null,
    "shieldedAddress": {
      "hex": "092492904b90b823633b80a5d1bde9ba8af392157674fbef166d60d18859ead503001d46331955141d3a1a4d945559c97887fcd90d27c0c841dc389b19d3c96e6341b22bc51315ebabef92ffb042a4f23bce2060f58248c81b85",
      "bech32m": "mn_shield-addr1pyjf9yztjzuzxcemszjar00fh2908ys4we60hmckd4sdrzzeat2sxqqagce3j4g5r5ap5nv524vuj7y8lnvs6f7qepqacwymr8fujmnrgxezh3gnzh46hmujl7cy9f8j808zqc84sfyvsxu95k8ja9"
    },
    "shieldedESK": {
      "hex": "030038e6e4972e4b097c048570ce2056efaea8c176dd6f08c6c40d815adb8b2c1cb4ab6057c25c6e8f9bca639f027dbdddbfd1cb026e615af20d0d",
      "bech32m": "mn_shield-esk1qvqr3ehyjuhykztuqjzhpn3q2mh6a2xpwmwk7zxxcsxczkkm3vkped9tvptuyhrw37du5culqf7mmhdl689symnptteq6rgktxymu"
    },
    "shieldedCPK": {
      "hex": "092492904b90b823633b80a5d1bde9ba8af392157674fbef166d60d18859ead5",
      "bech32m": "mn_shield-cpk1pyjf9yztjzuzxcemszjar00fh2908ys4we60hmckd4sdrzzeat2spllmuc"
    }
  },
  {
    "seed": "0404040404040404040404040404040404040404040404040404040404040404",
    "networkId": "my-private-net",
    "shieldedAddress": {
      "hex": "092492904b90b823633b80a5d1bde9ba8af392157674fbef166d60d18859ead503001d46331955141d3a1a4d945559c97887fcd90d27c0c841dc389b19d3c96e6341b22bc51315ebabef92ffb042a4f23bce2060f58248c81b85",
      "bech32m": "mn_shield-addr_my-private-net1pyjf9yztjzuzxcemszjar00fh2908ys4we60hmckd4sdrzzeat2sxqqagce3j4g5r5ap5nv524vuj7y8lnvs6f7qepqacwymr8fujmnrgxezh3gnzh46hmujl7cy9f8j808zqc84sfyvsxu9xgnn5t"
    },
    "shieldedESK": {
      "hex": "030038e6e4972e4b097c048570ce2056efaea8c176dd6f08c6c40d815adb8b2c1cb4ab6057c25c6e8f9bca639f027dbdddbfd1cb026e615af20d0d",
      "bech32m": "mn_shield-esk_my-private-net1qvqr3ehyjuhykztuqjzhpn3q2mh6a2xpwmwk7zxxcsxczkkm3vkped9tvptuyhrw37du5culqf7mmhdl689symnptteq6rgtp4smu"
    },
    "shieldedCPK": {
      "hex": "092492904b90b823633b80a5d1bde9ba8af392157674fbef166d60d18859ead5",
      "bech32m": "mn_shield-cpk_my-private-net1pyjf9yztjzuzxcemszjar00fh2908ys4we60hmckd4sdrzzeat2se2fprm"
    }
  },
  {
    "seed": "0404040404040404040404040404040404040404040404040404040404040404",
    "networkId": "dev",
    "shieldedAddress": {
      "hex": "092492904b90b823633b80a5d1bde9ba8af392157674fbef166d60d18859ead503001d46331955141d3a1a4d945559c97887fcd90d27c0c841dc389b19d3c96e6341b22bc51315ebabef92ffb042a4f23bce2060f58248c81b85",
      "bech32m": "mn_shield-addr_dev1pyjf9yztjzuzxcemszjar00fh2908ys4we60hmckd4sdrzzeat2sxqqagce3j4g5r5ap5nv524vuj7y8lnvs6f7qepqacwymr8fujmnrgxezh3gnzh46hmujl7cy9f8j808zqc84sfyvsxu9x79ksx"
    },
    "shieldedESK": {
      "hex": "030038e6e4972e4b097c048570ce2056efaea8c176dd6f08c6c40d815adb8b2c1cb4ab6057c25c6e8f9bca639f027dbdddbfd1cb026e615af20d0d",
      "bech32m": "mn_shield-esk_dev1qvqr3ehyjuhykztuqjzhpn3q2mh6a2xpwmwk7zxxcsxczkkm3vkped9tvptuyhrw37du5culqf7mmhdl689symnptteq6rglwanyp"
    },
    "shieldedCPK": {
      "hex": "092492904b90b823633b80a5d1bde9ba8af392157674fbef166d60d18859ead5",
      "bech32m": "mn_shield-cpk_dev1pyjf9yztjzuzxcemszjar00fh2908ys4we60hmckd4sdrzzeat2sugpec3"
    }
  },
  {
    "seed": "0404040404040404040404040404040404040404040404040404040404040404",
    "networkId": "test",
    "shieldedAddress": {
      "hex": "092492904b90b823633b80a5d1bde9ba8af392157674fbef166d60d18859ead503001d46331955141d3a1a4d945559c97887fcd90d27c0c841dc389b19d3c96e6341b22bc51315ebabef92ffb042a4f23bce2060f58248c81b85",
      "bech32m": "mn_shield-addr_test1pyjf9yztjzuzxcemszjar00fh2908ys4we60hmckd4sdrzzeat2sxqqagce3j4g5r5ap5nv524vuj7y8lnvs6f7qepqacwymr8fujmnrgxezh3gnzh46hmujl7cy9f8j808zqc84sfyvsxu9pkg0hm"
    },
    "shieldedESK": {
      "hex": "030038e6e4972e4b097c048570ce2056efaea8c176dd6f08c6c40d815adb8b2c1cb4ab6057c25c6e8f9bca639f027dbdddbfd1cb026e615af20d0d",
      "bech32m": "mn_shield-esk_test1qvqr3ehyjuhykztuqjzhpn3q2mh6a2xpwmwk7zxxcsxczkkm3vkped9tvptuyhrw37du5culqf7mmhdl689symnptteq6rgq54wsp"
    },
    "shieldedCPK": {
      "hex": "092492904b90b823633b80a5d1bde9ba8af392157674fbef166d60d18859ead5",
      "bech32m": "mn_shield-cpk_test1pyjf9yztjzuzxcemszjar00fh2908ys4we60hmckd4sdrzzeat2snm0ufx"
    }
  },
  {
    "seed": "0404040404040404040404040404040404040404040404040404040404040404",
    "networkId": "my-private-net-5",
    "shieldedAddress": {
      "hex": "092492904b90b823633b80a5d1bde9ba8af392157674fbef166d60d18859ead503001d46331955141d3a1a4d945559c97887fcd90d27c0c841dc389b19d3c96e6341b22bc51315ebabef92ffb042a4f23bce2060f58248c81b85",
      "bech32m": "mn_shield-addr_my-private-net-51pyjf9yztjzuzxcemszjar00fh2908ys4we60hmckd4sdrzzeat2sxqqagce3j4g5r5ap5nv524vuj7y8lnvs6f7qepqacwymr8fujmnrgxezh3gnzh46hmujl7cy9f8j808zqc84sfyvsxu9phr0e9"
    },
    "shieldedESK": {
      "hex": "030038e6e4972e4b097c048570ce2056efaea8c176dd6f08c6c40d815adb8b2c1cb4ab6057c25c6e8f9bca639f027dbdddbfd1cb026e615af20d0d",
      "bech32m": "mn_shield-esk_my-private-net-51qvqr3ehyjuhykztuqjzhpn3q2mh6a2xpwmwk7zxxcsxczkkm3vkped9tvptuyhrw37du5culqf7mmhdl689symnptteq6rglnpa5j"
    },
    "shieldedCPK": {
      "hex": "092492904b90b823633b80a5d1bde9ba8af392157674fbef166d60d18859ead5",
      "bech32m": "mn_shield-cpk_my-private-net-51pyjf9yztjzuzxcemszjar00fh2908ys4we60hmckd4sdrzzeat2s7yz4uf"
    }
  },
  {
    "seed": "0808080808080808080808080808080808080808080808080808080808080808",
    "networkId": null,
    "shieldedAddress": {
      "hex": "ef0ec893b33d6d2400de1291ea7250f7583e901b35acbb51c31545cfeefbba5303008ff9c8e470860f0d95fe9110c395eb2da48ab64518b6ad2b6b35e03bdee835591d437bb54968f404d5ae03edd7e6aeecbb5592849d358194",
      "bech32m": "mn_shield-addr1au8v3yan84kjgqx7z2g75ujs7avrayqmxkktk5wrz4zulmhmhffsxqy0l8ywguyxpuxetl53zrpet6ed5j9tv3gck6kjk6e4uqaaa6p4tyw5x7a4f950gpx44cp7m4lx4mktk4vjsjwntqv55hdqa5"
    },
    "shieldedESK": {
      "hex": "03003809afbe2cc0387a7bd8883fee3f6ba6d227262e77595d0050a09d4fd92a3e5a62bf41a63a2fd0edcf6e17c25c9d94fe1b0943ec999bd7591e",
      "bech32m": "mn_shield-esk1qvqrszd0hckvqwr600vgs0lw8a46d538ych8wk2aqpg2p820my4ruknzhaq6vw306rku7mshcfwfm987rvy58myen0t4j8se5d4t8"
    },
    "shieldedCPK": {
      "hex": "ef0ec893b33d6d2400de1291ea7250f7583e901b35acbb51c31545cfeefbba53",
      "bech32m": "mn_shield-cpk1au8v3yan84kjgqx7z2g75ujs7avrayqmxkktk5wrz4zulmhmhffs5xtgzh"
    }
  },
  {
    "seed": "0808080808080808080808080808080808080808080808080808080808080808",
    "networkId": "my-private-net",
    "shieldedAddress": {
      "hex": "ef0ec893b33d6d2400de1291ea7250f7583e901b35acbb51c31545cfeefbba5303008ff9c8e470860f0d95fe9110c395eb2da48ab64518b6ad2b6b35e03bdee835591d437bb54968f404d5ae03edd7e6aeecbb5592849d358194",
      "bech32m": "mn_shield-addr_my-private-net1au8v3yan84kjgqx7z2g75ujs7avrayqmxkktk5wrz4zulmhmhffsxqy0l8ywguyxpuxetl53zrpet6ed5j9tv3gck6kjk6e4uqaaa6p4tyw5x7a4f950gpx44cp7m4lx4mktk4vjsjwntqv5xfep56"
    },
    "shieldedESK": {
      "hex": "03003809afbe2cc0387a7bd8883fee3f6ba6d227262e77595d0050a09d4fd92a3e5a62bf41a63a2fd0edcf6e17c25c9d94fe1b0943ec999bd7591e",
      "bech32m": "mn_shield-esk_my-private-net1qvqrszd0hckvqwr600vgs0lw8a46d538ych8wk2aqpg2p820my4ruknzhaq6vw306rku7mshcfwfm987rvy58myen0t4j8sy77pt8"
    },
    "shieldedCPK": {
      "hex": "ef0ec893b33d6d2400de1291ea7250f7583e901b35acbb51c31545cfeefbba53",
      "bech32m": "mn_shield-cpk_my-private-net1au8v3yan84kjgqx7z2g75ujs7avrayqmxkktk5wrz4zulmhmhffsvnaja5"
    }
  },
  {
    "seed": "0808080808080808080808080808080808080808080808080808080808080808",
    "networkId": "dev",
    "shieldedAddress": {
      "hex": "ef0ec893b33d6d2400de1291ea7250f7583e901b35acbb51c31545cfeefbba5303008ff9c8e470860f0d95fe9110c395eb2da48ab64518b6ad2b6b35e03bdee835591d437bb54968f404d5ae03edd7e6aeecbb5592849d358194",
      "bech32m": "mn_shield-addr_dev1au8v3yan84kjgqx7z2g75ujs7avrayqmxkktk5wrz4zulmhmhffsxqy0l8ywguyxpuxetl53zrpet6ed5j9tv3gck6kjk6e4uqaaa6p4tyw5x7a4f950gpx44cp7m4lx4mktk4vjsjwntqv5xl0ysh"
    },
    "shieldedESK": {
      "hex": "03003809afbe2cc0387a7bd8883fee3f6ba6d227262e77595d0050a09d4fd92a3e5a62bf41a63a2fd0edcf6e17c25c9d94fe1b0943ec999bd7591e",
      "bech32m": "mn_shield-esk_dev1qvqrszd0hckvqwr600vgs0lw8a46d538ych8wk2aqpg2p820my4ruknzhaq6vw306rku7mshcfwfm987rvy58myen0t4j8ss3kz56"
    },
    "shieldedCPK": {
      "hex": "ef0ec893b33d6d2400de1291ea7250f7583e901b35acbb51c31545cfeefbba53",
      "bech32m": "mn_shield-cpk_dev1au8v3yan84kjgqx7z2g75ujs7avrayqmxkktk5wrz4zulmhmhffsf342x7"
    }
  },
  {
    "seed": "0808080808080808080808080808080808080808080808080808080808080808",
    "networkId": "test",
    "shieldedAddress": {
      "hex": "ef0ec893b33d6d2400de1291ea7250f7583e901b35acbb51c31545cfeefbba5303008ff9c8e470860f0d95fe9110c395eb2da48ab64518b6ad2b6b35e03bdee835591d437bb54968f404d5ae03edd7e6aeecbb5592849d358194",
      "bech32m": "mn_shield-addr_test1au8v3yan84kjgqx7z2g75ujs7avrayqmxkktk5wrz4zulmhmhffsxqy0l8ywguyxpuxetl53zrpet6ed5j9tv3gck6kjk6e4uqaaa6p4tyw5x7a4f950gpx44cp7m4lx4mktk4vjsjwntqv5phzah2"
    },
    "shieldedESK": {
      "hex": "03003809afbe2cc0387a7bd8883fee3f6ba6d227262e77595d0050a09d4fd92a3e5a62bf41a63a2fd0edcf6e17c25c9d94fe1b0943ec999bd7591e",
      "bech32m": "mn_shield-esk_test1qvqrszd0hckvqwr600vgs0lw8a46d538ych8wk2aqpg2p820my4ruknzhaq6vw306rku7mshcfwfm987rvy58myen0t4j8s0t7lq6"
    },
    "shieldedCPK": {
      "hex": "ef0ec893b33d6d2400de1291ea7250f7583e901b35acbb51c31545cfeefbba53",
      "bech32m": "mn_shield-cpk_test1au8v3yan84kjgqx7z2g75ujs7avrayqmxkktk5wrz4zulmhmhffsxzm0hf"
    }
  },
  {
    "seed": "0808080808080808080808080808080808080808080808080808080808080808",
    "networkId": "my-private-net-5",
    "shieldedAddress": {
      "hex": "ef0ec893b33d6d2400de1291ea7250f7583e901b35acbb51c31545cfeefbba5303008ff9c8e470860f0d95fe9110c395eb2da48ab64518b6ad2b6b35e03bdee835591d437bb54968f404d5ae03edd7e6aeecbb5592849d358194",
      "bech32m": "mn_shield-addr_my-private-net-51au8v3yan84kjgqx7z2g75ujs7avrayqmxkktk5wrz4zulmhmhffsxqy0l8ywguyxpuxetl53zrpet6ed5j9tv3gck6kjk6e4uqaaa6p4tyw5x7a4f950gpx44cp7m4lx4mktk4vjsjwntqv5pkfae5"
    },
    "shieldedESK": {
      "hex": "03003809afbe2cc0387a7bd8883fee3f6ba6d227262e77595d0050a09d4fd92a3e5a62bf41a63a2fd0edcf6e17c25c9d94fe1b0943ec999bd7591e",
      "bech32m": "mn_shield-esk_my-private-net-51qvqrszd0hckvqwr600vgs0lw8a46d538ych8wk2aqpg2p820my4ruknzhaq6vw306rku7mshcfwfm987rvy58myen0t4j8ssv2vyf"
    },
    "shieldedCPK": {
      "hex": "ef0ec893b33d6d2400de1291ea7250f7583e901b35acbb51c31545cfeefbba53",
      "bech32m": "mn_shield-cpk_my-private-net-51au8v3yan84kjgqx7z2g75ujs7avrayqmxkktk5wrz4zulmhmhffstakxzx"
    }
  },
  {
    "seed": "1010101010101010101010101010101010101010101010101010101010101010",
    "networkId": null,
    "shieldedAddress": {
      "hex": "dc4cded54d701a3b121f6ec09d58224c9ee4ffce4915e40e6073e9a593dbfb1f03005e68fd9c4a3969dc298e254945471e89000318faa638893f96e82206cfe4242b939de9d50283e3201889398d8c21af98f500efd3b84aeb84",
      "bech32m": "mn_shield-addr1m3xda42dwqdrkysldmqf6kpzfj0wfl7wfy27grnqw056ty7mlv0sxqz7dr7ecj3ed8wznr39f9z5w85fqqp3374x8zynl9hgygrvlepy9wfem6w4q2p7xgqc3yucmrpp47v02q806wuy46uyc9lqg8"
    },
    "shieldedESK": {
      "hex": "030038ee9ee901c990a5eafe545711a7f96c944cfd8c4e32a04d329d291eb1728aa8e299a5a9e20fc5380661cc3cdd2c263a7b92e29255a4ce6205",
      "bech32m": "mn_shield-esk1qvqr3m57ayquny99atl9g4c35luke9zvlkxyuv4qf5ef62g7k9eg428znxj6ncs0c5uqvcwv8nwjcf360wfw9yj45n8xypgc68t0v"
    },
    "shieldedCPK": {
      "hex": "dc4cded54d701a3b121f6ec09d58224c9ee4ffce4915e40e6073e9a593dbfb1f",
      "bech32m": "mn_shield-cpk1m3xda42dwqdrkysldmqf6kpzfj0wfl7wfy27grnqw056ty7mlv0s4kaucu"
    }
  },
  {
    "seed": "1010101010101010101010101010101010101010101010101010101010101010",
    "networkId": "my-private-net",
    "shieldedAddress": {
      "hex": "dc4cded54d701a3b121f6ec09d58224c9ee4ffce4915e40e6073e9a593dbfb1f03005e68fd9c4a3969dc298e254945471e89000318faa638893f96e82206cfe4242b939de9d50283e3201889398d8c21af98f500efd3b84aeb84",
      "bech32m": "mn_shield-addr_my-private-net1m3xda42dwqdrkysldmqf6kpzfj0wfl7wfy27grnqw056ty7mlv0sxqz7dr7ecj3ed8wznr39f9z5w85fqqp3374x8zynl9hgygrvlepy9wfem6w4q2p7xgqc3yucmrpp47v02q806wuy46uy2mtppf"
    },
    "shieldedESK": {
      "hex": "030038ee9ee901c990a5eafe545711a7f96c944cfd8c4e32a04d329d291eb1728aa8e299a5a9e20fc5380661cc3cdd2c263a7b92e29255a4ce6205",
      "bech32m": "mn_shield-esk_my-private-net1qvqr3m57ayquny99atl9g4c35luke9zvlkxyuv4qf5ef62g7k9eg428znxj6ncs0c5uqvcwv8nwjcf360wfw9yj45n8xypg9s5l0v"
    },
    "shieldedCPK": {
      "hex": "dc4cded54d701a3b121f6ec09d58224c9ee4ffce4915e40e6073e9a593dbfb1f",
      "bech32m": "mn_shield-cpk_my-private-net1m3xda42dwqdrkysldmqf6kpzfj0wfl7wfy27grnqw056ty7mlv0sdrtx8l"
    }
  },
  {
    "seed": "1010101010101010101010101010101010101010101010101010101010101010",
    "networkId": "dev",
    "shieldedAddress": {
      "hex": "dc4cded54d701a3b121f6ec09d58224c9ee4ffce4915e40e6073e9a593dbfb1f03005e68fd9c4a3969dc298e254945471e89000318faa638893f96e82206cfe4242b939de9d50283e3201889398d8c21af98f500efd3b84aeb84",
      "bech32m": "mn_shield-addr_dev1m3xda42dwqdrkysldmqf6kpzfj0wfl7wfy27grnqw056ty7mlv0sxqz7dr7ecj3ed8wznr39f9z5w85fqqp3374x8zynl9hgygrvlepy9wfem6w4q2p7xgqc3yucmrpp47v02q806wuy46uy2day9y"
    },
    "shieldedESK": {
      "hex": "030038ee9ee901c990a5eafe545711a7f96c944cfd8c4e32a04d329d291eb1728aa8e299a5a9e20fc5380661cc3cdd2c263a7b92e29255a4ce6205",
      "bech32m": "mn_shield-esk_dev1qvqr3m57ayquny99atl9g4c35luke9zvlkxyuv4qf5ef62g7k9eg428znxj6ncs0c5uqvcwv8nwjcf360wfw9yj45n8xypg3luus3"
    },
    "shieldedCPK": {
      "hex": "dc4cded54d701a3b121f6ec09d58224c9ee4ffce4915e40e6073e9a593dbfb1f",
      "bech32m": "mn_shield-cpk_dev1m3xda42dwqdrkysldmqf6kpzfj0wfl7wfy27grnqw056ty7mlv0sgpr7u4"
    }
  },
  {
    "seed": "1010101010101010101010101010101010101010101010101010101010101010",
    "networkId": "test",
    "shieldedAddress": {
      "hex": "dc4cded54d701a3b121f6ec09d58224c9ee4ffce4915e40e6073e9a593dbfb1f03005e68fd9c4a3969dc298e254945471e89000318faa638893f96e82206cfe4242b939de9d50283e3201889398d8c21af98f500efd3b84aeb84",
      "bech32m": "mn_shield-addr_test1m3xda42dwqdrkysldmqf6kpzfj0wfl7wfy27grnqw056ty7mlv0sxqz7dr7ecj3ed8wznr39f9z5w85fqqp3374x8zynl9hgygrvlepy9wfem6w4q2p7xgqc3yucmrpp47v02q806wuy46uyd9saze"
    },
    "shieldedESK": {
      "hex": "030038ee9ee901c990a5eafe545711a7f96c944cfd8c4e32a04d329d291eb1728aa8e299a5a9e20fc5380661cc3cdd2c263a7b92e29255a4ce6205",
      "bech32m": "mn_shield-esk_test1qvqr3m57ayquny99atl9g4c35luke9zvlkxyuv4qf5ef62g7k9eg428znxj6ncs0c5uqvcwv8nwjcf360wfw9yj45n8xypgw95py3"
    },
    "shieldedCPK": {
      "hex": "dc4cded54d701a3b121f6ec09d58224c9ee4ffce4915e40e6073e9a593dbfb1f",
      "bech32m": "mn_shield-cpk_test1m3xda42dwqdrkysldmqf6kpzfj0wfl7wfy27grnqw056ty7mlv0s8jdmdz"
    }
  },
  {
    "seed": "1010101010101010101010101010101010101010101010101010101010101010",
    "networkId": "my-private-net-5",
    "shieldedAddress": {
      "hex": "dc4cded54d701a3b121f6ec09d58224c9ee4ffce4915e40e6073e9a593dbfb1f03005e68fd9c4a3969dc298e254945471e89000318faa638893f96e82206cfe4242b939de9d50283e3201889398d8c21af98f500efd3b84aeb84",
      "bech32m": "mn_shield-addr_my-private-net-51m3xda42dwqdrkysldmqf6kpzfj0wfl7wfy27grnqw056ty7mlv0sxqz7dr7ecj3ed8wznr39f9z5w85fqqp3374x8zynl9hgygrvlepy9wfem6w4q2p7xgqc3yucmrpp47v02q806wuy46uydymav8"
    },
    "shieldedESK": {
      "hex": "030038ee9ee901c990a5eafe545711a7f96c944cfd8c4e32a04d329d291eb1728aa8e299a5a9e20fc5380661cc3cdd2c263a7b92e29255a4ce6205",
      "bech32m": "mn_shield-esk_my-private-net-51qvqr3m57ayquny99atl9g4c35luke9zvlkxyuv4qf5ef62g7k9eg428znxj6ncs0c5uqvcwv8nwjcf360wfw9yj45n8xypg3zqjqz"
    },
    "shieldedCPK": {
      "hex": "dc4cded54d701a3b121f6ec09d58224c9ee4ffce4915e40e6073e9a593dbfb1f",
      "bech32m": "mn_shield-cpk_my-private-net-51m3xda42dwqdrkysldmqf6kpzfj0wfl7wfy27grnqw056ty7mlv0s2dqjcd"
    }
  },
  {
    "seed": "2020202020202020202020202020202020202020202020202020202020202020",
    "networkId": null,
    "shieldedAddress": {
      "hex": "11d519b374e26d0bc42dfe1892f01899ae11b2d9455c0c453d373e48df9bceba03007cf6cfcc07561f7204e12b68252643bf952cfa2fa74221abfbf46ea9730f0da5bfbd26117fee7de84ed25c488bb2695d27ee12d771951098",
      "bech32m": "mn_shield-addr1z823nvm5ufksh3pdlcvf9uqcnxhprvkeg4wqc3faxuly3hume6aqxqru7m8ucp6kraeqfcftdqjjvsalj5k05ta8ggs6h7l5d65hxrcd5klm6fs30lh8m6zw6fwy3zajd9wj0msj6ace2yyc9j6lrx"
    },
    "shieldedESK": {
      "hex": "0300388006e79285e700c83d24bfa44b1a322e0870d75e9a5bbf942dbc56bdf369784a633e54338d0b8687178c3581fc848973f9a53f9f80719319",
      "bech32m": "mn_shield-esk1qvqr3qqxu7fgtecqeq7jf0ayfvdrytsgwrt4axjmh72zm0zkhhekj7z2vvl9gvudpwrgw9uvxkqlepyfw0u620ulspcexxg98pw4f"
    },
    "shieldedCPK": {
      "hex": "11d519b374e26d0bc42dfe1892f01899ae11b2d9455c0c453d373e48df9bceba",
      "bech32m": "mn_shield-cpk1z823nvm5ufksh3pdlcvf9uqcnxhprvkeg4wqc3faxuly3hume6aqjghuc7"
    }
  },
  {
    "seed": "2020202020202020202020202020202020202020202020202020202020202020",
    "networkId": "my-private-net",
    "shieldedAddress": {
      "hex": "11d519b374e26d0bc42dfe1892f01899ae11b2d9455c0c453d373e48df9bceba03007cf6cfcc07561f7204e12b68252643bf952cfa2fa74221abfbf46ea9730f0da5bfbd26117fee7de84ed25c488bb2695d27ee12d771951098",
      "bech32m": "mn_shield-addr_my-private-net1z823nvm5ufksh3pdlcvf9uqcnxhprvkeg4wqc3faxuly3hume6aqxqru7m8ucp6kraeqfcftdqjjvsalj5k05ta8ggs6h7l5d65hxrcd5klm6fs30lh8m6zw6fwy3zajd9wj0msj6ace2yychvw72g"
    },
    "shieldedESK": {
      "hex": "0300388006e79285e700c83d24bfa44b1a322e0870d75e9a5bbf942dbc56bdf369784a633e54338d0b8687178c3581fc848973f9a53f9f80719319",
      "bech32m": "mn_shield-esk_my-private-net1qvqr3qqxu7fgtecqeq7jf0ayfvdrytsgwrt4axjmh72zm0zkhhekj7z2vvl9gvudpwrgw9uvxkqlepyfw0u620ulspcexxgcdj64f"
    },
    "shieldedCPK": {
      "hex": "11d519b374e26d0bc42dfe1892f01899ae11b2d9455c0c453d373e48df9bceba",
      "bech32m": "mn_shield-cpk_my-private-net1z823nvm5ufksh3pdlcvf9uqcnxhprvkeg4wqc3faxuly3hume6aq2apx8a"
    }
  },
  {
    "seed": "2020202020202020202020202020202020202020202020202020202020202020",
    "networkId": "dev",
    "shieldedAddress": {
      "hex": "11d519b374e26d0bc42dfe1892f01899ae11b2d9455c0c453d373e48df9bceba03007cf6cfcc07561f7204e12b68252643bf952cfa2fa74221abfbf46ea9730f0da5bfbd26117fee7de84ed25c488bb2695d27ee12d771951098",
      "bech32m": "mn_shield-addr_dev1z823nvm5ufksh3pdlcvf9uqcnxhprvkeg4wqc3faxuly3hume6aqxqru7m8ucp6kraeqfcftdqjjvsalj5k05ta8ggs6h7l5d65hxrcd5klm6fs30lh8m6zw6fwy3zajd9wj0msj6ace2yych6cmw9"
    },
    "shieldedESK": {
      "hex": "0300388006e79285e700c83d24bfa44b1a322e0870d75e9a5bbf942dbc56bdf369784a633e54338d0b8687178c3581fc848973f9a53f9f80719319",
      "bech32m": "mn_shield-esk_dev1qvqr3qqxu7fgtecqeq7jf0ayfvdrytsgwrt4axjmh72zm0zkhhekj7z2vvl9gvudpwrgw9uvxkqlepyfw0u620ulspcexxgvz6e25"
    },
    "shieldedCPK": {
      "hex": "11d519b374e26d0bc42dfe1892f01899ae11b2d9455c0c453d373e48df9bceba",
      "bech32m": "mn_shield-cpk_dev1z823nvm5ufksh3pdlcvf9uqcnxhprvkeg4wqc3faxuly3hume6aq0lf7uh"
    }
  },
  {
    "seed": "2020202020202020202020202020202020202020202020202020202020202020",
    "networkId": "test",
    "shieldedAddress": {
      "hex": "11d519b374e26d0bc42dfe1892f01899ae11b2d9455c0c453d373e48df9bceba03007cf6cfcc07561f7204e12b68252643bf952cfa2fa74221abfbf46ea9730f0da5bfbd26117fee7de84ed25c488bb2695d27ee12d771951098",
      "bech32m": "mn_shield-addr_test1z823nvm5ufksh3pdlcvf9uqcnxhprvkeg4wqc3faxuly3hume6aqxqru7m8ucp6kraeqfcftdqjjvsalj5k05ta8ggs6h7l5d65hxrcd5klm6fs30lh8m6zw6fwy3zajd9wj0msj6ace2yycsj4zfc"
    },
    "shieldedESK": {
      "hex": "0300388006e79285e700c83d24bfa44b1a322e0870d75e9a5bbf942dbc56bdf369784a633e54338d0b8687178c3581fc848973f9a53f9f80719319",
      "bech32m": "mn_shield-esk_test1qvqr3qqxu7fgtecqeq7jf0ayfvdrytsgwrt4axjmh72zm0zkhhekj7z2vvl9gvudpwrgw9uvxkqlepyfw0u620ulspcexxgncjy75"
    },
    "shieldedCPK": {
      "hex": "11d519b374e26d0bc42dfe1892f01899ae11b2d9455c0c453d373e48df9bceba",
      "bech32m": "mn_shield-cpk_test1z823nvm5ufksh3pdlcvf9uqcnxhprvkeg4wqc3faxuly3hume6aqqv8mdq"
    }
  },
  {
    "seed": "2020202020202020202020202020202020202020202020202020202020202020",
    "networkId": "my-private-net-5",
    "shieldedAddress": {
      "hex": "11d519b374e26d0bc42dfe1892f01899ae11b2d9455c0c453d373e48df9bceba03007cf6cfcc07561f7204e12b68252643bf952cfa2fa74221abfbf46ea9730f0da5bfbd26117fee7de84ed25c488bb2695d27ee12d771951098",
      "bech32m": "mn_shield-addr_my-private-net-51z823nvm5ufksh3pdlcvf9uqcnxhprvkeg4wqc3faxuly3hume6aqxqru7m8ucp6kraeqfcftdqjjvsalj5k05ta8ggs6h7l5d65hxrcd5klm6fs30lh8m6zw6fwy3zajd9wj0msj6ace2yycsn7z8x"
    },
    "shieldedESK": {
      "hex": "0300388006e79285e700c83d24bfa44b1a322e0870d75e9a5bbf942dbc56bdf369784a633e54338d0b8687178c3581fc848973f9a53f9f80719319",
      "bech32m": "mn_shield-esk_my-private-net-51qvqr3qqxu7fgtecqeq7jf0ayfvdrytsgwrt4axjmh72zm0zkhhekj7z2vvl9gvudpwrgw9uvxkqlepyfw0u620ulspcexxgvlxh68"
    },
    "shieldedCPK": {
      "hex": "11d519b374e26d0bc42dfe1892f01899ae11b2d9455c0c453d373e48df9bceba",
      "bech32m": "mn_shield-cpk_my-private-net-51z823nvm5ufksh3pdlcvf9uqcnxhprvkeg4wqc3faxuly3hume6aqdn2jc0"
    }
  },
  {
    "seed": "4040404040404040404040404040404040404040404040404040404040404040",
    "networkId": null,
    "shieldedAddress": {
      "hex": "b018b0b0ad79ca5c84214ac6bb9a67b4f742953e081ab2424e199a556c3eaa4203003f28b539c8293d0982fa1532caf7081068a6ce3b639103fee711a7128b118b0a354a19a736f2540d2a7ff02a3b182c7dad3edb481232541b",
      "bech32m": "mn_shield-addr1kqvtpv9d0899epppftrthxn8knm599f7pqdtysjwrxd92mp74fpqxqpl9z6nnjpf85yc97s4xt90wzqsdznvuwmrjyplaec35ufgkyvtpg655xd8xme9grf20lcz5wcc937660kmfqfry4qmeaxpuc"
    },
    "shieldedESK": {
      "hex": "030038b50d6f5a55643e11ec0a81e8414aab7d7c25d16fe45d7f96f2089f0e4dbc3ea9349ad0d11195e60ae93e15722c17e01f9b55bc0209cb9a01",
      "bech32m": "mn_shield-esk1qvqr3dgddad92ep7z8kq4q0gg992kltuyhgkleza07t0yzylpexmc04fxjddp5g3jhnq46f7z4ezc9lqr7d4t0qzp89e5qgv4xnxv"
    },
    "shieldedCPK": {
      "hex": "b018b0b0ad79ca5c84214ac6bb9a67b4f742953e081ab2424e199a556c3eaa42",
      "bech32m": "mn_shield-cpk1kqvtpv9d0899epppftrthxn8knm599f7pqdtysjwrxd92mp74fpqujsguk"
    }
  },
  {
    "seed": "4040404040404040404040404040404040404040404040404040404040404040",
    "networkId": "my-private-net",
    "shieldedAddress": {
      "hex": "b018b0b0ad79ca5c84214ac6bb9a67b4f742953e081ab2424e199a556c3eaa4203003f28b539c8293d0982fa1532caf7081068a6ce3b639103fee711a7128b118b0a354a19a736f2540d2a7ff02a3b182c7dad3edb481232541b",
      "bech32m": "mn_shield-addr_my-private-net1kqvtpv9d0899epppftrthxn8knm599f7pqdtysjwrxd92mp74fpqxqpl9z6nnjpf85yc97s4xt90wzqsdznvuwmrjyplaec35ufgkyvtpg655xd8xme9grf20lcz5wcc937660kmfqfry4qmtrjq4k"
    },
    "shieldedESK": {
      "hex": "030038b50d6f5a55643e11ec0a81e8414aab7d7c25d16fe45d7f96f2089f0e4dbc3ea9349ad0d11195e60ae93e15722c17e01f9b55bc0209cb9a01",
      "bech32m": "mn_shield-esk_my-private-net1qvqr3dgddad92ep7z8kq4q0gg992kltuyhgkleza07t0yzylpexmc04fxjddp5g3jhnq46f7z4ezc9lqr7d4t0qzp89e5qg3l48xv"
    },
    "shieldedCPK": {
      "hex": "b018b0b0ad79ca5c84214ac6bb9a67b4f742953e081ab2424e199a556c3eaa42",
      "bech32m": "mn_shield-cpk_my-private-net1kqvtpv9d0899epppftrthxn8knm599f7pqdtysjwrxd92mp74fpqy8xjr4"
    }
  },
  {
    "seed": "4040404040404040404040404040404040404040404040404040404040404040",
    "networkId": "dev",
    "shieldedAddress": {
      "hex": "b018b0b0ad79ca5c84214ac6bb9a67b4f742953e081ab2424e199a556c3eaa4203003f28b539c8293d0982fa1532caf7081068a6ce3b639103fee711a7128b118b0a354a19a736f2540d2a7ff02a3b182c7dad3edb481232541b",
      "bech32m": "mn_shield-addr_dev1kqvtpv9d0899epppftrthxn8knm599f7pqdtysjwrxd92mp74fpqxqpl9z6nnjpf85yc97s4xt90wzqsdznvuwmrjyplaec35ufgkyvtpg655xd8xme9grf20lcz5wcc937660kmfqfry4qmt4y93m"
    },
    "shieldedESK": {
      "hex": "030038b50d6f5a55643e11ec0a81e8414aab7d7c25d16fe45d7f96f2089f0e4dbc3ea9349ad0d11195e60ae93e15722c17e01f9b55bc0209cb9a01",
      "bech32m": "mn_shield-esk_dev1qvqr3dgddad92ep7z8kq4q0gg992kltuyhgkleza07t0yzylpexmc04fxjddp5g3jhnq46f7z4ezc9lqr7d4t0qzp89e5qg9saye3"
    },
    "shieldedCPK": {
      "hex": "b018b0b0ad79ca5c84214ac6bb9a67b4f742953e081ab2424e199a556c3eaa42",
      "bech32m": "mn_shield-cpk_dev1kqvtpv9d0899epppftrthxn8knm599f7pqdtysjwrxd92mp74fpqp9w2cl"
    }
  },
  {
    "seed": "4040404040404040404040404040404040404040404040404040404040404040",
    "networkId": "test",
    "shieldedAddress": {
      "hex": "b018b0b0ad79ca5c84214ac6bb9a67b4f742953e081ab2424e199a556c3eaa4203003f28b539c8293d0982fa1532caf7081068a6ce3b639103fee711a7128b118b0a354a19a736f2540d2a7ff02a3b182c7dad3edb481232541b",
      "bech32m": "mn_shield-addr_test1kqvtpv9d0899epppftrthxn8knm599f7pqdtysjwrxd92mp74fpqxqpl9z6nnjpf85yc97s4xt90wzqsdznvuwmrjyplaec35ufgkyvtpg655xd8xme9grf20lcz5wcc937660kmfqfry4qmvafukx"
    },
    "shieldedESK": {
      "hex": "030038b50d6f5a55643e11ec0a81e8414aab7d7c25d16fe45d7f96f2089f0e4dbc3ea9349ad0d11195e60ae93e15722c17e01f9b55bc0209cb9a01",
      "bech32m": "mn_shield-esk_test1qvqr3dgddad92ep7z8kq4q0gg992kltuyhgkleza07t0yzylpexmc04fxjddp5g3jhnq46f7z4ezc9lqr7d4t0qzp89e5qg624ed3"
    },
    "shieldedCPK": {
      "hex": "b018b0b0ad79ca5c84214ac6bb9a67b4f742953e081ab2424e199a556c3eaa42",
      "bech32m": "mn_shield-cpk_test1kqvtpv9d0899epppftrthxn8knm599f7pqdtysjwrxd92mp74fpqwkq0fg"
    }
  },
  {
    "seed": "4040404040404040404040404040404040404040404040404040404040404040",
    "networkId": "my-private-net-5",
    "shieldedAddress": {
      "hex": "b018b0b0ad79ca5c84214ac6bb9a67b4f742953e081ab2424e199a556c3eaa4203003f28b539c8293d0982fa1532caf7081068a6ce3b639103fee711a7128b118b0a354a19a736f2540d2a7ff02a3b182c7dad3edb481232541b",
      "bech32m": "mn_shield-addr_my-private-net-51kqvtpv9d0899epppftrthxn8knm599f7pqdtysjwrxd92mp74fpqxqpl9z6nnjpf85yc97s4xt90wzqsdznvuwmrjyplaec35ufgkyvtpg655xd8xme9grf20lcz5wcc937660kmfqfry4qmvuzucc"
    },
    "shieldedESK": {
      "hex": "030038b50d6f5a55643e11ec0a81e8414aab7d7c25d16fe45d7f96f2089f0e4dbc3ea9349ad0d11195e60ae93e15722c17e01f9b55bc0209cb9a01",
      "bech32m": "mn_shield-esk_my-private-net-51qvqr3dgddad92ep7z8kq4q0gg992kltuyhgkleza07t0yzylpexmc04fxjddp5g3jhnq46f7z4ezc9lqr7d4t0qzp89e5qg9dp2fz"
    },
    "shieldedCPK": {
      "hex": "b018b0b0ad79ca5c84214ac6bb9a67b4f742953e081ab2424e199a556c3eaa42",
      "bech32m": "mn_shield-cpk_my-private-net-51kqvtpv9d0899epppftrthxn8knm599f7pqdtysjwrxd92mp74fpqrfdxu8"
    }
  },
  {
    "seed": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
    "networkId": null,
    "shieldedAddress": {
      "hex": "28574eaddbd020b46e53807474d8b7510ee6cf239607f2fc052a1a22b213003d03002fb3bb6966d62507536cb0be5c5e106eebaffbd1a2d0205c1c3e5d1eaed19ead1702fb4207dc15b85fc61b012ee873f4dc465c3faa4ec38f",
      "bech32m": "mn_shield-addr19pt5atwm6qstgmjnsp68fk9h2y8wdnerjcrl9lq99gdz9vsnqq7sxqp0kwakjekky5r4xm9shew9uyrwawhlh5dz6qs9c8p7t502a5v745ts976zqlwptwzlccdszthgw06dc3ju874yasu03j29ps"
    },
    "shieldedESK": {
      "hex": "030038b95515e121a4777afb82adb85dd17e0819bdd49157eb3adcd19a95f3c24729ed15896fb4a482e3d65fa637d3ef2e5c9f0551bb346d6e2115",
      "bech32m": "mn_shield-esk1qvqr3w24zhsjrfrh0tac9tdcthghuzqehh2fz4lt8twdrx5470pyw20dzkykld9yst3avhaxxlf77tjunuz4rwe5d4hzz9g2up8cg"
    },
    "shieldedCPK": {
      "hex": "28574eaddbd020b46e53807474d8b7510ee6cf239607f2fc052a1a22b213003d",
      "bech32m": "mn_shield-cpk19pt5atwm6qstgmjnsp68fk9h2y8wdnerjcrl9lq99gdz9vsnqq7scw6pn3"
    }
  },
  {
    "seed": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
    "networkId": "my-private-net",
    "shieldedAddress": {
      "hex": "28574eaddbd020b46e53807474d8b7510ee6cf239607f2fc052a1a22b213003d03002fb3bb6966d62507536cb0be5c5e106eebaffbd1a2d0205c1c3e5d1eaed19ead1702fb4207dc15b85fc61b012ee873f4dc465c3faa4ec38f",
      "bech32m": "mn_shield-addr_my-private-net19pt5atwm6qstgmjnsp68fk9h2y8wdnerjcrl9lq99gdz9vsnqq7sxqp0kwakjekky5r4xm9shew9uyrwawhlh5dz6qs9c8p7t502a5v745ts976zqlwptwzlccdszthgw06dc3ju874yasu0rv7yg7"
    },
    "shieldedESK": {
      "hex": "030038b95515e121a4777afb82adb85dd17e0819bdd49157eb3adcd19a95f3c24729ed15896fb4a482e3d65fa637d3ef2e5c9f0551bb346d6e2115",
      "bech32m": "mn_shield-esk_my-private-net1qvqr3w24zhsjrfrh0tac9tdcthghuzqehh2fz4lt8twdrx5470pyw20dzkykld9yst3avhaxxlf77tjunuz4rwe5d4hzz9ghkjncg"
    },
    "shieldedCPK": {
      "hex": "28574eaddbd020b46e53807474d8b7510ee6cf239607f2fc052a1a22b213003d",
      "bech32m": "mn_shield-cpk_my-private-net19pt5atwm6qstgmjnsp68fk9h2y8wdnerjcrl9lq99gdz9vsnqq7sqmvmvj"
    }
  },
  {
    "seed": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
    "networkId": "dev",
    "shieldedAddress": {
      "hex": "28574eaddbd020b46e53807474d8b7510ee6cf239607f2fc052a1a22b213003d03002fb3bb6966d62507536cb0be5c5e106eebaffbd1a2d0205c1c3e5d1eaed19ead1702fb4207dc15b85fc61b012ee873f4dc465c3faa4ec38f",
      "bech32m": "mn_shield-addr_dev19pt5atwm6qstgmjnsp68fk9h2y8wdnerjcrl9lq99gdz9vsnqq7sxqp0kwakjekky5r4xm9shew9uyrwawhlh5dz6qs9c8p7t502a5v745ts976zqlwptwzlccdszthgw06dc3ju874yasu0r6gpvn"
    },
    "shieldedESK": {
      "hex": "030038b95515e121a4777afb82adb85dd17e0819bdd49157eb3adcd19a95f3c24729ed15896fb4a482e3d65fa637d3ef2e5c9f0551bb346d6e2115",
      "bech32m": "mn_shield-esk_dev1qvqr3w24zhsjrfrh0tac9tdcthghuzqehh2fz4lt8twdrx5470pyw20dzkykld9yst3avhaxxlf77tjunuz4rwe5d4hzz9gre6s84"
    },
    "shieldedCPK": {
      "hex": "28574eaddbd020b46e53807474d8b7510ee6cf239607f2fc052a1a22b213003d",
      "bech32m": "mn_shield-cpk_dev19pt5atwm6qstgmjnsp68fk9h2y8wdnerjcrl9lq99gdz9vsnqq7s9eyrhc"
    }
  },
  {
    "seed": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
    "networkId": "test",
    "shieldedAddress": {
      "hex": "28574eaddbd020b46e53807474d8b7510ee6cf239607f2fc052a1a22b213003d03002fb3bb6966d62507536cb0be5c5e106eebaffbd1a2d0205c1c3e5d1eaed19ead1702fb4207dc15b85fc61b012ee873f4dc465c3faa4ec38f",
      "bech32m": "mn_shield-addr_test19pt5atwm6qstgmjnsp68fk9h2y8wdnerjcrl9lq99gdz9vsnqq7sxqp0kwakjekky5r4xm9shew9uyrwawhlh5dz6qs9c8p7t502a5v745ts976zqlwptwzlccdszthgw06dc3ju874yasu0yj9ctw"
    },
    "shieldedESK": {
      "hex": "030038b95515e121a4777afb82adb85dd17e0819bdd49157eb3adcd19a95f3c24729ed15896fb4a482e3d65fa637d3ef2e5c9f0551bb346d6e2115",
      "bech32m": "mn_shield-esk_test1qvqr3w24zhsjrfrh0tac9tdcthghuzqehh2fz4lt8twdrx5470pyw20dzkykld9yst3avhaxxlf77tjunuz4rwe5d4hzz9gurjdn4"
    },
    "shieldedCPK": {
      "hex": "28574eaddbd020b46e53807474d8b7510ee6cf239607f2fc052a1a22b213003d",
      "bech32m": "mn_shield-cpk_test19pt5atwm6qstgmjnsp68fk9h2y8wdnerjcrl9lq99gdz9vsnqq7s222xx0"
    }
  },
  {
    "seed": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
    "networkId": "my-private-net-5",
    "shieldedAddress": {
      "hex": "28574eaddbd020b46e53807474d8b7510ee6cf239607f2fc052a1a22b213003d03002fb3bb6966d62507536cb0be5c5e106eebaffbd1a2d0205c1c3e5d1eaed19ead1702fb4207dc15b85fc61b012ee873f4dc465c3faa4ec38f",
      "bech32m": "mn_shield-addr_my-private-net-519pt5atwm6qstgmjnsp68fk9h2y8wdnerjcrl9lq99gdz9vsnqq7sxqp0kwakjekky5r4xm9shew9uyrwawhlh5dz6qs9c8p7t502a5v745ts976zqlwptwzlccdszthgw06dc3ju874yasu0ynwc9s"
    },
    "shieldedESK": {
      "hex": "030038b95515e121a4777afb82adb85dd17e0819bdd49157eb3adcd19a95f3c24729ed15896fb4a482e3d65fa637d3ef2e5c9f0551bb346d6e2115",
      "bech32m": "mn_shield-esk_my-private-net-51qvqr3w24zhsjrfrh0tac9tdcthghuzqehh2fz4lt8twdrx5470pyw20dzkykld9yst3avhaxxlf77tjunuz4rwe5d4hzz9gryx7hx"
    },
    "shieldedCPK": {
      "hex": "28574eaddbd020b46e53807474d8b7510ee6cf239607f2fc052a1a22b213003d",
      "bech32m": "mn_shield-cpk_my-private-net-519pt5atwm6qstgmjnsp68fk9h2y8wdnerjcrl9lq99gdz9vsnqq7s8480nq"
    }
  },
  {
    "seed": "b49408db310c043ab736fb57a98e15c8cedbed4c38450df3755ac9726ee14d0c",
    "networkId": null,
    "shieldedAddress": {
      "hex": "0731484ed8b9321e68619d2133d31b9c936558449b9698ffa15956703c1f717d0300f31a67e9a2b8112d4d6e1422a8b1430d4f30369b0a53ebdfe44308bf3b9fccbedf3504a3c1aad5bb0b174b3bad0fc655c4a9e1d84da9539d",
      "bech32m": "mn_shield-addr1quc5snkchyepu6rpn5sn85cmnjfk2kzynwtf3lapt9t8q0qlw97sxq8nrfn7ng4czyk56ms5y25tzscdfucrdxc2204alezrpzlnh87vhm0n2p9rcx4dtwctza9nhtg0ce2uf20pmpx6j5uaa9xh4c"
    },
    "shieldedESK": {
      "hex": "0300382c3d55773fb48cceb9f3d1aaa6a3be3cbf6f7c11faca944357e1d8335bad2ca45cf88cb85989c53a22593ec9314dfef28e9f5704c3fc8323",
      "bech32m": "mn_shield-esk1qvqrstpa24mnldyve6ul85d2563mu09lda7pr7k2j3p40cwcxdd66t9ytnugewze38zn5gje8mynzn07728f74cyc07gxgceyu4ma"
    },
    "shieldedCPK": {
      "hex": "0731484ed8b9321e68619d2133d31b9c936558449b9698ffa15956703c1f717d",
      "bech32m": "mn_shield-cpk1quc5snkchyepu6rpn5sn85cmnjfk2kzynwtf3lapt9t8q0qlw97s6t4yl0"
    }
  },
  {
    "seed": "b49408db310c043ab736fb57a98e15c8cedbed4c38450df3755ac9726ee14d0c",
    "networkId": "my-private-net",
    "shieldedAddress": {
      "hex": "0731484ed8b9321e68619d2133d31b9c936558449b9698ffa15956703c1f717d0300f31a67e9a2b8112d4d6e1422a8b1430d4f30369b0a53ebdfe44308bf3b9fccbedf3504a3c1aad5bb0b174b3bad0fc655c4a9e1d84da9539d",
      "bech32m": "mn_shield-addr_my-private-net1quc5snkchyepu6rpn5sn85cmnjfk2kzynwtf3lapt9t8q0qlw97sxq8nrfn7ng4czyk56ms5y25tzscdfucrdxc2204alezrpzlnh87vhm0n2p9rcx4dtwctza9nhtg0ce2uf20pmpx6j5ua0mjkuk"
    },
    "shieldedESK": {
      "hex": "0300382c3d55773fb48cceb9f3d1aaa6a3be3cbf6f7c11faca944357e1d8335bad2ca45cf88cb85989c53a22593ec9314dfef28e9f5704c3fc8323",
      "bech32m": "mn_shield-esk_my-private-net1qvqrstpa24mnldyve6ul85d2563mu09lda7pr7k2j3p40cwcxdd66t9ytnugewze38zn5gje8mynzn07728f74cyc07gxgcyw0pma"
    },
    "shieldedCPK": {
      "hex": "0731484ed8b9321e68619d2133d31b9c936558449b9698ffa15956703c1f717d",
      "bech32m": "mn_shield-cpk_my-private-net1quc5snkchyepu6rpn5sn85cmnjfk2kzynwtf3lapt9t8q0qlw97sz7r7qv"
    }
  },
  {
    "seed": "b49408db310c043ab736fb57a98e15c8cedbed4c38450df3755ac9726ee14d0c",
    "networkId": "dev",
    "shieldedAddress": {
      "hex": "0731484ed8b9321e68619d2133d31b9c936558449b9698ffa15956703c1f717d0300f31a67e9a2b8112d4d6e1422a8b1430d4f30369b0a53ebdfe44308bf3b9fccbedf3504a3c1aad5bb0b174b3bad0fc655c4a9e1d84da9539d",
      "bech32m": "mn_shield-addr_dev1quc5snkchyepu6rpn5sn85cmnjfk2kzynwtf3lapt9t8q0qlw97sxq8nrfn7ng4czyk56ms5y25tzscdfucrdxc2204alezrpzlnh87vhm0n2p9rcx4dtwctza9nhtg0ce2uf20pmpx6j5ua0dyncm"
    },
    "shieldedESK": {
      "hex": "0300382c3d55773fb48cceb9f3d1aaa6a3be3cbf6f7c11faca944357e1d8335bad2ca45cf88cb85989c53a22593ec9314dfef28e9f5704c3fc8323",
      "bech32m": "mn_shield-esk_dev1qvqrstpa24mnldyve6ul85d2563mu09lda7pr7k2j3p40cwcxdd66t9ytnugewze38zn5gje8mynzn07728f74cyc07gxgcsp8zyq"
    },
    "shieldedCPK": {
      "hex": "0731484ed8b9321e68619d2133d31b9c936558449b9698ffa15956703c1f717d",
      "bech32m": "mn_shield-cpk_dev1quc5snkchyepu6rpn5sn85cmnjfk2kzynwtf3lapt9t8q0qlw97s8utxmx"
    }
  },
  {
    "seed": "b49408db310c043ab736fb57a98e15c8cedbed4c38450df3755ac9726ee14d0c",
    "networkId": "test",
    "shieldedAddress": {
      "hex": "0731484ed8b9321e68619d2133d31b9c936558449b9698ffa15956703c1f717d0300f31a67e9a2b8112d4d6e1422a8b1430d4f30369b0a53ebdfe44308bf3b9fccbedf3504a3c1aad5bb0b174b3bad0fc655c4a9e1d84da9539d",
      "bech32m": "mn_shield-addr_test1quc5snkchyepu6rpn5sn85cmnjfk2kzynwtf3lapt9t8q0qlw97sxq8nrfn7ng4czyk56ms5y25tzscdfucrdxc2204alezrpzlnh87vhm0n2p9rcx4dtwctza9nhtg0ce2uf20pmpx6j5uag9f2lx"
    },
    "shieldedESK": {
      "hex": "0300382c3d55773fb48cceb9f3d1aaa6a3be3cbf6f7c11faca944357e1d8335bad2ca45cf88cb85989c53a22593ec9314dfef28e9f5704c3fc8323",
      "bech32m": "mn_shield-esk_test1qvqrstpa24mnldyve6ul85d2563mu09lda7pr7k2j3p40cwcxdd66t9ytnugewze38zn5gje8mynzn07728f74cyc07gxgc0m0lsq"
    },
    "shieldedCPK": {
      "hex": "0731484ed8b9321e68619d2133d31b9c936558449b9698ffa15956703c1f717d",
      "bech32m": "mn_shield-cpk_test1quc5snkchyepu6rpn5sn85cmnjfk2kzynwtf3lapt9t8q0qlw97sg09r23"
    }
  },
  {
    "seed": "b49408db310c043ab736fb57a98e15c8cedbed4c38450df3755ac9726ee14d0c",
    "networkId": "my-private-net-5",
    "shieldedAddress": {
      "hex": "0731484ed8b9321e68619d2133d31b9c936558449b9698ffa15956703c1f717d0300f31a67e9a2b8112d4d6e1422a8b1430d4f30369b0a53ebdfe44308bf3b9fccbedf3504a3c1aad5bb0b174b3bad0fc655c4a9e1d84da9539d",
      "bech32m": "mn_shield-addr_my-private-net-51quc5snkchyepu6rpn5sn85cmnjfk2kzynwtf3lapt9t8q0qlw97sxq8nrfn7ng4czyk56ms5y25tzscdfucrdxc2204alezrpzlnh87vhm0n2p9rcx4dtwctza9nhtg0ce2uf20pmpx6j5uagyz23c"
    },
    "shieldedESK": {
      "hex": "0300382c3d55773fb48cceb9f3d1aaa6a3be3cbf6f7c11faca944357e1d8335bad2ca45cf88cb85989c53a22593ec9314dfef28e9f5704c3fc8323",
      "bech32m": "mn_shield-esk_my-private-net-51qvqrstpa24mnldyve6ul85d2563mu09lda7pr7k2j3p40cwcxdd66t9ytnugewze38zn5gje8mynzn07728f74cyc07gxgcsumv5n"
    },
    "shieldedCPK": {
      "hex": "0731484ed8b9321e68619d2133d31b9c936558449b9698ffa15956703c1f717d",
      "bech32m": "mn_shield-cpk_my-private-net-51quc5snkchyepu6rpn5sn85cmnjfk2kzynwtf3lapt9t8q0qlw97s9sg2l7"
    }
  },
  {
    "seed": "06004625b6cb2ccead21b15fee2a940c404365702b697b4721bfeecfc6b1b15e",
    "networkId": null,
    "shieldedAddress": {
      "hex": "e98ce5b18b700d393162f0985768c5c68e089e1bc2d18762105f25b6597012c903008de089f307ebffcda61ec2d5b1b1a7f33cc488bf460f6142259b22801347e4474033388b8c47c7bdceea1ab5de5842e1ca6db96f15ab9a16",
      "bech32m": "mn_shield-addr1axxwtvvtwqxnjvtz7zv9w6x9c68q38smctgcwcsstujmvktsztysxqyduzylxpltllx6v8kz6kcmrfln8nzg306xpas5yfvmy2qpx3lygaqrxwyt33ru00wwagdtthjcgtsu5mdedu26hxskrkdk0u"
    },
    "shieldedESK": {
      "hex": "03003876344263f848c56b6af24d46230b9afe11953d2e95eb320bbe5bdbc050a63cc89c10df6a4554585e60cecb67a20fe3ad14c04778cb435720",
      "bech32m": "mn_shield-esk1qvqrsa35gf3lsjx9dd40yn2xyv9e4ls3j57ja90txg9muk7mcpg2v0xgnsgd76j923v9ucxwedn6yrlr452vq3mcedp4wgqd2avnt"
    },
    "shieldedCPK": {
      "hex": "e98ce5b18b700d393162f0985768c5c68e089e1bc2d18762105f25b6597012c9",
      "bech32m": "mn_shield-cpk1axxwtvvtwqxnjvtz7zv9w6x9c68q38smctgcwcsstujmvktsztys705mez"
    }
  },
  {
    "seed": "06004625b6cb2ccead21b15fee2a940c404365702b697b4721bfeecfc6b1b15e",
    "networkId": "my-private-net",
    "shieldedAddress": {
      "hex": "e98ce5b18b700d393162f0985768c5c68e089e1bc2d18762105f25b6597012c903008de089f307ebffcda61ec2d5b1b1a7f33cc488bf460f6142259b22801347e4474033388b8c47c7bdceea1ab5de5842e1ca6db96f15ab9a16",
      "bech32m": "mn_shield-addr_my-private-net1axxwtvvtwqxnjvtz7zv9w6x9c68q38smctgcwcsstujmvktsztysxqyduzylxpltllx6v8kz6kcmrfln8nzg306xpas5yfvmy2qpx3lygaqrxwyt33ru00wwagdtthjcgtsu5mdedu26hxsk3gehxj"
    },
    "shieldedESK": {
      "hex": "03003876344263f848c56b6af24d46230b9afe11953d2e95eb320bbe5bdbc050a63cc89c10df6a4554585e60cecb67a20fe3ad14c04778cb435720",
      "bech32m": "mn_shield-esk_my-private-net1qvqrsa35gf3lsjx9dd40yn2xyv9e4ls3j57ja90txg9muk7mcpg2v0xgnsgd76j923v9ucxwedn6yrlr452vq3mcedp4wgqsqwcnt"
    },
    "shieldedCPK": {
      "hex": "e98ce5b18b700d393162f0985768c5c68e089e1bc2d18762105f25b6597012c9",
      "bech32m": "mn_shield-cpk_my-private-net1axxwtvvtwqxnjvtz7zv9w6x9c68q38smctgcwcsstujmvktsztysx6zpxp"
    }
  },
  {
    "seed": "06004625b6cb2ccead21b15fee2a940c404365702b697b4721bfeecfc6b1b15e",
    "networkId": "dev",
    "shieldedAddress": {
      "hex": "e98ce5b18b700d393162f0985768c5c68e089e1bc2d18762105f25b6597012c903008de089f307ebffcda61ec2d5b1b1a7f33cc488bf460f6142259b22801347e4474033388b8c47c7bdceea1ab5de5842e1ca6db96f15ab9a16",
      "bech32m": "mn_shield-addr_dev1axxwtvvtwqxnjvtz7zv9w6x9c68q38smctgcwcsstujmvktsztysxqyduzylxpltllx6v8kz6kcmrfln8nzg306xpas5yfvmy2qpx3lygaqrxwyt33ru00wwagdtthjcgtsu5mdedu26hxsk370jzl"
    },
    "shieldedESK": {
      "hex": "03003876344263f848c56b6af24d46230b9afe11953d2e95eb320bbe5bdbc050a63cc89c10df6a4554585e60cecb67a20fe3ad14c04778cb435720",
      "bech32m": "mn_shield-esk_dev1qvqrsa35gf3lsjx9dd40yn2xyv9e4ls3j57ja90txg9muk7mcpg2v0xgnsgd76j923v9ucxwedn6yrlr452vq3mcedp4wgqy0xmvk"
    },
    "shieldedCPK": {
      "hex": "e98ce5b18b700d393162f0985768c5c68e089e1bc2d18762105f25b6597012c9",
      "bech32m": "mn_shield-cpk_dev1axxwtvvtwqxnjvtz7zv9w6x9c68q38smctgcwcsstujmvktsztysrc2eat"
    }
  },
  {
    "seed": "06004625b6cb2ccead21b15fee2a940c404365702b697b4721bfeecfc6b1b15e",
    "networkId": "test",
    "shieldedAddress": {
      "hex": "e98ce5b18b700d393162f0985768c5c68e089e1bc2d18762105f25b6597012c903008de089f307ebffcda61ec2d5b1b1a7f33cc488bf460f6142259b22801347e4474033388b8c47c7bdceea1ab5de5842e1ca6db96f15ab9a16",
      "bech32m": "mn_shield-addr_test1axxwtvvtwqxnjvtz7zv9w6x9c68q38smctgcwcsstujmvktsztysxqyduzylxpltllx6v8kz6kcmrfln8nzg306xpas5yfvmy2qpx3lygaqrxwyt33ru00wwagdtthjcgtsu5mdedu26hxskkkzt9z"
    },
    "shieldedESK": {
      "hex": "03003876344263f848c56b6af24d46230b9afe11953d2e95eb320bbe5bdbc050a63cc89c10df6a4554585e60cecb67a20fe3ad14c04778cb435720",
      "bech32m": "mn_shield-esk_test1qvqrsa35gf3lsjx9dd40yn2xyv9e4ls3j57ja90txg9muk7mcpg2v0xgnsgd76j923v9ucxwedn6yrlr452vq3mcedp4wgqm4wxck"
    },
    "shieldedCPK": {
      "hex": "e98ce5b18b700d393162f0985768c5c68e089e1bc2d18762105f25b6597012c9",
      "bech32m": "mn_shield-cpk_test1axxwtvvtwqxnjvtz7zv9w6x9c68q38smctgcwcsstujmvktsztysvtyuvu"
    }
  },
  {
    "seed": "06004625b6cb2ccead21b15fee2a940c404365702b697b4721bfeecfc6b1b15e",
    "networkId": "my-private-net-5",
    "shieldedAddress": {
      "hex": "e98ce5b18b700d393162f0985768c5c68e089e1bc2d18762105f25b6597012c903008de089f307ebffcda61ec2d5b1b1a7f33cc488bf460f6142259b22801347e4474033388b8c47c7bdceea1ab5de5842e1ca6db96f15ab9a16",
      "bech32m": "mn_shield-addr_my-private-net-51axxwtvvtwqxnjvtz7zv9w6x9c68q38smctgcwcsstujmvktsztysxqyduzylxpltllx6v8kz6kcmrfln8nzg306xpas5yfvmy2qpx3lygaqrxwyt33ru00wwagdtthjcgtsu5mdedu26hxskkhfttu"
    },
    "shieldedESK": {
      "hex": "03003876344263f848c56b6af24d46230b9afe11953d2e95eb320bbe5bdbc050a63cc89c10df6a4554585e60cecb67a20fe3ad14c04778cb435720",
      "bech32m": "mn_shield-esk_my-private-net-51qvqrsa35gf3lsjx9dd40yn2xyv9e4ls3j57ja90txg9muk7mcpg2v0xgnsgd76j923v9ucxwedn6yrlr452vq3mcedp4wgqyj64u9"
    },
    "shieldedCPK": {
      "hex": "e98ce5b18b700d393162f0985768c5c68e089e1bc2d18762105f25b6597012c9",
      "bech32m": "mn_shield-cpk_my-private-net-51axxwtvvtwqxnjvtz7zv9w6x9c68q38smctgcwcsstujmvktsztysp5f4en"
    }
  },
  {
    "seed": "215ca8a6923ec73f241c92ef702ccfc277aa5856bc94f59afa7e82ec94547850",
    "networkId": null,
    "shieldedAddress": {
      "hex": "762d1b3bb135953041aaa23bd7bd90fa9abfdbd3c76c3904765613e05d5f23f70300382fd14c4e335d0863da7cbed708580c534314c96e25a3db7c5369525b3a548a921b955f8009403126a4b9b548dfd06176ecab5ef5dba08b",
      "bech32m": "mn_shield-addr1wck3kwa3xk2nqsd25gaa00vsl2dtlk7ncakrjprk2cf7qh2ly0msxqpc9lg5cn3nt5yx8knuhmtsskqv2dp3fjtwyk3aklznd9f9kwj532fph92lsqy5qvfx5jum2jxl6pshdm9ttm6ahgytymwxy6"
    },
    "shieldedESK": {
      "hex": "030038469ecdfb00523fa7db400237e38b51791dd58ed17598e64df62e62f0fa923c472912b1da9763edd68d865cecab0dbda329a9bccc33f79008",
      "bech32m": "mn_shield-esk1qvqrs357ehasq53l5ld5qq3huw94z7ga6k8dzavcuexlvtnz7rafy0z89yftrk5hv0kadrvxtnk2krda5v56n0xvx0meqzq3qh5sf"
    },
    "shieldedCPK": {
      "hex": "762d1b3bb135953041aaa23bd7bd90fa9abfdbd3c76c3904765613e05d5f23f7",
      "bech32m": "mn_shield-cpk1wck3kwa3xk2nqsd25gaa00vsl2dtlk7ncakrjprk2cf7qh2ly0msqmux4p"
    }
  },
  {
    "seed": "215ca8a6923ec73f241c92ef702ccfc277aa5856bc94f59afa7e82ec94547850",
    "networkId": "my-private-net",
    "shieldedAddress": {
      "hex": "762d1b3bb135953041aaa23bd7bd90fa9abfdbd3c76c3904765613e05d5f23f70300382fd14c4e335d0863da7cbed708580c534314c96e25a3db7c5369525b3a548a921b955f8009403126a4b9b548dfd06176ecab5ef5dba08b",
      "bech32m": "mn_shield-addr_my-private-net1wck3kwa3xk2nqsd25gaa00vsl2dtlk7ncakrjprk2cf7qh2ly0msxqpc9lg5cn3nt5yx8knuhmtsskqv2dp3fjtwyk3aklznd9f9kwj532fph92lsqy5qvfx5jum2jxl6pshdm9ttm6ahgytk968d5"
    },
    "shieldedESK": {
      "hex": "030038469ecdfb00523fa7db400237e38b51791dd58ed17598e64df62e62f0fa923c472912b1da9763edd68d865cecab0dbda329a9bccc33f79008",
      "bech32m": "mn_shield-esk_my-private-net1qvqrs357ehasq53l5ld5qq3huw94z7ga6k8dzavcuexlvtnz7rafy0z89yftrk5hv0kadrvxtnk2krda5v56n0xvx0meqzqv2yqsf"
    },
    "shieldedCPK": {
      "hex": "762d1b3bb135953041aaa23bd7bd90fa9abfdbd3c76c3904765613e05d5f23f7",
      "bech32m": "mn_shield-cpk_my-private-net1wck3kwa3xk2nqsd25gaa00vsl2dtlk7ncakrjprk2cf7qh2ly0mscw2u2z"
    }
  },
  {
    "seed": "215ca8a6923ec73f241c92ef702ccfc277aa5856bc94f59afa7e82ec94547850",
    "networkId": "dev",
    "shieldedAddress": {
      "hex": "762d1b3bb135953041aaa23bd7bd90fa9abfdbd3c76c3904765613e05d5f23f70300382fd14c4e335d0863da7cbed708580c534314c96e25a3db7c5369525b3a548a921b955f8009403126a4b9b548dfd06176ecab5ef5dba08b",
      "bech32m": "mn_shield-addr_dev1wck3kwa3xk2nqsd25gaa00vsl2dtlk7ncakrjprk2cf7qh2ly0msxqpc9lg5cn3nt5yx8knuhmtsskqv2dp3fjtwyk3aklznd9f9kwj532fph92lsqy5qvfx5jum2jxl6pshdm9ttm6ahgytknvzfe"
    },
    "shieldedESK": {
      "hex": "030038469ecdfb00523fa7db400237e38b51791dd58ed17598e64df62e62f0fa923c472912b1da9763edd68d865cecab0dbda329a9bccc33f79008",
      "bech32m": "mn_shield-esk_dev1qvqrs357ehasq53l5ld5qq3huw94z7ga6k8dzavcuexlvtnz7rafy0z89yftrk5hv0kadrvxtnk2krda5v56n0xvx0meqzqc9vr05"
    },
    "shieldedCPK": {
      "hex": "762d1b3bb135953041aaa23bd7bd90fa9abfdbd3c76c3904765613e05d5f23f7",
      "bech32m": "mn_shield-cpk_dev1wck3kwa3xk2nqsd25gaa00vsl2dtlk7ncakrjprk2cf7qh2ly0msavzy3g"
    }
  },
  {
    "seed": "215ca8a6923ec73f241c92ef702ccfc277aa5856bc94f59afa7e82ec94547850",
    "networkId": "test",
    "shieldedAddress": {
      "hex": "762d1b3bb135953041aaa23bd7bd90fa9abfdbd3c76c3904765613e05d5f23f70300382fd14c4e335d0863da7cbed708580c534314c96e25a3db7c5369525b3a548a921b955f8009403126a4b9b548dfd06176ecab5ef5dba08b",
      "bech32m": "mn_shield-addr_test1wck3kwa3xk2nqsd25gaa00vsl2dtlk7ncakrjprk2cf7qh2ly0msxqpc9lg5cn3nt5yx8knuhmtsskqv2dp3fjtwyk3aklznd9f9kwj532fph92lsqy5qvfx5jum2jxl6pshdm9ttm6ahgyt3mpmwy"
    },
    "shieldedESK": {
      "hex": "030038469ecdfb00523fa7db400237e38b51791dd58ed17598e64df62e62f0fa923c472912b1da9763edd68d865cecab0dbda329a9bccc33f79008",
      "bech32m": "mn_shield-esk_test1qvqrs357ehasq53l5ld5qq3huw94z7ga6k8dzavcuexlvtnz7rafy0z89yftrk5hv0kadrvxtnk2krda5v56n0xvx0meqzq8ly7m5"
    },
    "shieldedCPK": {
      "hex": "762d1b3bb135953041aaa23bd7bd90fa9abfdbd3c76c3904765613e05d5f23f7",
      "bech32m": "mn_shield-cpk_test1wck3kwa3xk2nqsd25gaa00vsl2dtlk7ncakrjprk2cf7qh2ly0msjlvpql"
    }
  },
  {
    "seed": "215ca8a6923ec73f241c92ef702ccfc277aa5856bc94f59afa7e82ec94547850",
    "networkId": "my-private-net-5",
    "shieldedAddress": {
      "hex": "762d1b3bb135953041aaa23bd7bd90fa9abfdbd3c76c3904765613e05d5f23f70300382fd14c4e335d0863da7cbed708580c534314c96e25a3db7c5369525b3a548a921b955f8009403126a4b9b548dfd06176ecab5ef5dba08b",
      "bech32m": "mn_shield-addr_my-private-net-51wck3kwa3xk2nqsd25gaa00vsl2dtlk7ncakrjprk2cf7qh2ly0msxqpc9lg5cn3nt5yx8knuhmtsskqv2dp3fjtwyk3aklznd9f9kwj532fph92lsqy5qvfx5jum2jxl6pshdm9ttm6ahgyt362mq6"
    },
    "shieldedESK": {
      "hex": "030038469ecdfb00523fa7db400237e38b51791dd58ed17598e64df62e62f0fa923c472912b1da9763edd68d865cecab0dbda329a9bccc33f79008",
      "bech32m": "mn_shield-esk_my-private-net-51qvqrs357ehasq53l5ld5qq3huw94z7ga6k8dzavcuexlvtnz7rafy0z89yftrk5hv0kadrvxtnk2krda5v56n0xvx0meqzqccsdl8"
    },
    "shieldedCPK": {
      "hex": "762d1b3bb135953041aaa23bd7bd90fa9abfdbd3c76c3904765613e05d5f23f7",
      "bech32m": "mn_shield-cpk_my-private-net-51wck3kwa3xk2nqsd25gaa00vsl2dtlk7ncakrjprk2cf7qh2ly0mslqpg4s"
    }
  },
  {
    "seed": "cfe40bcac30e818d3d4d35d79846b2df2f45c1bde9b7c2d8070095729d769af3",
    "networkId": null,
    "shieldedAddress": {
      "hex": "8281789c8b6651761d5f3c58ffb0eb6541745bc016906731976604519b1a781d03003607142f52ab31ab3723c84bd58e9a5d722071f72bb49f8271355397f39eecac44ae5f47ee56b192b9f4a93d1830989dc17db576d59ff991",
      "bech32m": "mn_shield-addr1s2qh38ytveghv82l83v0lv8tv4qhgk7qz6gxwvvhvcz9rxc60qwsxqpkqu2z754txx4nwg7gf02caxjawgs8raetkj0cyuf42wtl88hv43z2uh68aettry4e7j5n6xpsnzwuzld4wm2el7v30l26sm"
    },
    "shieldedESK": {
      "hex": "030036ef143b4c282f35ef0c22a9583e6dca45dba4850b95b63430d5e6343e9daed8a19e2484c6af8eceaa325adfd561120cf2127d564b0d12",
      "bech32m": "mn_shield-esk1qvqrdmc58dxzste4auxz922c8eku53wm5jzsh9dkxscdte3586w6ak9pncjgf3403m825vj6ml2kzysv7gf864jtp5fqzp6mzz"
    },
    "shieldedCPK": {
      "hex": "8281789c8b6651761d5f3c58ffb0eb6541745bc016906731976604519b1a781d",
      "bech32m": "mn_shield-cpk1s2qh38ytveghv82l83v0lv8tv4qhgk7qz6gxwvvhvcz9rxc60qwsgxm8qy"
    }
  },
  {
    "seed": "cfe40bcac30e818d3d4d35d79846b2df2f45c1bde9b7c2d8070095729d769af3",
    "networkId": "my-private-net",
    "shieldedAddress": {
      "hex": "8281789c8b6651761d5f3c58ffb0eb6541745bc016906731976604519b1a781d03003607142f52ab31ab3723c84bd58e9a5d722071f72bb49f8271355397f39eecac44ae5f47ee56b192b9f4a93d1830989dc17db576d59ff991",
      "bech32m": "mn_shield-addr_my-private-net1s2qh38ytveghv82l83v0lv8tv4qhgk7qz6gxwvvhvcz9rxc60qwsxqpkqu2z754txx4nwg7gf02caxjawgs8raetkj0cyuf42wtl88hv43z2uh68aettry4e7j5n6xpsnzwuzld4wm2el7v3ap7me4"
    },
    "shieldedESK": {
      "hex": "030036ef143b4c282f35ef0c22a9583e6dca45dba4850b95b63430d5e6343e9daed8a19e2484c6af8eceaa325adfd561120cf2127d564b0d12",
      "bech32m": "mn_shield-esk_my-private-net1qvqrdmc58dxzste4auxz922c8eku53wm5jzsh9dkxscdte3586w6ak9pncjgf3403m825vj6ml2kzysv7gf864jtp5fq799g64"
    },
    "shieldedCPK": {
      "hex": "8281789c8b6651761d5f3c58ffb0eb6541745bc016906731976604519b1a781d",
      "bech32m": "mn_shield-cpk_my-private-net1s2qh38ytveghv82l83v0lv8tv4qhgk7qz6gxwvvhvcz9rxc60qwssndal8"
    }
  },
  {
    "seed": "cfe40bcac30e818d3d4d35d79846b2df2f45c1bde9b7c2d8070095729d769af3",
    "networkId": "dev",
    "shieldedAddress": {
      "hex": "8281789c8b6651761d5f3c58ffb0eb6541745bc016906731976604519b1a781d03003607142f52ab31ab3723c84bd58e9a5d722071f72bb49f8271355397f39eecac44ae5f47ee56b192b9f4a93d1830989dc17db576d59ff991",
      "bech32m": "mn_shield-addr_dev1s2qh38ytveghv82l83v0lv8tv4qhgk7qz6gxwvvhvcz9rxc60qwsxqpkqu2z754txx4nwg7gf02caxjawgs8raetkj0cyuf42wtl88hv43z2uh68aettry4e7j5n6xpsnzwuzld4wm2el7v3ahg7ac"
    },
    "shieldedESK": {
      "hex": "030036ef143b4c282f35ef0c22a9583e6dca45dba4850b95b63430d5e6343e9daed8a19e2484c6af8eceaa325adfd561120cf2127d564b0d12",
      "bech32m": "mn_shield-esk_dev1qvqrdmc58dxzste4auxz922c8eku53wm5jzsh9dkxscdte3586w6ak9pncjgf3403m825vj6ml2kzysv7gf864jtp5fqj9mnh9"
    },
    "shieldedCPK": {
      "hex": "8281789c8b6651761d5f3c58ffb0eb6541745bc016906731976604519b1a781d",
      "bech32m": "mn_shield-cpk_dev1s2qh38ytveghv82l83v0lv8tv4qhgk7qz6gxwvvhvcz9rxc60qws4399yd"
    }
  },
  {
    "seed": "cfe40bcac30e818d3d4d35d79846b2df2f45c1bde9b7c2d8070095729d769af3",
    "networkId": "test",
    "shieldedAddress": {
      "hex": "8281789c8b6651761d5f3c58ffb0eb6541745bc016906731976604519b1a781d03003607142f52ab31ab3723c84bd58e9a5d722071f72bb49f8271355397f39eecac44ae5f47ee56b192b9f4a93d1830989dc17db576d59ff991",
      "bech32m": "mn_shield-addr_test1s2qh38ytveghv82l83v0lv8tv4qhgk7qz6gxwvvhvcz9rxc60qwsxqpkqu2z754txx4nwg7gf02caxjawgs8raetkj0cyuf42wtl88hv43z2uh68aettry4e7j5n6xpsnzwuzld4wm2el7v36l9869"
    },
    "shieldedESK": {
      "hex": "030036ef143b4c282f35ef0c22a9583e6dca45dba4850b95b63430d5e6343e9daed8a19e2484c6af8eceaa325adfd561120cf2127d564b0d12",
      "bech32m": "mn_shield-esk_test1qvqrdmc58dxzste4auxz922c8eku53wm5jzsh9dkxscdte3586w6ak9pncjgf3403m825vj6ml2kzysv7gf864jtp5fqvw9ujg"
    },
    "shieldedCPK": {
      "hex": "8281789c8b6651761d5f3c58ffb0eb6541745bc016906731976604519b1a781d",
      "bech32m": "mn_shield-cpk_test1s2qh38ytveghv82l83v0lv8tv4qhgk7qz6gxwvvhvcz9rxc60qws6ztq46"
    }
  },
  {
    "seed": "cfe40bcac30e818d3d4d35d79846b2df2f45c1bde9b7c2d8070095729d769af3",
    "networkId": "my-private-net-5",
    "shieldedAddress": {
      "hex": "8281789c8b6651761d5f3c58ffb0eb6541745bc016906731976604519b1a781d03003607142f52ab31ab3723c84bd58e9a5d722071f72bb49f8271355397f39eecac44ae5f47ee56b192b9f4a93d1830989dc17db576d59ff991",
      "bech32m": "mn_shield-addr_my-private-net-51s2qh38ytveghv82l83v0lv8tv4qhgk7qz6gxwvvhvcz9rxc60qwsxqpkqu2z754txx4nwg7gf02caxjawgs8raetkj0cyuf42wtl88hv43z2uh68aettry4e7j5n6xpsnzwuzld4wm2el7v367w85m"
    },
    "shieldedESK": {
      "hex": "030036ef143b4c282f35ef0c22a9583e6dca45dba4850b95b63430d5e6343e9daed8a19e2484c6af8eceaa325adfd561120cf2127d564b0d12",
      "bech32m": "mn_shield-esk_my-private-net-51qvqrdmc58dxzste4auxz922c8eku53wm5jzsh9dkxscdte3586w6ak9pncjgf3403m825vj6ml2kzysv7gf864jtp5fq579uea"
    },
    "shieldedCPK": {
      "hex": "8281789c8b6651761d5f3c58ffb0eb6541745bc016906731976604519b1a781d",
      "bech32m": "mn_shield-cpk_my-private-net-51s2qh38ytveghv82l83v0lv8tv4qhgk7qz6gxwvvhvcz9rxc60qwshaxfq4"
    }
  },
  {
    "seed": "97b43b7a3747b7f70491fe089c56fe1f6d01e602b7a3ec09cda89d7de324b7e9",
    "networkId": null,
    "shieldedAddress": {
      "hex": "d2dc8d175c0ef7d1f7e5b7f32bd9da5fcd4c60fa1b651f1d312986269c2d3c790300067163802a1811f3440d2721550addffcf4ebea5031da7ff2c2febbe8c987be6fa663d9f684f42a23a3b91e956615cac11ab32f68410d021",
      "bech32m": "mn_shield-addr16twg696upmmaral9klejhkw6tlx5cc86rdj378f39xrzd8pd83usxqqxw93cq2scz8e5grf8y92s4h0lea8tafgrrknl7tp0awlgexrmumaxv0vldp859g368wg7j4nptjkpr2ej76zpp5ppwxy4up"
    },
    "shieldedESK": {
      "hex": "0300377752a8e179c029feef6432d5a45cd9942fcb04ac9c8beee26f58a78a846b2e67aa135e6479b1e83ea4ca8ab0fc48d470543dcc3a1138b4",
      "bech32m": "mn_shield-esk1qvqrwa6j4rshnspflmhkgvk453wdn9p0evz2e8ytam3x7k9832zxktn84gf4uerek85rafx232c0cjx5wp2rmnp6zyutg8cp0x6"
    },
    "shieldedCPK": {
      "hex": "d2dc8d175c0ef7d1f7e5b7f32bd9da5fcd4c60fa1b651f1d312986269c2d3c79",
      "bech32m": "mn_shield-cpk16twg696upmmaral9klejhkw6tlx5cc86rdj378f39xrzd8pd83ush08fq2"
    }
  },
  {
    "seed": "97b43b7a3747b7f70491fe089c56fe1f6d01e602b7a3ec09cda89d7de324b7e9",
    "networkId": "my-private-net",
    "shieldedAddress": {
      "hex": "d2dc8d175c0ef7d1f7e5b7f32bd9da5fcd4c60fa1b651f1d312986269c2d3c790300067163802a1811f3440d2721550addffcf4ebea5031da7ff2c2febbe8c987be6fa663d9f684f42a23a3b91e956615cac11ab32f68410d021",
      "bech32m": "mn_shield-addr_my-private-net16twg696upmmaral9klejhkw6tlx5cc86rdj378f39xrzd8pd83usxqqxw93cq2scz8e5grf8y92s4h0lea8tafgrrknl7tp0awlgexrmumaxv0vldp859g368wg7j4nptjkpr2ej76zpp5ppucs540"
    },
    "shieldedESK": {
      "hex": "0300377752a8e179c029feef6432d5a45cd9942fcb04ac9c8beee26f58a78a846b2e67aa135e6479b1e83ea4ca8ab0fc48d470543dcc3a1138b4",
      "bech32m": "mn_shield-esk_my-private-net1qvqrwa6j4rshnspflmhkgvk453wdn9p0evz2e8ytam3x7k9832zxktn84gf4uerek85rafx232c0cjx5wp2rmnp6zyutg8cu94w"
    },
    "shieldedCPK": {
      "hex": "d2dc8d175c0ef7d1f7e5b7f32bd9da5fcd4c60fa1b651f1d312986269c2d3c79",
      "bech32m": "mn_shield-cpk_my-private-net16twg696upmmaral9klejhkw6tlx5cc86rdj378f39xrzd8pd83us063nlf"
    }
  },
  {
    "seed": "97b43b7a3747b7f70491fe089c56fe1f6d01e602b7a3ec09cda89d7de324b7e9",
    "networkId": "dev",
    "shieldedAddress": {
      "hex": "d2dc8d175c0ef7d1f7e5b7f32bd9da5fcd4c60fa1b651f1d312986269c2d3c790300067163802a1811f3440d2721550addffcf4ebea5031da7ff2c2febbe8c987be6fa663d9f684f42a23a3b91e956615cac11ab32f68410d021",
      "bech32m": "mn_shield-addr_dev16twg696upmmaral9klejhkw6tlx5cc86rdj378f39xrzd8pd83usxqqxw93cq2scz8e5grf8y92s4h0lea8tafgrrknl7tp0awlgexrmumaxv0vldp859g368wg7j4nptjkpr2ej76zpp5ppuwx33z"
    },
    "shieldedESK": {
      "hex": "0300377752a8e179c029feef6432d5a45cd9942fcb04ac9c8beee26f58a78a846b2e67aa135e6479b1e83ea4ca8ab0fc48d470543dcc3a1138b4",
      "bech32m": "mn_shield-esk_dev1qvqrwa6j4rshnspflmhkgvk453wdn9p0evz2e8ytam3x7k9832zxktn84gf4uerek85rafx232c0cjx5wp2rmnp6zyutgkcpz5f"
    },
    "shieldedCPK": {
      "hex": "d2dc8d175c0ef7d1f7e5b7f32bd9da5fcd4c60fa1b651f1d312986269c2d3c79",
      "bech32m": "mn_shield-cpk_dev16twg696upmmaral9klejhkw6tlx5cc86rdj378f39xrzd8pd83us2cetyr"
    }
  },
  {
    "seed": "97b43b7a3747b7f70491fe089c56fe1f6d01e602b7a3ec09cda89d7de324b7e9",
    "networkId": "test",
    "shieldedAddress": {
      "hex": "d2dc8d175c0ef7d1f7e5b7f32bd9da5fcd4c60fa1b651f1d312986269c2d3c790300067163802a1811f3440d2721550addffcf4ebea5031da7ff2c2febbe8c987be6fa663d9f684f42a23a3b91e956615cac11ab32f68410d021",
      "bech32m": "mn_shield-addr_test16twg696upmmaral9klejhkw6tlx5cc86rdj378f39xrzd8pd83usxqqxw93cq2scz8e5grf8y92s4h0lea8tafgrrknl7tp0awlgexrmumaxv0vldp859g368wg7j4nptjkpr2ej76zpp5ppmxtgkl"
    },
    "shieldedESK": {
      "hex": "0300377752a8e179c029feef6432d5a45cd9942fcb04ac9c8beee26f58a78a846b2e67aa135e6479b1e83ea4ca8ab0fc48d470543dcc3a1138b4",
      "bech32m": "mn_shield-esk_test1qvqrwa6j4rshnspflmhkgvk453wdn9p0evz2e8ytam3x7k9832zxktn84gf4uerek85rafx232c0cjx5wp2rmnp6zyutg2upkws"
    },
    "shieldedCPK": {
      "hex": "d2dc8d175c0ef7d1f7e5b7f32bd9da5fcd4c60fa1b651f1d312986269c2d3c79",
      "bech32m": "mn_shield-cpk_test16twg696upmmaral9klejhkw6tlx5cc86rdj378f39xrzd8pd83us9thw45"
    }
  },
  {
    "seed": "97b43b7a3747b7f70491fe089c56fe1f6d01e602b7a3ec09cda89d7de324b7e9",
    "networkId": "my-private-net-5",
    "shieldedAddress": {
      "hex": "d2dc8d175c0ef7d1f7e5b7f32bd9da5fcd4c60fa1b651f1d312986269c2d3c790300067163802a1811f3440d2721550addffcf4ebea5031da7ff2c2febbe8c987be6fa663d9f684f42a23a3b91e956615cac11ab32f68410d021",
      "bech32m": "mn_shield-addr_my-private-net-516twg696upmmaral9klejhkw6tlx5cc86rdj378f39xrzd8pd83usxqqxw93cq2scz8e5grf8y92s4h0lea8tafgrrknl7tp0awlgexrmumaxv0vldp859g368wg7j4nptjkpr2ej76zpp5ppm8qgcp"
    },
    "shieldedESK": {
      "hex": "0300377752a8e179c029feef6432d5a45cd9942fcb04ac9c8beee26f58a78a846b2e67aa135e6479b1e83ea4ca8ab0fc48d470543dcc3a1138b4",
      "bech32m": "mn_shield-esk_my-private-net-51qvqrwa6j4rshnspflmhkgvk453wdn9p0evz2e8ytam3x7k9832zxktn84gf4uerek85rafx232c0cjx5wp2rmnp6zyutg3fdfs7"
    },
    "shieldedCPK": {
      "hex": "d2dc8d175c0ef7d1f7e5b7f32bd9da5fcd4c60fa1b651f1d312986269c2d3c79",
      "bech32m": "mn_shield-cpk_my-private-net-516twg696upmmaral9klejhkw6tlx5cc86rdj378f39xrzd8pd83usg568qm"
    }
  }
]

================
File: packages/address-format/test/bech32.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { describe, expect, it } from 'vitest';
import {
  mainnet,
  MidnightBech32m,
  ShieldedAddress,
  ShieldedCoinPublicKey,
  ShieldedEncryptionSecretKey,
} from '../src/index.js';
import addresses from './addresses.json' with { type: 'json' };

describe('Bech32 addresses', () => {
  it('ShieldedAddress - Bech32 representation should match its Hex representation', () => {
    addresses.forEach((item, _) => {
      const shA = ShieldedAddress.codec.decode(
        item.networkId ?? mainnet,
        MidnightBech32m.parse(item.shieldedAddress.bech32m),
      );

      expect(item.shieldedAddress.hex).toEqual(`${shA.coinPublicKeyString()}${shA.encryptionPublicKeyString()}`);
    });
  });

  /**
   * addresses.json needs to be updated with the correct format for this test to pass
   */
  it.skip('ShieldedEncryptionSecretKey - Bech32 representation should match its Hex representation', () => {
    const zswapNetworkIds = ['dev', 'test', null];
    const filteredAddresses = addresses.filter((item) => zswapNetworkIds.includes(item.networkId));
    filteredAddresses.forEach((item, _) => {
      const shESK = ShieldedEncryptionSecretKey.codec.decode(
        'undeployed',
        MidnightBech32m.parse(item.shieldedESK.bech32m),
      );

      const eskHEXRaw = shESK.zswap.yesIKnowTheSecurityImplicationsOfThis_serialize();
      const eskHEX = Buffer.from(eskHEXRaw.subarray(1)).toString('hex');

      expect(item.shieldedESK.hex).toEqual(eskHEX);
    });
  });

  it('ShieldedCoinPublicKey - Bech32 representation should match its Hex representation', () => {
    addresses.forEach((item, _) => {
      const shCPK = ShieldedCoinPublicKey.codec.decode(
        item.networkId ?? mainnet,
        MidnightBech32m.parse(item.shieldedCPK.bech32m),
      );

      expect(item.shieldedCPK.hex).toEqual(Buffer.from(shCPK.data).toString('hex'));
    });
  });
});

================
File: packages/address-format/.npmignore
================
*.ts.map

================
File: packages/address-format/.prettierignore
================
dist/
coverage/
reports/

================
File: packages/address-format/eslint.config.mjs
================
import { packageConfig } from '../../eslint.config.mjs';

export default packageConfig();

================
File: packages/address-format/README.md
================
# Midnight Wallet SDK Address Format

This package provides support for the Bech32m address format.

================
File: packages/address-format/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "rootDir": "./src",
    "outDir": "./dist",
    "lib": ["ESNext", "dom"]
  },
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/test/**/*.ts", "src/**/*.test.ts"]
}

================
File: packages/address-format/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [{ "path": "./tsconfig.build.json" }, { "path": "./tsconfig.test.json" }]
}

================
File: packages/address-format/tsconfig.publish.json
================
{
  "extends": "./tsconfig.build.json",
  "compilerOptions": {
    "sourceMap": false,
    "declarationMap": false
  }
}

================
File: packages/address-format/tsconfig.test.json
================
{
  "extends": "./tsconfig.json",
  "include": ["src/**/test/**/*.ts", "test/**/*.ts", "src/**/*.ts"]
}

================
File: packages/address-format/vitest.config.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/// <reference types="vitest" />
/// <reference types="vitest/globals" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage',
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }],
    ],
  },
});

================
File: packages/capabilities/src/balancer/Balancer.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { CounterOffer, TransactionCostModel } from './CounterOffer.js';
import { CoinRecipe, Imbalance, Imbalances, TokenType, TokenValue } from './Imbalances.js';

export class InsufficientFundsError extends Error {
  readonly tokenType: TokenType;

  constructor(tokenType: TokenType) {
    super(`Insufficient Funds: could not balance ${tokenType}`);
    this.tokenType = tokenType;
  }
}

export interface BalanceRecipe<TInput extends CoinRecipe, TOutput extends CoinRecipe> {
  inputs: TInput[];
  outputs: TOutput[];
}

export type CoinSelection<TInput extends CoinRecipe> = (
  coins: readonly TInput[],
  tokenType: TokenType,
  amountNeeded: TokenValue,
  costModel: TransactionCostModel,
) => TInput | undefined;

export type BalanceRecipeProps<TInput extends CoinRecipe, TOutput extends CoinRecipe> = {
  coins: TInput[];
  initialImbalances: Imbalances;
  transactionCostModel: TransactionCostModel;
  feeTokenType: string;
  createOutput: (coin: CoinRecipe) => TOutput;
  isCoinEqual: (a: TInput, b: TInput) => boolean;
  coinSelection?: CoinSelection<TInput> | undefined;
  targetImbalances?: Imbalances;
};

export const getBalanceRecipe = <TInput extends CoinRecipe, TOutput extends CoinRecipe>({
  coins,
  initialImbalances,
  transactionCostModel,
  feeTokenType,
  createOutput,
  coinSelection,
  isCoinEqual,
  targetImbalances,
}: BalanceRecipeProps<TInput, TOutput>): BalanceRecipe<TInput, TOutput> => {
  const counterOffer = createCounterOffer(
    coins,
    initialImbalances,
    transactionCostModel,
    feeTokenType,
    coinSelection ?? chooseCoin,
    createOutput,
    isCoinEqual,
    targetImbalances,
  );

  return {
    inputs: counterOffer.inputs,
    outputs: counterOffer.outputs,
  };
};

export const createCounterOffer = <TInput extends CoinRecipe, TOutput extends CoinRecipe>(
  coins: TInput[],
  initialImbalances: Imbalances,
  transactionCostModel: TransactionCostModel,
  feeTokenType: string,
  coinSelection: CoinSelection<TInput>,
  createOutput: (coin: CoinRecipe) => TOutput,
  isCoinEqual: (a: TInput, b: TInput) => boolean,
  targetImbalances: Imbalances = new Map(),
): CounterOffer<TInput, TOutput> => {
  const counterOffer = new CounterOffer<TInput, TOutput>(
    initialImbalances,
    transactionCostModel,
    feeTokenType,
    targetImbalances,
  );

  let imbalance: Imbalance | undefined;

  while ((imbalance = counterOffer.findNonNativeImbalance())) {
    coins = doBalance(imbalance, coins, counterOffer, coinSelection, createOutput, isCoinEqual);
  }

  while ((imbalance = counterOffer.findNativeImbalance())) {
    coins = doBalance(imbalance, coins, counterOffer, coinSelection, createOutput, isCoinEqual);
  }

  return counterOffer;
};

const doBalance = <TInput extends CoinRecipe, TOutput extends CoinRecipe>(
  imbalance: Imbalance,
  coins: TInput[],
  counterOffer: CounterOffer<TInput, TOutput>,
  coinSelection: CoinSelection<TInput>,
  createOutput: (coin: CoinRecipe) => TOutput,
  isCoinEqual: (a: TInput, b: TInput) => boolean,
): TInput[] => {
  const [tokenType, imbalanceAmount] = imbalance;
  const shouldAddOutput =
    (tokenType === counterOffer.feeTokenType &&
      imbalanceAmount >=
        counterOffer.getTargetImbalance(counterOffer.feeTokenType) +
          counterOffer.transactionCostModel.outputFeeOverhead) ||
    (tokenType !== counterOffer.feeTokenType && imbalanceAmount > counterOffer.getTargetImbalance(tokenType));

  if (shouldAddOutput) {
    const output = createOutput({
      type: tokenType,
      value: imbalanceAmount - counterOffer.getTargetImbalance(tokenType),
    });

    counterOffer.addOutput(output);
  } else {
    const coin = coinSelection(coins, tokenType, imbalanceAmount, counterOffer.transactionCostModel);

    if (typeof coin === 'undefined') {
      throw new InsufficientFundsError(tokenType);
    }

    counterOffer.addInput(coin);

    coins = coins.filter((c) => !isCoinEqual(c, coin));
  }

  return coins;
};

export const chooseCoin = <TInput extends CoinRecipe>(
  coins: readonly TInput[],
  tokenType: TokenType,
): TInput | undefined => {
  return coins
    .filter((coin) => coin.type === tokenType)
    .sort((a, b) => Number(a.value - b.value))
    .at(0);
};

================
File: packages/capabilities/src/balancer/CounterOffer.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { CoinRecipe, Imbalance, Imbalances, TokenType } from './Imbalances.js';

export interface TransactionCostModel {
  inputFeeOverhead: bigint;
  outputFeeOverhead: bigint;
}

export class CounterOffer<TInput extends CoinRecipe, TOutput extends CoinRecipe> {
  public readonly imbalances: Imbalances;
  public readonly transactionCostModel: TransactionCostModel;
  public readonly feeTokenType: string;
  public readonly inputs: TInput[];
  public readonly outputs: TOutput[];
  public readonly targetImbalances: Imbalances;

  constructor(
    imbalances: Imbalances,
    transactionCostModel: TransactionCostModel,
    feeTokenType: string,
    targetImbalances: Imbalances,
  ) {
    this.imbalances = Imbalances.ensureZerosFor(imbalances, Imbalances.typeSet(targetImbalances));
    this.transactionCostModel = transactionCostModel;
    this.feeTokenType = feeTokenType;
    this.inputs = [];
    this.outputs = [];
    this.targetImbalances = targetImbalances;
  }

  getTargetImbalance(tokenType: TokenType): bigint {
    return this.targetImbalances.get(tokenType) ?? 0n;
  }

  findNonNativeImbalance(): Imbalance | undefined {
    return Array.from(this.imbalances.entries())
      .filter(([tokenType]) => tokenType !== this.feeTokenType)
      .find(([tokenType, value]) => value !== this.getTargetImbalance(tokenType));
  }

  findNativeImbalance(): Imbalance | undefined {
    if (!this.feeTokenType) {
      return undefined;
    }

    const nativeImbalance = this.imbalances.get(this.feeTokenType);
    if (nativeImbalance !== undefined && nativeImbalance !== this.getTargetImbalance(this.feeTokenType)) {
      return [this.feeTokenType, nativeImbalance];
    }
    return undefined;
  }

  addInput(input: TInput): void {
    this.inputs.push(input);
    const imbalance = this.imbalances.get(input.type) || 0n;
    this.imbalances.set(input.type, imbalance + input.value);
    const nativeImbalance = this.imbalances.get(this.feeTokenType) || 0n;

    this.imbalances.set(this.feeTokenType, nativeImbalance - this.transactionCostModel.inputFeeOverhead);
  }

  addOutput(output: TOutput): void {
    const imbalance = this.imbalances.get(output.type) || 0n;
    const subtractFee = output.type === this.feeTokenType ? this.transactionCostModel.outputFeeOverhead : 0n;
    const absoluteCoinValue = output.value < 0n ? -output.value : output.value;

    this.outputs.push({ ...output, type: output.type, value: absoluteCoinValue - subtractFee });

    this.imbalances.set(output.type, imbalance - absoluteCoinValue);

    if (output.type !== this.feeTokenType) {
      const nativeImbalance = this.imbalances.get(this.feeTokenType) || 0n;
      this.imbalances.set(this.feeTokenType, nativeImbalance - this.transactionCostModel.outputFeeOverhead);
    }
  }
}

================
File: packages/capabilities/src/balancer/Imbalances.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export type TokenType = string;
export type TokenValue = bigint;

export interface CoinRecipe {
  type: TokenType;
  value: TokenValue;
}

export type Imbalance = [TokenType, TokenValue];

export type Imbalances = Map<TokenType, TokenValue>;
export const Imbalances = new (class {
  empty = (): Imbalances => {
    return new Map();
  };
  fromEntry = (tokenType: TokenType, value: bigint): Imbalances => {
    return new Map([[tokenType, value]]);
  };
  fromEntries = (entries: Iterable<readonly [TokenType, bigint]>): Imbalances => {
    const out = new Map<string, bigint>();
    for (const [tokenType, value] of entries) {
      const existingValue = this.getValue(out, tokenType);
      out.set(tokenType, value + existingValue);
    }
    return out;
  };
  fromMap = (map: Map<TokenType, bigint>): Imbalances => {
    return this.fromEntries(map.entries());
  };
  fromMaybeMap = (map: Map<TokenType, bigint> | undefined): Imbalances => {
    return this.fromMap(map ?? new Map<TokenType, bigint>());
  };
  getValue = (map: Imbalances, tokenType: TokenType): bigint => {
    return map.get(tokenType) ?? 0n;
  };
  typeSet = (map: Imbalances): Set<TokenType> => {
    return new Set(map.keys());
  };

  ensureZerosFor(map: Imbalances, types: Iterable<TokenType>): Imbalances {
    const out = this.fromEntries(map.entries());
    for (const tokenType of types) {
      const existingValue = this.getValue(out, tokenType);
      out.set(tokenType, existingValue);
    }
    return out;
  }

  merge = (a: Imbalances, b: Imbalances): Imbalances => {
    const allTokenTypes = this.typeSet(a).union(this.typeSet(b));

    return this.fromEntries(
      allTokenTypes
        .values()
        .map((tokenType) => {
          const aValue = this.getValue(a, tokenType);
          const bValue = this.getValue(b, tokenType);
          return [tokenType, aValue + bValue] as const;
        })
        .filter(([, value]) => value !== 0n)
        .toArray(),
    );
  };
})();

================
File: packages/capabilities/src/balancer/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * from './Balancer.js';
export * from './CounterOffer.js';
export * from './Imbalances.js';

================
File: packages/capabilities/src/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * from './balancer/index.js';

================
File: packages/capabilities/test/Balancer.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import {
  createShieldedCoinInfo,
  QualifiedShieldedCoinInfo,
  RawTokenType,
  sampleRawTokenType,
  ShieldedCoinInfo,
  shieldedToken,
} from '@midnight-ntwrk/ledger-v6';
import * as fc from 'fast-check';
import { describe, expect, test } from 'vitest';
import { chooseCoin, CoinSelection, getBalanceRecipe, Imbalances, TransactionCostModel } from '../src/index.js';

const createQualifiedCoin = (tokenType: string, value: bigint) => ({
  ...createShieldedCoinInfo(tokenType, value),
  mt_index: 0n,
});

const dust = (value: number): bigint => BigInt(value * 10 ** 6);

const transactionCostModel = {
  inputFeeOverhead: 19314n,
  outputFeeOverhead: 19708n,
};

const nativeTokenType = (shieldedToken() as { tag: 'shielded'; raw: string }).raw;

const qualifiedCoinArbitrary = (typeArbitrary: fc.Arbitrary<RawTokenType>): fc.Arbitrary<QualifiedShieldedCoinInfo> => {
  return fc.record({
    nonce: fc.uint8Array({ maxLength: 32, minLength: 32 }).map((bytes) => Buffer.from(bytes).toString('hex')),
    value: fc.bigInt({ min: 1n, max: BigInt(Number.MAX_SAFE_INTEGER) }),
    mt_index: fc.constant(0n),
    type: typeArbitrary,
  });
};

const costModelArbitrary: fc.Arbitrary<TransactionCostModel> = fc.oneof(
  fc.constant<TransactionCostModel>({
    inputFeeOverhead: 0n,
    outputFeeOverhead: 0n,
  }),
  fc.record<TransactionCostModel>({
    inputFeeOverhead: fc.bigInt({ min: 0n, max: dust(1) }),
    outputFeeOverhead: fc.bigInt({ min: 0n, max: dust(1) }),
  }),
);

describe('Balancer', () => {
  test('Nothing to balance', () => {
    const counterOffer = getBalanceRecipe<QualifiedShieldedCoinInfo, ShieldedCoinInfo>({
      coins: [],
      initialImbalances: Imbalances.empty(),
      transactionCostModel,
      feeTokenType: nativeTokenType,
      createOutput: (c) => createShieldedCoinInfo(c.type, c.value),
      isCoinEqual: (a, b) => a.nonce === b.nonce,
    });

    expect(counterOffer.inputs).toHaveLength(0);
    expect(counterOffer.outputs).toHaveLength(0);
  });

  test('Use exactly one coin', () => {
    const coin = createQualifiedCoin(nativeTokenType, 1_000n + transactionCostModel.inputFeeOverhead);

    const counterOffer = getBalanceRecipe<QualifiedShieldedCoinInfo, ShieldedCoinInfo>({
      coins: [coin],
      initialImbalances: Imbalances.fromEntry(nativeTokenType, -1_000n),
      transactionCostModel,
      feeTokenType: nativeTokenType,
      createOutput: (c) => createShieldedCoinInfo(c.type, c.value),
      isCoinEqual: (a, b) => a.nonce === b.nonce,
    });

    expect(counterOffer.inputs).toHaveLength(1);
    expect(counterOffer.inputs[0]).toBe(coin);
    expect(counterOffer.outputs).toHaveLength(0);
  });

  test('Does not overspend coins', () => {
    const coins = [
      createQualifiedCoin(nativeTokenType, dust(10)),
      createQualifiedCoin(nativeTokenType, dust(10)),
      createQualifiedCoin(nativeTokenType, dust(10)),
    ];

    const counterOffer = getBalanceRecipe<QualifiedShieldedCoinInfo, ShieldedCoinInfo>({
      coins,
      initialImbalances: Imbalances.fromEntry(nativeTokenType, -dust(1)),
      transactionCostModel,
      feeTokenType: nativeTokenType,
      createOutput: (c) => createShieldedCoinInfo(c.type, c.value),
      isCoinEqual: (a, b) => a.nonce === b.nonce,
    });

    expect(counterOffer.inputs).toHaveLength(1);
    expect(counterOffer.outputs).toHaveLength(1);
  });

  test('Balance custom native token', () => {
    const customTokenType = sampleRawTokenType();
    const coins = [
      createQualifiedCoin(nativeTokenType, dust(100)),
      createQualifiedCoin(customTokenType, 1n),
      createQualifiedCoin(customTokenType, 2n),
      createQualifiedCoin(customTokenType, 3n),
    ];

    const counterOffer = getBalanceRecipe<QualifiedShieldedCoinInfo, ShieldedCoinInfo>({
      coins,
      initialImbalances: Imbalances.fromEntry(customTokenType, -1n),
      transactionCostModel,
      feeTokenType: nativeTokenType,
      createOutput: (c) => createShieldedCoinInfo(c.type, c.value),
      isCoinEqual: (a, b) => a.nonce === b.nonce,
    });

    expect(counterOffer.inputs).toHaveLength(2);
    expect(counterOffer.outputs).toHaveLength(1);
  });

  test('Balance multiple token types', () => {
    const customTokenType = sampleRawTokenType();
    const coins = [
      createQualifiedCoin(nativeTokenType, dust(10)),
      createQualifiedCoin(nativeTokenType, dust(20)),
      createQualifiedCoin(nativeTokenType, dust(30)),
      createQualifiedCoin(customTokenType, 1n),
      createQualifiedCoin(customTokenType, 2n),
      createQualifiedCoin(customTokenType, 3n),
    ];

    const targetImbalances = Imbalances.fromEntries([
      [customTokenType, -4n],
      [nativeTokenType, -dust(5)],
      [nativeTokenType, -dust(1)],
      [customTokenType, -1n],
    ]);

    const counterOffer = getBalanceRecipe<QualifiedShieldedCoinInfo, ShieldedCoinInfo>({
      coins,
      initialImbalances: targetImbalances,
      transactionCostModel,
      feeTokenType: nativeTokenType,
      createOutput: (coin) => createShieldedCoinInfo(coin.type, coin.value),
      isCoinEqual: (a, b) => a.nonce === b.nonce,
    });

    expect(counterOffer.inputs).toHaveLength(4);
    expect(counterOffer.outputs).toHaveLength(2);
  });

  test('Add change output', () => {
    const coin = createQualifiedCoin(nativeTokenType, dust(10));
    const counterOffer = getBalanceRecipe({
      coins: [coin],
      initialImbalances: Imbalances.fromEntry(nativeTokenType, -dust(3)),
      transactionCostModel,
      feeTokenType: nativeTokenType,
      createOutput: (c) => createShieldedCoinInfo(c.type, c.value),
      isCoinEqual: (a, b) => a.nonce === b.nonce,
    });

    expect(counterOffer.outputs).toHaveLength(1);
    expect(counterOffer.inputs).toContain(coin);
  });

  test("Fail if there aren't enough coins to cover the fees", () => {
    // due mapping the error in scala, the message in the thrown error is only the token type
    expect(() => {
      const coin = createQualifiedCoin(nativeTokenType, dust(1));
      return getBalanceRecipe({
        coins: [coin],
        initialImbalances: Imbalances.fromEntry(nativeTokenType, -dust(1)),
        transactionCostModel,
        feeTokenType: nativeTokenType,
        createOutput: (c) => createShieldedCoinInfo(c.type, c.value),
        isCoinEqual: (a, b) => a.nonce === b.nonce,
      });
    }).toThrow(nativeTokenType);
  });

  test('Fail if the change output value is smaller than the output fee', () => {
    expect(() => {
      const coin = createQualifiedCoin(nativeTokenType, transactionCostModel.inputFeeOverhead + 5n);

      const imbalanceValue = -(5n + transactionCostModel.outputFeeOverhead);

      return getBalanceRecipe({
        coins: [coin],
        initialImbalances: Imbalances.fromEntry(nativeTokenType, imbalanceValue),
        transactionCostModel,
        feeTokenType: nativeTokenType,
        createOutput: (c) => createShieldedCoinInfo(c.type, c.value),
        isCoinEqual: (a, b) => a.nonce === b.nonce,
      });
    }).toThrow(nativeTokenType);
  });

  test('Uses provided coin selection', () => {
    const nonceBasedSelection: CoinSelection<QualifiedShieldedCoinInfo> = (coins, type) => {
      return coins
        .filter((c) => c.type === type)
        .toSorted((a, b) => a.nonce.localeCompare(b.nonce))
        .at(0);
    };

    const coinsWithATargetValue = fc
      .record({
        valueToBalance: fc.bigInt({ min: 1n, max: BigInt(Number.MAX_SAFE_INTEGER) }),
        coins: fc.array(qualifiedCoinArbitrary(fc.constant(nativeTokenType)), { minLength: 1 }),
      })
      .filter(({ coins, valueToBalance }) => {
        const sum = coins.map((c) => c.value).reduce((a, b) => a + b);
        const desiredSum = BigInt(coins.length) * transactionCostModel.inputFeeOverhead + valueToBalance;

        return sum > desiredSum;
      });

    fc.assert(
      fc.property(coinsWithATargetValue, ({ coins, valueToBalance }) => {
        const nonceSortedCoins = coins.toSorted((a, b) => a.nonce.localeCompare(b.nonce));
        const counterOffer = getBalanceRecipe<QualifiedShieldedCoinInfo, ShieldedCoinInfo>({
          coins,
          initialImbalances: Imbalances.fromEntry(nativeTokenType, -1n * valueToBalance),
          transactionCostModel,
          feeTokenType: nativeTokenType,
          createOutput: (c) => createShieldedCoinInfo(c.type, c.value),
          coinSelection: nonceBasedSelection,
          isCoinEqual: (a, b) => a.nonce === b.nonce,
        });

        const counterOfferInputNonces = new Set(counterOffer.inputs.map((i) => i.nonce));
        const expectedNonces = new Set(nonceSortedCoins.slice(0, counterOffer.inputs.length).map((i) => i.nonce));

        expect(counterOfferInputNonces).toEqual(expectedNonces);
      }),
    );
  });

  test('Reaches target imbalances', () => {
    const tokenTypeArbitrary = fc.constantFrom(
      nativeTokenType,
      sampleRawTokenType(),
      sampleRawTokenType(),
      sampleRawTokenType(),
      sampleRawTokenType(),
    );
    const coinArbitrary = qualifiedCoinArbitrary(tokenTypeArbitrary);
    const coinWithDesiredInputValueArbitrary: fc.Arbitrary<{
      coin: QualifiedShieldedCoinInfo;
      maybeInputValue: bigint | null;
    }> = coinArbitrary.chain((coin) =>
      fc
        .option(
          fc.bigInt({
            min: 1n,
            max: coin.value,
          }),
        )
        .map((maybeInputValue) => ({ coin, maybeInputValue })),
    );
    const testCoinsArbitrary = fc.array(coinWithDesiredInputValueArbitrary);

    fc.assert(
      fc.property(
        testCoinsArbitrary,
        costModelArbitrary,
        fc.integer({ min: 0, max: 10 }),
        (coinsWithInputValues, costModel, existingOutputsToCover) => {
          const availableCoins = coinsWithInputValues
            .map(({ coin }) => coin)
            .concat(createQualifiedCoin(nativeTokenType, dust(100)));
          const availableNonces = new Set(availableCoins.map((c) => c.nonce));
          const desiredImbalances: Imbalances = coinsWithInputValues
            .map(({ coin, maybeInputValue }) => ({ value: maybeInputValue ?? 0n, type: coin.type }))
            .reduce((acc: Imbalances, { type, value }) => {
              const existingValue = acc.get(type) ?? 0n;
              acc.set(type, existingValue + value);
              return acc;
            }, new Map() as Imbalances);
          const existingFeesToCover = BigInt(existingOutputsToCover) * costModel.outputFeeOverhead;
          const desiredNonDustImbalances = new Map(
            desiredImbalances.entries().filter(([type]) => type != nativeTokenType),
          );
          const initialDesiredDustImbalance = (desiredImbalances.get(nativeTokenType) ?? 0n) + existingFeesToCover;

          const result = getBalanceRecipe<QualifiedShieldedCoinInfo, ShieldedCoinInfo>({
            coins: availableCoins,
            initialImbalances: new Map([[nativeTokenType, -1n * existingFeesToCover]]),
            transactionCostModel: costModel,
            feeTokenType: nativeTokenType,
            createOutput: (c) => createShieldedCoinInfo(c.type, c.value),
            coinSelection: chooseCoin,
            targetImbalances: desiredImbalances,
            isCoinEqual: (a, b) => a.nonce === b.nonce,
          });

          const resultInputImbalances: Imbalances = result.inputs.reduce((acc, coin) => {
            const existingValue = acc.get(coin.type) ?? 0n;
            acc.set(coin.type, existingValue + coin.value);
            return acc;
          }, new Map() as Imbalances);
          const resultImbalances: Imbalances = result.outputs.reduce((acc, coin) => {
            const existingValue = acc.get(coin.type) ?? 0n;
            acc.set(coin.type, existingValue - coin.value);
            return acc;
          }, resultInputImbalances);
          const finalExpectedDustImbalance =
            initialDesiredDustImbalance +
            BigInt(result.inputs.length) * costModel.inputFeeOverhead +
            BigInt(result.outputs.length) * costModel.outputFeeOverhead;

          const resultInputNonces = new Set(result.inputs.map((c) => c.nonce));

          expect(availableNonces.intersection(resultInputNonces)).toEqual(resultInputNonces);
          resultImbalances.entries().forEach(([type, value]) => {
            if (type === nativeTokenType) {
              expect(value).toBeGreaterThanOrEqual(finalExpectedDustImbalance);
              expect(value).toBeLessThanOrEqual(finalExpectedDustImbalance + costModel.outputFeeOverhead);
            } else {
              expect(value).toEqual(desiredNonDustImbalances.get(type));
            }
          });
        },
      ),
    );
  });

  test('Errors if there are no tokens to meet target imbalances', () => {
    const tokenTypeArbitrary = fc.constantFrom(
      nativeTokenType,
      sampleRawTokenType(),
      sampleRawTokenType(),
      sampleRawTokenType(),
      sampleRawTokenType(),
    );
    const otherTokenType = sampleRawTokenType();
    const coinArbitrary = qualifiedCoinArbitrary(tokenTypeArbitrary);
    const testCoinsArbitrary = fc.array(coinArbitrary);
    const desiredInputsArbitrary = fc
      .bigInt({ min: 1n, max: BigInt(Number.MAX_SAFE_INTEGER) })
      .map((targetValue) => new Map([[otherTokenType, targetValue]]));

    fc.assert(
      fc.property(testCoinsArbitrary, desiredInputsArbitrary, costModelArbitrary, (coins, inputs, costModel) => {
        expect(() =>
          getBalanceRecipe<QualifiedShieldedCoinInfo, ShieldedCoinInfo>({
            coins,
            initialImbalances: new Map(),
            transactionCostModel: costModel,
            feeTokenType: nativeTokenType,
            createOutput: (c) => createShieldedCoinInfo(c.type, c.value),
            coinSelection: chooseCoin,
            targetImbalances: inputs,
            isCoinEqual: (a, b) => a.nonce === b.nonce,
          }),
        ).toThrow(otherTokenType);
      }),
    );
  });
});

================
File: packages/capabilities/.npmignore
================
*.ts.map

================
File: packages/capabilities/.prettierignore
================
dist/
coverage/
reports/

================
File: packages/capabilities/eslint.config.mjs
================
import { packageConfig } from '../../eslint.config.mjs';

export default packageConfig();

================
File: packages/capabilities/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "rootDir": "./src",
    "outDir": "./dist",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "lib": ["ESNext", "dom"]
  },
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/test/**/*.ts", "src/**/*.test.ts"]
}

================
File: packages/capabilities/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [{ "path": "./tsconfig.build.json" }, { "path": "./tsconfig.test.json" }]
}

================
File: packages/capabilities/tsconfig.publish.json
================
{
  "extends": "./tsconfig.build.json",
  "compilerOptions": {
    "sourceMap": false,
    "declarationMap": false
  }
}

================
File: packages/capabilities/tsconfig.test.json
================
{
  "extends": "./tsconfig.json",
  "include": ["src/**/test/**/*.ts", "test/**/*.ts", "src/**/*.ts"]
}

================
File: packages/capabilities/vitest.config.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/// <reference types="vitest" />
/// <reference types="vitest/globals" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage',
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }],
    ],
  },
});

================
File: packages/docs-snippets/src/snippets/addresses.no-net.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import {
  ShieldedAddress,
  UnshieldedAddress,
  MidnightBech32m,
  DustAddress,
  ShieldedEncryptionPublicKey,
  ShieldedCoinPublicKey,
  mainnet,
} from '@midnight-ntwrk/wallet-sdk-address-format';
import type { NetworkId } from '@midnight-ntwrk/wallet-sdk-address-format';
import * as ledger from '@midnight-ntwrk/ledger-v6';

const networkId: NetworkId = 'undeployed';

// seeds/keys below are derived from the testing seed 0000000000000000000000000000000000000000000000000000000000000001
const unshieldedSecretKey = Buffer.from('b76bd8d92eb76098e938051af9d6bf2c81d8bf47ead2aa5442ca60c04346378b', 'hex');
const shieldedSeed = Buffer.from('a33865674c03ca1f6c4eb3f6b56625dce0accc96d2ca52114876a58773f5ecab', 'hex');
const dustSeed = Buffer.from('cab391b2eaaf459bd7ef54c461e7fc4e2377afb12fbdd532b0d63b0f48803534', 'hex');

const unshieldedAddress = new UnshieldedAddress(
  Buffer.from(ledger.addressFromKey(ledger.signatureVerifyingKey(unshieldedSecretKey.toString('hex'))), 'hex'),
);
const unshieldedAddressBech32m = MidnightBech32m.encode(networkId, unshieldedAddress).toString();
const unshieldedAddressParsed: UnshieldedAddress = MidnightBech32m.parse(unshieldedAddressBech32m).decode(
  UnshieldedAddress,
  networkId,
);

console.log('unshielded address', unshieldedAddressBech32m);
console.log(' are unshielded addresses equal?', unshieldedAddress.equals(unshieldedAddressParsed));

// same for mainnet:
const unshieldedAddressBech32mMainnet = MidnightBech32m.encode(mainnet, unshieldedAddress).toString();
const unshieldedAddressParsedMainnet: UnshieldedAddress = MidnightBech32m.parse(unshieldedAddressBech32mMainnet).decode(
  UnshieldedAddress,
  mainnet,
);

console.log('mainnet unshielded address', unshieldedAddressBech32mMainnet);
console.log(' are mainnet unshielded addresses equal?', unshieldedAddress.equals(unshieldedAddressParsedMainnet));

const shieldedKeys = ledger.ZswapSecretKeys.fromSeed(shieldedSeed);
const shieldedAddress = new ShieldedAddress(
  new ShieldedCoinPublicKey(Buffer.from(shieldedKeys.coinPublicKey, 'hex')),
  new ShieldedEncryptionPublicKey(Buffer.from(shieldedKeys.encryptionPublicKey, 'hex')),
);
const shieldedAddressBech32m = MidnightBech32m.encode(networkId, shieldedAddress).toString();
const shieldedAddressParsed: ShieldedAddress = MidnightBech32m.parse(shieldedAddressBech32m).decode(
  ShieldedAddress,
  networkId,
);

console.log('shielded address', shieldedAddressBech32m);
console.log(' are shielded addresses equal?', shieldedAddress.equals(shieldedAddressParsed));

const dustSecretKey = ledger.DustSecretKey.fromSeed(dustSeed);
const dustAddress = new DustAddress(dustSecretKey.publicKey);
const dustAddressBech32m = MidnightBech32m.encode(networkId, dustAddress).toString();
const dustAddressParsed: DustAddress = MidnightBech32m.parse(dustAddressBech32m).decode(DustAddress, networkId);

console.log('dust address', dustAddressBech32m);
console.log(' are dust addresses equal?', dustAddress.equals(dustAddressParsed));

================
File: packages/docs-snippets/src/snippets/hd.no-net.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import type { Role } from '@midnight-ntwrk/wallet-sdk-hd';
import { AccountKey, HDWallet, Roles } from '@midnight-ntwrk/wallet-sdk-hd';
import { Buffer } from 'buffer';

function deriveRoleKey(accountKey: AccountKey, role: Role, addressIndex: number = 0): Buffer {
  const result = accountKey.selectRole(role).deriveKeyAt(addressIndex);
  if (result.type === 'keyDerived') {
    return Buffer.from(result.key);
  }

  // There is small possibility of the derivation failing, so we retry with the next index as specified
  return deriveRoleKey(accountKey, role, addressIndex + 1);
}

function deriveAllKeys(seed: Uint8Array) {
  const hdWallet = HDWallet.fromSeed(seed);

  if (hdWallet.type !== 'seedOk') {
    throw new Error('Failed to derive keys');
  }

  const account = hdWallet.hdWallet.selectAccount(0);
  const shieldedSeed = deriveRoleKey(account, Roles.Zswap);
  const dustSeed = deriveRoleKey(account, Roles.Dust);
  const nightKey = deriveRoleKey(account, Roles.NightExternal);

  hdWallet.hdWallet.clear(); // Clear the HDWallet to avoid holding the private key in memory for longer than needed

  return {
    shielded: { seed: shieldedSeed, keys: ledger.ZswapSecretKeys.fromSeed(shieldedSeed) },
    dust: { seed: dustSeed, key: ledger.DustSecretKey.fromSeed(dustSeed) },
    night: nightKey,
  };
}

const seed = Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex'); // or generateRandomSeed() from @midnight-ntwrk/wallet-sdk-hd
const derivedKeys = deriveAllKeys(seed);
seed.fill(0);

console.log('seed', seed.toString('hex'));
console.log('unshielded(Night) secret key', derivedKeys.night.toString('hex'));
console.log('shielded:');
console.log('  seed', derivedKeys.shielded.seed.toString('hex'));
console.log(
  '  coin secret key',
  Buffer.from(derivedKeys.shielded.keys.coinSecretKey.yesIKnowTheSecurityImplicationsOfThis_serialize()).toString(
    'hex',
  ),
);
console.log(
  '  encryption secret key',
  Buffer.from(derivedKeys.shielded.keys.encryptionSecretKey.yesIKnowTheSecurityImplicationsOfThis_serialize()).toString(
    'hex',
  ),
);
console.log('dust:');
console.log('  seed', derivedKeys.dust.seed.toString('hex'));
console.log('  public key', derivedKeys.dust.key.publicKey.toString(16));

================
File: packages/docs-snippets/src/snippets/swap.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Buffer } from 'buffer';
import * as rx from 'rxjs';
import { initWalletWithSeed } from '../utils.ts';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { MidnightBech32m } from '@midnight-ntwrk/wallet-sdk-address-format';
import { FacadeState } from '@midnight-ntwrk/wallet-sdk-facade';

const alice = await initWalletWithSeed(
  Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex'),
);
const bob = await initWalletWithSeed(
  Buffer.from('0000000000000000000000000000000000000000000000000000000000000002', 'hex'),
);

const aliceInitialState = await rx.firstValueFrom(alice.wallet.state().pipe(rx.filter((s) => s.isSynced)));
const bobInitialState = await rx.firstValueFrom(bob.wallet.state().pipe(rx.filter((s) => s.isSynced)));

const shieldedToken1 = '0000000000000000000000000000000000000000000000000000000000000001';
const shieldedToken2 = '0000000000000000000000000000000000000000000000000000000000000002';

console.log(
  'Does Alice have specific shielded coin before swap?',
  aliceInitialState.shielded.availableCoins.some((c) => c.coin.type === shieldedToken2 && c.coin.value === 1_000_000n),
);
console.log(
  'Does Bob have specific shielded coin before swap?',
  bobInitialState.shielded.availableCoins.some((c) => c.coin.type === shieldedToken1 && c.coin.value === 1_000_000n),
);

const aliceSwapTx: ledger.FinalizedTransaction = await alice.wallet
  .initSwap(
    alice.shieldedSecretKeys,
    { shielded: { [shieldedToken1]: 1_000_000n } },
    [
      {
        type: 'shielded',
        outputs: [
          {
            type: shieldedToken2,
            amount: 1_000_000n,
            receiverAddress: MidnightBech32m.encode('undeployed', aliceInitialState.shielded.address).toString(),
          },
        ],
      },
    ],
    new Date(Date.now() + 30 * 60 * 1000),
  )
  .then((tx) => alice.wallet.finalizeTransaction({ type: 'TransactionToProve', transaction: tx }));

await bob.wallet
  .balanceTransaction(bob.shieldedSecretKeys, bob.dustSecretKey, aliceSwapTx, new Date(Date.now() + 30 * 60 * 1000))
  .then((recipe) => bob.wallet.finalizeTransaction(recipe))
  .then((tx) => bob.wallet.submitTransaction(tx));

const didShieldedChange = (state: FacadeState, initialState: FacadeState) => {
  const currentAppliedIndex = state.shielded.progress?.appliedIndex ?? 0n;
  const initialAppliedIndex = initialState.shielded.progress?.appliedIndex ?? 0n;
  return currentAppliedIndex > initialAppliedIndex;
};

const aliceFinalState = await rx.firstValueFrom(
  alice.wallet.state().pipe(
    rx.filter((s) => s.isSynced),
    rx.filter((s) => didShieldedChange(s, aliceInitialState)),
  ),
);

const bobFinalState = await rx.firstValueFrom(
  bob.wallet.state().pipe(
    rx.filter((s) => s.isSynced),
    rx.filter((s) => didShieldedChange(s, bobInitialState)),
  ),
);

console.log(
  'Does Alice have specific shielded coin after swap?',
  aliceFinalState.shielded.availableCoins.some((c) => c.coin.type === shieldedToken2 && c.coin.value === 1_000_000n),
);
console.log(
  'Does Bob have specific shielded coin after swap?',
  bobFinalState.shielded.availableCoins.some((c) => c.coin.type === shieldedToken1 && c.coin.value === 1_000_000n),
);

await alice.wallet.stop();
await bob.wallet.stop();

================
File: packages/docs-snippets/.prettierignore
================
dist/
coverage/
reports/

================
File: packages/docs-snippets/eslint.config.mjs
================
import { packageConfig } from '../../eslint.config.mjs';

const config = packageConfig({
  rules: {
    'no-console': 'off',
  },
});

export default config;

================
File: packages/docs-snippets/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": true,
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/test/**/*.ts", "src/**/*.test.ts"]
}

================
File: packages/docs-snippets/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "allowImportingTsExtensions": true
  },
  "files": [],
  "references": [{ "path": "./tsconfig.build.json" }, { "path": "./tsconfig.test.json" }]
}

================
File: packages/docs-snippets/tsconfig.test.json
================
{
  "extends": "./tsconfig.json",
  "include": ["test/**/*.ts", "src/**/*.ts"]
}

================
File: packages/dust-wallet/src/types/Dust.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { DustInitialNonce, DustNullifier, DustNonce, DustPublicKey, Utxo } from '@midnight-ntwrk/ledger-v6';

export type DustToken = {
  initialValue: bigint;
  owner: DustPublicKey;
  nonce: DustNonce;
  seq: number;
  ctime: Date;
  backingNight: DustInitialNonce;
  mtIndex: bigint;
};

export type DustTokenWithNullifier = DustToken & {
  nullifier: DustNullifier;
};

export type DustTokenFullInfo = {
  token: DustToken;
  dtime: Date | undefined;
  maxCap: bigint; // maximum capacity (gen.value * night_dust_ratio)
  maxCapReachedAt: Date; // ctime + timeToCapSeconds
  generatedNow: bigint;
  rate: bigint; // the slope of generation and decay for a specific dust UTXO (gen.value * generation_decay_rate)
};

export type DustGenerationInfo = {
  value: bigint;
  owner: DustPublicKey;
  nonce: DustInitialNonce;
  dtime: Date | undefined;
};

export type UtxoWithMeta = Utxo & { ctime: Date };

================
File: packages/dust-wallet/src/types/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * from './Dust.js';
export * from './ledger.js';
export * from './transaction.js';

================
File: packages/dust-wallet/src/types/ledger.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';

export type AnyTransaction = ledger.UnprovenTransaction | ledger.FinalizedTransaction | ledger.ProofErasedTransaction;
export type UnprovenDustSpend = ledger.DustSpend<ledger.PreProof>;

export type NetworkId = string;

================
File: packages/dust-wallet/src/types/transaction.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export type TotalCostParameters = {
  additionalFeeOverhead: bigint;
  // a number of blocks we expect for finalization.
  feeBlocksMargin: number;
};

================
File: packages/dust-wallet/src/CoinsAndBalances.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Array, pipe } from 'effect';
import { updatedValue } from '@midnight-ntwrk/ledger-v6';
import { DateOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import { DustCoreWallet } from './DustCoreWallet.js';
import { DustGenerationInfo, DustToken, DustTokenFullInfo } from './types/Dust.js';

export type Balance = bigint;

export type CoinWithValue<TToken> = {
  token: TToken;
  value: Balance;
};

export type CoinSelection<TInput> = (
  coins: readonly CoinWithValue<TInput>[],
  amountNeeded: Balance,
) => CoinWithValue<TInput>[];

export const chooseCoin = <TInput>(
  coins: readonly CoinWithValue<TInput>[],
  amountNeeded: Balance,
): CoinWithValue<TInput>[] => {
  let sum = 0n;
  const sorted = coins.toSorted((a, b) => Number(a.value - b.value));
  const result = [];
  for (const coin of sorted) {
    sum += coin.value;
    result.push(coin);
    if (sum >= amountNeeded) break;
  }
  return result;
};

export type CoinsAndBalancesCapability<TState> = {
  getWalletBalance(state: TState, time: Date): Balance;
  getAvailableCoins(state: TState): readonly DustToken[];
  getPendingCoins(state: TState): readonly DustToken[];
  getTotalCoins(state: TState): ReadonlyArray<DustToken>;
  getAvailableCoinsWithGeneratedDust(state: TState, currentTime: Date): ReadonlyArray<CoinWithValue<DustToken>>;
  getAvailableCoinsWithFullInfo(state: TState, blockTime: Date): readonly DustTokenFullInfo[];
  getGenerationInfo(state: TState, token: DustToken): DustGenerationInfo | undefined;
};

export const makeDefaultCoinsAndBalancesCapability = (): CoinsAndBalancesCapability<DustCoreWallet> => {
  const getWalletBalance = (state: DustCoreWallet, time: Date): Balance => {
    return state.state.walletBalance(time);
  };

  const getAvailableCoins = (state: DustCoreWallet): DustToken[] => {
    const pendingSpends = new Set([...state.pendingDustTokens.values()].map((coin) => coin.nonce));
    return pipe(
      state.state.utxos,
      Array.filter((coin) => !pendingSpends.has(coin.nonce)),
    );
  };

  const getPendingCoins = (state: DustCoreWallet): DustToken[] => state.pendingDustTokens;

  const getTotalCoins = (state: DustCoreWallet): Array<DustToken> => [
    ...getAvailableCoins(state),
    ...getPendingCoins(state),
  ];

  const getGenerationInfo = (state: DustCoreWallet, token: DustToken): DustGenerationInfo | undefined => {
    const info = state.state.generationInfo(token);
    return info && info.dtime
      ? {
          ...info,
          dtime: new Date(+info.dtime), // TODO: remove when the ledger start to return a date instead of the number
        }
      : info;
  };

  const getAvailableCoinsWithGeneratedDust = (
    state: DustCoreWallet,
    currentTime: Date,
  ): Array<CoinWithValue<DustToken>> => {
    const result: Array<CoinWithValue<DustToken>> = [];
    const available = getAvailableCoins(state);

    for (const coin of available) {
      const genInfo = getGenerationInfo(state, coin);
      if (genInfo) {
        const generatedValue = updatedValue(coin.ctime, coin.initialValue, genInfo, currentTime, state.state.params);
        result.push({ token: coin, value: generatedValue });
      }
    }

    return result;
  };

  const getAvailableCoinsWithFullInfo = (state: DustCoreWallet, blockTime: Date): Array<DustTokenFullInfo> => {
    const result: Array<DustTokenFullInfo> = [];
    const available = getAvailableCoins(state);
    for (const coin of available) {
      const genInfo = getGenerationInfo(state, coin);
      if (genInfo) {
        const generatedValue = updatedValue(coin.ctime, coin.initialValue, genInfo, blockTime, state.state.params);
        result.push({
          token: coin,
          dtime: genInfo.dtime,
          maxCap: genInfo.value * state.state.params.nightDustRatio,
          maxCapReachedAt: DateOps.addSeconds(coin.ctime, state.state.params.timeToCapSeconds),
          generatedNow: generatedValue,
          rate: genInfo.value * state.state.params.generationDecayRate,
        });
      }
    }

    return result;
  };

  return {
    getWalletBalance,
    getAvailableCoins,
    getPendingCoins,
    getTotalCoins,
    getAvailableCoinsWithGeneratedDust,
    getAvailableCoinsWithFullInfo,
    getGenerationInfo,
  };
};

================
File: packages/dust-wallet/src/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * from './DustCoreWallet.js';
export * from './DustWallet.js';
export * as Keys from './Keys.js';
export * as Simulator from './Simulator.js';
export * as SyncService from './Sync.js';
export * as Transacting from './Transacting.js';
export * from './RunningV1Variant.js';
export * from './V1Builder.js';
export * from './types/index.js';

================
File: packages/dust-wallet/src/Keys.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { DustPublicKey } from '@midnight-ntwrk/ledger-v6';
import { DustAddress } from '@midnight-ntwrk/wallet-sdk-address-format';
import { DustCoreWallet } from './DustCoreWallet.js';

export type KeysCapability<TState> = {
  getDustPublicKey(state: TState): DustPublicKey;
  getDustAddress(state: TState): DustAddress;
};

export const makeDefaultKeysCapability = (): KeysCapability<DustCoreWallet> => {
  return {
    getDustPublicKey: (state: DustCoreWallet): DustPublicKey => {
      return state.publicKey.publicKey;
    },
    getDustAddress: (state: DustCoreWallet): DustAddress => {
      return new DustAddress(state.publicKey.publicKey);
    },
  };
};

================
File: packages/dust-wallet/src/Serialization.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, ParseResult, Either, pipe, Schema } from 'effect';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { WalletError } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import { DustCoreWallet } from './DustCoreWallet.js';

export type SerializationCapability<TWallet, TAux, TSerialized> = {
  serialize(wallet: TWallet): TSerialized;
  deserialize(aux: TAux, data: TSerialized): Either.Either<TWallet, WalletError.WalletError>;
};

const StateSchema = Schema.declare(
  (input: unknown): input is ledger.DustLocalState => input instanceof ledger.DustLocalState,
).annotations({
  identifier: 'ledger.DustLocalState',
});

export const Uint8ArraySchema = Schema.declare(
  (input: unknown): input is Uint8Array => input instanceof Uint8Array,
).annotations({
  identifier: 'Uint8Array',
});

const StateFromUInt8Array: Schema.Schema<ledger.DustLocalState, Uint8Array> = Schema.asSchema(
  Schema.transformOrFail(Uint8ArraySchema, StateSchema, {
    encode: (state) => {
      return Effect.try({
        try: () => {
          return state.serialize();
        },
        catch: (err) => {
          return new ParseResult.Unexpected(err, 'Could not serialize local state');
        },
      });
    },
    decode: (bytes) =>
      Effect.try({
        try: () => ledger.DustLocalState.deserialize(bytes),
        catch: (err) => {
          return new ParseResult.Unexpected(err, 'Could not deserialize local state');
        },
      }),
  }),
);

const HexedState: Schema.Schema<ledger.DustLocalState, string> = pipe(
  Schema.Uint8ArrayFromHex,
  Schema.compose(StateFromUInt8Array),
);

const SnapshotSchema = Schema.Struct({
  publicKey: Schema.Struct({
    publicKey: Schema.BigInt,
  }),
  state: HexedState,
  protocolVersion: Schema.BigInt,
  networkId: Schema.String,
  offset: Schema.optional(Schema.BigInt),
});

type Snapshot = Schema.Schema.Type<typeof SnapshotSchema>;

export const makeDefaultV1SerializationCapability = (): SerializationCapability<DustCoreWallet, null, string> => {
  return {
    serialize: (wallet) => {
      const buildSnapshot = (w: DustCoreWallet): Snapshot => ({
        publicKey: w.publicKey,
        state: w.state,
        protocolVersion: w.protocolVersion,
        networkId: w.networkId,
        offset: w.progress?.appliedIndex,
      });

      return pipe(wallet, buildSnapshot, Schema.encodeSync(SnapshotSchema), JSON.stringify);
    },
    deserialize: (aux, serialized): Either.Either<DustCoreWallet, WalletError.WalletError> => {
      return pipe(
        serialized,
        Schema.decodeUnknownEither(Schema.parseJson(SnapshotSchema)),
        Either.mapLeft((err) => WalletError.WalletError.other(err)),
        Either.flatMap((snapshot: Snapshot) =>
          Either.try({
            try: () =>
              DustCoreWallet.restore(
                snapshot.state,
                snapshot.publicKey,
                [],
                {
                  appliedIndex: snapshot.offset ?? 0n,
                  highestRelevantWalletIndex: 0n,
                  highestIndex: 0n,
                  highestRelevantIndex: 0n,
                  isConnected: false,
                },
                snapshot.protocolVersion,
                snapshot.networkId,
              ),
            catch: (err) => WalletError.WalletError.other(err),
          }),
        ),
      );
    },
  };
};

================
File: packages/dust-wallet/src/Submission.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Deferred, Effect, Encoding, Exit, pipe, Scope } from 'effect';
import {
  NodeClient,
  NodeClientError,
  PolkadotNodeClient,
  SubmissionEvent as SubmissionEventImported,
} from '@midnight-ntwrk/wallet-sdk-node-client/effect';
import { FinalizedTransaction, ProofErasedTransaction } from '@midnight-ntwrk/ledger-v6';
import { WalletError } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import { Simulator } from './Simulator.js';
import { NetworkId } from './types/ledger.js';

export const SubmissionEvent = SubmissionEventImported;
export type SubmissionEvent = SubmissionEventImported.SubmissionEvent;
export declare namespace SubmissionEventCases {
  export type Finalized = SubmissionEventImported.Cases.Finalized;
  export type Submitted = SubmissionEventImported.Cases.Submitted;
  export type InBlock = SubmissionEventImported.Cases.InBlock;
}

export type SubmitTransactionMethod<TTransaction> = {
  (
    transaction: TTransaction,
    waitForStatus: 'Submitted',
  ): Effect.Effect<SubmissionEventCases.Submitted, WalletError.WalletError>;
  (
    transaction: TTransaction,
    waitForStatus: 'InBlock',
  ): Effect.Effect<SubmissionEventCases.InBlock, WalletError.WalletError>;
  (
    transaction: TTransaction,
    waitForStatus: 'Finalized',
  ): Effect.Effect<SubmissionEventCases.Finalized, WalletError.WalletError>;
  (transaction: TTransaction): Effect.Effect<SubmissionEventCases.InBlock, WalletError.WalletError>;
  (
    transaction: TTransaction,
    waitForStatus?: 'Submitted' | 'InBlock' | 'Finalized',
  ): Effect.Effect<SubmissionEvent, WalletError.WalletError>;
};

export interface SubmissionService<TTransaction> {
  submitTransaction: SubmitTransactionMethod<TTransaction>;
  close(): Effect.Effect<void>;
}

export type DefaultSubmissionConfiguration = {
  relayURL: URL;
  networkId: NetworkId;
};
export const makeDefaultSubmissionService = (
  config: DefaultSubmissionConfiguration,
): SubmissionService<FinalizedTransaction> => {
  //Using Deferred under the hood + allowing for "close" method in the service allows to keep resource usage in check and a synchronous API
  type ScopeAndClient = { scope: Scope.CloseableScope; client: NodeClient.Service };

  const scopeAndClientDeferred = Deferred.make<ScopeAndClient, NodeClientError.NodeClientError>().pipe(Effect.runSync);

  const makeScopeAndClient: Effect.Effect<ScopeAndClient, NodeClientError.NodeClientError> = Effect.gen(function* () {
    const scope = yield* Scope.make();
    const client = yield* PolkadotNodeClient.make({
      nodeURL: config.relayURL,
    }).pipe(Effect.provideService(Scope.Scope, scope));

    return { scope, client };
  });

  void pipe(scopeAndClientDeferred, Deferred.complete(makeScopeAndClient), Effect.runPromise);

  const submit = (transaction: FinalizedTransaction, waitForStatus: SubmissionEvent['_tag'] = 'InBlock') => {
    return pipe(
      NodeClient.sendMidnightTransactionAndWait(transaction.serialize(), waitForStatus),
      Effect.provideServiceEffect(
        NodeClient.NodeClient,
        pipe(
          scopeAndClientDeferred,
          Deferred.await,
          Effect.map(({ client }) => client),
        ),
      ),
      Effect.mapError((err) => WalletError.WalletError.submission(err)),
    );
  };

  return {
    submitTransaction: submit as SubmitTransactionMethod<FinalizedTransaction>,
    close(): Effect.Effect<void> {
      return pipe(
        scopeAndClientDeferred,
        Deferred.await,
        Effect.flatMap(({ scope }) => Scope.close(scope, Exit.void)),
        Effect.ignoreLogged,
      );
    },
  };
};

export type SimulatorSubmissionConfiguration = {
  simulator: Simulator;
};
export const makeSimulatorSubmissionService =
  (waitForStatus: 'Submitted' | 'InBlock' | 'Finalized' = 'InBlock') =>
  (config: SimulatorSubmissionConfiguration): SubmissionService<ProofErasedTransaction> => {
    const submit = (transaction: ProofErasedTransaction): Effect.Effect<SubmissionEvent, WalletError.WalletError> => {
      const serializedTx = transaction.serialize();
      return config.simulator.submitRegularTx(transaction).pipe(
        Effect.map((output) => {
          // Let's mimic node's client behavior here
          switch (waitForStatus) {
            case 'Submitted':
              return SubmissionEvent.Submitted({
                tx: serializedTx,
                txHash: Encoding.encodeHex(serializedTx.subarray(0, 32)),
              });
            case 'InBlock':
              return SubmissionEvent.InBlock({
                tx: serializedTx,
                blockHash: output.blockHash,
                blockHeight: output.blockNumber,
                txHash: Encoding.encodeHex(serializedTx.subarray(0, 32)),
              });
            case 'Finalized':
              return SubmissionEvent.Finalized({
                tx: serializedTx,
                blockHash: output.blockHash,
                blockHeight: output.blockNumber,
                txHash: Encoding.encodeHex(serializedTx.subarray(0, 32)),
              });
          }
        }),
      );
    };

    return {
      submitTransaction: submit as SubmitTransactionMethod<ProofErasedTransaction>,
      close: (): Effect.Effect<void> => Effect.void,
    };
  };

================
File: packages/dust-wallet/src/Utils.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export const SignatureMarker = {
  signature: 'signature',
  signatureErased: 'signature-erased',
} as const;

export const ProofMarker = {
  proof: 'proof',
  preProof: 'pre-proof',
  noProof: 'no-proof',
} as const;

export const BindingMarker = {
  binding: 'binding',
  preBinding: 'pre-binding',
  noBinding: 'no-binding',
} as const;

================
File: packages/dust-wallet/test/UnshieldedKeyStore.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// TODO: remove this file once all the components migrate to ledger v6

import {
  addressFromKey,
  Signature,
  SignatureVerifyingKey,
  signData,
  UserAddress,
  signatureVerifyingKey,
} from '@midnight-ntwrk/ledger-v6';

export interface UnshieldedKeystore {
  getSecretKey(): Buffer;
  getPublicKey(): SignatureVerifyingKey;
  getAddress(includeVersion?: boolean): UserAddress;
  signData(data: Uint8Array): Signature;
}

export const createUnshieldedKeystore = (dustSeed: Uint8Array<ArrayBufferLike>): UnshieldedKeystore => {
  const keystore: UnshieldedKeystore = {
    getSecretKey: () => Buffer.from(dustSeed),

    getPublicKey: () => signatureVerifyingKey(keystore.getSecretKey().toString('hex')),

    getAddress: () => addressFromKey(keystore.getPublicKey()),

    signData: (data: Uint8Array) => signData(keystore.getSecretKey().toString('hex'), data),
  };

  return keystore;
};

================
File: packages/dust-wallet/test/utils.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { HDWallet, Roles } from '@midnight-ntwrk/wallet-sdk-hd';

export const getDustSeed = (seed: string): Uint8Array<ArrayBufferLike> => {
  const seedBuffer = Buffer.from(seed, 'hex');
  const hdWalletResult = HDWallet.fromSeed(seedBuffer);

  const { hdWallet } = hdWalletResult as {
    type: 'seedOk';
    hdWallet: HDWallet;
  };

  const derivationResult = hdWallet.selectAccount(0).selectRole(Roles.Dust).deriveKeyAt(0);

  if (derivationResult.type === 'keyOutOfBounds') {
    throw new Error('Key derivation out of bounds');
  }

  return derivationResult.key;
};

================
File: packages/dust-wallet/.prettierignore
================
dist/
coverage/
reports/

================
File: packages/dust-wallet/eslint.config.mjs
================
import { packageConfig } from '../../eslint.config.mjs';

export default packageConfig();

================
File: packages/dust-wallet/README.md
================
# Wallet SDK Dust Wallet

TBD

================
File: packages/dust-wallet/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/test/**/*.ts", "src/**/*.test.ts"]
}

================
File: packages/dust-wallet/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [{ "path": "./tsconfig.build.json" }, { "path": "./tsconfig.test.json" }]
}

================
File: packages/dust-wallet/tsconfig.publish.json
================
{
  "extends": "./tsconfig.build.json",
  "compilerOptions": {
    "sourceMap": false,
    "declarationMap": false
  }
}

================
File: packages/dust-wallet/tsconfig.test.json
================
{
  "extends": "./tsconfig.json",
  "include": ["src/**/test/**/*.ts", "test/**/*.ts", "src/**/*.ts"]
}

================
File: packages/dust-wallet/vitest.config.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/// <reference types="vitest" />
/// <reference types="vitest/globals" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage',
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }],
    ],
  },
});

================
File: packages/e2e-tests/allure-results/categories.json
================
[
    {
      "name": "Infrastructure problems",
      "messageRegex": ".*java.lang.Exception: There was an error proving the transaction: Exception when sending request:.*",
      "matchedStatuses": ["broken"]
    },
    {
      "name": "Wasm issues",
      "messageRegex": ".*unreachable.*",
      "matchedStatuses": ["broken"]
    }
]

================
File: packages/e2e-tests/project/build.properties
================
sbt.version=1.10.0

================
File: packages/e2e-tests/scripts/conversion.mjs
================
#!/usr/bin/env -S node  --experimental-specifier-resolution=node

import * as KeyManagement from "@cardano-sdk/key-management"

const mnemonics = [
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'abandon',
    'absurd',
    'fetch'
  ];

  const seed = KeyManagement.util.mnemonicWordsToEntropy(mnemonics)
  console.log(seed);

  const seed2 = '0000000000000000000000000000000000000000000000000000000000000001';
  const mnemonics2 = KeyManagement.util.entropyToMnemonicWords(seed2);
  console.log(mnemonics2);

================
File: packages/e2e-tests/src/tests/fundTestWallets.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/* eslint-disable @typescript-eslint/restrict-plus-operands */
/* eslint-disable @typescript-eslint/no-base-to-string */
import { firstValueFrom } from 'rxjs';
import { TestContainersFixture, useTestContainersFixture } from './test-fixture.js';
import { nativeToken, ZswapSecretKeys } from '@midnight-ntwrk/ledger-v6';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import * as utils from './utils.js';
import { logger } from './logger.js';
import { exit } from 'node:process';
import { ShieldedWallet, ShieldedWalletClass } from '@midnight-ntwrk/wallet-sdk-shielded';
import { DefaultV1Configuration } from '@midnight-ntwrk/wallet-sdk-shielded/v1';

/**
 * Tests performing a token transfer
 *
 * @group devnet
 * @group testnet
 */

describe('Token transfer', () => {
  if (process.env['SEED'] === undefined) {
    logger.info('SEED env var not set');
    exit(1);
  }
  if (process.env['SEED_STABLE'] === undefined) {
    logger.info('SEED_STABLE env var not set');
    exit(1);
  }
  const getFixture = useTestContainersFixture();
  const seedFunded = process.env['SEED'];
  const seedStable = process.env['SEED_STABLE'];
  const timeout = 3_600_000;
  const outputValue = 100_000_000n;
  const nativeTokenValue = 25n;
  const nativeTokenValue2 = 50n;
  const rawNativeTokenType = (nativeToken() as { tag: string; raw: string }).raw;
  const nativeTokenHash = '02000000000000000000000000000000000000000000000000000000000000000001';
  const nativeTokenHash2 = '02000000000000000000000000000000000000000000000000000000000000000002';
  const secretKey = ZswapSecretKeys.fromSeed(utils.getShieldedSeed(seedFunded));

  let Wallet: ShieldedWalletClass;
  let walletFunded: ShieldedWallet;
  let fixture: TestContainersFixture;
  let networkId: NetworkId.NetworkId;

  beforeEach(() => {
    fixture = getFixture();
    switch (TestContainersFixture.network) {
      case 'undeployed':
        networkId = NetworkId.NetworkId.Undeployed;
        break;
      case 'devnet':
        networkId = NetworkId.NetworkId.DevNet;
        break;
      case 'testnet':
        networkId = NetworkId.NetworkId.TestNet;
        break;
    }

    const walletConfig: DefaultV1Configuration = fixture.getWalletConfig();
    Wallet = ShieldedWallet(walletConfig);
    walletFunded = Wallet.startWithShieldedSeed(Buffer.from(seedFunded, 'hex'));
  });

  afterEach(async () => {
    await walletFunded.stop();
  });

  test(
    'Is working for distribution to the test wallets',
    async () => {
      if (process.env['ADDRESSES'] === undefined) {
        logger.info('ADDRESSES env var not set');
        exit(1);
      }
      const addresses = process.env['ADDRESSES'].split(',');

      await utils.waitForSyncShielded(walletFunded);

      const sendTx = async (address: string): Promise<void> => {
        const initialState = await firstValueFrom(walletFunded.state);
        const initialBalance = initialState.balances[rawNativeTokenType] ?? 0n;
        const initialBalanceNative = initialState.balances[nativeTokenHash] ?? 0n;
        logger.info(`Wallet 1: ${initialBalance} tDUST`);
        logger.info(`Wallet 1: ${initialBalanceNative} ${nativeTokenHash}`);
        logger.info(`Wallet 1 available coins: ${initialState.availableCoins.length}`);
        logger.info(
          `Sending ${outputValue / 1_000_000n} tDUST and ${nativeTokenValue} ${nativeTokenHash} to address: ${address}`,
        );

        const outputsToCreate = [
          {
            type: rawNativeTokenType,
            amount: outputValue,
            receiverAddress: address,
          },
          {
            type: nativeTokenHash,
            amount: nativeTokenValue,
            receiverAddress: address,
          },
        ];

        const txToProve = await walletFunded.transferTransaction(secretKey, outputsToCreate);
        const provenTx = await walletFunded.finalizeTransaction(txToProve);
        const id = await walletFunded.submitTransaction(provenTx);
        logger.info('Transaction id: ' + id);

        const pendingState = await utils.waitForPending(walletFunded);
        // logger.info(utils.walletStateTrimmed(pendingState));
        logger.info(`Wallet 1 available coins: ${pendingState.availableCoins.length}`);

        const finalState = await utils.waitForFinalizedBalance(walletFunded);
        // logger.info(utils.walletStateTrimmed(finalState));
        expect(finalState.balances[rawNativeTokenType] ?? 0n).toBeLessThan(initialBalance - outputValue);
        expect(finalState.balances[nativeTokenHash] ?? 0n).toBe(initialBalanceNative - nativeTokenValue);
        expect(finalState.pendingCoins.length).toBe(0);
        // expect(finalState.transactionHistory.length).toBeGreaterThanOrEqual(initialState.transactionHistory.length + 1);
      };

      for (const address of addresses) {
        await sendTx(address);
      }
    },
    timeout,
  );

  test(
    'Is working for preparing the stable wallet',
    async () => {
      const walletStable: ShieldedWallet = Wallet.startWithShieldedSeed(Buffer.from(seedStable, 'hex'));

      const addressStable = (await firstValueFrom(walletStable.state)).address;
      const walletAddressStable = utils.getShieldedAddress(networkId, addressStable);
      await walletStable.stop();

      await utils.waitForSyncShielded(walletFunded);
      const initialState = await firstValueFrom(walletFunded.state);
      const initialBalance = initialState.balances[rawNativeTokenType] ?? 0n;
      const initialBalanceNative = initialState.balances[nativeTokenHash] ?? 0n;
      const initialBalanceNative2 = initialState.balances[nativeTokenHash2] ?? 0n;
      logger.info(`Wallet 1: ${initialBalance} tDUST`);
      logger.info(`Wallet 1: ${initialBalanceNative} ${nativeTokenHash}`);
      logger.info(`Wallet 1: ${initialBalanceNative2} ${nativeTokenHash2}`);
      logger.info(`Wallet 1 available coins: ${initialState.availableCoins.length}`);
      logger.info(
        `Sending ${
          outputValue / 1_000_000n
        } tDUST and ${nativeTokenValue} ${nativeTokenHash} to address: ${walletAddressStable}`,
      );

      const outputsToCreate = [
        {
          type: rawNativeTokenType,
          amount: outputValue,
          receiverAddress: walletAddressStable,
        },
        {
          type: nativeTokenHash,
          amount: nativeTokenValue,
          receiverAddress: walletAddressStable,
        },
      ];

      const outputsToCreate2 = [
        {
          type: nativeTokenHash2,
          amount: nativeTokenValue2,
          receiverAddress: walletAddressStable,
        },
      ];

      const txToProve = await walletFunded.transferTransaction(secretKey, outputsToCreate);
      const provenTx = await walletFunded.finalizeTransaction(txToProve);
      const id = await walletFunded.submitTransaction(provenTx);
      logger.info('Transaction id: ' + id);
      // await utils.waitForTxInHistory(String(id), walletFunded);

      logger.info(`Sending ${nativeTokenValue2} ${nativeTokenHash2} to address: ${walletAddressStable}`);
      const txToProve2 = await walletFunded.transferTransaction(secretKey, outputsToCreate2);
      const provenTx2 = await walletFunded.finalizeTransaction(txToProve2);
      const id2 = await walletFunded.submitTransaction(provenTx2);
      logger.info('Transaction id: ' + id2);
      // await utils.waitForTxInHistory(String(id2), walletFunded);
      const finalState = await utils.waitForSyncShielded(walletFunded);
      // logger.info(utils.walletStateTrimmed(finalState));
      expect(finalState.balances[rawNativeTokenType] ?? 0n).toBeLessThan(initialBalance - outputValue);
      expect(finalState.balances[nativeTokenHash] ?? 0n).toBe(initialBalanceNative - nativeTokenValue);
      expect(finalState.balances[nativeTokenHash2] ?? 0n).toBe(initialBalanceNative2 - nativeTokenValue2);
      expect(finalState.pendingCoins.length).toBe(0);
      // expect(finalState.transactionHistory.length).toBeGreaterThanOrEqual(initialState.transactionHistory.length + 2);

      // TO-DO: contract deploy and call, obtaining minted token from contract
    },
    timeout,
  );
});

================
File: packages/e2e-tests/src/tests/logger.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import pinoPretty from 'pino-pretty';
import pino, { Logger } from 'pino';
import fs, { createWriteStream } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const logDir = path.join(__dirname, '..', 'logs');
if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir, { recursive: true });
}

export const createLogger = (): pino.Logger => {
  const pretty: pinoPretty.PrettyStream = pinoPretty({
    colorize: true,
    sync: true,
  });
  const level = 'info';
  return pino(
    {
      level,
      depthLimit: 20,
    },
    pino.multistream([
      { stream: pretty, level: 'info' },
      { stream: createWriteStream(path.join(logDir, `e2e-tests-${new Date().toISOString()}.log`)), level },
    ]),
  );
};

export const logger: Logger = createLogger();

================
File: packages/e2e-tests/.prettierignore
================
dist/
coverage/
reports/
allure-results/

================
File: packages/e2e-tests/eslint.config.mjs
================
import { packageConfig } from '../../eslint.config.mjs';

export default packageConfig();

================
File: packages/e2e-tests/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": ["src/**/*.test.ts"]
}

================
File: packages/e2e-tests/tsconfig.json
================
{
  "include": ["src/**/*.ts", ".eslintrc.cjs"],
  "extends": "@tsconfig/node20/tsconfig.json",
  "compilerOptions": {
    "types": ["vitest/globals"],
    "module": "ESNext",
    "strict": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "importHelpers": true,
    "noEmit": true,
    "composite": true,
    "resolveJsonModule": true,
    "target": "ESNext",
    "moduleResolution": "Bundler",
    "plugins": [
      {
        "name": "@effect/language-service"
      }
    ],
    "noPropertyAccessFromIndexSignature": true,
    "alwaysStrict": true,
    "exactOptionalPropertyTypes": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    "esModuleInterop": true,
    "ignoreDeprecations": "5.0",
    "erasableSyntaxOnly": true,
    "lib": ["ESNext"]
  }
}

================
File: packages/facade/.npmignore
================
*.ts.map

================
File: packages/facade/.prettierignore
================
dist/
coverage/
reports/
tx.json

================
File: packages/facade/eslint.config.mjs
================
import { packageConfig } from '../../eslint.config.mjs';

export default packageConfig();

================
File: packages/facade/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/test/**/*.ts", "src/**/*.test.ts"]
}

================
File: packages/facade/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [{ "path": "./tsconfig.build.json" }, { "path": "./tsconfig.test.json" }]
}

================
File: packages/facade/tsconfig.publish.json
================
{
  "extends": "./tsconfig.build.json",
  "compilerOptions": {
    "sourceMap": false,
    "declarationMap": false
  }
}

================
File: packages/facade/tsconfig.test.json
================
{
  "extends": "./tsconfig.json",
  "include": ["test/**/*.ts", "src/**/*.ts"]
}

================
File: packages/facade/tx.json
================
{
  "tx": "000400000000000101120000000000000000000000020000000100000000007a00000001000080e03779c311000000000000000000010024bdbc9f85437d4c6de66e8373f309b62bef5bc8ae998b00d2a40a9adced2069000000000000000000000000000000000000000000000000000000000000000001008862bd25e673b5a4ba370dcac0f0bfd8a67832bd64e3cd974709c18ba3f948a00b0000000100000020000000caef884ca41757ed4d1ebf123e27739b1520677aed6025be6ee32c2f648335310100000001010000002000000040799da3fca7a8596840efd2ff93ebe2970c91539e1b31173475c39e6e8294cc1200000003010000000000000008040000000000000000000000540000000100801a0600000000000000000000000000020034944abaf2f136aa6d9db0052af742abf37775c598279b77ba8cfe09aa82102a0000000000000000000000000000000000000000000000000000000000000000010000002000000020935950612756d63255b55646da4c504c61ae17ddc3e08e504bfd5aef3800f70100000001010000002000000031dd63abae612b518bf32429f285ca647dbddb2ed6dc6961a680f4cf192d9a22110000000301000000000000000603000000000000000000005400000001008065da3779c311000000000000000000020045bb01c45163890c11520869198871f33d3a8e3f82512d3288a1eadeda425bcc00000000000000000000000000000000000000000000000000000000000000000100000020000000bbdffd417ea39c38bc898e0486f56c6b1807a5798a7238d0a3bf098fef400b6601000000010100000020000000306f997f87ab1e2ae894590654e07d13180493b8f18634d2b75ef6b76acbcc531100000003010000000000000006030000000000000000000001000000001000000020000000c37c2f548cf7909c15d02ab3f823a2247b19e831b0d1cacc015f300d0ba00b002000000060bd7fed65f758d28cdf41265df7f34012e1ed69ae88ff0464b4dcbe06e49e0f20000000957b88b12730e646e0f33d3618b77dfa579e8231e3c59c7104be7165611c802720000000957b88b12730e646e0f33d3618b77dfa579e8231e3c59c7104be7165611c802720000000957b88b12730e646e0f33d3618b77dfa579e8231e3c59c7104be7165611c802720000000957b88b12730e646e0f33d3618b77dfa579e8231e3c59c7104be7165611c802720000000957b88b12730e646e0f33d3618b77dfa579e8231e3c59c7104be7165611c802720000000957b88b12730e646e0f33d3618b77dfa579e8231e3c59c7104be7165611c802720000000957b88b12730e646e0f33d3618b77dfa579e8231e3c59c7104be7165611c802720000000957b88b12730e646e0f33d3618b77dfa579e8231e3c59c7104be7165611c802720000000957b88b12730e646e0f33d3618b77dfa579e8231e3c59c7104be7165611c802720000000957b88b12730e646e0f33d3618b77dfa579e8231e3c59c7104be7165611c802720000000957b88b12730e646e0f33d3618b77dfa579e8231e3c59c7104be7165611c802720000000957b88b12730e646e0f33d3618b77dfa579e8231e3c59c7104be7165611c802720000000957b88b12730e646e0f33d3618b77dfa579e8231e3c59c7104be7165611c802720000000957b88b12730e646e0f33d3618b77dfa579e8231e3c59c7104be7165611c80270900000002020000000000000001000000200000004b2c848a2a703ea6f6e25377203debebf23322486922148fe8bc2e17a5dc838b0f0000000302000000000000000101000000000300000020000000cbaad8fb2e93faf5ce0ec465a83e5b90fb42d83be8368ea0a457cf4f55db0643200000005bd0d65b38415c4e8b3f891e30dd28cc1ea893926c81c97624cfd9f0f1a9d1cf20000000957b88b12730e646e0f33d3618b77dfa579e8231e3c59c7104be7165611c8027000000000200000020000000c3b3f0667b2f87d75d50c5671c59bd62c732f5939a83048ceb4e73a894547b3620000000957b88b12730e646e0f33d3618b77dfa579e8231e3c59c7104be7165611c80272b0000000001534eb8680000000020bfcbfe4af0862b7c3972d40fc3e3c206beee61f361881212e222a27cd5cb34020200000020000000771042ab19903664f075c65613976a8e20dfa482966ab505d6695e84ade772f520000000472fc84d81d0a981faf3b7c0211d291c5dcf17fdf1aa661e2708cebbee6afc06000000000100000020000000b343b1024cd9bd90b21c5764b374883aaffd95a731846fcfdabff2e9dca54e870100000001010000002000000083fb6bd482e9eb7b2a0928fa1c1ea8109563d3f61ea780822d389976e4b592fa3200000003010000000000000048240000002000000047dc540c94ceb704a23875c11273e16bb0b8a87aed84de911f2133568115f254010c000000000000000000000098180000108d14f54af5bbce72c4a69ae7f271d55b607d4fb3e7b3eec9471be4e098ba37cb0d2bd806151f1b0eb3908b914a91d147afb3c25f556f8b97d5cb00edc57a900120df3217dbc33885475222fdd866a4e86a6c107598241d8d5c11b874ed63420d280400301800008ad46c1506b6b3eeb0e79a4f88095186608880c19369c2b5d217b5fd8dd66e6e42243f4c1e0171174258fa4f62ba7f37b7b1255d796ea95c14a7c718ad685ac7766729b520e498c4e0528c8c2971dac2125f888290dd84208d15ed7b72bedcabae17073d2b40478c49a68b5636b5eed18ab53fbf238e9f069d3428bc47a5ec3fe20b7c3c3f2944c17aeb65e308c87f4f8690187fdcd5820a2ae4ada1956d674db45cccdeaf3a8f1346970fbd613fff5c750c985e99a17e4e6f2dbef7c2f578a6b8c92c8b5d69a08b4d075424785feb78aff4c1e4721dcda6a85918b7514e44c398158d41a9b1a35cf7db862b936e8b84b421e073fa5ec1dfd40bdd443689fa58366c3ab55516af90b6d00164e46c966f97db11e79808ac3d12418d063acac838a2af97483e0940bee07445e34370d3e121c507dc9e0fdfa52e9b43349a60f1dec7a12f79a6b0ac3e4d7ab974da0e95aa80a2e5376ff3b5bf653b886363e30525851e1a8985c0a793a210b95d45284601373265e680629f0dc17101bdfedb0bd898f83728c1299fef3e8dacf1fb48b588fd95f8d9ec6ac56c92daa0249edacebade282afcaf33ce241a3b279a62b341f0a91937257c06ff464c12efd36ccd5bf214fdecc07d78f93e8f4832a32e3746f2fce6c8ed8b1d0f521e7302006a158bc4aaa80d06316807080be56f0e3353836915be19c448d84c7d1fcd9ae02f0f995dfd6958b2c587134d7e0b8740cdadd5f284f144983514b3114f2ee91db3840d4c9f2ff90e560ccda9e5f28bc885a1e5d50ff5680c8288e285cb615bb3bd931cccae7e39853deca1f20b0438b877e901ce7e4d5e34912cffb51db22d42f5caf114576e55fbada3b31d7b8bb24599165c8092e846c875e1a1fb7feaff533d0b4e1af158eb0e6ac024addc52f2aeeba64728d8b97cca50d5c5cf6f1361a71fc6a116883445ede3663fccc9dc6898fb82810c25271b36367a8ab7fa2d2c79ca94e8a9a7745b36e5868199e3e3b9466a3b8200ac76ecaa3678175a735e9e1b3e83bc959321041af65a8d3b2dbdab30b2cb70d2434f0b3895c13141faf572633f3158449280522128eb4ea427255cb081268c6ee44be334f95d460b89342126dd9eede601ebdb7a28a0306cbc5fb41aa9aa407c9561d30390407f0b610fb3ee8c3373ca8c10bf7cbfee1e7198b3060e0a4d541ea1045126ab18ff63b404fca7a3fdbdf4a81474bca15833241736cc62020d31d166339a7abc1a3a4b5d1c5bbd140a38899ed2a913b7ed43fe8a4fe6fd0728140db0b6416558d230dccbfd6c2978f72ebaad56eb66a594f4f95736bbd852434e8fa1070ad0fe0a5cce730e823b5dd6540e931303097c583ac6561f874d1713f44166b71aca84a3bf81d464a4d5873b0ca4948a348ef277a07335e23559b7da2fc3827344a10043e2bb5ded0c04762659897e207cfabda40069cb61cf2009b995870fa2490feb293416221270a1d71363ae9734bf244b740ff151e1a965ded9d0a019664044e066aeedfb915217e2ec1b2b0e767f6e56230a5093ce916c81ffb87e81b192fb2396dfb3d3c1ee72c7356d72cae927e3431561a2cd40a0555d40437006a80c96ab28abd84e611b6a63377a51853f0730662d862a4b91eb4dad1b7b02f385b634b6edd0259e262dffa2250217554f60e0c234b1e14075214e178c001fb11ce02a103d4cb0974d4d0f99e8a083394debed73c4291080610c2d69d1d7a4c202695ad22c7f0f9d6f7bfe038fe453911e764fba06c1a6f6494487164d1d95901c9562adf2f2dc3890995a55dfab3668e7d93bb94a2d8fa1d22fcca83fe81d8c2c550188b8ff47b3fed197f257f4cbe5a675b110836cbf7a492924694d9a0b54c08b89c2faa4c03b5f1c99a4fdcf8985167da856ab28be499ea7f3666f4299a3dc6707f5a7dcb5bd80078d9a6ce8e28b67da2f87af2d327d2d55b30363c0cbb5cdc62f1ed9186c3555ca68297b9ed333f3b0d60286c5f2ec650f7af1ca10c82898f3e6bf275422a3fb2a3c220ac1f6b4505b6e0e46d9ccf3674d981b8ac543a005fc9a1226db43bf126ef27f68ee1797593ffa629f6bd0e492460cbacab43fb6e67562822130f336ca0dcecd5fd9ef1a3330b5384247ca40d0c05c53000f2abea1abf900b1650c397fb9169c480021b23ba7a01e563c36696505842d097dd86058d3a4a0d61216ebfc7e11942a98d312361058e5861abe425836074489ef4e841dc3f110e63c67ac2777daef1897e83246b6c64a6246eb0e69b5e2296c0ce664e538bcb7f3e1cb2142c137adce185b8c5032710c4bc1316fa0254b0717197b58bc1c409ef17ff48bef0fcc8b0020475bf1d024531267957af202dfdbad1e6b901cd4b90cb6593a9135a09b153574508578cfa108da7676c93c240e08887f063d07a74c27cba8f19e08f2628e9f54e9b76733ad8a84b398291191a5f16b351744d2d27a9ae6b3c2d4236eab5707cd61ce5ac0b2de8506ae6efa6547537f577d020191ffb2631151ae28e1ca3a1fd352f3fb390f6296ffcc3eda8517c345f91fb3540daac31cbd72c3a4843bb9f1949e83643bc11cf6be5ed62cdd90f99f4f447de4bf51d3a20e250d2df50f344272ee64c0838e58d5c2a1944526e0ce067538e4f7774f48a7a9296e14d434c87b80f8a1043214e3018aad8bdc3ee50efee143021e966a04d97730eff14468bd1b1cc404e640cef9c225906132605f23d3611f8ae82c1ec2f0c8498d21b48b2712745e0cd3313c4fb061eed83a4b2c6495301f09256d7934875189587d53e6bfe27239a3d4279db06c882e227f7288d5ad67488b83dd47e5ace0d0d4cf675ff1b97be77d83c0f1f1d9328ca4507da89c69890eaff7d62a234834291a55f787737a1ee625db4326c9ac7c55abc8a42197e84205128c8ce699197b5beddca4c227af0749d77eb4ae71b86981ddfc327682e0941e59aa345d0146d930809a6f8fa0633f04dac99af54c4c8a5789455727df590004407fbbd1492bcee034804473b1941e11b7246088a8ec0288856074c2623b1123f16ca8a4898a46e2f17025020fef1a1c7543ebfcb2ac26db44dcfc62466cc932ac4e6dd1b1efa50bec2a19304aa082926bd85e2bbbf1291e503f7db4896e463c8de74ff4908af2feb3472b65f7f0e87dcfb86cb1c922607e005e0f0a05e9ea6cc981e47ca7b6b30c126dfe922103ee56d6d20dcbbdce823ac80e8aa616433a1b290083bdf404471716ea8d761e49ee6a8f53dc01b2a4bf7471295e0906b34433e192d0892694042d1650ebde96074c39e069f29cf348f1b792103a7999255b04681982171ed48d15349b32b1e16e1e23fa187b19c72c2b7dcb5810d8899b1b0538f45c753b13c66439a1c73c2e4beba61ad6a9981eec5a3cd505b50719b17e2137c554acaec15e4641b2a67e2998bb15f497791455d69a51fdb08c6d15b41e0ded7d344aa9504205aa8afa73be99b435f0bac9cd3d5ad05edb048a9c971fe56c5aab55ab9d4ec372e318c551c1354fabcc57b897438872bca83bd69236f91f6fda5d3d1feb081d2107ebfba5d9b393628fdb0ca848c179b4eb56e1b316b647528ff8ff1722b5ae2439366e83e7a3d3dc20b778b7353e946de709eb118e712471c2b4a1d0114b2370db63f62fefec9c2589cd6e552693a2afb8fe891a9d462f5d2199c7b4e1d8dbdac440f1e43c1a146dad01b7f2b9d095537ff585ff6d15b21bfe2aebcb98a1e02c4c3ad0e974e014670e17c1d687cd187d53903e920344e11883acd1f09f090d81b01c4d1b75474838ed80610f55471beae48c39ce6151b141f9dadf23e98872f8d43a11c91ac277dee53e711675fb36a9b8c3480b19ff04573dfc4a3e99a6aeb6211378edfa18b8df782b456773f9488576891bfc4bed472a3b47e98ffa082e002bf409e443a0a8e36e177a0891eecc17fb86336d7ca7bc32bdde94de96d9a750ec8732b21ca5afc1fc7a4713b8d84d9bfeb15154c34f573be5a7169a8dc9340a43192775f298f106e73bdde4eec862157ce695b49ea72c1c9506e95530fc0b30a427c11c9c184efbba31918d7688b33356668414621cb8024898c921d41fbc8d786056824074cd4133de5eb2d2806df7dbf67588dda90f631034bdec9dd7a507be9c6ba02a14534f0b5f762e78e52af7b5b3075b04602770a853fa7e984a968b79abc3759815bf461ee6f76d7252dfe36e4ffae5633fe125bc0885af8830823987fed446029ab4dcb2f5f8b7bd21e01667d1ca40ff8e613c54856adfb7fbea29a45cfee410d2419dbc1801401eb1282b5e7ba175e889da696b698988546f96287c5d4a60e86bb603041d9955fbc0c8dd386f700eebda575f0a783f4863fcfb16693051810230c96f6a5b9194e1dcd86df5f508c9f054382bea735f7ad9171d5a9e216531f2d921ef58dc7cda767a487e8c7ab427b342874e923b6f9fab7b40b4e77c67e3764a782489764196ae1af68c20702da7487a946586b89357ad83f501a542f106d7b434338f74b64de273c8cdac2b83c3710b4a5119585aaed6818893d7bd271be483a9f1e2ef5165f0f0a44120a0b0e7772b9f488477d315dad57cfd01c5b1f1ddbee5924483c97141f177e3b68020fe2804784eaaf0a16b9343898596fbace8e8b1009891ebe5aca48f0929ee0c212de03dea458128ad233d164bf8f13f2b179a981222ec95571256a88345a62558ae933f5d360740e80000bbcac5343a8cb25914c2799e40618dab2e3f18284e3c8b75eba520d9e52f0737dc2cae959a887f1b187a08b0aca6aa8bb9397788a254bea6564e1a6495f0231ce9dcfbb2f36f8e76a8c67c3f98a12c46a80384487fdaa70b9d0a4e0740e80000bbcac5343a8cb25914c2799e40618dab2e3f18284e3c8b75eba5206495f0231ce9dcfbb2f36f8e76a8c67c3f98a12c46a80384487fdaa70b9d0a4ec18b61ce5c3eb99611b2ad44e6d790efba332f09586eec23dfd0834955628f277a1d79ffc9cfd57eefbf18bd8e9cbd79b5088f533bd11db53a0eacb843508940e868f36cd4b124bd9e0fac8805bb9dad4f977d9ee1593308ff6068f0bfd1962b67d340fc1aede50adbc79d0e559fb70cd480f12be10ad2e9a36cec9da9b16971b99a2f29c0a7f86f39c418083bb34534027ceab278724524176c9636757d8b4f2e64f70aee0a7724e197e840a030f7bfe7f7674d1d0916dad260460a17cb484fe33c5cf41a4ccf59cc0b338b5b980621239053d7d6e9216bc74a625755606b71e65c679fc615c1b08176d83a6ec4b60bef7071848c2f7137bf2527ae2291475773d17f40d16dfcca43027b6c9732aa1ae5a80ce97e023987db7933d2e71e2037bb42dcbcdef8c211c25163813ae9e3976b524e88b016b2f3e3379985e19a4b3d04b0c1dd2a351b9018b7bcc3472d5d8bade4909a249ab77f096a01f3227e8d4556c3011ed30a6565574e997c8d318dca441a7ac31f23e67de0cd9d6c4de15e21b15a5f91d77745f9c7ac0f2f110aa6628307b3b4a4b3320657b7325d4a03815bc992f0f6bfd36f9f554fab2243ebfe0b344ad54694e848ee50fb656f0c64f1133d74541c84b892b6509fbe20fbf107555c608a9155dc470e33f75e80f4159a4fe7f964083362b7c83e7075776d9d8b1d057ee091912847bc8bf96ed67c254f436897bd96f08569102f1bceb572efb6cf8a4d5eb6122c541af5bf649044a6e15f54d66e630976226636bcfa67e805f8044db794ef22656400664328421c06c5320bfee6c51d8ee9833dc498cf568c9798abf610eee744297a09a43392965c0a2499cba963e97aebb127c9c7a0f02e6d4ce527b1fbc8a0cfc2513d8cd1bc0008213beba336ac064ba8b8ea231f8e8f85fc379bb5f70df7500cd097cae4188978540d4f93c778a7dcd5fcbd44ea78be9b85f936f49447ea911d7aa189b72bd1bd4d01eadaf1758c1ce38cc3b394604285c5ba63833ab1f73d3cb567290edced563b47ba5b369d5ab0e9987b66f3b5b47dc49058d5f32509f01aa660e246e57bbc32a926c76e16e716303efcc14f20d05a36b7c2e2cc01f5bb9b33fb209d1beccb1d026eb090043a56a4ca904ab4c81c247da843acda5c146812eb470c349e25940a986c250fd53288dfe504ba83093cbdecdd6b061180528c63bd80b4e08da48a54a64e190396023f44a27426d32f4f4d2a31233fcdf9123cf0f67d3677263de72e63b6b2a3d52a372d8c1d3ae08d40912f610221a9beab13879857d6cf369ee65671b9d779aabcec95911e6181cc7957dc97f0c8c1b8100e24f2d5611b5a19ff1e012efe977c1147487c796d31a9894a98cca04afb3704e2f5a7e856dde6cfad3e417700055849d8ffb778ace733235dbed4917e539732579b989f9d51e9c6ae63c3b24b260fb99d48a742a809ffc5e84f200fb99eef455a7f0ead19ca756d6d489f4548b6bfdf474ac95083ad797a3032d3dcdd6725eb6f6a4959166cee4ed9159c40f5ce667c4984bfd79b268807323d5ea8b5c8507ad6dd6f70e32b0488a66c1b4933246ae2338f9ad20300816ac9b168f65b7b1a57768da52b71f351b8053c7ebfec3655bfb5540e9d17cc30f96fde390b367e0904ab9773f7dc93a24208388b79556842c0d0391a9ccf2facdca968c8fc5188862c3156c459252a3dc354361638c3109744ab57d66749f41b6e3ff5f29221b41820ebf3411dc339b295535f7bcb319ba2434d48ccc4faee8ea35ea969a57cc15df6a2d08bbb1d2d57880748e6a6bd9cf54aac9ef691734a476de0a86541f33162f59927de303ef619c54571e8cf04d47fc5a8a2ae9bdacc9c2a4ad49f1fd0a272a6aa525dbc32f4298fce06d1ac3d883205de87e504b5706083bb47503a4b1571bc898d0ca4f52cf4db7c334ec7143f5ba757ef683d2ba065258b74878a9a06e025fe1a4354120e760721449393b830faecea45921660b6b954a126469dcfa03c771825f1c954f1932ba62eb18ac18adfe917a907ddbad348d1f435e211f71b3d4f9755bfe33f2e644c6f2e87af1cd5135bc42b270b6cdd1f1aeaea53177428fa96335c03ab0ab51a754e37c47d2e4727966ad27b8f968f133046df54175fcafd1e6247e89b18993b510050b516439f2d3a1b28051a9a02730327a6b8e7e268eab8ba04c7588564c0c3b91c71734a23db45ef25560d11f49455bb2c0bf4d409520b82d29ee6720dcf7e3f15fcbeff306f49382613165d9bf93ea5ed474608f9b0049702fc95124039fc986ac6b2c4415fd7c6cb8bcd707eb03920518038284269dd9dcce8c09406dc9fec4863756a3a429350f097428419f697f71807d2b91b5c7113de736230fdcb926470dca4b999b3f8b8eafc1f435a1678635d3332a9e8efa584487c313f8c92bc0763d931ec31c19f2cccb51ae20cde3466b68e60f92e459ea07968acc221fb3e4813071175f76a4373897e3e22139910fe84c3f210a0ea1d09688f96943d0939d40de70b459e7700ecb2bc11ce2ce2cd0fb678cecccedad4f5964ea1611b8ee4346a243e50a45ecbed4b7458a20ca2744cbb9724dbf3a82feb9473273c7411cfbb1854483a35db1b856748e12bdbc14e63931474322bf001f8e92d261f295dc3d656de0626f68e22758b99c824745829e67131ed92422ab654e577857c2f96b296103776bd54b655315c6a80c808d62e1735fb3e3dc4b139e4d82e14311d1628ef4b975e54a3423159105429f8fe307041f28a348f9008b8c6e3d95aeb244064182db544a8338553e08163ff3cfa447f3ece69e9975cd0ca1fa218f888c061c9de65565487613214efee3377cb8c6137469edb679883cdf9f9ebf8287db52e39746a58843a20dcb23bf3eed2e3b89e223d2f44fb2851fe465f99caecf2455bc94a0377532907cb4f24cf15be69039dee8de8db17307b18519226f1a339b5d3922254375623f4c3594c48d5207e34abb92f1b05ee4629b43922ce76e0e967b209f6303cbe2f83806ca966fd11b6a415d61a4816e5f2dd309f2fa2a7521dde9016c83278ca7ca505f02cc4137874637e324dee3b720e167eb22db9e02204abd975cb08aedda398ad25291dc34b1773c9f8473d202502890f3c2fe776f4de0d5d64cb1f979ca89a4d36b8b3ad27216c5300eeccfbf3adbe989a03e5258dda51ce238a0e1717af923dd1645b09f894789fb32177d475530e4f631003738af27f94ded94440db1bd404a86646b9259d9586c65aeea0ae54cde53b8766cc2a9192a7227f3558524927d934af165823b4fce5f938e5c9904be04ebd2f0255ed72319a18ca495c2092360973503f1e3e60c3f54d0813e28b047c6d55f27ace0d417445dfd535e2e3e92a4f0a38bb92ce2a7ff051c1dacad0fb6e78706e10201c3c6e1c907d2d9554e586070e87afa508d44131c16435628c24ff08d1577e9fb6d67cf7960bbc84bc6a9e1c0f759634fb4f2b07006017c06613a51a7bff2be7ff429b252d112eda14ed1fb0715ae860773e3f1dac6d46adb2a964c8cb1849d88d4597f4c2351272ce668b10a096dd0b9b2b710d903e2e2bf1b82d8477cd5b94be262cd2ffd8c6d69a7d99d22aa19b2211d9b2967dff3979682e53a95696b04372b23c6d15fd847515d6028b85aadcace0858f0db4c607b8eee85d872409d423f0b35d14ec05fe8bac8056eec6e073f42a654e52c99b02a7c628c96b2874111378b22aeb3c23212ee51979e40f435576d77d177dc4a5cb990b11626833421ae4f99803a2dc0c070100000020000000b7ffb966a95e8b44eeb138396b61883354a009cf233389d93abdf54d1adfb351010000000101000000200000008e650b6261001745c1c9a2ecb9e674cbbb485ffe54ac8021d4ec046754b5c91a1200000003010000000000000008040000000000000000000000e6000000b730e2d1d7b1e693309cf6d6d12614418bfe5a2e8c43c0da48464dea0024a2d2200e3451d4f587750a40d6a3eb3c7d1d74f6e397e5f506ab918a1b627ef3beff6c20f8f2d54f35d3939cd557e943c8370f5d9316a17db6c92514e950f7894375656b20dfbeb418dd42da2f78c309867e5540ceeb8d71bef67c9695bdf330e529a2033a2014d8739ae4a40893570d6e92fc7c79b45a5f9af93b8d5a8f91e829face7d834020b2a733da6da9cb87174346efed0d6537ed4a88e7237fc2b37e5c3b9be992856c20e6e6d2a86e6f41cabbedb81ca14cfd75a9040247bf6ffe65581969a1aae10b600100000020000000d4ebe125264984294626edfb4ccab9154420a07e1338670e14be14b3df43d13878180000a8cf73fd53daea372c9f0cacd8d7a7a77e670ae5a0da6cd22b6e090d0d945165482b50388d91b223f76f85b9ab8d26ddc61d69505d8e5ca2e5b20ad613b1b2800100040030180000844b9f59d604190d45d77d389cf2323df506c0eda5f26e869d960f963ea370eabf60b7604f04b508a4960d3a36e7e57db3d859052c210669d0ae6ff9cd1ed94c04b26edac3c016f13a7bdb07d13a1db15e2c572a898b77f926f8753f361853628a7822544d35164c9f14e7f65d71b85b4a474ef15c30d1fd9a32384cc992dc3301622306c9627df78509673f9d93d3778b769401171968bf59aad2e4075f4a899303613cde292cb0fcdc4e477224be0a80238c4e78e25e5a9ce3ea253415a25aabf32bf4d98a4a102004d0cace2e056fbc61fa31a2348f80d9c1d9b803ce2d2e66c01d410697a3aa270dbe9a56dd61e397e5dba28406e5720b3fab770b25f079b0d9f9db59568497d5f2e0e54aee01de19f0c63781e8d8c1039ffee6c0cde300b7b9d421db7113962560508e2256472295c0ade7e5461d6777eb30a4fcb6085f509a1a737aa92c0ca779d6705bd2aa4ea2ae7657ac3d8715baa6b8c66f8233d07591e5961bcdaed807add1e3e9581f6a6c5a34cfd93bac5ad1ff6ceb06cf80fdb9b2de9bb78d542ca6c2ad3941dd80097d163d8dfb7e4a132424d73f0c2ee0a5faacf19c1a88cdf8528c0f9c0f9919cc8dd7d46814035f73c80ec807f30463696e42a91d4ac2f917d1c40458ab44e6b0d26571eab0c2a6d0608babfdb02cc7c996ddeb02df698bdf99e282f04e7396aed90a791495e6c03a56c8d7c659bcb095d4de74133dfcb06fa06355d564e76d44a8a805de3f35e9ba66fafc006b5e285530e25e0244e47c26212c724fdd42ecb359fe8a72fca6fd0285850794cde0a43c84224d8822053c25cb01c1e617cc000f41b6391b88331f2ac2731cafc0386ebf0ab14db2875a9c193d28626532b3a45387c49e9674a1238d9ee2e8bb0cce5c730b007e4ec902ffd06425152e7ab1bd2b6a2b1b0fc3f88561e6df19b09b8c354e90638f4a5815ae3aaaa90d7ea59a1c20a2cec70f3eb92a4ca7eb7c68b2bfe55f3cd5598b80318939c9976914417b9bf68023e3acdc4b73d89afdfc8bda201ad1d2bbc824a506d15a4717c205490a823dc10e3dfff8305786a219c7f5fc381ab88f2a166a5e1e6a10f486f6c409ae23344f15431504e3df12138fa3cc4dae3ae426c672183cb2cbc04cce4e07f9ef48afa10044e80b38d0f869481e94f43270278c377aff9f55b874dc988f0829c2c4a27186558e546a65c2942f9753f489496293f30a0638855aacfba8599041cb6cfc5e6805d187fab8e7c8e1bcfd8e62548c2adf0834dcb4121eac90d95eecebeb24b89fc0f2111c16feb97c40205d53545cff2836cba318552d87b21c23169ebbaf8266bbd29e7dc746ce905e1d9192185e807db25b5e5d31b680c24e6f9170dfb808e23ed80b5c5900d8489f40e3192fb7779b309a859279a45a9972c0e7b12b29b675807e74dc95179a78d30f8969d64de7ae1fe3d2a2457519ce752bc18ee2ba9a89f11717b4c1b1973c69a4ffd6303b9846a2d0e824e6716ebfe56bfb8ecf5a9d563736cfcb320c265b398e7315289a1a414fd5f6a909f5a6f09f836f8ddc99b643c64b8a67a74d767f441149b1669346955f6693f810568b3d485cb2cebbbbac34b7378e5b75f21e88e40c61e35c17922fbee759a556a486782c050cfac2a21e7f300f74f7671c7393c69ada44f0618931aea6c0f3a021459de6830b55dea0b97e97e65dbab2c3792f09cb2e17a7debdceaed192424cffe40ea8316cde0342e2d571413e079753280b21bfeead94738b7921dcdd6b135d1eeac4f82a36c4f3ad0dae516077a6fe074d3cd6565da02d4148bf49a48d9eb32f926b8df85646f08592597cd3cac02d4f5840368f04dd8a80b146314bfabcb968d18bfbb2d577a4b0c50919bdd65901f06a8a575b9db04e90fc55e09e34c03de973ed4b3bba44d736e309c50f025fcb8756d35334195e5d7101dc8e08de185bb2a6dea3c26cbffe97c32578a62e0f435641df61cfc8678a7c58a7670f7330307539c2a00af6ca8653a71ce5557eec62bcb8aa979986b503845f70067cc0a9f6aba33eccbdb9cd2983d06d5d37c184cda3e0dc25cfec635556afe1e3d0eb9ac6a721ef7cfe5f1d2aa310b357e62abd8f800a4037227a106f80c83c0c24a8176970e1102d4ea04b4923d8fb21414a3e6112b532328611461a894bf3bd78a77a55fdb957680c079e1498bcbd67f639c237350872fcb60bda03fd35203c270210600ef9d7b30757497d89d5e7757dac3979e23492688fb5bb97a7e8981b447ab94d820fde19fd54d602a104a09ad4d3a19ecde52e85b6c70acdaccdcd94909b2515bf31aba37c1dc3c1cceeb7c05b027ea9e096139c4cb1eb3d56aa5987449b357ec52cfa4085d746188bd0b4080cdcbe3ae485daa6b5080ec8f5f5e7983a93ea446ff73416d6af5bfd8e895076c0403c0ebe311902f3569595a6200dd961a20bbbf3c97c18de2ae4a379c36e452dacd2b4a30cd8e84a62cadda53b13d433279ecee04d2171cca4670635ca5f27fbfd0f891e2053dfe38fc72f07ceddd4109261a959ce5e0266f8475d5cc15afe10baeb5ad8eca17cec0f0c46fd2b9840f96c40a9d618b4af67c5c9333f91d33e7e6a047c15da13c60b589cf25f8cf36aa9da30446514e593c810af3337170978f4776b7160b9a491f00f2a96502f27ea65fbf5101763cc3d463f75625d3c70971926aa8c5d6aa739832d2f8ac75395900b9a7034ac920405c001d51e3eec67c53b10a6996f2b10d7f95db69bc469642be2ac29593cf77c5f15452c268c92a981a8fdd632df7dc0bd8bec783d21ef49b968d5d9ce1af1c7701deef046ddcbb81b3a9f0a34c3b8f842527eeab159500015129cd177d3ed8ac65b855202363f71ad56b4c52585e767f5fac45359817a4a03456811fafea5c5875ba3ea027f8c1855d7fc107c81e19d557223bb0556b1b03e4308576695cf3a3407e3e54c098eed077b3a9b5a876ea0eac1d7365dff57ba5def267ef444c1243f5d9e6d4b454b28dc939f4b131a69cc53b70bae7557499be37407fbe393b1adf3790bd061be838f99a999e1f34c725b993aa3b1667f3f77f70ad0364d097a1b7e6f97ae6c688d9b445939085e7f1d040aa599690645baa69c1d039c70354d0d301ff3cc0f50b255b053cf7f293be5917f8a0e8380a98058f91d9acd2aaeaa8fca216e51344c66b2f173d85ca8c15264d6978d643b9452afaafd2e7ccad00bc362eacb5131c50be452e695ee9b5fb37d4e19120442ba2a08262aca358de4a02a4182c2322bf3a76aae24415fc4d005008d2134e32ec06b8a5e341ecc259d33619cdcd5b91aef1e7f3318f4e222ae68bcdf9dc874750677a003717aa50a4307ab041544a51a7421835eaaabb12b337bed13b1b96f09a62cf93a162c4e9964b93db83dd6c25666553781988f3298ad5aa47b5da82e47e8e070f2b2eff698da1d2848bbf6cb023af1df853afabbfaef396200ae254350c62baa37971a17d7b65998d9c12a6c31db410ebde2c8d7bfc52d0e8c34a46b4aacab8c98289a7638edb4024b54e16945b9ad16f6b558423d27d890e05321b76d428e892ac55a67ffd6cf01006a0f6056dba6f04fdfca52ce46924f35f67698768b4da77dcd741fc4d560426972317f258d5dfb7f45084dbfc4a71fa80b3fff40c70f4425690afbf09cb6eb761b87cd194049ffc06fa0163baa66971b987a12b59df511af457ffc780c17ac44c883f7555b2dd60d8ae2e9e6ea072bd2a1189bfdb26cd68e5cc1ecab55ec22242458b0584b78efd1eee5bb5dba3c563d821176bdbac05d3476dd7a2bf11de4f3116ef3648989bb0f9b999bdcab70078b4d223174ed29d21c33fcd7013d31a7314ec1863875119534dbf51eb14451bbb91a5b89cb152e318434276fa4a3065b23e96bb002bb84404b52c1857842a490eb146c2abe5f87bd2040730320d78afa779dd7f024bf5920c8ccb1750b70ddba8737f69c79343dec7a03525a7e205bde6f32b2c002a42a2ef67be23afc664935500715447474cbc82c4a8ab476a26deaa2281aeb27c2761365df1fa76e82c91d5bfc2470d8b98dd6e05dea3dc28a3800b75b1be56174be74f8f938fd2ca91ed3d17f9d170458ac51f44a86ea6d28b0250977775a457f4cfc0570f9c18772c7a4718ed772649f7945ca1d45fc24b9eb65556e45183d26563f08513f4edec8f6bc2f1dc9101ebd30921a78a3ff17faa72c786ca59f6bee1e2d5a0009ad00b5e896b10155ef8ba468ca0ea596d55d9aa989c0e4c1f629b6c3c84b4e553bc3218203e7e8aef0aa25bbcd6336c3977b91cdc22ceab6ae472ce1bc29b8bf0adde9430ebd8f8ebd4a3f16c0b5f2e7ebb0944aab28ef0f8750e7a8a9b3cfed1fcef36efa4c644e6fbf3af60dfb17976240fc83c59d42957727c5ef04b64eabf5a031d5a7393a5c5aa74fed804fe983144414587dd13cc5f64fbf06a2dda61c0d11950123b7e05cf9707760ce0abea896933088bd2d83737813beedcbfee8f29f1408a9a06bc1188e076da94c86e2258f4bc1dfc7c8faa62f3a5add329b6f9b37d14be4147855deaaa2d1d2ca0ba3e51c56448a55115ebc3e03280976bc35de165f8978926d0c5c25986c6ebcf60685e9c0752531ceca3e263c01a96fc4ce28e0697284a5163fc9e6773d063ab426c7b661a985d84fd183cf06d435ca152b5c353e4f54ee4f88a16e63330f9c89a011aaa907f95a470ddebc6c10ba1c6dc00fb79c88a46f9807a03e4093269e61ba2512a0fcb1e3f79f3efb599479d50e9c1c3e37c08306b8cef451e1b5f52c8326cc6c9eb222ef0f12f14f5830ee099072900075a252c268847996ccc3a9609e6f9894b2378359905dd57f6d10ba1c6dc00fb79c88a46f9807a03e4093269e61ba2512a0fcb1e3f79f3efb5930ee099072900075a252c268847996ccc3a9609e6f9894b2378359905dd57f6d037b165afca6be1b3dbaaa05be81c6fcdcbdd501d740e7550b3cbda5e3a0a6001ed6cc8e7f4a41bc6d3f9cd465eca4dd3afd8d3297046fbd39c4c1608640bd6e3b0f7fe895ce3ffa1db3081e65896806331273ad2ab3689b860f9213abc3b3024c12c150fbbee2add778d491f7e96338d2d85f03fe42db83f6cc504c60ac8302301c7d910a741b193707ff9285cf4c227300e7ef1c2fe672745417a193e3086b8ffa00dcf576c387d7461b745fa7662eb2f0bd6ded90d316daa126edff99924de42a034d6c948788c6efe3114492202a5dd5fc73dc2732d97edad6fc253a386e9acabf6b86e417399ab49c007aed6945e204a03b5d7193dd7f03fb14c19bac4a5850aa2c8faadfb31f14b9251cbf7866a630ade9cf1450f76c7e5bca5a661417d8555ce1820ae239c764594a2b0989a92f2849dbb7d8f1bb870590f580960b5f2dd73fd7f809611694dc2959b98aaf641f2df3776b9175c7987da55f26f608049583a2ffb939288067a5deb56499ecc6553ca3a10e595c16d22a5a30754caa3934a538f9f4838da2761f227c0a08d28bc196464774501a0a7c218e9679c86e4fe1c47dc432e358f6756cebe511b55975fca15c3a6a3cafead47bf562b5a41833f20f209e2774c3a4d95bfb9282c20ee409979fb189b86cdc3694b18ba4509f3a266cc68910af357b118230d0cb8bdd364425b777b526458b18829e7c2d31616fdad9b188b8c0db1062df3897d750193bc4bf00469e9d7c54dc4b2fc7a71e94723d5c62c463bc08c0a5a2d0eeb7f652dd8c37546547bf7262ee20c5440d4ed41f95ea69d7c3a1a71d252f0790013eb214622f5b1b51236bbae0e3f01be260d345325ccc00d33ebb1800273af3fdc451b31cf6b6b173abc70979b4585883e5221bd443a8e43bd8517bed8a7bb382c2da58b63ac62979d4391b6538688a0ef0591556a03f2c189b5e67389d1bf6589ca5bf432fa6a952bf8bbff8fbd05273da00689723165ac2a230aa7727f20f2ad62fc5eda71f4732f89f6a03e30bddcf9acc17c8055ac94a5813adaee69bbf06ddedb1c4a3f155f25906c960a56010701750233843094b34d596664edba5c35fb0c6b6b7a2cfa96da25ed9df4f203c5c09e05fe73d6771f5add6be0518ae5719b0c05cd1e11b0f6f670cde302dd7ee8d3e03142c87495e46cb0b76c7ad6c2d787c0103bfbed801cd21340a203944dc654f053fd895b99697ef9b0db739486ac2be1c6a999dfb0bc7855a3e1e02db55dec40f0045ddf7f880dd0fd6afc5fa552a1abcc28abbe111c766d566dde2ca666c2ed42717496604e122598a4a5f3e3fcdd9bcb1aa1188b0175e9e7afe0fccf48a08bf4fade1399afe31e486d353dc78d55cc84c9821a86a6c332889de7e0274203bf614c8193dcb82c344ef6217ea5b0ff8b8d8ef4f4777c5eb8f19cca7c5ddf2ae0400d1eee80510a9f98891264ced9c6db391a6c610f744ea7d5673749131959dec6a1d65e2ccba892e7faee56807932298985d936aa8d79e420d3da0dcf2e860f05a5b0f4ff533994666c44ec8e3e97da2386a81c72f976e0b44d278b8065e126e169605d619c80cfc87eaba3ac02c1088c894ac321d395426f251395d11e9294a53885704adb0a53c59303aeaea1c82d099d3845456f7da2296c4d3dc6e265acd31b3e680034b900127f7dc41ec2da128c4fb56068c8a0806a838e745612136772532d32a75d7ed99a752fbd5ddd317b115b1f3ae1897a6ba9d1ddfdae61d684623931c5b457accf7161566520207ab4e60b2688c1f7a5076e91820df142095e7229c203e699daae7d18e7a545d3a083c4ba8c6a056f786bb32eff7cbaf4c8ef22fd6040b812479f84222a634189bdfa6f2e49d2d637384bfef2ef303ba518a503786756adc7c95c42b22e1501bbfdb6c0a0bd0d4d3ac3e8071d32656380b43c36d26e945297c0f45f90c55a7e16352422fef3b114d01d48e8e25a780eeb80d915a5c7f7df3f22938305f5c8d308a5f891c30b5257cab26770c9d283a70c558b81b546628f27b09ad0c9d6486c6321e3bf7926fc03aac9201d3a1f3f55a3b96c162e4b3ec324aa159f1039ec48033bbcce8510a47f6e4fcaba512d1d06c41fbea09efda6f936462a0c7d89c0472bf3107b4a7c51df193960974a9b294f2a521631e366aae99477c843814dbae9443b45f0ca9d61188d4cf65dfa1e934b502497741028ede08dd0a406c0847678bfcfcf74a3f5d735f0cbbbc22ecd100be320e074935a924ecdee90f8243dff9f301425077ec193b0d7fee1b8e932a428ec0555324c3c2e6cf8bbe4abe6c9b8ba5bb4b3c1a687429908cb819daea0ed643ac13ee139a94bc25e78d4781735c85e941baab77e555ab33baf720e1a22093af27ec442442135fffa91fef843c577f6b2d97b7ee12a11b1e099e9ebc7c6b13929709d373a5a021b78d46091d67ba06f8246c1706bb37eb1fb3664c67596a32a1b049a55946bc0538849cb0b85813d892a6a094d41f6bf5d5439b11c085a7f6b03bd2d846218ce7ad1d45c00bf05ba67bd5d4c08c6202060730690b49631c733926e15945d54a63514a229d57458680bedaa2cf0410c6e969e3ffe53a17fc1902f9c0dd61fe89e95ee28a65a5415092e09b4d3a63d41945cbe121bdf20e158075fbfa88059eadc535722cc14e06fde43d8a661e89f79103facde8853dee6cea0d1f47f9724ee6fffed078eb8b53ae44a7bd9e60d384cfa78a1dd48f62f5fceb4257df0e2c029a56c5149ebf2792358123a0901f73451638ac73997e5ae79c05af9127a13e526a3c5443de244859943e6659796a6424d739cee45cea1537ee11d80819960ebd3b6a81a4c559db58bfcb65954ce3e42f4fdd1c5bc1e6702e43d2c7e8ecea453840d99f578a71f10eb6641e477ee6446f8f1648e946b1a083d3d95093879a6d83ec32eb3a3618656797db70060ecb38a550e138a9bc533e4f6bcde1edf20959c5a0f2e7118fd049251d28fd988a438f741b627d6d5e8c8571a6f1ff8191bf1344c47efa25288e99c77d993292322e8c7b0671e4b204edbafc02742978294f2e09e6f6cf3e2dd4aa9fc5d36629c73544ee3b92f80e160652c6882a22de1fa7113009e7ba646f52e2343d2cd0cebfd1ad4bd67435cf35daa59e428edda53bb95926eb1e6b971af07bb14396923ab4ea0c4223137f7161045ccd73e1d03cf3d124f9f73306366f4b9e5159be763a4fc4d609374a425a17394db32fe839ba809757486ef500d5a68189cfa74ef6f4340e8dbe57dde5449bb88a26a78fefd3de83706e91a2689aad7ddfd1d8c072796c6c41f922170e74921f684787e30f1ddbb443fc5f9671b583aa9a4257fe180c2876255ddb27e7e067837346586087a64318244d5cfa32dd0148269bae08bce7ff4b1f86e4ec2a59fdbef5f596d076bc8d8107a4e9c168208e93c6582228ac4b79c67bd4b8a84e29a80bce3e7929e60c700a7d2cdd072bd5f7cd0ecf17120782dac1079f839ae42eb9585aabab37a1e47e07dbb4cea89803be9d3a49377d1ee8ccd63f18d5cfe3269f745f4459c406209b7044d41076a05e0e9a631f9ae8d2fe0b8512a30bc67b61ad8a842d2c00077c64084d61160440a902133d6e7348f1aa4d5b69d1c2838f4fb93d37090869abce20750d7f68a9710d75a1f6e04b8246b9426a30642a437b93b8a695c4403362eaa04d4d845e02f2820e3f564352cf1384c65c2aa2033aefac3678d4afbea42bc52f5ff0470ff40337444f2e5eb0342f8bcd20b1b0ff408cb4ac9b659ababe7ccd92b9de0100000020000000aa898e48fc66661162bd9ebe3bbd873ea6affbff7c132b2c3ee510a97d741e620100000001010000002000000067d314a240b687b60ab78107d60406a147a4d428a9cc8a1fc404058fe33995c012000000030100000000000000080400000000000000000000000100000000000000003000000000000000000000000000000000000000000000000000000000000000000000005809020000000000000000000000000001000000200000005c113d6440b27bc9cf9f485ff93543016fa78f3fb00d049a47ab3a546c5e776c010000000101000000200000008962884046d1a46e8da0aea7583b41c77dab4fe394038465b7cc37b480ff777f120000000301000000000000000804000000000000000400000020000000dbd2ded1aa7d2c849b368a592e3419ddd588e72151c13e9b525cc40fea7e780a20000000f438a2ca5ff27ac96b5f8b63b94e8b69bc59a9148597576e38ab2f67e1af4d5720000000957b88b12730e646e0f33d3618b77dfa579e8231e3c59c7104be7165611c8027200000009496ca4decc5cd986a77d9e48189993485b4a58ee92174ad41537efe7be2acd800000000010101000000000000000000000001000000001fc83151da0ddcf404369cbf0932134ff90246d690bd2c2af5a7671a69a44e7b"
}

================
File: packages/hd/src/HDWallet.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { HDKey } from '@scure/bip32';

type ValueOf<T> = T[keyof T];

export const Roles = {
  NightExternal: 0,
  NightInternal: 1,
  Dust: 2,
  Zswap: 3,
  Metadata: 4,
} as const;

export type Role = ValueOf<typeof Roles>;

type DerivationResult = { readonly type: 'keyDerived'; readonly key: Uint8Array } | { readonly type: 'keyOutOfBounds' };
type CompositeDerivationResult<T extends readonly Role[]> =
  | { readonly type: 'keysDerived'; readonly keys: Record<T[number], Uint8Array> }
  | { readonly type: 'keyOutOfBounds'; readonly roles: readonly Role[] };
type HDWalletResult =
  | { readonly type: 'seedOk'; readonly hdWallet: HDWallet }
  | { readonly type: 'seedError'; readonly error: unknown };

const PURPOSE = 44;
const COIN_TYPE = 2400;

const CompositeDerivationResult = {
  fromResults: <T extends readonly Role[]>(
    results: { role: T[number]; result: DerivationResult }[],
  ): CompositeDerivationResult<T> => {
    const { succeededKeys, failedRoles } = results.reduce(
      (acc, result) => {
        if (result.result.type === 'keyDerived') {
          acc.succeededKeys[result.role] = result.result.key!;
        } else {
          acc.failedRoles.push(result.role);
        }
        return acc;
      },
      { succeededKeys: {} as Record<T[number], Uint8Array>, failedRoles: [] as Role[] },
    );

    if (failedRoles.length > 0) {
      return { type: 'keyOutOfBounds', roles: failedRoles };
    } else {
      return { type: 'keysDerived', keys: succeededKeys };
    }
  },
};

export class HDWallet {
  private readonly rootKey: HDKey;

  private constructor(key: HDKey) {
    this.rootKey = key;
  }

  static fromSeed(seed: Uint8Array): HDWalletResult {
    try {
      const rootKey = HDKey.fromMasterSeed(seed);
      return { type: 'seedOk', hdWallet: new HDWallet(rootKey) };
    } catch (e: unknown) {
      return { type: 'seedError', error: e };
    }
  }

  // Begin by selecting an account.
  public selectAccount(account: number): AccountKey {
    return new AccountKey(this.rootKey, account);
  }

  /**
   * Once all keys are derived - clear internals from private data, so that they do not reside in memory longer than needed.
   */
  public clear(): void {
    this.rootKey.wipePrivateData();
  }
}

export class AccountKey {
  private readonly rootKey: HDKey;
  private readonly account: number;

  constructor(rootKey: HDKey, account: number) {
    this.account = account;
    this.rootKey = rootKey;
  }

  // After account, select a role.
  public selectRole(role: Role): RoleKey {
    return new RoleKey(this.rootKey, this.account, role);
  }

  public selectRoles<T extends readonly Role[]>(roles: T): CompositeRoleKey<T> {
    return new CompositeRoleKey<T>(this.rootKey, this.account, roles);
  }
}

export class RoleKey {
  private readonly rootKey: HDKey;
  private readonly account: number;
  private readonly role: Role;

  constructor(rootKey: HDKey, account: number, role: Role) {
    this.role = role;
    this.account = account;
    this.rootKey = rootKey;
  }

  // Finally, derive the key at the given index.
  public deriveKeyAt(index: number): DerivationResult {
    const path = `m/${PURPOSE}'/${COIN_TYPE}'/${this.account}'/${this.role}/${index}`;
    const derivedKey = this.rootKey.derive(path);
    return derivedKey.privateKey ? { type: 'keyDerived', key: derivedKey.privateKey } : { type: 'keyOutOfBounds' };
  }
}

export class CompositeRoleKey<T extends readonly Role[]> {
  private readonly rootKey: HDKey;
  private readonly account: number;
  private readonly roles: T;

  constructor(rootKey: HDKey, account: number, roles: T) {
    this.roles = roles;
    this.rootKey = rootKey;
    this.account = account;
  }

  public deriveKeysAt(index: number): CompositeDerivationResult<T> {
    const results = this.roles.map((role) => ({
      role,
      result: new RoleKey(this.rootKey, this.account, role).deriveKeyAt(index),
    }));

    return CompositeDerivationResult.fromResults<T>(results);
  }
}

================
File: packages/hd/src/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * from './HDWallet.js';
export * from './MnemonicUtils.js';

================
File: packages/hd/src/MnemonicUtils.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as bip39 from '@scure/bip39';
import { wordlist as english } from '@scure/bip39/wordlists/english';

export const mnemonicToWords: (mnemonic: string) => string[] = (mnemonic: string) => mnemonic.split(' ');

/** A wrapper around the bip39 package function, with default strength applied to produce 24 words */
export const generateMnemonicWords: (strength?: number) => string[] = (strength = 256) =>
  mnemonicToWords(bip39.generateMnemonic(english, strength));

export const joinMnemonicWords: (mnenomic: string[]) => string = (mnenomic: string[]) => mnenomic.join(' ');

export const generateRandomSeed = (strength = 256): Uint8Array => {
  return crypto.getRandomValues(new Uint8Array(Math.ceil(strength / 8)));
};

/** A wrapper around the bip39 package function */
export const validateMnemonic = (mnemonic: string): boolean => bip39.validateMnemonic(mnemonic, english);

================
File: packages/hd/test/tests.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { hdkey } from '@ethereumjs/wallet';
import { HDKey } from '@scure/bip32';
import * as bip39 from '@scure/bip39';
import { wordlist as english } from '@scure/bip39/wordlists/english';
import * as fc from 'fast-check';
import { describe, expect, it } from 'vitest';
import {
  generateMnemonicWords,
  generateRandomSeed,
  HDWallet,
  joinMnemonicWords,
  Roles,
  validateMnemonic,
} from '../src/index.js';

const MASTER_KEY_MIN_LENGTH = 16;
const MASTER_KEY_MAX_LENGTH = 64;

describe('HD Wallet', () => {
  function derive3rdPartyPrivateKey(seed: Uint8Array, account: number, role: number, index: number) {
    const thirdPartyWallet = hdkey.EthereumHDKey.fromMasterSeed(seed);
    const derivedKey = thirdPartyWallet.derivePath(`m/44'/2400'/${account}'/${role}/${index}`);
    return derivedKey.getWallet().getPrivateKey();
  }

  const validMnemonicLength = [16, 20, 24, 28, 32];
  const arbStrength = fc.constantFrom(...validMnemonicLength);

  it('Derivation from valid seed should be consistent', () => {
    const seedArb = fc.uint8Array({
      minLength: MASTER_KEY_MIN_LENGTH,
      maxLength: MASTER_KEY_MAX_LENGTH,
      size: 'max',
    });

    // account and index can be between 0 to 2^31
    const accountArb = fc.nat(2147483647);
    const indexArb = fc.nat(2147483647);

    const roleArb = fc.constantFrom(...Object.values(Roles));

    fc.assert(
      fc.property(seedArb, accountArb, indexArb, roleArb, (seed, account, index, role) => {
        const hdWalletResult = HDWallet.fromSeed(seed);
        if (hdWalletResult.type == 'seedError') {
          throw Error('Wrong seed!');
        }

        const derivationResult = hdWalletResult.hdWallet.selectAccount(account).selectRole(role).deriveKeyAt(index);

        if (derivationResult.type == 'keyOutOfBounds') {
          expect(() => derive3rdPartyPrivateKey(seed, account, role, index)).toThrow();
        } else {
          // Checks our implementation vs. @ethereumjs/wallet library.
          const thridPartyPK = derive3rdPartyPrivateKey(seed, account, role, index);
          const derivedOur = Buffer.from(derivationResult.key).toString('hex');
          const expectedOther = Buffer.from(thridPartyPK).toString('hex');

          expect(derivedOur).toEqual(expectedOther);
        }
      }),
    );
  });

  it('Invalid seed length should fail < 16', () => {
    const seedArb = fc.uint8Array({ maxLength: MASTER_KEY_MIN_LENGTH - 1, size: 'max' });
    fc.assert(
      fc.property(seedArb, (seed) => {
        expect(() => hdkey.EthereumHDKey.fromMasterSeed(seed)).toThrow();
        expect(() => HDKey.fromMasterSeed(seed)).toThrow();
      }),
    );
  });

  it('Invalid seed length should fail > 64', () => {
    const seedArb = fc.uint8Array({
      minLength: MASTER_KEY_MAX_LENGTH + 1,
      maxLength: 128,
      size: 'max',
    });
    fc.assert(
      fc.property(seedArb, (seed) => {
        expect(() => hdkey.EthereumHDKey.fromMasterSeed(seed)).toThrow();
        expect(() => HDKey.fromMasterSeed(seed)).toThrow();
      }),
    );
  });

  it('Generated mnemonic should always be valid', () => {
    fc.assert(
      fc.property(arbStrength, (strength) => {
        const mnemonic = generateMnemonicWords(strength * 8);
        expect(validateMnemonic(joinMnemonicWords(mnemonic))).toBeTruthy();
      }),
    );
  });

  it('Roundtrip from seed to mnemonic and back should give the same seed', () => {
    fc.assert(
      fc.property(arbStrength, (strength) => {
        const initialSeed = generateRandomSeed(strength * 8);
        const mnemonic = bip39.entropyToMnemonic(initialSeed, english);
        const regeneratedSeed = Buffer.from(bip39.mnemonicToEntropy(mnemonic, english).slice(0, 32)).toString('hex');

        expect(bip39.validateMnemonic(mnemonic, english)).toBeTruthy();
        expect(Buffer.from(initialSeed).toString('hex')).toEqual(regeneratedSeed);
      }),
    );
  });
});

================
File: packages/hd/.npmignore
================
*.ts.map

================
File: packages/hd/.prettierignore
================
dist/
coverage/
reports/

================
File: packages/hd/eslint.config.mjs
================
import { packageConfig } from '../../eslint.config.mjs';

export default packageConfig();

================
File: packages/hd/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "rootDir": "./src",
    "outDir": "./dist",
    "lib": ["ESNext", "dom"]
  },
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/test/**/*.ts", "src/**/*.test.ts"]
}

================
File: packages/hd/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [{ "path": "./tsconfig.build.json" }, { "path": "./tsconfig.test.json" }]
}

================
File: packages/hd/tsconfig.publish.json
================
{
  "extends": "./tsconfig.build.json",
  "compilerOptions": {
    "sourceMap": false,
    "declarationMap": false
  }
}

================
File: packages/hd/tsconfig.test.json
================
{
  "extends": "./tsconfig.json",
  "include": ["src/**/test/**/*.ts", "test/**/*.ts", "src/**/*.ts"]
}

================
File: packages/hd/vitest.config.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/// <reference types="vitest" />
/// <reference types="vitest/globals" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage',
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }],
    ],
  },
});

================
File: packages/indexer-client/src/effect/test/httpQueryClient.spied.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect } from 'effect';
import { describe, expect, it, vi } from 'vitest';
import * as QueryClient from '../QueryClient.js';

vi.mock('graphql-http', () => ({
  createClient: vi.fn(),
}));

describe('HttpQueryClient', () => {
  describe('layer', () => {
    it('disposes of underlying scoped client', async () => {
      const graphqlHTTP = await import('graphql-http');
      const SpiedHttpQueryClient = await import('../HttpQueryClient.js');

      const dispose = vi.fn();
      const spiedCreateClient = vi
        .spyOn(graphqlHTTP, 'createClient')
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-explicit-any
        .mockImplementationOnce(() => ({ dispose }) as any);

      await Effect.gen(function* () {
        const client = yield* QueryClient.QueryClient;

        expect(client).toBeDefined();
      }).pipe(
        Effect.provide(SpiedHttpQueryClient.layer({ url: 'http://localhost.com' })),
        Effect.scoped,
        Effect.runPromise,
      );

      expect(spiedCreateClient).toHaveBeenCalled();
      expect(dispose).toHaveBeenCalled();
    });
  });
});

================
File: packages/indexer-client/src/effect/test/httpQueryClient.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect } from 'effect';
import { describe, it } from 'vitest';
import * as QueryClient from '../QueryClient.js';
import * as HttpQueryClient from '../HttpQueryClient.js';

describe('HttpQueryClient', () => {
  describe('layer', () => {
    // Ensures that we cannot construct a layer for HttpQueryClient when we use common incorrect URI schemes.
    it.each(['ftp:', 'mailto:', 'ws:', 'wss:', 'file:'])(
      'should fail when constructed with %s as the URI scheme',
      async (scheme) => {
        await Effect.gen(function* () {
          // We should never be able to resolve a QueryClient since the configuration used to create the
          // associated HttpQueryClient layer is invalid with the protocol schemes being used.
          return yield* QueryClient.QueryClient;
        }).pipe(
          Effect.flatMap((_) => Effect.fail('Unexpectedly resolved a QueryClient')),
          Effect.provide(HttpQueryClient.layer({ url: `${scheme}//localhost.com` })),
          // Ensure the reported invalid protocol scheme is the one used.
          Effect.catchTag('InvalidProtocolSchemeError', (err) =>
            err.invalidScheme !== scheme
              ? Effect.fail(`Expected '${scheme}' but received '${err.invalidScheme}'`)
              : Effect.succeed(void 0),
          ),
          Effect.scoped,
          Effect.runPromise,
        );
      },
    );
  });
});

================
File: packages/indexer-client/src/effect/test/wsSubscriptionClient.spied.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect } from 'effect';
import { describe, expect, it, vi } from 'vitest';
import * as SubscriptionClient from '../SubscriptionClient.js';

vi.mock('graphql-ws', () => ({
  createClient: vi.fn(),
}));

describe('WsSubscriptionClient', () => {
  describe('layer', () => {
    it('disposes of underlying scoped client', async () => {
      const graphqlWS = await import('graphql-ws');
      const SpiedWsSubscriptionClient = await import('../WsSubscriptionClient.js');

      const dispose = vi.fn();
      const spiedCreateClient = vi
        .spyOn(graphqlWS, 'createClient')
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-explicit-any
        .mockImplementationOnce(() => ({ dispose }) as any);

      await Effect.gen(function* () {
        const client = yield* SubscriptionClient.SubscriptionClient;

        expect(client).toBeDefined();
      }).pipe(
        Effect.provide(SpiedWsSubscriptionClient.layer({ url: 'ws://localhost.com' })),
        Effect.scoped,
        Effect.runPromise,
      );

      expect(spiedCreateClient).toHaveBeenCalled();
      expect(dispose).toHaveBeenCalled();
    });
  });
});

================
File: packages/indexer-client/src/effect/test/wsSubscriptionClient.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect } from 'effect';
import { describe, it } from 'vitest';
import * as SubscriptionClient from '../SubscriptionClient.js';
import * as WsSubscriptionClient from '../WsSubscriptionClient.js';

describe('WsSubscriptionClient', () => {
  describe('layer', () => {
    // Ensures that we cannot construct a layer for WsSubscriptionClient when we use common incorrect URI schemes.
    it.each(['ftp:', 'mailto:', 'http:', 'https:', 'file:'])(
      'should fail when constructed with %s as the URI scheme',
      async (scheme) => {
        await Effect.gen(function* () {
          // We should never be able to resolve a SubscriptionClient since the configuration used to create the
          // associated WsSubscriptionClient layer is invalid with the protocol schemes being used.
          return yield* SubscriptionClient.SubscriptionClient;
        }).pipe(
          Effect.flatMap((_) => Effect.fail('Unexpectedly resolved a SubscriptionClient')),
          Effect.provide(WsSubscriptionClient.layer({ url: `${scheme}//localhost.com` })),
          // Ensure the reported invalid protocol scheme is the one used.
          Effect.catchTag('InvalidProtocolSchemeError', (err) =>
            err.invalidScheme !== scheme
              ? Effect.fail(`Expected '${scheme}' but received '${err.invalidScheme}'`)
              : Effect.succeed(void 0),
          ),
          Effect.scoped,
          Effect.runPromise,
        );
      },
    );
  });
});

================
File: packages/indexer-client/src/effect/ConnectionHelper.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as Either from 'effect/Either';
import { URLError, FailedToDeriveWebSocketUrlError } from '@midnight-ntwrk/wallet-sdk-utilities/networking';

export const deriveWebSocketUrl = (url: URL | string): Either.Either<string, URLError> => {
  const httpUrl = typeof url === 'string' ? new URL(url) : url;
  try {
    const wsUrl = new URL(httpUrl);

    // Convert protocol
    wsUrl.protocol = httpUrl.protocol === 'https:' ? 'wss:' : 'ws:';

    // Ensure pathname ends with '/ws'
    if (!wsUrl.pathname.endsWith('/')) {
      wsUrl.pathname += '/';
    }
    wsUrl.pathname += 'ws';

    return Either.right(wsUrl.toString());
  } catch (err) {
    const error = err instanceof Error ? err : new Error(String(err));
    return Either.left(
      new FailedToDeriveWebSocketUrlError({
        message: `Failed to derive WebSocket URL from ${httpUrl.toString()}`,
        cause: error,
      }),
    );
  }
};

export const createWebSocketUrl = (httpUrl: URL | string, wsUrl?: string): Either.Either<string, URLError> => {
  if (wsUrl) {
    return Either.right(wsUrl);
  }

  return deriveWebSocketUrl(httpUrl);
};

================
File: packages/indexer-client/src/effect/HttpQueryClient.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Context, Layer, Scope } from 'effect';
import { print, ExecutionResult } from 'graphql';
import { createClient, Client, type RequestParams, NetworkError } from 'graphql-http';
import { QueryClient } from './QueryClient.js';
import type { Query } from './Query.js';
import {
  InvalidProtocolSchemeError,
  ClientError,
  ServerError,
  HttpURL,
} from '@midnight-ntwrk/wallet-sdk-utilities/networking';

export const layer: (
  config: QueryClient.ServerConfig,
) => Layer.Layer<QueryClient, InvalidProtocolSchemeError, Scope.Scope> = (config) =>
  Layer.effect(
    QueryClient,
    HttpURL.make(config.url).pipe(
      Effect.flatMap((url) =>
        Effect.acquireRelease(
          Effect.sync(() =>
            createClient({
              url: url.toString(),
              shouldRetry: (error, retries) => {
                const statusCode = error.response?.status ?? 500;
                return Promise.resolve(retries < 3 && statusCode >= 502 && statusCode <= 504);
              },
            }),
          ),
          (client) => Effect.sync(() => client.dispose()),
        ),
      ),
      Effect.map((client) => new HttpQueryClientImpl(client)),
    ),
  );

class HttpQueryClientImpl implements Context.Tag.Service<QueryClient> {
  constructor(client: Client) {
    this.client = client;
  }

  protected readonly client: Client;

  query<R, V, T extends Query.Document<R, V> = Query.Document<R, V>>(
    document: T,
    variables: V,
  ): Effect.Effect<Query.Result<T>, ClientError | ServerError> {
    return Effect.async((resume) => {
      let result: ExecutionResult<Query.Result<T>, unknown>;

      const dispose = this.client.subscribe<Query.Result<T>>(
        { query: print(document), variables: variables as RequestParams['variables'] },
        {
          next: (data) => (result = data),
          error: (error: NetworkError) => {
            const statusCode = error.response?.status ?? 500;
            const message = error.response?.statusText ?? 'An unknown error occurred';

            resume(
              Effect.fail(
                statusCode >= 400 && statusCode < 500
                  ? new ClientError({ message, cause: error })
                  : new ServerError({ message }),
              ),
            );
          },
          complete: () =>
            resume(
              result.errors
                ? Effect.fail(new ClientError({ message: result.errors[0].message, cause: result.errors }))
                : Effect.succeed(result.data!),
            ),
        },
      );

      // Ensure we dispose of the query if the running Fiber is terminated.
      return Effect.sync(dispose);
    });
  }
}

================
File: packages/indexer-client/src/effect/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * as Query from './Query.js';
export * as Subscription from './Subscription.js';
export * from './QueryClient.js';
export * as HttpQueryClient from './HttpQueryClient.js';
export * from './SubscriptionClient.js';
export * as WsSubscriptionClient from './WsSubscriptionClient.js';
export * as ConnectionHelper from './ConnectionHelper.js';

================
File: packages/indexer-client/src/effect/QueryClient.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Context } from 'effect';
import { ClientError, ServerError } from '@midnight-ntwrk/wallet-sdk-utilities/networking';
import type { Query } from './Query.js';

export class QueryClient extends Context.Tag('@midnight-ntwrk/indexer-client#QueryClient')<
  QueryClient,
  QueryClient.Service
>() {}

export declare namespace QueryClient {
  interface ServerConfig {
    readonly url: URL | string;
  }

  interface Service {
    query<R, V, T extends Query.Document<R, V> = Query.Document<R, V>>(
      document: T,
      variables: V,
    ): Effect.Effect<Query.Result<T>, ClientError | ServerError>;
  }
}

================
File: packages/indexer-client/src/effect/SubscriptionClient.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Stream, Context } from 'effect';
import type { Query } from './Query.js';
import { ClientError, ServerError } from '@midnight-ntwrk/wallet-sdk-utilities/networking';

export class SubscriptionClient extends Context.Tag('@midnight-ntwrk/indexer-client#SubscriptionClient')<
  SubscriptionClient,
  SubscriptionClient.Service
>() {}

export declare namespace SubscriptionClient {
  interface ServerConfig {
    readonly url: URL | string;
  }

  interface Service {
    subscribe<R, V, T extends Query.Document<R, V> = Query.Document<R, V>>(
      document: T,
      variables: V,
    ): Stream.Stream<Query.Result<T>, ClientError | ServerError>;
  }
}

================
File: packages/indexer-client/src/effect/WsSubscriptionClient.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Stream, Context, Layer, Scope } from 'effect';
import { createClient, type Client, type SubscribePayload } from 'graphql-ws';
import { type GraphQLError, print } from 'graphql';
import { SubscriptionClient } from './SubscriptionClient.js';
import { Query } from './Query.js';
import {
  InvalidProtocolSchemeError,
  WsURL,
  ClientError,
  ServerError,
} from '@midnight-ntwrk/wallet-sdk-utilities/networking';

export const layer: (
  config: SubscriptionClient.ServerConfig,
) => Layer.Layer<SubscriptionClient, InvalidProtocolSchemeError, Scope.Scope> = (config) =>
  Layer.effect(
    SubscriptionClient,
    WsURL.make(config.url).pipe(
      Effect.flatMap((url) =>
        Effect.acquireRelease(
          Effect.sync(() => createClient({ url: url.toString(), shouldRetry: () => true, retryAttempts: 100 })),
          (client) => Effect.sync(() => client.dispose()),
        ),
      ),
      Effect.map((client) => new WebSocketSubscriptionClientImpl(client)),
    ),
  );

class WebSocketSubscriptionClientImpl implements Context.Tag.Service<SubscriptionClient> {
  constructor(client: Client) {
    this.client = client;
  }

  protected readonly client: Client;

  subscribe<R, V, T extends Query.Document<R, V> = Query.Document<R, V>>(
    document: T,
    variables: V,
  ): Stream.Stream<Query.Result<T>, ClientError | ServerError> {
    return Stream.async((emit) => {
      const dispose = this.client.subscribe<Query.Result<T>>(
        { query: print(document), variables: variables as SubscribePayload['variables'] },
        {
          next: (data) => {
            if (data.errors) {
              return void emit.fail(new ClientError({ message: data.errors[0].message, cause: data.errors }));
            }

            void emit.single(data.data!);
          },
          error: (err: unknown) => {
            void emit.fail(
              Array.isArray(err)
                ? new ClientError({ message: (err as readonly GraphQLError[])[0].message })
                : new ServerError({ message: String(err) }),
            );
          },
          complete: () => void emit.end(),
        },
      );

      // Ensure we dispose of the query if the running Fiber is terminated.
      return Effect.sync(dispose);
    });
  }
}

================
File: packages/indexer-client/src/graphql/queries/Connect.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Query } from '../../effect/index.js';
import { gql } from '../generated/index.js';

export const Connect = Query.make(
  'Connect',
  gql(`
    mutation Connect($viewingKey: ViewingKey!) {
      connect(viewingKey: $viewingKey)
    }
  `),
);

================
File: packages/indexer-client/src/graphql/queries/Disconnect.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Query } from '../../effect/index.js';
import { gql } from '../generated/index.js';

export const Disconnect = Query.make(
  'Disconnect',
  gql(`
    mutation Disconnect($sessionId: HexEncoded!) {
      disconnect(sessionId: $sessionId)
    }
  `),
);

================
File: packages/indexer-client/src/graphql/queries/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * from './Connect.js';
export * from './Disconnect.js';
export * from './BlockHash.js';

================
File: packages/indexer-client/src/graphql/subscriptions/test/ShieldedTransactions.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Stream } from 'effect';
import { randomUUID } from 'node:crypto';
import { buildTestEnvironmentVariables, getComposeDirectory } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import { DockerComposeEnvironment, Wait, type StartedDockerComposeEnvironment } from 'testcontainers';
import { afterAll, beforeAll, describe, expect, it } from 'vitest';
import { HttpQueryClient, WsSubscriptionClient } from '../../../effect/index.js';
import { Connect, Disconnect } from '../../queries/index.js';
import { ShieldedTransactions } from '../ShieldedTransactions.js';

const KNOWN_VIEWING_KEY =
  'mn_shield-esk_undeployed1d45kgmnfva58gwn9de3hy7tsw35k7m3dwdjkxun9wskkketetdmrzhf6dlyj7u8juj68fd4psnkqhjxh32sec0q480vzswg8kd485e2kljcsmxqc0u';

const timeout_minutes = (mins: number) => 1_000 * 60 * mins;

const environmentId = randomUUID();

const environmentVars = buildTestEnvironmentVariables(['APP_INFRA_SECRET'], {
  additionalVars: {
    TESTCONTAINERS_UID: environmentId,
  },
});

const environment = new DockerComposeEnvironment(getComposeDirectory(), 'docker-compose.yml')
  .withWaitStrategy(`node_${environmentId}`, Wait.forListeningPorts())
  .withWaitStrategy(`indexer_${environmentId}`, Wait.forListeningPorts())
  .withEnvironment(environmentVars);

describe('Wallet subscription', () => {
  describe('with available Indexer Server', () => {
    let startedEnvironment: StartedDockerComposeEnvironment | undefined = undefined;
    const getIndexerPort = () =>
      startedEnvironment?.getContainer(`indexer_${environmentId}`).getMappedPort(8088) ?? 8088;

    beforeAll(async () => {
      startedEnvironment = await environment.up();
    }, timeout_minutes(3));

    afterAll(async () => {
      await startedEnvironment?.down();
    }, timeout_minutes(1));

    it(
      'should stream GraphQL subscription',
      async () => {
        const makeScopedSession = Effect.acquireRelease(Connect.run({ viewingKey: KNOWN_VIEWING_KEY }), (session) =>
          Disconnect.run({ sessionId: session.connect }).pipe(Effect.catchAll((_) => Effect.void)),
        );

        await Effect.gen(function* () {
          const session = yield* makeScopedSession;
          const events = yield* ShieldedTransactions.run({
            sessionId: session.connect,
            index: null,
          }).pipe(
            Stream.take(2),
            Stream.tap((data) => Effect.log(data.shieldedTransactions.__typename)),
            Stream.runCollect,
          );

          expect(events).toHaveLength(2);
        }).pipe(
          Effect.provide(HttpQueryClient.layer({ url: `http://127.0.0.1:${getIndexerPort()}/api/v3/graphql` })),
          Effect.provide(WsSubscriptionClient.layer({ url: `ws://127.0.0.1:${getIndexerPort()}/api/v3/graphql/ws` })),
          Effect.scoped,
          Effect.runPromise,
        );
      },
      timeout_minutes(1),
    );
  });
});

================
File: packages/indexer-client/src/graphql/subscriptions/test/UnshieldedTransactions.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Stream } from 'effect';
import { randomUUID } from 'node:crypto';
import { buildTestEnvironmentVariables, getComposeDirectory } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import { DockerComposeEnvironment, Wait, type StartedDockerComposeEnvironment } from 'testcontainers';
import { afterAll, beforeAll, describe, expect, it } from 'vitest';
import { WsSubscriptionClient } from '../../../effect/index.js';
import { UnshieldedTransactions } from '../UnshieldedTransactions.js';

const timeout_minutes = (mins: number) => 1_000 * 60 * mins;

const ADDRESS = 'mn_addr_undeployed1rhqz8aq6t74ym2uq5gh53t9x02gducxnamtdvnjxfhelxwaf8ztqpmrwwj';

const environmentId = randomUUID();

const environmentVars = buildTestEnvironmentVariables(['APP_INFRA_SECRET'], {
  additionalVars: {
    TESTCONTAINERS_UID: environmentId,
  },
});

const environment = new DockerComposeEnvironment(getComposeDirectory(), 'docker-compose.yml')
  .withWaitStrategy(`node_${environmentId}`, Wait.forListeningPorts())
  .withWaitStrategy(`indexer_${environmentId}`, Wait.forLogMessage(/block indexed/))
  .withEnvironment(environmentVars);

describe('Wallet subscription', () => {
  describe('with available Indexer Server', () => {
    let startedEnvironment: StartedDockerComposeEnvironment | undefined = undefined;
    const getIndexerPort = () =>
      startedEnvironment?.getContainer(`indexer_${environmentId}`).getMappedPort(8088) ?? 8088;

    beforeAll(async () => {
      startedEnvironment = await environment.up();
    }, timeout_minutes(3));

    afterAll(async () => {
      await startedEnvironment?.down();
    }, timeout_minutes(1));

    it(
      'should stream GraphQL subscription',
      async () => {
        await Effect.gen(function* () {
          const events = yield* UnshieldedTransactions.run({
            address: ADDRESS,
            transactionId: 0,
          }).pipe(
            Stream.take(2),
            Stream.tap((data) => Effect.log(data.unshieldedTransactions.type)),
            Stream.runCollect,
          );

          expect(events).toHaveLength(2);
        }).pipe(
          Effect.provide(WsSubscriptionClient.layer({ url: `ws://127.0.0.1:${getIndexerPort()}/api/v3/graphql/ws` })),
          Effect.scoped,
          Effect.runPromise,
        );
      },
      timeout_minutes(1),
    );
  });
});

================
File: packages/indexer-client/src/graphql/subscriptions/test/ZswapEvents.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Stream } from 'effect';
import { randomUUID } from 'node:crypto';
import { buildTestEnvironmentVariables, getComposeDirectory } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import { DockerComposeEnvironment, Wait, type StartedDockerComposeEnvironment } from 'testcontainers';
import { afterAll, beforeAll, describe, expect, it } from 'vitest';
import { WsSubscriptionClient } from '../../../effect/index.js';
import { ZswapEvents } from '../ZswapEvents.js';

const timeout_minutes = (mins: number) => 1_000 * 60 * mins;

const environmentId = randomUUID();

const environmentVars = buildTestEnvironmentVariables(['APP_INFRA_SECRET'], {
  additionalVars: {
    TESTCONTAINERS_UID: environmentId,
  },
});

const environment = new DockerComposeEnvironment(getComposeDirectory(), 'docker-compose.yml')
  .withWaitStrategy(`node_${environmentId}`, Wait.forListeningPorts())
  .withWaitStrategy(`indexer_${environmentId}`, Wait.forLogMessage(/block indexed/))
  .withEnvironment(environmentVars);

describe('ZSwap events subscription', () => {
  describe('with available Indexer Server', () => {
    let startedEnvironment: StartedDockerComposeEnvironment | undefined = undefined;
    const getIndexerPort = () =>
      startedEnvironment?.getContainer(`indexer_${environmentId}`).getMappedPort(8088) ?? 8088;

    beforeAll(async () => {
      startedEnvironment = await environment.up();
    }, timeout_minutes(3));

    afterAll(async () => {
      await startedEnvironment?.down();
    }, timeout_minutes(1));

    it(
      'should stream GraphQL subscription',
      async () => {
        await Effect.gen(function* () {
          const events = yield* ZswapEvents.run({
            id: 0,
          }).pipe(
            Stream.take(2),
            Stream.tap((data) => Effect.log(`ID=${data.zswapLedgerEvents.id}, MAX_ID=${data.zswapLedgerEvents.maxId}`)),
            Stream.runCollect,
          );

          expect(events).toHaveLength(2);
        }).pipe(
          Effect.provide(WsSubscriptionClient.layer({ url: `ws://127.0.0.1:${getIndexerPort()}/api/v3/graphql/ws` })),
          Effect.scoped,
          Effect.runPromise,
        );
      },
      timeout_minutes(1),
    );
  });
});

================
File: packages/indexer-client/src/graphql/subscriptions/DustLedgerEvents.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Subscription } from '../../effect/index.js';
import { gql } from '../generated/index.js';

export const DustLedgerEvents = Subscription.make(
  'DustLedgerEvents',
  gql(`
    subscription DustLedgerEvents($id: Int) {
      dustLedgerEvents(id: $id) {
        type: __typename
        id
        raw
        maxId
      }
    }
  `),
);

================
File: packages/indexer-client/src/graphql/subscriptions/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * from './DustLedgerEvents.js';
export * from './ShieldedTransactions.js';
export * from './UnshieldedTransactions.js';
export * from './ZswapEvents.js';

================
File: packages/indexer-client/src/graphql/subscriptions/ShieldedTransactions.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Subscription } from '../../effect/index.js';
import { gql } from '../generated/index.js';

export const ShieldedTransactions = Subscription.make(
  'ShieldedTransactions',
  gql(`
    subscription ShieldedTransactions($sessionId: HexEncoded!, $index: Int) {
      shieldedTransactions(sessionId: $sessionId, index: $index) {
        __typename
        ... on ShieldedTransactionsProgress {
          highestEndIndex
          highestCheckedEndIndex
          highestRelevantEndIndex
        }
        ... on RelevantTransaction {
          transaction {
            id
            raw
            hash
            protocolVersion
            identifiers
            startIndex
            endIndex
            fees {
              paidFees
              estimatedFees
            }
            transactionResult {
              status
              segments {
                id
                success
              }
            }
          }
          collapsedMerkleTree {
            startIndex
            endIndex
            update
            protocolVersion
          }
        }
      }
    }
  `),
);

================
File: packages/indexer-client/src/graphql/subscriptions/ZswapEvents.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Subscription } from '../../effect/index.js';
import { gql } from '../generated/index.js';

export const ZswapEvents = Subscription.make(
  'ZswapEvents',
  gql(`
    subscription ZswapEvents($id: Int) {
      zswapLedgerEvents(id: $id) {
        id
        raw
        maxId
      }
    }
  `),
);

================
File: packages/indexer-client/src/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * from './graphql/queries/index.js';
export * from './graphql/subscriptions/index.js';
export * from './graphql/generated/graphql.js';

================
File: packages/indexer-client/.prettierignore
================
dist/
coverage/
reports/
src/graphql/generated/

================
File: packages/indexer-client/codegen.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import type { CodegenConfig } from '@graphql-codegen/cli';

//
// This file provides configuration for the GraphQL code generator. It combines:
// - The Indexer GraphQL (`indexer.gql`),
// - Queries from `graphql/queries`
// - Subscriptions from `graphql/subscriptions`
//
// Generated types are then written to `graphql/generated`.
//

export default {
  generates: {
    './src/graphql/generated/': {
      documents: ['./src/graphql/queries/*.ts', './src/graphql/subscriptions/*.ts'],
      schema: './indexer.gql',
      preset: 'client',
      config: {
        avoidOptionals: true,
        skipTypename: true,
        skipTypeNameForRoot: true,
        enumsAsTypes: true,
        futureProofEnums: true,
        immutableTypes: true,
        useTypeImports: true,
        strictScalars: true,
        scalars: {
          BigInt: 'number',
          SessionId: 'string',
          WalletLocalState: 'string',
          Unit: 'null',
          Instant: 'number',
          ApplyStage: 'string',
          HexEncoded: 'string',
          ViewingKey: 'string',
          UnshieldedAddress: 'string',
        },
        namingConvention: {
          transformUnderscore: true,
        },
      },
      presetConfig: {
        gqlTagName: 'gql',
      },
      hooks: { afterAllFileWrite: ['prettier --write'] },
    },
  },
} as CodegenConfig;

================
File: packages/indexer-client/eslint.config.mjs
================
import { packageConfig } from '../../eslint.config.mjs';

export default packageConfig({ ignores: ['src/graphql/generated/'] });

================
File: packages/indexer-client/indexer.gql
================
"""
A block with its relevant data.
"""
type Block {
	"""
	The block hash.
	"""
	hash: HexEncoded!
	"""
	The block height.
	"""
	height: Int!
	"""
	The protocol version.
	"""
	protocolVersion: Int!
	"""
	The UNIX timestamp.
	"""
	timestamp: Int!
	"""
	The hex-encoded block author.
	"""
	author: HexEncoded
	"""
	The parent of this block.
	"""
	parent: Block
	"""
	The transactions within this block.
	"""
	transactions: [Transaction!]!
	"""
	The hex-encoded ledger parameters for this block.
	"""
	ledgerParameters: HexEncoded!
}

"""
Either a block hash or a block height.
"""
input BlockOffset @oneOf {
	"""
	A hex-encoded block hash.
	"""
	hash: HexEncoded
	"""
	A block height.
	"""
	height: Int
}

type CollapsedMerkleTree {
	"""
	The zswap state start index.
	"""
	startIndex: Int!
	"""
	The zswap state end index.
	"""
	endIndex: Int!
	"""
	The hex-encoded value.
	"""
	update: HexEncoded!
	"""
	The protocol version.
	"""
	protocolVersion: Int!
}

"""
A contract action.
"""
interface ContractAction {
	address: HexEncoded!
	state: HexEncoded!
	chainState: HexEncoded!
	transaction: Transaction!
	unshieldedBalances: [ContractBalance!]!
}

"""
Either a block offset or a transaction offset.
"""
input ContractActionOffset @oneOf {
	"""
	Either a block hash or a block height.
	"""
	blockOffset: BlockOffset
	"""
	Either a transaction hash or a transaction identifier.
	"""
	transactionOffset: TransactionOffset
}

"""
Represents a token balance held by a contract.
This type is exposed through the GraphQL API to allow clients to query
unshielded token balances for any contract action (Deploy, Call, Update).
"""
type ContractBalance {
	"""
	Hex-encoded token type identifier.
	"""
	tokenType: HexEncoded!
	"""
	Balance amount as string to support larger integer values (up to 16 bytes).
	"""
	amount: String!
}

"""
A contract call.
"""
type ContractCall implements ContractAction {
	"""
	The hex-encoded serialized address.
	"""
	address: HexEncoded!
	"""
	The hex-encoded serialized state.
	"""
	state: HexEncoded!
	"""
	The hex-encoded serialized contract-specific zswap state.
	"""
	chainState: HexEncoded!
	"""
	The entry point.
	"""
	entryPoint: String!
	"""
	Transaction for this contract call.
	"""
	transaction: Transaction!
	"""
	Contract deploy for this contract call.
	"""
	deploy: ContractDeploy!
	"""
	Unshielded token balances held by this contract.
	"""
	unshieldedBalances: [ContractBalance!]!
}

"""
A contract deployment.
"""
type ContractDeploy implements ContractAction {
	"""
	The hex-encoded serialized address.
	"""
	address: HexEncoded!
	"""
	The hex-encoded serialized state.
	"""
	state: HexEncoded!
	"""
	The hex-encoded serialized contract-specific zswap state.
	"""
	chainState: HexEncoded!
	"""
	Transaction for this contract deploy.
	"""
	transaction: Transaction!
	"""
	Unshielded token balances held by this contract.
	"""
	unshieldedBalances: [ContractBalance!]!
}

"""
A contract update.
"""
type ContractUpdate implements ContractAction {
	"""
	The hex-encoded serialized address.
	"""
	address: HexEncoded!
	"""
	The hex-encoded serialized state.
	"""
	state: HexEncoded!
	"""
	The hex-encoded serialized contract-specific zswap state.
	"""
	chainState: HexEncoded!
	"""
	Transaction for this contract update.
	"""
	transaction: Transaction!
	"""
	Unshielded token balances held by this contract after the update.
	"""
	unshieldedBalances: [ContractBalance!]!
}

type DustGenerationDtimeUpdate implements DustLedgerEvent {
	"""
	The ID of this dust ledger event.
	"""
	id: Int!
	"""
	The hex-encoded serialized event.
	"""
	raw: HexEncoded!
	"""
	The maximum ID of all dust ledger events.
	"""
	maxId: Int!
}

"""
DUST generation status for a specific Cardano stake key.
"""
type DustGenerationStatus {
	"""
	The hex-encoded Cardano stake key.
	"""
	cardanoStakeKey: HexEncoded!
	"""
	The hex-encoded associated DUST address if registered.
	"""
	dustAddress: HexEncoded
	"""
	Whether this stake key is registered.
	"""
	registered: Boolean!
	"""
	NIGHT balance backing generation.
	"""
	nightBalance: String!
	"""
	Generation rate in Specks per second.
	"""
	generationRate: String!
	"""
	Current DUST capacity.
	"""
	currentCapacity: String!
}

type DustInitialUtxo implements DustLedgerEvent {
	"""
	The ID of this dust ledger event.
	"""
	id: Int!
	"""
	The hex-encoded serialized event.
	"""
	raw: HexEncoded!
	"""
	The maximum ID of all dust ledger events.
	"""
	maxId: Int!
	"""
	The dust output.
	"""
	output: DustOutput!
}

"""
A dust related ledger event.
"""
interface DustLedgerEvent {
	id: Int!
	raw: HexEncoded!
	maxId: Int!
}

"""
A dust output.
"""
type DustOutput {
	"""
	The hex-encoded 32-byte nonce.
	"""
	nonce: HexEncoded!
}

type DustSpendProcessed implements DustLedgerEvent {
	"""
	The ID of this dust ledger event.
	"""
	id: Int!
	"""
	The hex-encoded serialized event.
	"""
	raw: HexEncoded!
	"""
	The maximum ID of all dust ledger events.
	"""
	maxId: Int!
}

scalar HexEncoded

type Mutation {
	"""
	Connect the wallet with the given viewing key and return a session ID.
	"""
	connect(viewingKey: ViewingKey!): HexEncoded!
	"""
	Disconnect the wallet with the given session ID.
	"""
	disconnect(sessionId: HexEncoded!): Unit!
}

type ParamChange implements DustLedgerEvent {
	"""
	The ID of this dust ledger event.
	"""
	id: Int!
	"""
	The hex-encoded serialized event.
	"""
	raw: HexEncoded!
	"""
	The maximum ID of all dust ledger events.
	"""
	maxId: Int!
}

type Query {
	"""
	Find a block for the given optional offset; if not present, the latest block is returned.
	"""
	block(offset: BlockOffset): Block
	"""
	Find transactions for the given offset.
	"""
	transactions(offset: TransactionOffset!): [Transaction!]!
	"""
	Find a contract action for the given address and optional offset.
	"""
	contractAction(address: HexEncoded!, offset: ContractActionOffset): ContractAction
	"""
	Get DUST generation status for specific Cardano stake keys.
	"""
	dustGenerationStatus(cardanoStakeKeys: [HexEncoded!]!): [DustGenerationStatus!]!
}

"""
A regular Midnight transaction.
"""
type RegularTransaction implements Transaction {
	"""
	The transaction ID.
	"""
	id: Int!
	"""
	The hex-encoded transaction hash.
	"""
	hash: HexEncoded!
	"""
	The protocol version.
	"""
	protocolVersion: Int!
	"""
	The hex-encoded serialized transaction content.
	"""
	raw: HexEncoded!
	"""
	The result of applying this transaction to the ledger state.
	"""
	transactionResult: TransactionResult!
	"""
	The hex-encoded serialized transaction identifiers.
	"""
	identifiers: [HexEncoded!]!
	"""
	The hex-encoded serialized merkle-tree root.
	"""
	merkleTreeRoot: HexEncoded!
	"""
	The zswap state start index.
	"""
	startIndex: Int!
	"""
	The zswap state end index.
	"""
	endIndex: Int!
	"""
	Fee information for this transaction.
	"""
	fees: TransactionFees!
	"""
	The block for this transaction.
	"""
	block: Block!
	"""
	The contract actions for this transaction.
	"""
	contractActions: [ContractAction!]!
	"""
	Unshielded UTXOs created by this transaction.
	"""
	unshieldedCreatedOutputs: [UnshieldedUtxo!]!
	"""
	Unshielded UTXOs spent (consumed) by this transaction.
	"""
	unshieldedSpentOutputs: [UnshieldedUtxo!]!
	"""
	Zswap ledger events of this transaction.
	"""
	zswapLedgerEvents: [ZswapLedgerEvent!]!
	"""
	Dust ledger events of this transaction.
	"""
	dustLedgerEvents: [DustLedgerEvent!]!
}

"""
A transaction relevant for the subscribing wallet and an optional collapsed merkle tree.
"""
type RelevantTransaction {
	"""
	A transaction relevant for the subscribing wallet.
	"""
	transaction: RegularTransaction!
	"""
	An optional collapsed merkle tree.
	"""
	collapsedMerkleTree: CollapsedMerkleTree
}

"""
One of many segments for a partially successful transaction result showing success for some
segment.
"""
type Segment {
	"""
	Segment ID.
	"""
	id: Int!
	"""
	Successful or not.
	"""
	success: Boolean!
}

"""
An event of the shielded transactions subscription.
"""
union ShieldedTransactionsEvent = RelevantTransaction | ShieldedTransactionsProgress

"""
Information about the shielded transactions indexing progress.
"""
type ShieldedTransactionsProgress {
	"""
	The highest zswap state end index (see `endIndex` of `Transaction`) of all transactions. It
	represents the known state of the blockchain. A value of zero (completely unlikely) means
	that no shielded transactions have been indexed yet.
	"""
	highestEndIndex: Int!
	"""
	The highest zswap state end index (see `endIndex` of `Transaction`) of all transactions
	checked for relevance. Initially less than and eventually (when some wallet has been fully
	indexed) equal to `highest_end_index`. A value of zero (very unlikely) means that no wallet
	has subscribed before and indexing for the subscribing wallet has not yet started.
	"""
	highestCheckedEndIndex: Int!
	"""
	The highest zswap state end index (see `endIndex` of `Transaction`) of all relevant
	transactions for the subscribing wallet. Usually less than `highest_checked_end_index`
	unless the latest checked transaction is relevant for the subscribing wallet. A value of
	zero means that no relevant transactions have been indexed for the subscribing wallet.
	"""
	highestRelevantEndIndex: Int!
}

type Subscription {
	"""
	Subscribe to blocks starting at the given offset or at the latest block if the offset is
	omitted.
	"""
	blocks(offset: BlockOffset): Block!
	"""
	Subscribe to contract actions with the given address starting at the given offset or at the
	latest block if the offset is omitted.
	"""
	contractActions(address: HexEncoded!, offset: BlockOffset): ContractAction!
	"""
	Subscribe to dust ledger events starting at the given ID or at the very start if omitted.
	"""
	dustLedgerEvents(id: Int): DustLedgerEvent!
	"""
	Subscribe to shielded transaction events for the given session ID starting at the given
	index or at zero if omitted.
	"""
	shieldedTransactions(sessionId: HexEncoded!, index: Int): ShieldedTransactionsEvent!
	"""
	Subscribe unshielded transaction events for the given address and the given transaction ID
	or zero if omitted.
	"""
	unshieldedTransactions(address: UnshieldedAddress!, transactionId: Int): UnshieldedTransactionsEvent!
	"""
	Subscribe to zswap ledger events starting at the given ID or at the very start if omitted.
	"""
	zswapLedgerEvents(id: Int): ZswapLedgerEvent!
}

"""
A system Midnight transaction.
"""
type SystemTransaction implements Transaction {
	"""
	The transaction ID.
	"""
	id: Int!
	"""
	The hex-encoded transaction hash.
	"""
	hash: HexEncoded!
	"""
	The protocol version.
	"""
	protocolVersion: Int!
	"""
	The hex-encoded serialized transaction content.
	"""
	raw: HexEncoded!
	"""
	The block for this transaction.
	"""
	block: Block!
	"""
	The contract actions for this transaction.
	"""
	contractActions: [ContractAction!]!
	"""
	Unshielded UTXOs created by this transaction.
	"""
	unshieldedCreatedOutputs: [UnshieldedUtxo!]!
	"""
	Unshielded UTXOs spent (consumed) by this transaction.
	"""
	unshieldedSpentOutputs: [UnshieldedUtxo!]!
	"""
	Zswap ledger events of this transaction.
	"""
	zswapLedgerEvents: [ZswapLedgerEvent!]!
	"""
	Dust ledger events of this transaction.
	"""
	dustLedgerEvents: [DustLedgerEvent!]!
}

"""
A Midnight transaction.
"""
interface Transaction {
	id: Int!
	hash: HexEncoded!
	protocolVersion: Int!
	raw: HexEncoded!
	block: Block!
	contractActions: [ContractAction!]!
	unshieldedCreatedOutputs: [UnshieldedUtxo!]!
	unshieldedSpentOutputs: [UnshieldedUtxo!]!
	zswapLedgerEvents: [ZswapLedgerEvent!]!
	dustLedgerEvents: [DustLedgerEvent!]!
}

"""
Fees information for a transaction, including both paid and estimated fees.
"""
type TransactionFees {
	"""
	The actual fees paid for this transaction in DUST.
	"""
	paidFees: String!
	"""
	The estimated fees that was calculated for this transaction in DUST.
	"""
	estimatedFees: String!
}

"""
Either a transaction hash or a transaction identifier.
"""
input TransactionOffset @oneOf {
	"""
	A hex-encoded transaction hash.
	"""
	hash: HexEncoded
	"""
	A hex-encoded transaction identifier.
	"""
	identifier: HexEncoded
}

"""
The result of applying a transaction to the ledger state. In case of a partial success (status),
there will be segments.
"""
type TransactionResult {
	status: TransactionResultStatus!
	segments: [Segment!]
}

"""
The status of the transaction result: success, partial success or failure.
"""
enum TransactionResultStatus {
	SUCCESS
	PARTIAL_SUCCESS
	FAILURE
}

scalar Unit

scalar UnshieldedAddress

"""
A transaction that created and/or spent UTXOs alongside these and other information.
"""
type UnshieldedTransaction {
	"""
	The transaction that created and/or spent UTXOs.
	"""
	transaction: Transaction!
	"""
	UTXOs created in the above transaction, possibly empty.
	"""
	createdUtxos: [UnshieldedUtxo!]!
	"""
	UTXOs spent in the above transaction, possibly empty.
	"""
	spentUtxos: [UnshieldedUtxo!]!
}

"""
An event of the unshielded transactions subscription.
"""
union UnshieldedTransactionsEvent = UnshieldedTransaction | UnshieldedTransactionsProgress

"""
Information about the unshielded indexing progress.
"""
type UnshieldedTransactionsProgress {
	"""
	The highest transaction ID of all currently known transactions for a subscribed address.
	"""
	highestTransactionId: Int!
}

"""
Represents an unshielded UTXO.
"""
type UnshieldedUtxo {
	"""
	Owner Bech32m-encoded address.
	"""
	owner: UnshieldedAddress!
	"""
	Token hex-encoded serialized token type.
	"""
	tokenType: HexEncoded!
	"""
	UTXO value (quantity) as a string to support u128.
	"""
	value: String!
	"""
	The hex-encoded serialized intent hash.
	"""
	intentHash: HexEncoded!
	"""
	Index of this output within its creating transaction.
	"""
	outputIndex: Int!
	"""
	The creation time in seconds.
	"""
	ctime: Int
	"""
	The hex-encoded initial nonce for DUST generation tracking.
	"""
	initialNonce: HexEncoded!
	"""
	Whether this UTXO is registered for DUST generation.
	"""
	registeredForDustGeneration: Boolean!
	"""
	Transaction that created this UTXO.
	"""
	createdAtTransaction: Transaction!
	"""
	Transaction that spent this UTXO.
	"""
	spentAtTransaction: Transaction
}

scalar ViewingKey

"""
A zswap related ledger event.
"""
type ZswapLedgerEvent {
	"""
	The ID of this zswap ledger event.
	"""
	id: Int!
	"""
	The hex-encoded serialized event.
	"""
	raw: HexEncoded!
	"""
	The maximum ID of all zswap ledger events.
	"""
	maxId: Int!
}

"""
Directs the executor to include this field or fragment only when the `if` argument is true.
"""
directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
"""
Indicates that an Input Object is a OneOf Input Object (and thus requires exactly one of its field be provided)
"""
directive @oneOf on INPUT_OBJECT
"""
Directs the executor to skip this field or fragment when the `if` argument is true.
"""
directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
schema {
	query: Query
	mutation: Mutation
	subscription: Subscription
}

================
File: packages/indexer-client/README.md
================
# Wallet SDK Unshielded Token Indexer Client

================
File: packages/indexer-client/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": ["src/**/*.ts"]
}

================
File: packages/indexer-client/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [{ "path": "./tsconfig.build.json" }, { "path": "./tsconfig.test.json" }]
}

================
File: packages/indexer-client/tsconfig.publish.json
================
{
  "extends": "./tsconfig.build.json",
  "compilerOptions": {
    "sourceMap": false,
    "declarationMap": false
  }
}

================
File: packages/indexer-client/tsconfig.test.json
================
{
  "extends": "./tsconfig.json",
  "include": ["test/**/*.ts", "src/**/*.ts"]
}

================
File: packages/node-client/scripts/utils/command.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Cause, Console, Data, Effect, Exit, Fiber, pipe, Stream } from 'effect';
import { Command, CommandExecutor, Error } from '@effect/platform';

const printStream = <E, R>(stream: Stream.Stream<Uint8Array, E, R>): Effect.Effect<Fiber.Fiber<void, E>, never, R> =>
  pipe(stream, Stream.decodeText('utf-8'), Stream.splitLines, Stream.tap(Console.log), Stream.runDrain, Effect.fork);

export class CommandFailureError extends Data.TaggedError(
  '@midnight-ntwrk/node-client/scripts/utils/command#CommandFailureError',
)<{ command: Command.Command; exitCode: number }> {}

export const gatherAndPrintCommandOutput = (
  process: CommandExecutor.Process,
): Effect.Effect<Exit.Exit<number, Error.PlatformError>> => {
  const exitCode = process.exitCode.pipe(
    Effect.flatMap((code) => Console.log('Process exit code', code).pipe(Effect.as(code))),
    Effect.fork,
  );

  const stdout = printStream(process.stdout);
  const stderr = printStream(process.stderr);

  return Effect.gen(function* () {
    const exitCodeFiber = yield* exitCode;
    const stdoutFiber = yield* stdout;
    const stderrFiber = yield* stderr;

    const exit = yield* Fiber.await(exitCodeFiber);
    yield* Fiber.await(stdoutFiber);
    yield* Fiber.await(stderrFiber);

    return exit;
  });
};

export const handleProcessExit = (
  command: Command.Command,
  exit: Exit.Exit<number, Error.PlatformError>,
): Effect.Effect<void, Cause.Cause<Error.PlatformError> | CommandFailureError> => {
  return Exit.match(exit, {
    onFailure: (cause) => Effect.fail(cause),
    onSuccess: (code) =>
      code === 0
        ? Effect.void
        : Console.error('Command failed: ', command).pipe(
            Effect.andThen(
              Effect.fail(
                new CommandFailureError({
                  command,
                  exitCode: code,
                }),
              ),
            ),
          ),
  });
};

================
File: packages/node-client/scripts/generate-test-tx.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * IMPORTANT: This file isn't used in the current test setup as we generate the txs before running the tests (please see gen-txs.ts instead)
 *
 * This script uses midnight node toolkit to generate test transactions
 * Such approach, while potentially more involved when node version changes, has many benefits:
 * 1. It does not create a cyclic dependency on wallet code for such foundational package
 * 2. Transaction generator does save transactions into file, so they can be re-generated only when node changes its ledger version
 */
import { Effect } from 'effect';
import { FileSystem } from '@effect/platform';
import { NodeContext, NodeRuntime } from '@effect/platform-node';
import * as path from 'node:path';
import { TestContainers } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import * as process from 'process';
import { generateTestTransactions } from '../src/testing/test-transactions.js';

const paths = new (class {
  currentDir = path.dirname(new URL(import.meta.url).pathname);
  packageDir = path.resolve(this.currentDir, '..');
  outputPath = path.resolve(this.packageDir, 'resources');
  fileName = 'test-txs.json';
  repositoryRoot = path.resolve(this.packageDir, '..', '..');
})();

const argsSpec = yargs().option('node-path', {
  default: path.resolve(paths.repositoryRoot, '..', 'midnight-node'),
  type: 'string',
  describe: 'Path to node repo',
});

const parseArgs = Effect.sync(() => argsSpec.parseSync(hideBin(process.argv)));
type Args = {
  nodePath: string;
};

const removeSyncCache = (args: Args) =>
  Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    yield* fs.remove(path.resolve(args.nodePath, '.sync_cache'), { force: true, recursive: true });
  });

const prepareDestDir = Effect.gen(function* () {
  const fs = yield* FileSystem.FileSystem;

  yield* fs.makeDirectory(path.dirname(paths.outputPath), {
    recursive: true,
  });
});

const main = Effect.gen(function* () {
  const args = yield* parseArgs;

  yield* removeSyncCache(args);
  yield* prepareDestDir;

  const network = yield* TestContainers.createNetwork();
  const proofServer = yield* TestContainers.runProofServerContainer();

  yield* TestContainers.runNodeContainer((c) => c.withNetwork(network).withNetworkAliases('midnight-node'));

  yield* generateTestTransactions(
    'ws://midnight-node:9944',
    `http://127.0.0.1:${proofServer.getMappedPort(6300)}`,
    network,
    paths.outputPath,
    paths.fileName,
  );
}).pipe(Effect.scoped, Effect.provide(NodeContext.layer));

NodeRuntime.runMain(main);

================
File: packages/node-client/scripts/generate-types.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * This script calls polkadot codegen to generate types for a Midnight's Node Runtime
 * For unknown reason though, the generated code does not work out of the box, and there is a bunch of issues reported
 * One possible cause is our usage of pnpm linker (which is needed for as long as we have Scala code present)
 * For that reason the current flow for updating type definitions is:
 * 1. Ensure package.json field "referenceNodeVersion" contains right value
 * 2. Call this script, e.g. with `yarn turbo polkadot-typegen` in the repository root directory
 * 3. Edit contents of files generated at `src/gen` directory to one's needs
 */

import { Console, Effect, pipe, Stream } from 'effect';
import { type StartedTestContainer } from 'testcontainers';
import { Command, FileSystem } from '@effect/platform';
import { NodeContext, NodeRuntime } from '@effect/platform-node';
import * as path from 'node:path';
import { gatherAndPrintCommandOutput, handleProcessExit } from './utils/command.js';
import { TestContainers } from '@midnight-ntwrk/wallet-sdk-utilities/testing';

const paths = new (class {
  currentDir = path.dirname(new URL(import.meta.url).pathname);
  genDir = path.resolve(this.currentDir, '../src/gen');
  packageDir = path.resolve(this.currentDir, '..');
  genRelativeToPackage = path.relative(this.packageDir, this.genDir);
})();

const prepareGenDirectory = Effect.gen(function* () {
  const fs = yield* FileSystem.FileSystem;
  yield* fs.remove(paths.genDir, { recursive: true, force: true });
  yield* fs.makeDirectory(paths.genDir, { recursive: true });
});

const generateTypes = (container: StartedTestContainer) => {
  const command = Command.make(
    'polkadot-types-from-chain',
    ...[
      [`--endpoint`, `ws://localhost:${container.getMappedPort(9944)}`],
      [`--output`, paths.genRelativeToPackage],
      ['--strict'],
    ].flat(),
  );

  return pipe(
    command,
    Command.start,
    Effect.flatMap(gatherAndPrintCommandOutput),
    Effect.flatMap((commandExit) => handleProcessExit(command, commandExit)),
  );
};

const insertMissingImports = (() => {
  const prefixToAdd = `/* eslint-disable */
/**
 * Auto-generated with scripts/generate-types.ts
 * Then manually modified to only expose types and endpoints of interest
 */
  `;
  return Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    const files = yield* fs.readDirectory(paths.genDir, { recursive: true });

    yield* Stream.fromIterable(files).pipe(
      Stream.tap((item) => {
        return Console.log(item);
      }),
      Stream.filter((name) => name != `augment-api.ts`),
      Stream.map((filename) => path.resolve(paths.genDir, filename)),
      Stream.mapEffect((file: string) => {
        return Effect.gen(function* () {
          const fs = yield* FileSystem.FileSystem;

          const contents = yield* fs.readFileString(file, 'utf-8');
          const updatedContents = prefixToAdd.concat(contents);
          yield* fs.writeFileString(file, updatedContents);
        });
      }),
      Stream.runDrain,
    );
  });
})();

const main = pipe(
  prepareGenDirectory,
  Effect.andThen(TestContainers.runNodeContainer()),
  Effect.andThen(generateTypes),
  Effect.andThen(insertMissingImports),
  Effect.provide(NodeContext.layer),
  Effect.scoped,
);

NodeRuntime.runMain(main);

================
File: packages/node-client/src/effect/test/gen-txs.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { FileSystem } from '@effect/platform';
import { Effect, Scope } from 'effect';
import path from 'path';
import { StartedNetwork } from 'testcontainers';
import { generateTestTransactions } from '../../testing/test-transactions.js';
import { PlatformError } from '@effect/platform/Error';
import { NodeContext } from '@effect/platform-node';

const paths = new (class {
  currentDir = path.dirname(new URL(import.meta.url).pathname);
  outputPath = path.resolve(this.currentDir, 'tmp');
  fileName = 'test-txs.json';
})();

export const getTestTxsPath = (): string => `${paths.outputPath}/${paths.fileName}`;

const cleanDir = () =>
  Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    yield* fs.remove(getTestTxsPath(), { force: true, recursive: true });
  });

export const generateTxs = (
  nodeUrl: string,
  proofServerUrl: string,
  network: StartedNetwork,
): Effect.Effect<void, Error | PlatformError, Scope.Scope> =>
  Effect.gen(function* () {
    yield* cleanDir();
    yield* generateTestTransactions(nodeUrl, proofServerUrl, network, paths.outputPath, paths.fileName);
  }).pipe(Effect.provide(NodeContext.layer));

================
File: packages/node-client/src/effect/test/PolkadotNodeClient.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { describe, it, vi, expect, beforeAll, afterAll } from 'vitest';
import { PolkadotNodeClient } from '../PolkadotNodeClient.js';
import * as NodeClient from '../NodeClient.js';
import * as SubmissionEvent from '../SubmissionEvent.js';
import { StartedTestContainer } from 'testcontainers';
import { Array as EArray, Chunk, Effect, Either, Exit, Order, pipe, Random, Scope, Stream } from 'effect';
import { TestTransactions } from '../../testing/index.js';
import { TestContainers } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import { NodeContext } from '@effect/platform-node';
import { generateTxs, getTestTxsPath } from './gen-txs.js';

const clientLayer = (nodePort: number) =>
  PolkadotNodeClient.layer({
    nodeURL: new URL(`ws://127.0.0.1:${nodePort}`),
  });

// It takes some time to pass through enough rounds of consensus, even in tests
vi.setConfig({ testTimeout: 120_000, hookTimeout: 120_000 });

describe.skip('PolkadotNodeClient', () => {
  let scope: Scope.CloseableScope | undefined = undefined;
  let node: StartedTestContainer | undefined = undefined;

  beforeAll(async () => {
    await Effect.gen(function* () {
      scope = yield* Scope.make();

      const network = yield* TestContainers.createNetwork().pipe(Effect.provideService(Scope.Scope, scope));

      node = yield* TestContainers.runNodeContainer((c) =>
        c.withNetwork(network).withNetworkAliases('midnight-node'),
      ).pipe(Effect.provideService(Scope.Scope, scope));

      const proofServer = yield* TestContainers.runProofServerContainer().pipe(
        Effect.provideService(Scope.Scope, scope),
      );

      yield* generateTxs(
        `ws://midnight-node:9944`,
        `http://127.0.0.1:${proofServer.getMappedPort(6300)}`,
        network,
      ).pipe(Effect.provideService(Scope.Scope, scope));

      return [node, scope];
    }).pipe(Effect.provide(NodeContext.layer), Effect.scoped, Effect.runPromise);
  });
  afterAll(async () => {
    if (scope) {
      await pipe(Scope.close(scope, Exit.void), Effect.runPromise);
    }
  });

  it('does report an error if transaction fails well-formedness check upon submission', async () => {
    const result = await pipe(
      Effect.gen(function* () {
        const transactions = yield* TestTransactions.load(getTestTxsPath());
        return yield* NodeClient.sendMidnightTransactionAndWait(transactions.unbalanced_tx.serialize(), 'Submitted');
      }),
      Effect.either,
      Effect.provide(clientLayer(node!.getMappedPort(9944))),
      Effect.provide(NodeContext.layer),
      Effect.scoped,
      Effect.runPromiseExit,
    );

    Exit.match(result, {
      onFailure: (cause) => {
        //We don't want here any error
        expect(cause).toBe(null);
      },
      onSuccess: (result) => {
        expect(Either.isLeft(result)).toBe(true);
      },
    });
  });

  it('does report an error if node cannot deserialize transaction', async () => {
    const modifyTx = (txBytes: Uint8Array) => {
      return Effect.gen(function* () {
        const pickNumber = Random.nextIntBetween(0, txBytes.length - 1);
        const indexA = yield* pickNumber;
        const indexB = yield* pickNumber.pipe(
          Effect.repeat({
            until: (value) => value != indexA,
          }),
        );
        const [startIndex, endIndex] = pipe([indexA, indexB], EArray.sort(Order.number));
        return Buffer.from(txBytes).subarray(startIndex, endIndex);
      });
    };

    const allSubmissions = TestTransactions.load(getTestTxsPath()).pipe(
      Stream.fromEffect,
      Stream.flatMap(TestTransactions.streamAllValid),
      Stream.mapEffect((tx) => modifyTx(tx.serialize())),
      Stream.mapEffect((serializedTx) => NodeClient.sendMidnightTransactionAndWait(serializedTx, 'Submitted')),
      Stream.either,
      Stream.runCollect,
    );

    const result = await pipe(
      allSubmissions,
      Effect.provide(clientLayer(node!.getMappedPort(9944))),
      Effect.provide(NodeContext.layer),
      Effect.scoped,
      Effect.runPromiseExit,
    );

    Exit.match(result, {
      onFailure: (cause) => {
        //We don't want here any error
        expect(cause).toBe(null);
      },
      onSuccess: Chunk.forEach((item) => {
        expect(Either.isLeft(item)).toBe(true);
      }),
    });
  });

  it('does submit a transaction', async () => {
    const submitAllTransactions = TestTransactions.load(getTestTxsPath()).pipe(
      Stream.fromEffect,
      Stream.flatMap(TestTransactions.streamAllValid),
      Stream.mapEffect((tx) => NodeClient.sendMidnightTransactionAndWait(tx.serialize(), 'InBlock')),
      Stream.runDrain,
    );

    const result = await pipe(
      submitAllTransactions,
      Effect.provide(clientLayer(node!.getMappedPort(9944))),
      Effect.provide(NodeContext.layer),
      Effect.scoped,
      Effect.runPromiseExit,
    );

    expect(Exit.isSuccess(result)).toBe(true);
  });

  it.concurrent('does emit subsequent events', async () => {
    const submitAndCollectEvents = TestTransactions.load(getTestTxsPath()).pipe(
      Stream.fromEffect,
      Stream.flatMap(TestTransactions.streamAllValid),
      Stream.take(1),
      Stream.flatMap((tx) => NodeClient.sendMidnightTransaction(tx.serialize())),
      Stream.runCollect,
      Effect.map(Chunk.toArray),
    );

    const [submitted, inBlock, finalized] = await pipe(
      submitAndCollectEvents,
      Effect.provide(clientLayer(node!.getMappedPort(9944))),
      Effect.provide(NodeContext.layer),
      Effect.scoped,
      Effect.runPromise,
    );

    expect(SubmissionEvent.is('Submitted')(submitted)).toBe(true);
    expect(SubmissionEvent.is('InBlock')(inBlock)).toBe(true);
    expect(SubmissionEvent.is('Finalized')(finalized)).toBe(true);
    // expect((inBlock as SubmissionEvent.Cases.InBlock).blockHeight).toBeLessThanOrEqual(
    //   (finalized as SubmissionEvent.Cases.Finalized).blockHeight,
    // );
    // expect((inBlock as SubmissionEvent.Cases.InBlock).blockHash).toEqual(
    //   (finalized as SubmissionEvent.Cases.Finalized).blockHash,
    // );
  });

  it.skip("is able to submit transaction after node's unavailability", async () => {
    const first2Transactions = TestTransactions.load(getTestTxsPath()).pipe(
      Stream.fromEffect,
      Stream.flatMap(TestTransactions.streamAllValid),
      Stream.take(2),
      Stream.runCollect,
      Effect.map(Chunk.toArray),
    );

    const program = (node: StartedTestContainer) =>
      Effect.gen(function* () {
        const [tx1, tx2] = yield* first2Transactions;
        yield* NodeClient.sendMidnightTransactionAndWait(tx1.serialize(), 'InBlock');
        yield* Effect.promise(() =>
          node.restart({
            timeout: 10_000,
          }),
        );
        yield* NodeClient.sendMidnightTransactionAndWait(tx2.serialize(), 'InBlock');
      });

    const result = await pipe(
      TestContainers.findAvailablePort,
      Effect.flatMap((port) =>
        TestContainers.runNodeContainer((desc) =>
          desc.withExposedPorts({
            container: 9944,
            host: port,
          }),
        ),
      ),
      Effect.flatMap((container) =>
        pipe(program(container), Effect.provide(clientLayer(container.getMappedPort(9944)))),
      ),
      Effect.provide(NodeContext.layer),
      Effect.scoped,
      Effect.runPromiseExit,
    );

    Exit.match(result, {
      onFailure: (failure) => expect(failure).toBe(null),
      onSuccess: () => expect(true).toBe(true),
    });
  });
});

================
File: packages/node-client/src/effect/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * as NodeClient from './NodeClient.js';
export * from './PolkadotNodeClient.js';
export * as SubmissionEvent from './SubmissionEvent.js';
export * as NodeClientError from './NodeClientError.js';

================
File: packages/node-client/src/effect/NodeClient.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Context, Effect, Option, Stream } from 'effect';
import * as SubmissionEvent from './SubmissionEvent.js';
import * as NodeClientError from './NodeClientError.js';

export type SerializedMnTransaction = Uint8Array;

export type Genesis = { readonly transactions: readonly SerializedMnTransaction[] };

export interface Service {
  sendMidnightTransaction(
    serializedTransaction: SerializedMnTransaction,
  ): Stream.Stream<SubmissionEvent.SubmissionEvent, NodeClientError.NodeClientError>;
  getGenesis(): Effect.Effect<Genesis, NodeClientError.NodeClientError>;
}

export class NodeClient extends Context.Tag('@midnight-ntwrk/wallet-node-client#NodeClient')<NodeClient, Service>() {}

export const getGenesisTransactions = (): Effect.Effect<Genesis, NodeClientError.NodeClientError, NodeClient> =>
  NodeClient.pipe(Effect.flatMap((client) => client.getGenesis()));

export const sendMidnightTransaction = (
  serializedTransaction: SerializedMnTransaction,
): Stream.Stream<SubmissionEvent.SubmissionEvent, NodeClientError.NodeClientError, NodeClient> =>
  NodeClient.pipe(
    Stream.fromEffect,
    Stream.flatMap((client) => client.sendMidnightTransaction(serializedTransaction)),
  );

export function sendMidnightTransactionAndWait(
  serializedTransaction: SerializedMnTransaction,
  waitFor: SubmissionEvent.Cases.Submitted['_tag'],
): Effect.Effect<SubmissionEvent.Cases.Submitted, NodeClientError.NodeClientError, NodeClient>;
export function sendMidnightTransactionAndWait(
  serializedTransaction: SerializedMnTransaction,
  waitFor: SubmissionEvent.Cases.InBlock['_tag'],
): Effect.Effect<SubmissionEvent.Cases.InBlock, NodeClientError.NodeClientError, NodeClient>;
export function sendMidnightTransactionAndWait(
  serializedTransaction: SerializedMnTransaction,
  waitFor: SubmissionEvent.Cases.Finalized['_tag'],
): Effect.Effect<SubmissionEvent.Cases.Finalized, NodeClientError.NodeClientError, NodeClient>;
export function sendMidnightTransactionAndWait(
  serializedTransaction: SerializedMnTransaction,
  waitFor: SubmissionEvent.SubmissionEvent['_tag'],
): Effect.Effect<SubmissionEvent.SubmissionEvent, NodeClientError.NodeClientError, NodeClient>;
export function sendMidnightTransactionAndWait(
  serializedTransaction: SerializedMnTransaction,
  waitFor: SubmissionEvent.SubmissionEvent['_tag'],
): Effect.Effect<SubmissionEvent.SubmissionEvent, NodeClientError.NodeClientError, NodeClient> {
  return sendMidnightTransaction(serializedTransaction).pipe(
    Stream.find(SubmissionEvent.is(waitFor)),
    Stream.runHead,
    Effect.flatMap(
      Option.match({
        onNone: () =>
          Effect.fail(
            new NodeClientError.TransactionProgressError({
              message: 'Transaction did not reach desired stage and no other error was reported',
              txData: serializedTransaction,
              desiredStage: waitFor,
            }),
          ),
        onSome: (event) => Effect.succeed(event),
      }),
    ),
  );
}

================
File: packages/node-client/src/effect/NodeClientError.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Data } from 'effect';
import { SubmissionEvent } from './SubmissionEvent.js';

export class SubmissionError extends Data.TaggedError('SubmissionError')<{
  message: string;
  txData: Uint8Array;
  cause?: unknown;
}> {}
export class ConnectionError extends Data.TaggedError('ConnectionError')<{
  message: string;
  cause?: unknown;
}> {}
export class TransactionProgressError extends Data.TaggedError('TransactionProgressError')<{
  message: string;
  txData: Uint8Array;
  desiredStage: SubmissionEvent['_tag'];
}> {}
export class ParseError extends Data.TaggedError('ParseError')<{
  message: string;
  cause?: unknown;
}> {}
export class TransactionUsurpedError extends Data.TaggedError('TransactionUsurpedError')<{
  message: string;
  txData: Uint8Array;
}> {}
export class TransactionDroppedError extends Data.TaggedError('TransactionDroppedError')<{
  message: string;
  txData: Uint8Array;
}> {}
export class TransactionInvalidError extends Data.TaggedError('TransactionInvalidError')<{
  message: string;
  txData: Uint8Array;
  cause?: unknown;
}> {}

export type NodeClientError =
  | SubmissionError
  | ConnectionError
  | TransactionProgressError
  | ParseError
  | TransactionUsurpedError
  | TransactionDroppedError
  | TransactionInvalidError;

================
File: packages/node-client/src/effect/PolkadotNodeClient.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import '../gen/augment-api.js';

import { ApiPromise, SubmittableResult, WsProvider } from '@polkadot/api';
import {
  Duration,
  Effect,
  Either,
  Layer,
  ParseResult,
  pipe,
  Schedule,
  Schema,
  Scope,
  Stream,
  StreamEmit,
} from 'effect';
import * as NodeClient from './NodeClient.js';
import * as SubmissionEvent from './SubmissionEvent.js';
import * as NodeClientError from './NodeClientError.js';
import BN from 'bn.js';
import { u8aToHex } from '@polkadot/util';

export type Config = {
  nodeURL: URL;
  reconnectionTimeout: Duration.Duration;
  reconnectionDelay: Duration.Duration;
};

export const DEFAULT_CONFIG = {
  reconnectionTimeout: Duration.infinity,
  reconnectionDelay: Duration.seconds(1),
};

export const makeConfig = (input: Partial<Config> & Pick<Config, 'nodeURL'>): Config => ({
  ...DEFAULT_CONFIG,
  ...input,
});

export class PolkadotNodeClient implements NodeClient.Service {
  static make(
    configInput: Partial<Config> & Pick<Config, 'nodeURL'>,
  ): Effect.Effect<PolkadotNodeClient, NodeClientError.NodeClientError, Scope.Scope> {
    const config = makeConfig(configInput);
    return Effect.acquireRelease(
      Effect.promise(() =>
        ApiPromise.create({
          // @ts-expect-error -- exactOptionalPropertyTypes cause an incompatibility here
          provider: new WsProvider(config.nodeURL.toString()),
          throwOnConnect: false,
          noInitWarn: true,
        }),
      ),
      (api) => Effect.promise(() => api.disconnect()),
    ).pipe(Effect.map((api) => new PolkadotNodeClient(config, api)));
  }

  static layer(
    configInput: Partial<Config> & Pick<Config, 'nodeURL'>,
  ): Layer.Layer<NodeClient.NodeClient, NodeClientError.NodeClientError, Scope.Scope> {
    return Layer.effect(NodeClient.NodeClient, PolkadotNodeClient.make(configInput));
  }

  readonly config: Config;
  readonly api: ApiPromise;

  constructor(config: Config, api: ApiPromise) {
    this.config = config;
    this.api = api;
  }

  ensureConnection(): Effect.Effect<void, NodeClientError.NodeClientError> {
    return pipe(
      Effect.promise(async () => {
        if (!this.api.isConnected) {
          await this.api.connect();
        }
      }),
      Effect.andThen(Effect.sync(() => this.api.isConnected)),
      Effect.repeat({
        until: (value) => value,
        schedule: Schedule.spaced(this.config.reconnectionDelay),
      }),
      Effect.timeout(this.config.reconnectionTimeout),
      Effect.asVoid,
      Effect.mapError(
        (timeout) =>
          new NodeClientError.ConnectionError({
            message: 'Could not connect within specified time range (5s)',
            cause: timeout,
          }),
      ),
    );
  }

  sendMidnightTransaction(
    serializedTransaction: NodeClient.SerializedMnTransaction,
  ): Stream.Stream<SubmissionEvent.SubmissionEvent, NodeClientError.NodeClientError> {
    const outputStream: Stream.Stream<SubmissionEvent.SubmissionEvent, NodeClientError.NodeClientError> = Stream.async(
      (emit) => {
        const callUnsubscribe = () => unsubscribeP.then((thunk) => thunk());
        const unsubscribeP: Promise<() => void> = this.api.tx.midnight
          .sendMnTransaction(u8aToHex(serializedTransaction))
          .send(this.#handleSubmissionResult(serializedTransaction, emit, callUnsubscribe))
          .catch((err) => {
            return emit
              .fail(
                new NodeClientError.SubmissionError({
                  message: 'Transaction submission failed',
                  txData: serializedTransaction,
                  cause: err,
                }),
              )
              .then(() => () => {});
          });

        return Effect.promise(callUnsubscribe);
      },
    );

    return pipe(
      Stream.fromEffect(this.ensureConnection()),
      Stream.flatMap(() => outputStream),
    );
  }

  getGenesis(): Effect.Effect<
    { readonly transactions: readonly NodeClient.SerializedMnTransaction[] },
    NodeClientError.NodeClientError
  > {
    return Effect.promise(() => this.api.rpc.chain.getBlock(this.api.genesisHash)).pipe(
      Effect.map((block) => {
        // https://polkadot.js.org/docs/api/cookbook/blocks/#how-do-i-view-extrinsic-information
        return {
          transactions: block.block.extrinsics
            .filter(
              (extrinsic) => extrinsic.method.section === 'midnight' && extrinsic.method.method === 'sendMnTransaction',
            )
            .map((extrinsic) => extrinsic.method.args[0].toU8a()),
        };
      }),
      Effect.mapError(
        (error) =>
          new NodeClientError.ConnectionError({
            message: 'Failed to retrieve genesis transactions',
            cause: error,
          }),
      ),
    );
  }

  #handleSubmissionResult = (
    serializedTransaction: NodeClient.SerializedMnTransaction,
    emit: StreamEmit.Emit<never, NodeClientError.NodeClientError, SubmissionEvent.SubmissionEvent, void>,
    unsubscribe: () => Promise<void>,
  ) => {
    const WithBNBlockNumber = Schema.Struct({
      blockNumber: Schema.instanceOf(BN),
    });

    const emitParseError = (error: ParseResult.ParseError) =>
      emit.fail(
        new NodeClientError.ParseError({
          message: 'Failed to parse result provided by node',
          cause: error,
        }),
      );
    const decodeBlockNumber = Schema.decodeUnknownEither(WithBNBlockNumber, {
      errors: 'all',
      onExcessProperty: 'ignore',
    });

    return async (result: SubmittableResult) => {
      //Here's a detailed documentation about the result: https://github.com/paritytech/polkadot-sdk/blob/9b4cfe66188aa6f4408ca0463d373f0121bc1a8c/substrate/client/transaction-pool/api/src/lib.rs#L132
      const status = result.status;

      if (status.isReady || status.isFuture || status.isBroadcast || status.isRetracted) {
        // The retracted status means the original block was rolled back, so transaction went back to mempool
        await emit.single(SubmissionEvent.Submitted({ tx: serializedTransaction, txHash: result.txHash.toString() }));
      } else if (status.isInBlock) {
        await pipe(
          decodeBlockNumber(result),
          Either.match({
            onLeft: emitParseError,
            onRight: (parsed: { blockNumber: BN }) => {
              return emit.single(
                SubmissionEvent.InBlock({
                  tx: serializedTransaction,
                  blockHash: status.asInBlock.toString(),
                  blockHeight: BigInt(parsed.blockNumber.toString(10)),
                  txHash: result.txHash.toString(),
                }),
              );
            },
          }),
        );
      } else if (status.isFinalized) {
        await pipe(
          decodeBlockNumber(result),
          Either.match({
            onLeft: emitParseError,
            onRight: (parsed: { blockNumber: BN }) => {
              return emit.single(
                SubmissionEvent.Finalized({
                  tx: serializedTransaction,
                  blockHash: status.asFinalized.toString(),
                  blockHeight: BigInt(parsed.blockNumber.toString(10)),
                  txHash: result.txHash.toString(),
                }),
              );
            },
          }),
        );
        await emit.end();
        await unsubscribe();
      } else if (status.isFinalityTimeout) {
        await emit.fail(
          new NodeClientError.TransactionProgressError({
            message: 'Transaction did not reach finality within expected time, likely consensus issues arised',
            desiredStage: 'Finalized',
            txData: serializedTransaction,
          }),
        );
        await unsubscribe();
      } else if (status.isUsurped) {
        await emit.fail(
          new NodeClientError.TransactionUsurpedError({
            message:
              'Transaction got usurped (replaced by another one matching its discriminators like sender or nonce)',
            txData: serializedTransaction,
          }),
        );
        await unsubscribe();
      } else if (status.isDropped) {
        await emit.fail(
          new NodeClientError.TransactionDroppedError({
            message: 'Transaction got dropped, the mempool likely is full and network congested',
            txData: serializedTransaction,
          }),
        );
        await unsubscribe();
      } else if (status.isInvalid) {
        await emit.fail(
          new NodeClientError.TransactionInvalidError({
            message: 'Transaction got dropped, the mempool likely is full and network congested',
            txData: serializedTransaction,
          }),
        );
        await unsubscribe();
      }
    };
  };
}

================
File: packages/node-client/src/effect/SubmissionEvent.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Data } from 'effect';
import { SerializedMnTransaction } from './NodeClient.js';

export type HexString = string;

export type SubmissionEvent = Cases.Submitted | Cases.InBlock | Cases.Finalized;
export const { Submitted, InBlock, Finalized, $match: match, $is: is } = Data.taggedEnum<SubmissionEvent>();
export declare namespace Cases {
  export type Submitted = {
    _tag: 'Submitted';
    tx: SerializedMnTransaction;
    txHash: HexString;
  };
  export type InBlock = {
    _tag: 'InBlock';
    blockHash: HexString;
    blockHeight: bigint;
    tx: SerializedMnTransaction;
    txHash: HexString;
  };
  export type Finalized = {
    _tag: 'Finalized';
    blockHash: HexString;
    blockHeight: bigint;
    tx: SerializedMnTransaction;
    txHash: HexString;
  };
}

================
File: packages/node-client/src/gen/augment-api-errors.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/* eslint-disable */
/**
 * Auto-generated with scripts/generate-types.ts
 * Then manually modified to only expose types and endpoints of interest
 */

// import type lookup before we augment - in some environments
// this is required to allow for ambient/previous definitions
import '@polkadot/api-base/types/errors';

import type { ApiTypes, AugmentedError } from '@polkadot/api-base/types';

export type __AugmentedError<ApiType extends ApiTypes> = AugmentedError<ApiType>;

declare module '@polkadot/api-base/types/errors' {
  interface AugmentedErrors<ApiType extends ApiTypes> {
    midnight: {
      ContractCallCostError: AugmentedError<ApiType>;
      Deserialization: AugmentedError<ApiType>;
      LedgerCacheError: AugmentedError<ApiType>;
      LedgerStateScaleDecodingError: AugmentedError<ApiType>;
      NewStateOutOfBounds: AugmentedError<ApiType>;
      NoLedgerState: AugmentedError<ApiType>;
      Serialization: AugmentedError<ApiType>;
      Transaction: AugmentedError<ApiType>;
    };
  } // AugmentedErrors
} // declare module

================
File: packages/node-client/src/gen/augment-api-query.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/* eslint-disable */
/**
 * Auto-generated with scripts/generate-types.ts
 * Then manually modified to only expose types and endpoints of interest
 */

// import type lookup before we augment - in some environments
// this is required to allow for ambient/previous definitions
import '@polkadot/api-base/types/storage';

import type { ApiTypes, AugmentedQuery, QueryableStorageEntry } from '@polkadot/api-base/types';
import type { Bytes, Null, Option, U8aFixed, Vec, bool, u128, u16, u32, u64 } from '@polkadot/types-codec';
import type { AnyNumber, ITuple } from '@polkadot/types-codec/types';
import type { AccountId32, H256 } from '@polkadot/types/interfaces/runtime';
import type { Observable } from '@polkadot/types/types';

export type __AugmentedQuery<ApiType extends ApiTypes> = AugmentedQuery<ApiType, () => unknown>;
export type __QueryableStorageEntry<ApiType extends ApiTypes> = QueryableStorageEntry<ApiType>;

declare module '@polkadot/api-base/types/storage' {
  interface AugmentedQueries<ApiType extends ApiTypes> {
    midnight: {
      networkId: AugmentedQuery<ApiType, () => Observable<Option<Bytes>>, []>;
      stateKey: AugmentedQuery<ApiType, () => Observable<Option<Bytes>>, []>;
    };
  } // AugmentedQueries
} // declare module

================
File: packages/node-client/src/gen/augment-api-tx.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/* eslint-disable */
/**
 * Auto-generated with scripts/generate-types.ts
 * Then manually modified to only expose types and endpoints of interest
 */

// import type lookup before we augment - in some environments
// this is required to allow for ambient/previous definitions
import '@polkadot/api-base/types/submittable';

import type {
  ApiTypes,
  AugmentedSubmittable,
  SubmittableExtrinsic,
  SubmittableExtrinsicFunction,
} from '@polkadot/api-base/types';
import type { Bytes } from '@polkadot/types-codec';

export type __AugmentedSubmittable = AugmentedSubmittable<() => unknown>;
export type __SubmittableExtrinsic<ApiType extends ApiTypes> = SubmittableExtrinsic<ApiType>;
export type __SubmittableExtrinsicFunction<ApiType extends ApiTypes> = SubmittableExtrinsicFunction<ApiType>;

declare module '@polkadot/api-base/types/submittable' {
  interface AugmentedSubmittables<ApiType extends ApiTypes> {
    midnight: {
      sendMnTransaction: AugmentedSubmittable<
        (midnightTx: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>,
        [Bytes]
      >;
    };
  } // AugmentedSubmittables
} // declare module

================
File: packages/node-client/src/gen/augment-api.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/* eslint-disable */
/**
 * Auto-generated with scripts/generate-types.ts
 * Then manually modified to only expose types and endpoints of interest
 */

import './augment-api-errors.js';
import './augment-api-query.js';
import './augment-api-tx.js';

================
File: packages/node-client/src/testing/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * as TestTransactions from './test-transactions.js';

================
File: packages/node-client/src/testing/normalize-txs.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Encoding } from 'effect';

type TxContainer = {
  tx: string;
  [key: string]: unknown;
};

type Batch = {
  txs: string[];
};

type TestTxFile = {
  initial_tx?: string;
  batches?: Batch[];
  unbalanced_tx?: string;
};

export function normalizeTxs(tx: string): {
  initial_tx: string;
  batches: string[];
} {
  const normalizedTxs: {
    initial_tx: string;
    batches: string[];
  } = {
    initial_tx: '',
    batches: [],
  };

  const data = JSON.parse(tx) as TestTxFile;

  if (data.initial_tx) {
    try {
      const inner = JSON.parse(data.initial_tx) as TxContainer;
      if (inner.tx) normalizedTxs.initial_tx = Encoding.encodeHex(inner.tx);
    } catch {
      throw Error('Failed to parse initial_tx');
    }
  } else {
    throw Error('initial_tx is missing');
  }

  for (const batch of data.batches ?? []) {
    for (const bufferTx of batch.txs ?? []) {
      try {
        const inner = JSON.parse(bufferTx) as TxContainer;
        if (inner.tx) {
          const txHex = Encoding.encodeHex(inner.tx);
          normalizedTxs.batches.push(txHex);
        }
      } catch {
        throw Error('Failed to parse batch tx');
      }
    }
  }

  return normalizedTxs;
}

================
File: packages/node-client/src/testing/test-transactions.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Error, FileSystem } from '@effect/platform';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { SerializedTransaction } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { HttpProverClient, ProverClient } from '@midnight-ntwrk/wallet-sdk-prover-client/effect';
import { ClientError, ServerError } from '@midnight-ntwrk/wallet-sdk-utilities/networking';
import { TestContainers } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import { Effect, Encoding, ParseResult, pipe, Random, Schema, Stream } from 'effect';
import { Scope } from 'effect/Scope';
import { StartedNetwork } from 'testcontainers';
import { normalizeTxs } from './normalize-txs.js';

export type FinalizedTransaction = ledger.Transaction<ledger.SignatureEnabled, ledger.Proof, ledger.Binding>;

const TxSchema = Schema.declare(
  (input: unknown): input is FinalizedTransaction => input instanceof ledger.Transaction,
).annotations({
  identifier: 'ledger.Transaction',
});
const Uint8ArraySchema = Schema.declare(
  (input: unknown): input is Uint8Array => input instanceof Uint8Array,
).annotations({
  identifier: 'Uint8Array',
});

const TxFromUint8Array: Schema.Schema<FinalizedTransaction, Uint8Array> = Schema.asSchema(
  Schema.transformOrFail(Uint8ArraySchema, TxSchema, {
    encode: (tx) => Effect.sync(() => tx.serialize()),
    decode: (bytes) =>
      Effect.try({
        try: () => ledger.Transaction.deserialize('signature', 'proof', 'binding', bytes),

        catch: (err) => new ParseResult.Unexpected(err, 'Could not deserialize transaction'),
      }),
  }),
);

const HexedTx: Schema.Schema<FinalizedTransaction, string> = pipe(
  Schema.Uint8ArrayFromHex,
  Schema.compose(TxFromUint8Array),
);
type TxSchema = Schema.Schema.Type<typeof HexedTx>;

const TestTransactionsSchema = Schema.Struct({
  initial_tx: HexedTx,
  unbalanced_tx: HexedTx,
  batches: Schema.Array(HexedTx),
});
export type TestTransactions = Schema.Schema.Type<typeof TestTransactionsSchema>;

export const load: (
  file: string,
) => Effect.Effect<TestTransactions, ParseResult.ParseError | Error.PlatformError, FileSystem.FileSystem> = (file) =>
  pipe(
    FileSystem.FileSystem.pipe(Effect.flatMap((fs) => fs.readFileString(file))),
    Effect.map((str) => JSON.parse(str) as unknown),
    Effect.andThen(Schema.decodeUnknown(TestTransactionsSchema, { errors: 'all' })),
    Effect.cached,
    Effect.flatten,
  );

export const streamAllValid = (txs: TestTransactions): Stream.Stream<FinalizedTransaction> => {
  const initial = Stream.succeed(txs.initial_tx);
  const batches = Stream.fromIterable(txs.batches);

  return Stream.concat(initial, batches);
};

export const genUnbalancedTx = (): Effect.Effect<
  SerializedTransaction,
  ClientError | ServerError,
  ProverClient.ProverClient
> =>
  Effect.Do.pipe(
    Effect.bind('value', () => Random.nextIntBetween(1, 100_000_000).pipe(Effect.map((nr) => BigInt(nr)))),
    Effect.bind('shieldedTokenType', () =>
      Effect.succeed(ledger.shieldedToken() as unknown as { type: 'shielded'; raw: string }),
    ),
    Effect.let('unprovenTx', ({ value, shieldedTokenType }) => {
      const recipient = ledger.ZswapSecretKeys.fromSeed(new Uint8Array(32).fill(0));
      const coin = ledger.createShieldedCoinInfo(shieldedTokenType.raw, value);
      const unprovenOutput = ledger.ZswapOutput.new(coin, 0, recipient.coinPublicKey, recipient.encryptionPublicKey);
      const unprovenOffer = ledger.ZswapOffer.fromOutput(unprovenOutput, shieldedTokenType.raw, value);
      return ledger.Transaction.fromParts('undeployed', unprovenOffer);
    }),
    Effect.flatMap(({ unprovenTx }) =>
      Effect.gen(function* () {
        const proverClient = yield* ProverClient.ProverClient;
        const provedTx = yield* proverClient.proveTransaction(unprovenTx, ledger.CostModel.initialCostModel());

        return SerializedTransaction(provedTx.bind().serialize());
      }),
    ),
  );

const normalizeAndSaveUnbalancedTx = (txsPath: string, tx: Uint8Array) => {
  /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any */
  return Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    const outputFileData: any = yield* fs.readFileString(txsPath, 'utf8').pipe(Effect.map((str) => normalizeTxs(str)));

    const augmentedOutput = {
      ...outputFileData,
      unbalanced_tx: Encoding.encodeHex(tx),
    };
    yield* fs.writeFileString(txsPath, JSON.stringify(augmentedOutput));
  });
  /* eslint-enable */
};

const generateUnbalancedTransaction = (proofServerUrl: string) => {
  // Originally written with `Effect.gen`, but rewritten to Do notation to debug some typing issue
  // It seems to be a somewhat regular issue
  return Effect.Do.pipe(
    Effect.bind('tx', () => genUnbalancedTx()),
    Effect.map(({ tx }) => tx),
    Effect.provide(
      HttpProverClient.layer({
        url: new URL(proofServerUrl),
      }),
    ),
  );
};

export const generateTestTransactions = (
  nodeUrl: string,
  proofServerUrl: string,
  network: StartedNetwork,
  outputPath: string,
  fileName: string,
): Effect.Effect<void, Error | Error.PlatformError, FileSystem.FileSystem | Scope> =>
  Effect.gen(function* () {
    const [, unbalancedTx] = yield* Effect.all([
      TestContainers.runTxGenerator(
        {
          nodeUrl: nodeUrl,
          destPath: outputPath,
          fileName: fileName,
          txsPerBatch: 1,
          batches: 1,
        },
        (c) => c.withNetwork(network),
      ),
      generateUnbalancedTransaction(proofServerUrl),
    ]);

    yield* normalizeAndSaveUnbalancedTx(`${outputPath}/${fileName}`, unbalancedTx);
  });

================
File: packages/node-client/src/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import {
  NodeClient,
  PolkadotNodeClient as EffectNodeClient,
  SubmissionEvent,
  NodeClientError,
  Config,
} from './effect/index.js';
import { Effect, Exit, pipe, Scope } from 'effect';
import { Observable } from '@polkadot/types/types';
import { ObservableOps } from '@midnight-ntwrk/wallet-sdk-utilities';

export { Config, makeConfig, DEFAULT_CONFIG } from './effect/PolkadotNodeClient.js';

export class PolkadotNodeClient {
  static init(config: Config): Promise<PolkadotNodeClient> {
    return Effect.gen(function* () {
      const scope = yield* Scope.make();
      const client = yield* NodeClient.NodeClient.pipe(
        Effect.provide(EffectNodeClient.layer(config)),
        Effect.provideService(Scope.Scope, scope),
      );

      return new PolkadotNodeClient(client, scope);
    }).pipe(Effect.runPromise);
  }

  readonly #effectClient: NodeClient.Service;
  readonly #scope: Scope.CloseableScope;
  private constructor(effectClient: NodeClient.Service, scope: Scope.CloseableScope) {
    this.#effectClient = effectClient;
    this.#scope = scope;
  }

  sendMidnightTransaction(
    serializedTransaction: NodeClient.SerializedMnTransaction,
  ): Observable<SubmissionEvent.SubmissionEvent> {
    return ObservableOps.fromStream(this.#effectClient.sendMidnightTransaction(serializedTransaction));
  }

  sendMidnightTransactionAndWait(
    serializedTransaction: NodeClient.SerializedMnTransaction,
    waitFor: SubmissionEvent.Cases.Submitted['_tag'],
  ): Promise<SubmissionEvent.Cases.Submitted>;
  sendMidnightTransactionAndWait(
    serializedTransaction: NodeClient.SerializedMnTransaction,
    waitFor: SubmissionEvent.Cases.InBlock['_tag'],
  ): Promise<SubmissionEvent.Cases.InBlock>;
  sendMidnightTransactionAndWait(
    serializedTransaction: NodeClient.SerializedMnTransaction,
    waitFor: SubmissionEvent.Cases.Finalized['_tag'],
  ): Promise<SubmissionEvent.Cases.Finalized>;
  sendMidnightTransactionAndWait(
    serializedTransaction: NodeClient.SerializedMnTransaction,
    waitFor: SubmissionEvent.SubmissionEvent['_tag'],
  ): Promise<SubmissionEvent.SubmissionEvent> {
    const runRequest = <A>(
      request: Effect.Effect<A, NodeClientError.NodeClientError, NodeClient.NodeClient>,
    ): Promise<A> => pipe(request, Effect.provideService(NodeClient.NodeClient, this.#effectClient), Effect.runPromise);

    return NodeClient.sendMidnightTransactionAndWait(serializedTransaction, waitFor).pipe(runRequest);
  }

  close(): Promise<void> {
    return Scope.close(this.#scope, Exit.void).pipe(Effect.runPromise);
  }
}

================
File: packages/node-client/.gitignore
================
src/effect/test/tmp

================
File: packages/node-client/.prettierignore
================
dist/
coverage/
reports/

================
File: packages/node-client/eslint.config.mjs
================
import { packageConfig } from '../../eslint.config.mjs';

export default packageConfig({
  ignores: ['src/gen/'],
});

================
File: packages/node-client/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/test/**/*.ts", "src/**/*.test.ts"]
}

================
File: packages/node-client/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [
    { "path": "./tsconfig.build.json" },
    { "path": "./tsconfig.test.json" },
    { "path": "./tsconfig.script.json" }
  ]
}

================
File: packages/node-client/tsconfig.publish.json
================
{
  "extends": "./tsconfig.build.json",
  "compilerOptions": {
    "sourceMap": false,
    "declarationMap": false
  }
}

================
File: packages/node-client/tsconfig.script.json
================
{
  "extends": "./tsconfig.json",
  "include": ["scripts/**/*.ts", "src/testing/**/*.ts"],
  "compilerOptions": {
    "allowImportingTsExtensions": true
  }
}

================
File: packages/node-client/tsconfig.test.json
================
{
  "extends": "./tsconfig.json",
  "include": ["test/**/*.ts", "src/**/*.ts"]
}

================
File: packages/node-client/turbo.json
================
{
  "extends": ["//"],
  "tasks": {
    "typecheck-script": {
      "inputs": ["scripts/**", "src/testing/**", "package.json"],
      "dependsOn": ["^dist"]
    },
    "polkadot-typegen": {
      "inputs": ["scripts/**", "src/testing/**", "package.json"],
      "outputs": ["src/gen/**"],
      "dependsOn": ["typecheck-script"]
    },
    "gen-test-tx": {
      "inputs": ["scripts/**", "src/testing/**", "package.json"],
      "outputs": ["src/resources"],
      "dependsOn": ["typecheck-script"]
    }
  }
}

================
File: packages/node-client/vitest.config.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/// <reference types="vitest" />
/// <reference types="vitest/globals" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage',
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }],
    ],
  },
});

================
File: packages/prover-client/src/effect/test/httpProverClient.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import {
  CostModel,
  createShieldedCoinInfo,
  LedgerParameters,
  sampleCoinPublicKey,
  sampleEncryptionPublicKey,
  shieldedToken,
  Transaction,
  ZswapOffer,
  ZswapOutput,
} from '@midnight-ntwrk/ledger-v6';
import { Effect } from 'effect';
import { GenericContainer, Wait, type StartedTestContainer } from 'testcontainers';
import { afterAll, beforeAll, describe, expect, it } from 'vitest';
import * as HttpProverClient from '../HttpProverClient.js';
import * as ProverClient from '../ProverClient.js';

const PROOF_SERVER_IMAGE: string = 'ghcr.io/midnight-ntwrk/proof-server:6.1.0-alpha.5';
const PROOF_SERVER_PORT: number = 6300;

const timeout_minutes = (mins: number) => 1_000 * 60 * mins;

describe('HttpProverClient', () => {
  describe('layer', () => {
    // Ensures that we cannot construct a layer for HttpProverClient when we use common incorrect URI schemes.
    it.each(['ftp:', 'mailto:', 'ws:', 'wss:', 'file:'])(
      'should fail when constructed with %s as the URI scheme',
      async (scheme) => {
        await Effect.gen(function* () {
          // We should never be able to resolve a ProverClient since the configuration used to create the
          // associated HttpProverClient layer is invalid with the protocol schemes being used.
          return yield* ProverClient.ProverClient;
        }).pipe(
          Effect.flatMap((_) => Effect.fail('Unexpectedly resolved a ProverClient')),
          Effect.provide(HttpProverClient.layer({ url: `${scheme}//localhost.com` })),
          // Ensure the reported invalid protocol scheme is the one used.
          Effect.catchTag('InvalidProtocolSchemeError', (err) =>
            err.invalidScheme !== scheme
              ? Effect.fail(`Expected '${scheme}' but received '${err.invalidScheme}'`)
              : Effect.succeed(void 0),
          ),
          Effect.runPromise,
        );
      },
    );
  });

  describe('with available Proof Server', () => {
    let proofServerContainer: StartedTestContainer | undefined = undefined;

    const proofServerPort = () => proofServerContainer?.getMappedPort(PROOF_SERVER_PORT) ?? PROOF_SERVER_PORT;

    const shieldedTokenType = shieldedToken() as { raw: string; tag: 'shielded' };
    const makeValidTransaction = (spendCoinAmount: bigint) => {
      const spendCoin = createShieldedCoinInfo(shieldedTokenType.raw, spendCoinAmount);
      const cpk = sampleCoinPublicKey();
      const epk = sampleEncryptionPublicKey();
      const output = ZswapOutput.new(spendCoin, 0, cpk, epk);
      const unprovenOffer = ZswapOffer.fromOutput(output, shieldedTokenType.raw, spendCoinAmount);

      return Transaction.fromParts('undeployed', unprovenOffer);
    };

    beforeAll(async () => {
      proofServerContainer = await new GenericContainer(PROOF_SERVER_IMAGE)
        .withExposedPorts(PROOF_SERVER_PORT)
        .withWaitStrategy(Wait.forListeningPorts().withStartupTimeout(timeout_minutes(2)))
        .start();
    }, timeout_minutes(5));

    afterAll(async () => {
      await proofServerContainer?.stop();
    }, timeout_minutes(1));

    it(
      'should prove a valid transaction',
      async () => {
        await Effect.gen(function* () {
          const proveClient = yield* ProverClient.ProverClient;

          const spendCoinAmount = 1_000n;

          const validTx = makeValidTransaction(spendCoinAmount);

          const tx = yield* proveClient.proveTransaction(validTx, CostModel.initialCostModel());

          const imbalances = tx.imbalances(0, tx.fees(LedgerParameters.initialParameters()));

          // workaround because imbalances keys are objects, while js compares them by reference
          const filteredImbalances = Array.from(imbalances.entries()).filter(
            ([tokenType, tokenValue]) => tokenType.tag === shieldedTokenType.tag && tokenValue <= spendCoinAmount,
          );

          expect(filteredImbalances.length).toEqual(1);
          expect(tx.fees(LedgerParameters.initialParameters())).not.toEqual(0n);
        }).pipe(
          Effect.provide(HttpProverClient.layer({ url: `http://127.0.0.1:${proofServerPort()}` })),
          Effect.catchAll((err) => Effect.fail(`Encountered unexpected '${err._tag}' error: ${err.message}`)),
          Effect.runPromise,
        );
      },
      timeout_minutes(5),
    );

    it(
      'should fail to prove an invalid transaction',
      async () => {
        await Effect.gen(function* () {
          const proveClient = yield* ProverClient.ProverClient;

          const tx = makeValidTransaction(1n);

          yield* proveClient.proveTransaction(tx, CostModel.initialCostModel());
        }).pipe(
          Effect.catchAll(() => Effect.succeed(void 0)),
          Effect.provide(HttpProverClient.layer({ url: `http://127.0.0.1:${proofServerPort()}` })),
          Effect.catchAll((err) => Effect.fail(`Encountered unexpected '${err._tag}' error: ${err.message}`)),
          Effect.runPromise,
        );
      },
      timeout_minutes(5),
    );
  });
});

================
File: packages/prover-client/src/effect/HttpProverClient.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Chunk, Context, Duration, Effect, Either, Layer, pipe, Schedule, Stream } from 'effect';
import { FetchHttpClient, HttpClient, HttpClientRequest, HttpClientResponse } from '@effect/platform';
import { SerializedTransaction, SerializedUnprovenTransaction } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { ProverClient } from './ProverClient.js';
import {
  InvalidProtocolSchemeError,
  ClientError,
  ServerError,
  HttpURL,
} from '@midnight-ntwrk/wallet-sdk-utilities/networking';
import { BlobOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import * as ledger from '@midnight-ntwrk/ledger-v6';

const PROVE_TX_PATH = '/prove';
const CHECK_TX_PATH = '/check';

/**
 * Creates a layer for a {@link ProverClient} that sends requests to a Proof Server over HTTP.
 *
 * @param config The server configuration to use when configuring the HTTP elements of the layer.
 * @returns A `Layer` for {@link ProverClient} that sends requests to a configured Proof Server over HTTP.
 * The layer can fail with an `InvalidProtocolSchemeError` if `config` is invalid for a HTTP context.
 */
export const layer: (config: ProverClient.ServerConfig) => Layer.Layer<ProverClient, InvalidProtocolSchemeError> = (
  config,
) =>
  Layer.effect(
    ProverClient,
    HttpURL.make(new URL(config.url)).pipe(
      Either.map((baseUrl) => new HttpProverClientImpl(baseUrl)),
      Either.match({
        onLeft: (l) => Effect.fail(l),
        onRight: (r) => Effect.succeed(r),
      }),
    ),
  );

class HttpProverClientImpl implements Context.Tag.Service<ProverClient> {
  constructor(baseUrl: HttpURL.HttpUrl) {
    this.baseUrl = baseUrl;
  }

  protected readonly baseUrl: HttpURL.HttpUrl;

  private request(
    path: string,
    transaction: SerializedUnprovenTransaction | SerializedTransaction,
    failurePrefix: string,
  ): Effect.Effect<SerializedTransaction, ClientError | ServerError> {
    const concatBytes = (chunks: Uint8Array[]): Effect.Effect<Uint8Array> =>
      Effect.promise((): Promise<Uint8Array> => BlobOps.getBytes(new Blob(chunks)));

    const receiveBody = (response: HttpClientResponse.HttpClientResponse) =>
      pipe(
        response.stream,
        Stream.runCollect,
        Effect.flatMap((chunks) => concatBytes(Chunk.toArray(chunks))),
      );

    // Build endpoint URL from the already validated base URL
    const url = HttpURL.HttpURL(new URL(path, this.baseUrl));

    const proveTxRequest = pipe(
      Effect.succeed(transaction),
      Effect.map((body) => HttpClientRequest.post(url).pipe(HttpClientRequest.bodyUint8Array(body))),
      Effect.flatMap(HttpClient.execute),
      Effect.flatMap((response: HttpClientResponse.HttpClientResponse) =>
        Effect.gen(function* () {
          if (response.status !== 200) {
            const text = yield* response.text;
            return yield* new ClientError({ message: `${failurePrefix}: ${text}` });
          }
          return yield* receiveBody(response);
        }),
      ),
      Effect.retry({
        times: 3,
        while: (error) =>
          // Retry if we get a Bad Gateway, Service Unavailable, or Gateway Timeout error.
          error._tag === 'ResponseError' && error.response.status >= 502 && error.response.status <= 504,
        schedule: Schedule.exponential(Duration.seconds(2), 2),
      }),
    );

    return proveTxRequest.pipe(
      Effect.map(SerializedTransaction),
      Effect.catchTags({
        RequestError: (err) => new ClientError({ message: `Failed to connect to Proof Server: ${err.message}` }),
        ResponseError: (err) =>
          Effect.orElseSucceed(err.response.text, () => 'Unknown server error').pipe(
            Effect.flatMap((message) => new ServerError({ message })),
          ),
      }),
      Effect.provide(FetchHttpClient.layer),
    );
  }

  private serverProverProvider = (): ledger.ProvingProvider => ({
    check: async (serializedPreimage: Uint8Array, _keyLocation: string): Promise<(bigint | undefined)[]> =>
      pipe(
        Effect.succeed(ledger.createCheckPayload(serializedPreimage)),
        Effect.map(SerializedTransaction),
        Effect.flatMap((tx) => this.request(CHECK_TX_PATH, tx, 'Failed to check')),
        Effect.map((response) => ledger.parseCheckResult(response)),
        Effect.runPromise,
      ),
    prove: async (
      serializedPreimage: Uint8Array,
      _keyLocation: string,
      overwriteBindingInput?: bigint,
    ): Promise<Uint8Array> =>
      pipe(
        Effect.succeed(ledger.createProvingPayload(serializedPreimage, overwriteBindingInput)),
        Effect.map(SerializedUnprovenTransaction),
        Effect.flatMap((tx) => this.request(PROVE_TX_PATH, tx, 'Failed to prove')),
        Effect.runPromise,
      ),
  });

  proveTransaction<S extends ledger.Signaturish, B extends ledger.Bindingish>(
    transaction: ledger.Transaction<S, ledger.PreProof, B>,
    costModel: ledger.CostModel,
  ): Effect.Effect<ledger.Transaction<S, ledger.Proof, B>, ClientError | ServerError> {
    return pipe(
      Effect.succeed(this.serverProverProvider()),
      Effect.flatMap((provider) =>
        Effect.tryPromise({
          try: () => transaction.prove(provider, costModel),
          catch: (error) =>
            error instanceof ClientError || error instanceof ServerError
              ? error
              : new ClientError({ message: 'Failed to prove transaction', cause: error }),
        }),
      ),
    );
  }
}

================
File: packages/prover-client/src/effect/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * as ProverClient from './ProverClient.js';
export * as HttpProverClient from './HttpProverClient.js';

================
File: packages/prover-client/src/effect/ProverClient.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Context } from 'effect';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { ClientError, ServerError } from '@midnight-ntwrk/wallet-sdk-utilities/networking';

/**
 * A client that provides proof services for unproven transactions.
 */
export class ProverClient extends Context.Tag('@midnight-ntwrk/prover-client#ProverClient')<
  ProverClient,
  ProverClient.Service
>() {}

export declare namespace ProverClient {
  /**
   * Provides server related configuration for {@link ProverClient} implementations.
   */
  interface ServerConfig {
    /** The base URL to the Proof Server. */
    readonly url: URL | string;
  }

  interface Service {
    /**
     * Proves an unproven transaction by submitting it to an associated Proof Server.
     *
     * @param transaction A serialized unproven transaction.
     * @returns An `Effect` that yields with a serialized transaction representing the proven version of `transaction`;
     * or fails with a client or server side error.
     */
    proveTransaction<S extends ledger.Signaturish, B extends ledger.Bindingish>(
      tx: ledger.Transaction<S, ledger.PreProof, B>,
      costModel?: ledger.CostModel,
    ): Effect.Effect<ledger.Transaction<S, ledger.Proof, B>, ClientError | ServerError>;
  }
}

================
File: packages/prover-client/src/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect } from 'effect';
import { ProverClient, HttpProverClient as _HttpProverClient } from './effect/index.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';

/**
 * Sends serialized unproven transactions to a Proof Server over HTTP.
 */
export class HttpProverClient {
  #innerClient: ProverClient.ProverClient.Service;

  /**
   * Initializes a new {@link HttpProverClient}.
   *
   * @param config The server configuration to use when configuring the HTTP elements of the Proof Server.
   * @throws {@link ProverClient.InvalidProtocolSchemeError}
   * The `config` is invalid for a HTTP context. E.g., expecting 'http:' or 'https:' URLs but something other
   * was provided.
   */
  constructor(config: ProverClient.ProverClient.ServerConfig) {
    this.#innerClient = Effect.gen(function* () {
      return yield* ProverClient.ProverClient;
    }).pipe(Effect.provide(_HttpProverClient.layer(config)), Effect.runSync);
  }

  /**
   * Proves an unproven transaction by submitting it over HTTP to an associated Proof Server.
   *
   * @param transaction An unproven ledger transaction.
   * @returns A `Promise` that resolves with a proven transaction or fails with a client or server side error.
   * @throws {@link ClientError}
   * There was an issue with the provided `transaction`, or a connection with the configured Proof
   * Server could not be initiated.
   * @throws {@link ServerError}
   * Unable to establish a connection with the configured Proof Server, or there was an internal error that
   * prevented the proof request from being executed.
   */
  proveTransaction<S extends ledger.Signaturish, B extends ledger.Bindingish>(
    transaction: ledger.Transaction<S, ledger.PreProof, B>,
    costModel?: ledger.CostModel,
  ): Promise<ledger.Transaction<S, ledger.Proof, B>> {
    return this.#innerClient.proveTransaction(transaction, costModel).pipe(Effect.runPromise);
  }
}

================
File: packages/prover-client/.npmignore
================
*.ts.map

================
File: packages/prover-client/.prettierignore
================
dist/
coverage/
reports/

================
File: packages/prover-client/eslint.config.mjs
================
import { packageConfig } from '../../eslint.config.mjs';

export default packageConfig();

================
File: packages/prover-client/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/test/**/*.ts", "src/**/*.test.ts"]
}

================
File: packages/prover-client/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [{ "path": "./tsconfig.build.json" }, { "path": "./tsconfig.test.json" }]
}

================
File: packages/prover-client/tsconfig.publish.json
================
{
  "extends": "./tsconfig.build.json",
  "compilerOptions": {
    "sourceMap": false,
    "declarationMap": false
  }
}

================
File: packages/prover-client/tsconfig.test.json
================
{
  "extends": "./tsconfig.json",
  "include": ["test/**/*.ts", "src/**/*.ts"]
}

================
File: packages/prover-client/vitest.config.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/// <reference types="vitest" />
/// <reference types="vitest/globals" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage',
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }],
    ],
  },
});

================
File: packages/runtime/src/abstractions/test/variant.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { HList, Poly } from '@midnight-ntwrk/wallet-sdk-utilities';
import type { Expect, Equal, CanAssign } from '@midnight-ntwrk/wallet-sdk-utilities/types';
import { describe, expect, it } from 'vitest';
import {
  InterceptingRunningVariant,
  InterceptingVariant,
  Numeric,
  NumericMultiplier,
  NumericRange,
  NumericRangeMultiplier,
} from '../../testing/variants.js';
import { makeVersionedRecord, RunningVariant, RunningVariantOf, StateOf, VersionedVariant } from '../Variant.js';

describe('Variant', () => {
  it('infers its state correctly', () => {
    type _1 = Expect<Equal<StateOf<VersionedVariant<NumericRange>>, number>>;
    type _2 = Expect<Equal<StateOf<NumericRange>, number>>;
    type _3 = Expect<Equal<StateOf<VersionedVariant<NumericRangeMultiplier>>, number>>;
    type _4 = Expect<Equal<StateOf<NumericRangeMultiplier>, number>>;
    type _5 = Expect<Equal<StateOf<VersionedVariant<InterceptingVariant<string, string>>>, string>>;
    type _6 = Expect<Equal<StateOf<InterceptingVariant<string, string>>, string>>;
    type _7 = Expect<
      Equal<StateOf<InterceptingVariant<string, string> | NumericRangeMultiplier | NumericRange>, string | number>
    >;
    type _8 = Expect<
      Equal<
        StateOf<
          | VersionedVariant<InterceptingVariant<string, string>>
          | VersionedVariant<NumericRangeMultiplier>
          | VersionedVariant<NumericRange>
        >,
        string | number
      >
    >;
  });

  it('infers variant state by finding it in an hlist', () => {
    type Variants = [
      VersionedVariant<InterceptingVariant<'foo', string>>,
      VersionedVariant<NumericRangeMultiplier>,
      VersionedVariant<NumericRange>,
    ];
    type InferState<TTag extends string | symbol> = StateOf<HList.Find<Variants, { variant: Poly.WithTag<TTag> }>>;

    type _1 = Expect<Equal<InferState<'foo'>, string>>;
    type _2 = Expect<Equal<InferState<typeof Numeric>, number>>;
    type _3 = Expect<Equal<InferState<typeof NumericMultiplier>, number>>;

    type _4 = Expect<Equal<InferState<'bar'>, never>>;
  });

  it('infers its running type correctly', () => {
    type _1 = Expect<Equal<RunningVariantOf<VersionedVariant<NumericRange>>, RunningVariant<'NumericRange', number>>>;
    type _2 = Expect<Equal<RunningVariantOf<NumericRange>, RunningVariant<'NumericRange', number>>>;
    type _3 = Expect<
      Equal<RunningVariantOf<VersionedVariant<NumericRangeMultiplier>>, RunningVariant<'NumericMultiplier', number>>
    >;
    type _4 = Expect<Equal<RunningVariantOf<NumericRangeMultiplier>, RunningVariant<'NumericMultiplier', number>>>;
    type _5 = Expect<
      Equal<
        RunningVariantOf<VersionedVariant<InterceptingVariant<string, string>>>,
        InterceptingRunningVariant<string, string>
      >
    >;
    type _6 = Expect<
      Equal<RunningVariantOf<InterceptingVariant<string, string>>, InterceptingRunningVariant<string, string>>
    >;
    type _7 = Expect<
      Equal<
        RunningVariantOf<InterceptingVariant<string, string> | NumericRangeMultiplier | NumericRange>,
        | RunningVariant<'NumericRange', number>
        | RunningVariant<'NumericMultiplier', number>
        | InterceptingRunningVariant<string, string>
      >
    >;
    type _8 = Expect<
      Equal<
        RunningVariantOf<
          | VersionedVariant<InterceptingVariant<string, string>>
          | VersionedVariant<NumericRangeMultiplier>
          | VersionedVariant<NumericRange>
        >,
        | RunningVariant<'NumericRange', number>
        | RunningVariant<'NumericMultiplier', number>
        | InterceptingRunningVariant<string, string>
      >
    >;
  });

  describe('building a tagged record', () => {
    it('returns and infers an empty object in case of empty array provided', () => {
      const record = makeVersionedRecord([] as const);
      expect(record).toEqual({});
      type _1 = Expect<Equal<typeof record, object>>;
    });

    it('returns and infers in single-variant case correctly', () => {
      const range: VersionedVariant<NumericRange> = {
        sinceVersion: ProtocolVersion.ProtocolVersion(1n),
        variant: new NumericRange({ min: 0, max: 1 }, 1, false),
      };
      const record1 = makeVersionedRecord([range] as const);
      expect(record1).toEqual({ [Numeric]: range });
      type _1 = Expect<Equal<typeof record1, object & { readonly NumericRange: VersionedVariant<NumericRange> }>>;

      const rangeMultiplier: VersionedVariant<NumericRangeMultiplier> = {
        sinceVersion: ProtocolVersion.ProtocolVersion(1n),
        variant: new NumericRangeMultiplier({ min: 0, max: 1, multiplier: 2 }),
      };
      const record2 = makeVersionedRecord([rangeMultiplier] as const);
      expect(record2).toEqual({ [NumericMultiplier]: rangeMultiplier });
      type _2 = Expect<
        Equal<typeof record2, object & { readonly NumericMultiplier: VersionedVariant<NumericRangeMultiplier> }>
      >;

      const interceptor: VersionedVariant<InterceptingVariant<'foo', number>> = {
        sinceVersion: ProtocolVersion.ProtocolVersion(1n),
        variant: new InterceptingVariant('foo'),
      };
      const record3 = makeVersionedRecord([interceptor] as const);
      expect(record3).toEqual({ foo: interceptor });
      type _3 = Expect<
        Equal<typeof record3, object & { readonly foo: VersionedVariant<InterceptingVariant<'foo', number>> }>
      >;
    });

    it('returns and infers in multi-variant case correctly', () => {
      const range: VersionedVariant<NumericRange> = {
        sinceVersion: ProtocolVersion.ProtocolVersion(1n),
        variant: new NumericRange({ min: 0, max: 1 }, 1, false),
      };
      const rangeMultiplier: VersionedVariant<NumericRangeMultiplier> = {
        sinceVersion: ProtocolVersion.ProtocolVersion(1n),
        variant: new NumericRangeMultiplier({ min: 0, max: 1, multiplier: 2 }),
      };
      const interceptor: VersionedVariant<InterceptingVariant<'foo', number>> = {
        sinceVersion: ProtocolVersion.ProtocolVersion(1n),
        variant: new InterceptingVariant('foo'),
      };

      const record = makeVersionedRecord([range, rangeMultiplier, interceptor] as const);
      expect(record).toEqual({
        [Numeric]: range,
        [NumericMultiplier]: rangeMultiplier,
        foo: interceptor,
      });
      type _1 = Expect<
        CanAssign<
          {
            readonly NumericRange: VersionedVariant<NumericRange>;
            readonly NumericMultiplier: VersionedVariant<NumericRangeMultiplier>;
            readonly foo: VersionedVariant<InterceptingVariant<'foo', number>>;
          },
          typeof record
        >
      >;
    });
  });
});

================
File: packages/runtime/src/abstractions/test/variantBuilder.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { HList } from '@midnight-ntwrk/wallet-sdk-utilities';
import type { Equal, Expect } from '@midnight-ntwrk/wallet-sdk-utilities/types';
import { describe, it } from 'vitest';
import {
  InterceptingVariant,
  InterceptingVariantBuilder,
  NumericRange,
  NumericRangeBuilder,
  NumericRangeMultiplier,
  NumericRangeMultiplierBuilder,
  RangeConfig,
  RangeMultiplierConfig,
} from '../../testing/variants.js';
import { VersionedVariant } from '../Variant.js';
import { ConfigurationOf, VersionedVariantBuilder, VersionedVariantsOf } from '../VariantBuilder.js';

describe('VariantBuilder', () => {
  type Builders = [NumericRangeBuilder, InterceptingVariantBuilder<string, string>, NumericRangeMultiplierBuilder];
  type VersionedBuilders = [
    VersionedVariantBuilder<NumericRangeBuilder>,
    VersionedVariantBuilder<InterceptingVariantBuilder<string, string>>,
    VersionedVariantBuilder<NumericRangeMultiplierBuilder>,
  ];

  it('properly infers its versioned variant types', () => {
    type Expected = [
      VersionedVariant<NumericRange>,
      VersionedVariant<InterceptingVariant<string, string>>,
      VersionedVariant<NumericRangeMultiplier>,
    ];

    type _1 = Expect<Equal<VersionedVariantsOf<Builders>, Expected>>;
    type _2 = Expect<Equal<VersionedVariantsOf<VersionedBuilders>, Expected>>;
  });

  it('properly infers needed configuration', () => {
    type Expected = RangeConfig | RangeMultiplierConfig | object;

    type _1 = Expect<Equal<ConfigurationOf<VersionedVariantBuilder<NumericRangeBuilder>>, RangeConfig>>;
    type _2 = Expect<Equal<ConfigurationOf<NumericRangeBuilder>, RangeConfig>>;
    type _3 = Expect<
      Equal<ConfigurationOf<VersionedVariantBuilder<InterceptingVariantBuilder<string, string>>>, object>
    >;
    type _4 = Expect<Equal<ConfigurationOf<InterceptingVariantBuilder<string, string>>, object>>;

    type _5 = Expect<
      Equal<ConfigurationOf<VersionedVariantBuilder<NumericRangeMultiplierBuilder>>, RangeMultiplierConfig>
    >;
    type _6 = Expect<Equal<ConfigurationOf<NumericRangeMultiplierBuilder>, RangeMultiplierConfig>>;
    type _7 = Expect<Equal<ConfigurationOf<HList.Each<Builders>>, Expected>>;
    type _8 = Expect<Equal<ConfigurationOf<HList.Each<VersionedBuilders>>, Expected>>;
  });
});

================
File: packages/runtime/src/abstractions/test/versionChangeType.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { describe, expect, it } from 'vitest';
import * as VersionChangeType from '../VersionChangeType.js';

describe('VersionChangeType', () => {
  it('should create a version change with a given protocol version number', () => {
    const change = VersionChangeType.Version({ version: ProtocolVersion.ProtocolVersion(100n) });

    expect(VersionChangeType.isVersion(change)).toBeTruthy();
    expect(VersionChangeType.isNext(change)).toBeFalsy();
  });

  it('should create a version change for the next protocol version number', () => {
    const change = VersionChangeType.Next();

    expect(VersionChangeType.isNext(change)).toBeTruthy();
    expect(VersionChangeType.isVersion(change)).toBeFalsy();
  });

  it('should match version change for given protocol number', () => {
    const expectedVersion = 100n;
    const change = VersionChangeType.Version({ version: ProtocolVersion.ProtocolVersion(expectedVersion) });

    expect(
      VersionChangeType.match(change, {
        Version: (vc) => vc.version,
        Next: () => 0n,
      }),
    ).toEqual(expectedVersion);
  });
});

================
File: packages/runtime/src/abstractions/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * as Variant from './Variant.js';
export * as VariantBuilder from './VariantBuilder.js';
export * as WalletLike from './WalletLike.js';
export * from './WalletRuntimeError.js';
export * as StateChange from './StateChange.js';
export * as VersionChangeType from './VersionChangeType.js';

================
File: packages/runtime/src/abstractions/StateChange.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Data } from 'effect';
import { VersionChangeType } from './VersionChangeType.js';

/**
 * A tagged enum data type that represents the state changes across wallet implementation variants.
 *
 * @remarks
 * A variant can report changes in state using the {@link StateChange.State} enum variant. The
 * {@link StateChange.ProgressUpdate} and {@link StateChange.VersionChange} enum variants should be used when a
 * variant needs to report a sync progress update, or a detected change in protocol version respectively.
 */
export type StateChange<TState> = Data.TaggedEnum<{
  /** A change in state. */
  State: { readonly state: TState };

  /** A change in reported progress. */
  ProgressUpdate: {
    /**
     * The number of blocks that remain for the underlying datasource to process in order to be fully synchronized.
     */
    readonly sourceGap: bigint;
    /**
     * The number of blocks that remain for the variant to apply in order to be fully synchronized.
     */
    readonly applyGap: bigint;
  };

  /** A change in Midnight protocol version. */
  VersionChange: { readonly change: VersionChangeType };
}>;
const StateChange = Data.taggedEnum<_StateChange>();

interface _StateChange extends Data.TaggedEnum.WithGenerics<1> {
  readonly taggedEnum: StateChange<this['A']>;
}

/**
 * A type predicate that determines if a given value is a {@link StateChange.State} enum variant.
 */
export const isState = StateChange.$is('State');

/**
 * A type predicate that determines if a given value is a {@link StateChange.ProgressUpdate} enum variant.
 */
export const isProgressUpdate = StateChange.$is('ProgressUpdate');

/**
 * A type predicate that determines if a given value is a {@link StateChange.VersionChange} enum variant.
 */
export const isVersionChange = StateChange.$is('VersionChange');

export const { $match: match, State, ProgressUpdate, VersionChange } = StateChange;

================
File: packages/runtime/src/abstractions/Variant.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/* eslint-disable @typescript-eslint/no-explicit-any -- unknown does not work well as a default, because it causes assignability issues */
import { Scope, SubscriptionRef } from 'effect';
import type { Effect } from 'effect/Effect';
import type { Stream } from 'effect/Stream';
import { Poly } from '@midnight-ntwrk/wallet-sdk-utilities';
import type { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { WalletRuntimeError } from './WalletRuntimeError.js';
import * as StateChange from './StateChange.js';

export interface VariantContext<TState> {
  stateRef: SubscriptionRef.SubscriptionRef<TState>;
}

/**
 * Encapsulates a variant of a wallet implementation.
 *
 * @typeParam TTState The type of state that the variant will operate over.
 * @typeParam TPreviousState The type of state that the variant can migrate from.
 * @typeParam TDomain The variant-specific functionality
 */
export type Variant<
  TTag extends string | symbol,
  TState,
  TPreviousState,
  TRunning extends RunningVariant<TTag, TState>,
> = Poly.WithTag<TTag> & {
  start(context: VariantContext<TState>): Effect<TRunning, WalletRuntimeError, Scope.Scope>;

  migrateState(previousState: TPreviousState): Effect<TState>;
};

export type RunningVariant<TTag extends symbol | string, TState> = Poly.WithTag<TTag> & {
  state: Stream<StateChange.StateChange<TState>, WalletRuntimeError>;
};

/**
 * A utility type that represents any {@link Variant}.
 */
export type AnyVariant = Variant<string | symbol, any, any, AnyRunningVariant>;

export type AnyRunningVariant = RunningVariant<string | symbol, any>;

export type RunningVariantOf<T> =
  T extends VersionedVariant<infer V>
    ? RunningVariantOf<V>
    : T extends Variant<string | symbol, any, any, infer Running>
      ? Running
      : never;

export type StateOf<T> =
  T extends Variant<any, infer S, any, AnyRunningVariant>
    ? S
    : T extends VersionedVariant<infer V>
      ? StateOf<V>
      : never;

export type PreviousStateOf<T> =
  T extends VersionedVariant<infer V>
    ? PreviousStateOf<V>
    : T extends Variant<string | symbol, unknown, infer S, any>
      ? S
      : never;

/**
 * An array of {@link Variant} instances.
 */
export type AnyVariantArray = AnyVariant[];

/**
 * A type that associates a {@link Variant} with a given version of the Midnight protocol.
 */
export type VersionedVariant<T extends AnyVariant> = Readonly<{
  sinceVersion: ProtocolVersion.ProtocolVersion;
  variant: T;
}>;

export type AnyVersionedVariant = VersionedVariant<AnyVariant>;

/**
 * An ordered array of types that associates a {@link Variant} with a given version of the Midnight protocol.
 *
 * @remarks
 * The expected order of the variants will be ascending on `sinceVersion`.
 */
export type AnyVersionedVariantArray = AnyVersionedVariant[];

export type VariantTag<T> =
  T extends VersionedVariant<infer V> ? VariantTag<V> : T extends Poly.WithTag<infer Tag> ? Tag : never;
export type VariantRecord<Variants> = Variants extends [infer THead, ...infer TRest]
  ? { readonly [K in VariantTag<THead>]: THead } & VariantRecord<TRest>
  : Variants extends []
    ? object
    : never;
export const getVersionedVariantTag = <Variant extends AnyVariant>(v: VersionedVariant<Variant>): VariantTag<Variant> =>
  Poly.getTag(v.variant) as VariantTag<Variant>;
export const makeVersionedRecord = <Variants extends AnyVersionedVariantArray>(
  variants: Variants,
): VariantRecord<Variants> => {
  return variants.reduce((acc: Partial<VariantRecord<Variants>>, variant) => {
    return { ...acc, [getVersionedVariantTag(variant)]: variant };
  }, {}) as VariantRecord<Variants>;
};

================
File: packages/runtime/src/abstractions/VariantBuilder.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { AnyVariant, VersionedVariant } from './Variant.js';

/**
 * Builds a target {@link Variant} object from internal build state.
 *
 * @typeParam TTState The type of state that the variant will operate over.
 * @typeParam TPreviousState The type of state that the variant can migrate from.
 * @typeParam TConfiguration A type representing the configuration required by the variant.
 */

export interface VariantBuilder<TVariant extends AnyVariant, TConfiguration extends object = object> {
  /**
   * Builds the target variant object from the internal build state.
   *
   * @param configuration The configuration to use when building the target variant.
   *
   * @returns An instance of {@link Variant} that operates over `TState`.
   */
  build(configuration: TConfiguration): TVariant;
}

/**
 * Base type that represents variant configuration.
 */
export type AnyBuilderConfiguration = object;

/**
 * A utility type that represents any {@link VariantBuilder}.
 */
export type AnyVariantBuilder = VariantBuilder<AnyVariant, AnyBuilderConfiguration>;

export type VariantOf<T> =
  T extends VersionedVariantBuilder<infer TBuilder>
    ? VariantOf<TBuilder>
    : T extends VariantBuilder<infer TVariant, object>
      ? TVariant
      : never;

export type VersionedVariantBuilder<TBuilder extends AnyVariantBuilder> = Readonly<{
  sinceVersion: ProtocolVersion.ProtocolVersion;
  variantBuilder: TBuilder;
}>;

export type VariantsOf<T> = T extends [infer THead, ...infer TRest]
  ? [VariantOf<THead>, ...VariantsOf<TRest>]
  : T extends []
    ? []
    : never;

export type VersionedVariantsOf<T> = T extends [infer THead, ...infer Rest]
  ? [VersionedVariant<VariantOf<THead>>, ...VersionedVariantsOf<Rest>]
  : T extends []
    ? []
    : never;

export type ConfigurationOf<T> =
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  T extends VariantBuilder<any, infer Config>
    ? Config
    : T extends VersionedVariantBuilder<infer Builder>
      ? ConfigurationOf<Builder>
      : never;

/**
 * A type that associates a {@link VariantBuilder} with a given version of the Midnight protocol.
 */
export type AnyVersionedVariantBuilder = VersionedVariantBuilder<AnyVariantBuilder>;

================
File: packages/runtime/src/abstractions/VersionChangeType.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Data } from 'effect';
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';

/**
 * A tagged enum data type that represents a change in Midnight protocol versions.
 *
 * @remarks
 * A specific protocol version can be specified using the {@link VersionChangeType.Version} enum variant. It has a
 * `version` property that accepts a {@link ProtocolVersion} value for a known protocol version.
 * For use cases where a specific protocol version cannot be given, the {@link VersionChangeType.Next} enum variant
 * can be used. Its use is context specific.
 */
export type VersionChangeType = Data.TaggedEnum<{
  /** A change to a particular protocol version. */
  Version: { readonly version: ProtocolVersion.ProtocolVersion };

  /** A change to the 'next' protocol version. Particularly useful in testing */
  Next: {}; // eslint-disable-line @typescript-eslint/no-empty-object-type
}>;
const VersionChangeType = Data.taggedEnum<VersionChangeType>();

/**
 * A type predicate that determines if a given value is a {@link VersionChangeType.Version} enum variant.
 */
export const isVersion = VersionChangeType.$is('Version');

/**
 * A type predicate that determines if a given value is a {@link VersionChangeType.Next} enum variant.
 */
export const isNext = VersionChangeType.$is('Next');

export const { $match: match, Version, Next } = VersionChangeType;

================
File: packages/runtime/src/abstractions/WalletRuntimeError.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Data } from 'effect';

export class WalletRuntimeError extends Data.TaggedError('WalletRuntimeError')<{ message: string; cause?: unknown }> {}

================
File: packages/runtime/src/test/runtime.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Effect } from 'effect';
import * as rx from 'rxjs';
import { describe, expect, it } from 'vitest';
import { VersionChangeType } from '../abstractions/index.js';
import { toProtocolStateArray } from '../testing/utils.js';
import {
  InterceptingRunningVariant,
  InterceptingVariantBuilder,
  Numeric,
  NumericMultiplier,
  NumericRangeBuilder,
  NumericRangeMultiplierBuilder,
} from '../testing/variants.js';
import { WalletBuilder } from '../WalletBuilder.js';

describe('Wallet runtime', () => {
  it('allows to dispatch a poly function on a running variant', async () => {
    const interceptingTag = 'intercept' as const;
    const builder = WalletBuilder.init()
      // Have the first variant complete after producing two values, signifying a protocol change.
      .withVariant(ProtocolVersion.MinSupportedVersion, new NumericRangeBuilder(2))
      .withVariant(
        ProtocolVersion.ProtocolVersion(50n),
        new InterceptingVariantBuilder<typeof interceptingTag, number>(interceptingTag),
      )
      .withVariant(ProtocolVersion.ProtocolVersion(100n), new NumericRangeMultiplierBuilder());
    const Wallet = builder.build({
      min: 0,
      max: 4,
      multiplier: 2,
    });
    const wallet = Wallet.startEmpty(Wallet);

    const allCollectedState = toProtocolStateArray<number>(wallet.rawState.pipe(rx.take(6)));

    // Let's wait for the intercepting variant to be initiated to remove any chance of races
    await rx.firstValueFrom(
      wallet.rawState.pipe(rx.find(({ version }) => version == ProtocolVersion.ProtocolVersion(50n))),
    );

    const dispatchResult = await wallet.runtime
      .dispatch({
        [Numeric]: () => Effect.succeed(false),
        [NumericMultiplier]: () => Effect.succeed(false),
        [interceptingTag]: (interceptingVariant) =>
          interceptingVariant
            .emitProtocolVersionChange(VersionChangeType.Version({ version: ProtocolVersion.ProtocolVersion(100n) }))
            .pipe(Effect.as(true)),
      })
      .pipe(Effect.runPromise);

    expect(dispatchResult).toBe(true);
    expect(await allCollectedState).toEqual([
      { version: ProtocolVersion.MinSupportedVersion, state: 0 },
      { version: ProtocolVersion.MinSupportedVersion, state: 0 },
      { version: ProtocolVersion.MinSupportedVersion, state: 1 },
      { version: ProtocolVersion.ProtocolVersion(50n), state: 1 }, // This is expected to be emitted by the intercepting variant
      { version: ProtocolVersion.ProtocolVersion(100n), state: 4 }, // This is the rest
      { version: ProtocolVersion.ProtocolVersion(100n), state: 6 },
    ]);
  });

  it('allows wallet to implement own starting procedure', async () => {
    const builder = WalletBuilder.init()
      .withVariant(ProtocolVersion.MinSupportedVersion, new NumericRangeBuilder(2))
      .withVariant(ProtocolVersion.ProtocolVersion(100n), new NumericRangeMultiplierBuilder());
    const BaseWallet = builder.build({
      min: 0,
      max: 46,
      multiplier: 2,
    });
    class Wallet extends BaseWallet {
      static startFrom(nr: number): Wallet {
        return Wallet.startFirst(Wallet, nr);
      }
    }

    const wallet = Wallet.startFrom(42);

    expect(wallet).toBeInstanceOf(BaseWallet);
    expect(wallet).toBeInstanceOf(Wallet);

    const state = wallet.rawState.pipe(rx.take(6)); // We expect five values + the initial one.
    const receivedStates = await toProtocolStateArray(state);

    expect(receivedStates).toEqual([
      { version: ProtocolVersion.MinSupportedVersion, state: 42 },
      { version: ProtocolVersion.MinSupportedVersion, state: 42 },
      { version: ProtocolVersion.MinSupportedVersion, state: 43 },
      // The second variant starts applying the multiplier to the state (represents a protocol change).
      { version: ProtocolVersion.ProtocolVersion(100n), state: 88 },
      { version: ProtocolVersion.ProtocolVersion(100n), state: 90 },
      { version: ProtocolVersion.ProtocolVersion(100n), state: 92 },
    ]);
  });

  it('allows to start from arbitrary variant by providing its state', async () => {
    const Intercepting = 'intercepting' as const;
    const builder = WalletBuilder.init()
      .withVariant(ProtocolVersion.MinSupportedVersion, new NumericRangeBuilder(2))
      .withVariant(
        ProtocolVersion.ProtocolVersion(50n),
        new InterceptingVariantBuilder<typeof Intercepting, number>(Intercepting),
      )
      .withVariant(ProtocolVersion.ProtocolVersion(100n), new NumericRangeMultiplierBuilder());
    const Wallet = builder.build({
      min: 0,
      max: 44,
      multiplier: 2,
    });
    const wallet = Wallet.start(Wallet, Intercepting, 42);

    const state = wallet.rawState.pipe(rx.take(3));

    await wallet.runtime
      .dispatch({
        [Numeric]: () => Effect.void,
        [NumericMultiplier]: () => Effect.void,
        [Intercepting]: (interceptingVariant: InterceptingRunningVariant<typeof Intercepting, number>) =>
          interceptingVariant.emitProtocolVersionChange(VersionChangeType.Next()),
      })
      .pipe(Effect.runPromise);

    const receivedStates = await toProtocolStateArray(state);

    expect(receivedStates).toEqual([
      { version: ProtocolVersion.ProtocolVersion(50n), state: 42 }, // this is the state we provided, and runtime automatically emits it
      { version: ProtocolVersion.ProtocolVersion(100n), state: 86 },
      { version: ProtocolVersion.ProtocolVersion(100n), state: 88 },
    ]);
  });

  it('allows to start from the first variant by providing its state', async () => {
    const builder = WalletBuilder.init()
      .withVariant(ProtocolVersion.MinSupportedVersion, new NumericRangeBuilder(2))
      .withVariant(ProtocolVersion.ProtocolVersion(100n), new NumericRangeMultiplierBuilder());
    const Wallet = builder.build({
      min: 0,
      max: 46,
      multiplier: 2,
    });

    const wallet = Wallet.startFirst(Wallet, 42);

    const state = wallet.rawState.pipe(rx.take(6)); // We expect five values.
    const receivedStates = await toProtocolStateArray(state);

    expect(receivedStates).toEqual([
      { version: ProtocolVersion.MinSupportedVersion, state: 42 }, // The initial state is emitted both by runtime and the variant
      { version: ProtocolVersion.MinSupportedVersion, state: 42 },
      { version: ProtocolVersion.MinSupportedVersion, state: 43 },
      // The second variant starts applying the multiplier to the state (represents a protocol change).
      { version: ProtocolVersion.ProtocolVersion(100n), state: 88 },
      { version: ProtocolVersion.ProtocolVersion(100n), state: 90 },
      { version: ProtocolVersion.ProtocolVersion(100n), state: 92 },
    ]);
  });
});

================
File: packages/runtime/src/test/walletBuilder.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ProtocolState, ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Equal, Expect } from '@midnight-ntwrk/wallet-sdk-utilities/types';
import { Effect, Option, PubSub, Scope, Stream } from 'effect';
import * as rx from 'rxjs';
import { describe, expect, it } from 'vitest';
import { StateChange, Variant, VariantBuilder, WalletLike } from '../abstractions/index.js';
import { Runtime } from '../Runtime.js';
import { isRange, reduceToChunk, toProtocolStateArray } from '../testing/utils.js';
import {
  NumericRange,
  NumericRangeBuilder,
  NumericRangeMultiplier,
  NumericRangeMultiplierBuilder,
  RangeConfig,
} from '../testing/variants.js';
import { WalletBuilder } from '../WalletBuilder.js';

describe('Wallet Builder', () => {
  describe('without variants', () => {
    it('should not build a valid wallet', () => {
      //TODO: it should be possible to play with types to hide build method unless variant is registered
      expect(() => WalletBuilder.init().build()).toThrow();
    });
  });

  it('should support single variant implementations', async () => {
    const builder = WalletBuilder.init().withVariant(ProtocolVersion.MinSupportedVersion, new NumericRangeBuilder());
    const Wallet = builder.build({
      min: 0,
      max: 1,
    });
    const wallet = Wallet.startEmpty(Wallet);

    type _1 = Expect<
      Equal<typeof Wallet, WalletLike.BaseWalletClass<[Variant.VersionedVariant<NumericRange>], RangeConfig>>
    >;
    type _2 = Expect<Equal<typeof wallet, WalletLike.WalletLike<[Variant.VersionedVariant<NumericRange>]>>>;
    type _3 = Expect<Equal<typeof wallet.runtime, Runtime<[Variant.VersionedVariant<NumericRange>]>>>;
    type _4 = Expect<Equal<typeof wallet.rawState, rx.Observable<ProtocolState.ProtocolState<number>>>>;

    expect(wallet).toBeDefined();

    const state = wallet.rawState.pipe(rx.take(3)); // We expect two values.
    const receivedStates = await toProtocolStateArray(state);

    expect(receivedStates).toEqual([
      { version: ProtocolVersion.MinSupportedVersion, state: 0 },
      { version: ProtocolVersion.MinSupportedVersion, state: 0 },
      { version: ProtocolVersion.MinSupportedVersion, state: 1 },
    ]);
  });

  it('should support multiple variant implementations through state migration', async () => {
    const builder = WalletBuilder.init()
      // Have the first variant complete after producing two values, signifying a protocol change.
      .withVariant(ProtocolVersion.MinSupportedVersion, new NumericRangeBuilder(2))
      .withVariant(ProtocolVersion.ProtocolVersion(100n), new NumericRangeMultiplierBuilder());

    const Wallet = builder.build({
      min: 0,
      max: 4,
      multiplier: 2,
    });
    const wallet = Wallet.startEmpty(Wallet);

    type Variants = [Variant.VersionedVariant<NumericRange>, Variant.VersionedVariant<NumericRangeMultiplier>];
    type _1 = Expect<Equal<typeof wallet, WalletLike.WalletLike<Variants>>>;
    type _2 = Expect<Equal<typeof wallet.runtime, Runtime<Variants>>>;
    type _3 = Expect<Equal<typeof wallet.rawState, rx.Observable<ProtocolState.ProtocolState<number>>>>;

    expect(wallet).toBeDefined();

    const state = wallet.rawState.pipe(rx.take(6)); // We expect five values.
    const receivedStates = await toProtocolStateArray(state);

    expect(receivedStates).toEqual([
      { version: ProtocolVersion.MinSupportedVersion, state: 0 },
      { version: ProtocolVersion.MinSupportedVersion, state: 0 },
      { version: ProtocolVersion.MinSupportedVersion, state: 1 },
      // The second variant starts applying the multiplier to the state (represents a protocol change).
      { version: ProtocolVersion.ProtocolVersion(100n), state: 4 },
      { version: ProtocolVersion.ProtocolVersion(100n), state: 6 },
      { version: ProtocolVersion.ProtocolVersion(100n), state: 8 },
    ]);
  });

  it('should stop variant once stop is called', async () => {
    const pubsub = Effect.runSync(PubSub.bounded<number>({ capacity: 1, replay: 1 }));

    const pubSubVariantBuilder: VariantBuilder.VariantBuilder<
      Variant.Variant<'pubsub', number, null, Variant.RunningVariant<'pubsub', number>>
    > = {
      build: () => {
        return {
          __polyTag__: 'pubsub',
          start(context) {
            return Stream.fromEffect(context.stateRef.get).pipe(
              Stream.flatMap((state) => {
                return Stream.unfold(state, (previous: number) => {
                  const next = previous + 1;
                  return Option.some([next, next] as const);
                });
              }),
              Stream.mapEffect((value) => PubSub.publish(pubsub, value).pipe(Effect.delay(1))),
              Stream.takeUntilEffect(() => PubSub.isShutdown(pubsub)),
              Stream.runDrain,
              Effect.forkScoped,
              Effect.flatMap(() => Scope.Scope),
              Effect.map((scope) => ({
                __polyTag__: 'pubsub',
                state: Stream.acquireRelease(Effect.succeed(pubsub), () => PubSub.shutdown(pubsub)).pipe(
                  Stream.mapEffect(PubSub.subscribe),
                  Stream.flatMap(Stream.fromQueue),
                  Stream.map((number) => StateChange.State({ state: number })),
                  Stream.provideService(Scope.Scope, scope),
                ),
              })),
            );
          },
          migrateState() {
            return Effect.succeed(0);
          },
        };
      },
    };

    const Wallet = WalletBuilder.init().withVariant(ProtocolVersion.MinSupportedVersion, pubSubVariantBuilder).build();
    const wallet = Wallet.startEmpty(Wallet);

    const stopSubject = new rx.Subject<boolean>();

    const valuesP = rx.firstValueFrom(
      wallet.rawState.pipe(rx.map(ProtocolState.state), rx.takeUntil(stopSubject), rx.takeLast(5), reduceToChunk()),
    );

    await wallet.stop();
    stopSubject.next(true);

    const values = await valuesP;

    const isShutDown = await PubSub.awaitShutdown(pubsub).pipe(
      Effect.timeoutTo({
        duration: 1_000,
        onTimeout: () => PubSub.shutdown(pubsub).pipe(Effect.as(false)),
        onSuccess: () => Effect.succeed(true),
      }),
      Effect.flatten,
      Effect.runPromise,
    );

    expect(isRange(values)).toBe(true);
    expect(isShutDown).toBe(true);
  });

  const staticConfigCases = [
    () => {
      const config = {
        min: 0,
        max: 1,
      };
      return {
        config: config,
        Wallet: WalletBuilder.init()
          .withVariant(ProtocolVersion.MinSupportedVersion, new NumericRangeBuilder())
          .build(config),
      };
    },
    () => {
      const config = {
        min: 0,
        max: 4,
        multiplier: 2,
      };
      return {
        config: config,
        Wallet: WalletBuilder.init()
          .withVariant(ProtocolVersion.MinSupportedVersion, new NumericRangeBuilder(2))
          .withVariant(ProtocolVersion.ProtocolVersion(100n), new NumericRangeMultiplierBuilder())
          .build(config),
      };
    },
  ] as const;

  it.each(staticConfigCases)('should make config available statically', (factory) => {
    const { Wallet, config } = factory();
    expect(Wallet.configuration).toEqual(config);
  });
});

================
File: packages/runtime/src/test/walletBuilderType.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { CanAssign, Equal, Expect } from '@midnight-ntwrk/wallet-sdk-utilities/types';
import { VariantBuilder } from '../abstractions/index.js';
import { WalletBuilder } from '../WalletBuilder.js';
import {
  InterceptingVariantBuilder,
  NumericRangeBuilder,
  NumericRangeMultiplierBuilder,
  RangeConfig,
  RangeMultiplierConfig,
} from '../testing/variants.js';
import { describe, it } from 'vitest';

describe('WalletBuilder', () => {
  describe('inferring configuration type', () => {
    it('infers undefined for no variants', () => {
      type _1 = Expect<Equal<WalletBuilder.FullConfiguration<[]>, unknown>>;
    });

    it('infers undefined for a variant with no effective configuration to pass', () => {
      type _11 = Expect<
        Equal<
          WalletBuilder.FullConfiguration<
            [VariantBuilder.VersionedVariantBuilder<InterceptingVariantBuilder<string, string>>]
          >,
          object
        >
      >;
    });

    it('infers an expected intersection type with multiple variants', () => {
      //Note: CanAssign assertion is used because the exact types are following the pattern object & Variant1Config & Variant2Config
      type _2 = Expect<
        Equal<
          WalletBuilder.FullConfiguration<[VariantBuilder.VersionedVariantBuilder<NumericRangeBuilder>]>,
          RangeConfig
        >
      >;
      type _3 = Expect<
        CanAssign<
          RangeConfig,
          WalletBuilder.FullConfiguration<
            [
              VariantBuilder.VersionedVariantBuilder<NumericRangeBuilder>,
              VariantBuilder.VersionedVariantBuilder<InterceptingVariantBuilder<string, string>>,
            ]
          >
        >
      >;
      type _4 = Expect<
        CanAssign<
          RangeMultiplierConfig,
          WalletBuilder.FullConfiguration<
            [
              VariantBuilder.VersionedVariantBuilder<NumericRangeBuilder>,
              VariantBuilder.VersionedVariantBuilder<InterceptingVariantBuilder<string, string>>,
              VariantBuilder.VersionedVariantBuilder<NumericRangeMultiplierBuilder>,
            ]
          >
        >
      >;
    });
  });

  describe('inferring build parameters type', () => {
    it('infers no parameters for no variants', () => {
      type _1 = Expect<Equal<WalletBuilder.BuildArguments<[]>, []>>;
    });

    it('infers no parameters if variant does not have effective config', () => {
      type _1 = Expect<
        Equal<
          WalletBuilder.BuildArguments<
            [VariantBuilder.VersionedVariantBuilder<InterceptingVariantBuilder<string, string>>]
          >,
          []
        >
      >;
    });

    it('infers proper type for single variant', () => {
      type _1 = Expect<
        Equal<
          WalletBuilder.BuildArguments<[VariantBuilder.VersionedVariantBuilder<NumericRangeBuilder>]>,
          [RangeConfig]
        >
      >;
      type _2 = Expect<
        Equal<
          WalletBuilder.BuildArguments<[VariantBuilder.VersionedVariantBuilder<NumericRangeMultiplierBuilder>]>,
          [RangeMultiplierConfig]
        >
      >;
    });

    it('infers proper type for multiple variants', () => {
      type _1 = Expect<
        CanAssign<
          [RangeConfig],
          WalletBuilder.BuildArguments<
            [
              VariantBuilder.VersionedVariantBuilder<NumericRangeBuilder>,
              VariantBuilder.VersionedVariantBuilder<InterceptingVariantBuilder<string, string>>,
            ]
          >
        >
      >;
      type _2 = Expect<
        CanAssign<
          [RangeMultiplierConfig],
          WalletBuilder.BuildArguments<
            [
              VariantBuilder.VersionedVariantBuilder<NumericRangeBuilder>,
              VariantBuilder.VersionedVariantBuilder<InterceptingVariantBuilder<string, string>>,
              VariantBuilder.VersionedVariantBuilder<NumericRangeMultiplierBuilder>,
            ]
          >
        >
      >;
    });
  });
});

================
File: packages/runtime/src/test/walletState.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import * as rx from 'rxjs';
import { describe, expect, it, vi } from 'vitest';
import { toProtocolStateArray } from '../testing/utils.js';
import { NumericRangeBuilder } from '../testing/variants.js';
import { WalletBuilder } from '../WalletBuilder.js';

describe('Wallet', () => {
  describe('state', () => {
    it('should report errors', async () => {
      const builder = WalletBuilder.init()
        // Have the variant throw an error after producing two elements.
        .withVariant(ProtocolVersion.MinSupportedVersion, new NumericRangeBuilder(2, true));
      const Wallet = builder.build({
        min: 0,
        max: 9,
      });
      const wallet = Wallet.startEmpty(Wallet);

      expect(wallet).toBeDefined();

      const errorHandler = vi.fn();
      const receivedStates = await toProtocolStateArray<number>(wallet.rawState.pipe(rx.take(4)), errorHandler);

      expect(receivedStates).toEqual([
        { version: ProtocolVersion.MinSupportedVersion, state: 0 }, // The initial state is emitted both by runtime and the variant
        { version: ProtocolVersion.MinSupportedVersion, state: 0 },
        { version: ProtocolVersion.MinSupportedVersion, state: 1 },
      ]);
      expect(errorHandler).toHaveBeenCalled();
    });
  });
});

================
File: packages/runtime/src/testing/utils.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ProtocolState } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Chunk } from 'effect';
import { Observable, OperatorFunction, reduce } from 'rxjs';

/**
 * Utility function that takes state values from an RxJS observable until it completes or errors.
 *
 * @param observable The RxJS observable from which state values should be read.
 * @param onErrCallback An optional callback to invoke if an error is encountered reading a state value.
 * @returns A `Promise` that resolves with an array of state values that were received before encountering
 * any error.
 *
 * @internal
 */
export const toProtocolStateArray = <T>(
  observable: Observable<ProtocolState.ProtocolState<T>>,
  onErrCallback?: (err: unknown) => void,
): Promise<ProtocolState.ProtocolState<T>[]> =>
  new Promise<ProtocolState.ProtocolState<T>[]>((resolve) => {
    const receivedStates: ProtocolState.ProtocolState<T>[] = [];

    observable.subscribe({
      next(value) {
        receivedStates.push(value);
      },
      complete() {
        resolve(receivedStates);
      },
      error(err) {
        onErrCallback?.call(undefined, err);
        resolve(receivedStates);
      },
    });
  });

export const reduceToChunk = <T>(): OperatorFunction<T, Chunk.Chunk<T>> =>
  reduce((chunk, value) => Chunk.append(chunk, value), Chunk.empty<T>());

export const isRange = (values: Chunk.Chunk<number>): boolean => {
  const firstDropped = Chunk.drop(values, 1);
  const lastDropped = Chunk.dropRight(values, 1);
  return Chunk.zip(lastDropped, firstDropped).pipe(Chunk.every(([l, r]) => r == l + 1));
};

================
File: packages/runtime/src/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * from './WalletBuilder.js';
export * as Runtime from './Runtime.js';

================
File: packages/runtime/src/Runtime.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Either, Exit, Option, Scope, Stream, SubscriptionRef, SynchronizedRef } from 'effect';
import { ProtocolState, ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { StateChange, Variant, VersionChangeType, WalletRuntimeError } from './abstractions/index.js';
import { EitherOps, HList, Poly } from '@midnight-ntwrk/wallet-sdk-utilities';

/**
 * The {@link Runtime} service type.
 */
export interface Runtime<Variants extends Variant.AnyVersionedVariantArray> {
  readonly stateChanges: Stream.Stream<
    ProtocolState.ProtocolState<Variant.StateOf<HList.Each<Variants>>>,
    WalletRuntimeError
  >;

  readonly progress: Effect.Effect<Progress>;

  readonly currentVariant: Effect.Effect<EachRunningVariant<Variants>>;

  dispatch<TResult, E = never>(
    impl: Poly.PolyFunction<Variant.RunningVariantOf<HList.Each<Variants>>, Effect.Effect<TResult, E>>,
  ): Effect.Effect<TResult, WalletRuntimeError | E>;
}

export type RunningVariant<
  TVariant extends Variant.AnyVersionedVariant,
  TRest extends Variant.AnyVersionedVariantArray,
> = Poly.WithTagFrom<TVariant['variant']> & {
  variant: TVariant;
  runningVariant: Variant.RunningVariantOf<TVariant>;
  initialState: Variant.StateOf<TVariant>;
  variantScope: Scope.CloseableScope;
  currentStateRef: SynchronizedRef.SynchronizedRef<Variant.StateOf<TVariant>>;
  restVariants: TRest;
  initProtocolVersion: ProtocolVersion.ProtocolVersion;
  validVersionRange: ProtocolVersion.ProtocolVersion.Range;
  nextProtocolVersion: ProtocolVersion.ProtocolVersion | null;
};
type EachRunningVariant<TAll extends Variant.AnyVersionedVariantArray> = TAll extends [
  infer THead extends Variant.AnyVersionedVariant,
  ...infer TRest extends Variant.AnyVersionedVariantArray,
]
  ? RunningVariant<THead, TRest> | EachRunningVariant<TRest>
  : never;
/**
 * A type that represents the reported progress of a variant expressed in terms of gaps to reaching synced
 * progress in application site and data source site
 */
type Progress = { readonly sourceGap: bigint; readonly applyGap: bigint };

export type InitRuntimeHeadArgs<Variants extends Variant.AnyVersionedVariantArray> = {
  variants: Variants;
  state: Variant.StateOf<HList.Head<Variants>>;
};
export const initHead = <Variants extends Variant.AnyVersionedVariantArray>(
  initArgs: InitRuntimeHeadArgs<Variants>,
): Effect.Effect<Runtime<Variants>, WalletRuntimeError, Scope.Scope> => {
  const headVariant: HList.Head<Variants> = HList.head(initArgs.variants);
  return init({
    variants: initArgs.variants,
    tag: Poly.getTag(headVariant.variant),
    state: initArgs.state,
  });
};

export type InitRuntimeArgs<Variants extends Variant.AnyVersionedVariantArray, InitTag extends string | symbol> = {
  variants: Variants;
  tag: InitTag;
  state: Variant.StateOf<HList.Find<Variants, { variant: Poly.WithTag<InitTag> }>>;
};
export const init = <Variants extends Variant.AnyVersionedVariantArray, InitTag extends string | symbol>(
  initArgs: InitRuntimeArgs<Variants, InitTag>,
): Effect.Effect<Runtime<Variants>, WalletRuntimeError, Scope.Scope> => {
  //Rewritten from generators to better track type issues reported
  return Effect.Do.pipe(
    Effect.bind('initiatedFirstVariant', () => initVariant(initArgs)),
    Effect.bind('currentStateRef', ({ initiatedFirstVariant }) =>
      initiatedFirstVariant.currentStateRef.get.pipe(
        Effect.flatMap((state: Variant.StateOf<HList.Each<Variants>>) =>
          SubscriptionRef.make<
            Either.Either<ProtocolState.ProtocolState<Variant.StateOf<HList.Each<Variants>>>, WalletRuntimeError>
          >(Either.right({ version: initiatedFirstVariant.initProtocolVersion, state })),
        ),
      ),
    ),
    Effect.bind('progressRef', () => SynchronizedRef.make<Progress>({ applyGap: 0n, sourceGap: 0n })),
    Effect.bind('currentVariantRef', ({ initiatedFirstVariant }) =>
      Effect.acquireRelease(SynchronizedRef.make<EachRunningVariant<Variants>>(initiatedFirstVariant), (ref, exit) =>
        Effect.gen(function* () {
          // This is needed to properly close variant scope when whole runtime closes
          // Otherwise variant would be running in the background
          const runningVariant = yield* SynchronizedRef.get(ref);
          yield* Scope.close(runningVariant.variantScope, exit);
        }),
      ),
    ),
    Effect.bind('runningStream', ({ initiatedFirstVariant, currentStateRef, progressRef, currentVariantRef }) => {
      return runVariantStream(initiatedFirstVariant, currentStateRef, progressRef, currentVariantRef).pipe(
        Effect.catchAll((error: WalletRuntimeError) => {
          return SubscriptionRef.set(currentStateRef, Either.left(error));
        }),
        Effect.forkScoped,
      );
    }),
    Effect.flatMap(
      ({ currentStateRef, progressRef, currentVariantRef }): Effect.Effect<Runtime<Variants>, never, Scope.Scope> => {
        return Effect.gen(function* () {
          const changesStream = yield* currentStateRef.changes.pipe(
            Stream.mapEffect((value) => EitherOps.toEffect(value)),
            Stream.share({ capacity: 'unbounded', replay: 1 }),
          );
          const runtime = {
            stateChanges: changesStream,
            progress: progressRef.get,
            currentVariant: currentVariantRef.get,
            dispatch: <TResult, E = never>(
              impl: Poly.PolyFunction<Variant.RunningVariantOf<HList.Each<Variants>>, Effect.Effect<TResult, E>>,
            ): Effect.Effect<TResult, WalletRuntimeError | E> => dispatch(runtime, impl),
          };

          return runtime;
        });
      },
    ),
  );
};

export const dispatch = <Variants extends Variant.AnyVersionedVariantArray, TResult, E = never>(
  runtime: Runtime<Variants>,
  impl: Poly.PolyFunction<Variant.RunningVariantOf<HList.Each<Variants>>, Effect.Effect<TResult, E>>,
): Effect.Effect<TResult, WalletRuntimeError | E> => {
  return runtime.currentVariant.pipe(
    Effect.flatMap((current) =>
      Poly.dispatch(current.runningVariant as Variant.RunningVariantOf<HList.Each<Variants>>, impl),
    ),
  );
};

type MigrateArgs<Variants extends Variant.AnyVersionedVariantArray> = {
  variants: Variants;
  state: Variant.PreviousStateOf<HList.Head<Variants>>;
  initProtocolVersion?: ProtocolVersion.ProtocolVersion;
};
const migrateToNextVariant = <Variants extends Variant.AnyVersionedVariantArray>(
  migrateArgs: MigrateArgs<Variants>,
): Effect.Effect<EachRunningVariant<Variants>, WalletRuntimeError> => {
  return Effect.gen(function* () {
    const [headVersionedVariant] = migrateArgs.variants;
    if (!headVersionedVariant) {
      yield* Effect.fail(new WalletRuntimeError({ message: 'No variant to init' }));
    }

    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- It seems that TS is defaulting to the constraint provided for a generic type with its inference, which includes any
    const newState = yield* headVersionedVariant.variant.migrateState(migrateArgs.state);

    return yield* initHeadVariant({
      variants: migrateArgs.variants,
      state: newState as Variant.StateOf<HList.Head<Variants>>,
      initProtocolVersion: migrateArgs.initProtocolVersion,
    });
  });
};

type InitArgs<Variants extends Variant.AnyVersionedVariantArray, TTag extends string | symbol> = {
  variants: Variants;
  tag: TTag;
  state: Variant.StateOf<HList.Find<Variants, { variant: Poly.WithTag<TTag> }>>;
};
// Arguments are gathered to a separate type because presence of HList.Find is crashing TS compiler ¯\_(ツ)_/¯
const initVariant = <Variants extends Variant.AnyVersionedVariantArray, TTag extends string | symbol>(
  init: InitArgs<Variants, TTag>,
): Effect.Effect<EachRunningVariant<Variants>, WalletRuntimeError> => {
  return Effect.gen(function* () {
    const index = init.variants.findIndex((variant) => Poly.getTag(variant.variant) === init.tag);
    const theRest = init.variants.toSpliced(0, index);

    //These casts are terrible, but they allow to call the initHeadVariant
    return yield* initHeadVariant({
      variants: theRest as Variants,
      state: init.state as unknown as Variant.StateOf<HList.Head<Variants>>,
      initProtocolVersion: undefined,
    });
  });
};

type InitHeadArgs<Variants extends Variant.AnyVersionedVariantArray> = {
  variants: Variants;
  state: Variant.StateOf<HList.Head<Variants>>;
  initProtocolVersion: ProtocolVersion.ProtocolVersion | undefined;
};
// Following pattern from `initVariant` for consistency
const initHeadVariant = <Variants extends Variant.AnyVersionedVariantArray>(
  init: InitHeadArgs<Variants>,
): Effect.Effect<EachRunningVariant<Variants>, WalletRuntimeError> => {
  return Effect.gen(function* () {
    const [anyHeadVersionedVariant, maybeNextVersionedVariant] = init.variants;
    if (!anyHeadVersionedVariant) {
      yield* Effect.fail(new WalletRuntimeError({ message: 'No variant to init' }));
    }
    const headVersionedVariant = anyHeadVersionedVariant as HList.Head<Variants> & Variant.AnyVersionedVariant;

    const actualInitProtocolVersion = init.initProtocolVersion ?? headVersionedVariant.sinceVersion;
    const nextActivationVersion = maybeNextVersionedVariant
      ? maybeNextVersionedVariant.sinceVersion
      : ProtocolVersion.MaxSupportedVersion;
    const validVersionRange = ProtocolVersion.makeRange(headVersionedVariant.sinceVersion, nextActivationVersion);

    const stateRef = yield* SubscriptionRef.make(init.state);
    const variantScope = yield* Scope.make();
    const runningVariant = yield* headVersionedVariant.variant
      .start({ stateRef })
      .pipe(Effect.provideService(Scope.Scope, variantScope)) as Effect.Effect<
      Variant.RunningVariantOf<HList.Head<Variants>>,
      WalletRuntimeError
    >;
    //This type declaration helps with setting right properties...
    const out: RunningVariant<HList.Head<Variants> & Variant.AnyVersionedVariant, HList.Tail<Variants>> = {
      __polyTag__: headVersionedVariant.variant.__polyTag__ as Poly.TagOf<HList.Each<Variants>['variant']>,
      variant: headVersionedVariant,
      initialState: init.state,
      runningVariant: runningVariant,
      currentStateRef: stateRef,
      restVariants: HList.tail(init.variants),
      initProtocolVersion: actualInitProtocolVersion,
      validVersionRange,
      nextProtocolVersion: maybeNextVersionedVariant ? maybeNextVersionedVariant.sinceVersion : null,
      variantScope,
    };
    // ...while this type casting makes things bearable in the rest of the code (TS's type inference is great, but still limited)
    return out as unknown as EachRunningVariant<Variants>;
  });
};

const runVariantStream = <Variants extends Variant.AnyVersionedVariantArray>(
  initiatedVariant: EachRunningVariant<Variants>,
  stateRef: SubscriptionRef.SubscriptionRef<
    Either.Either<ProtocolState.ProtocolState<Variant.StateOf<HList.Each<Variants>>>, WalletRuntimeError>
  >,
  progressRef: SynchronizedRef.SynchronizedRef<Progress>,
  currentVariantRef: SynchronizedRef.SynchronizedRef<EachRunningVariant<Variants>>,
): Effect.Effect<void, WalletRuntimeError> => {
  type Accumulator = {
    protocolVersion: ProtocolVersion.ProtocolVersion;
    followEffect: Effect.Effect<void, WalletRuntimeError>;
    shouldInitChange: boolean;
    lastState: Variant.StateOf<HList.Each<Variants>>;
  };
  type StreamState = StateChange.StateChange<Variant.StateOf<HList.Each<Variants>>>;

  const initialAcc: Accumulator = {
    protocolVersion: initiatedVariant.initProtocolVersion,
    shouldInitChange: false,
    followEffect: Effect.void,
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    lastState: initiatedVariant.initialState,
  };
  return initiatedVariant.runningVariant.state.pipe(
    Stream.scanEffect(initialAcc, (accumulator: Accumulator, change: StreamState) => {
      return StateChange.match(change, {
        State: ({ state }) => {
          return SubscriptionRef.set(
            stateRef,
            Either.right({ version: accumulator.protocolVersion, state } as const),
          ).pipe(Effect.as({ ...accumulator, lastState: state }));
        },
        ProgressUpdate: (progress) => {
          return SynchronizedRef.set(progressRef, progress).pipe(Effect.as(accumulator));
        },
        VersionChange: ({ change }) => {
          const newProtocolVersion: ProtocolVersion.ProtocolVersion | null = VersionChangeType.match(change, {
            Version: ({ version }) => version,
            Next: () => initiatedVariant.nextProtocolVersion,
          });
          if (
            newProtocolVersion != null &&
            !ProtocolVersion.withinRange(newProtocolVersion, initiatedVariant.validVersionRange)
          ) {
            return Effect.succeed({
              ...accumulator,
              protocolVersion: newProtocolVersion,
              shouldInitChange: true,
              followEffect: Effect.gen(function* () {
                yield* Scope.close(initiatedVariant.variantScope, Exit.void);
                const newInitiatedVariant = yield* migrateToNextVariant({
                  variants: initiatedVariant.restVariants,
                  state: accumulator.lastState as Variant.PreviousStateOf<
                    HList.Head<typeof initiatedVariant.restVariants>
                  >,
                  initProtocolVersion: newProtocolVersion,
                });
                yield* SynchronizedRef.set(currentVariantRef, newInitiatedVariant);
                return yield* runVariantStream(newInitiatedVariant, stateRef, progressRef, currentVariantRef);
              }),
            });
          } else {
            return Effect.succeed({
              ...accumulator,
              protocolVersion: newProtocolVersion ?? accumulator.protocolVersion,
            });
          }
        },
      });
    }),
    Stream.filter((streamAcc) => streamAcc.shouldInitChange),
    Stream.runHead,
    Effect.flatMap((streamAccOption) => {
      return Option.match(streamAccOption, {
        onSome: (value) => {
          return value.followEffect;
        },
        onNone: () => {
          return Effect.void;
        },
      });
    }),
  );
};

================
File: packages/runtime/src/WalletBuilder.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Exit, Scope, Types } from 'effect';
import * as rx from 'rxjs';
import { ProtocolState, ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Variant, VariantBuilder, WalletLike, WalletRuntimeError } from './abstractions/index.js';
import { StateOf } from './abstractions/Variant.js';
import { ObservableOps, HList, Poly } from '@midnight-ntwrk/wallet-sdk-utilities';
import * as Runtime from './Runtime.js';

/**
 * Builds a wallet-like implementation from a collection of wallet-like variants, each specific
 * to a given version of the Midnight protocol.
 *
 * @typeParam TBuilders The sequence of variant builders that will manage the wallet state
 */
export class WalletBuilder<TBuilders extends VariantBuilder.AnyVersionedVariantBuilder[]> {
  private constructor(buildState: WalletBuilder.BuildState<TBuilders>) {
    this.#buildState = buildState;
  }

  static init(): WalletBuilder<[]> {
    return new WalletBuilder<[]>({
      variants: [],
    });
  }

  readonly #buildState: WalletBuilder.BuildState<TBuilders>;

  /**
   * Ensures that the built wallet uses a given variant.
   *
   * @param sinceVersion The Midnight protocol version that the variant should operate from.
   * @param variantBuilder A {@link VariantBuilder} that builds the variant.
   * @returns A new {@link WalletBuilder} that uses the variant that will be built from `variantBuilder`.
   */
  withVariant<TBuilder extends VariantBuilder.AnyVariantBuilder>(
    sinceVersion: ProtocolVersion.ProtocolVersion,
    variantBuilder: TBuilder,
  ): WalletBuilder<HList.Append<TBuilders, VariantBuilder.VersionedVariantBuilder<TBuilder>>> {
    const { sinceVersion: previousVersion } = this.#buildState.variants.at(-1) ?? {
      sinceVersion: ProtocolVersion.ProtocolVersion(-1n),
    };

    if (sinceVersion <= previousVersion) {
      throw new Error('ProtocolMismatch: sinceVersion is prior to previously registered version');
    }

    const newBuilder: VariantBuilder.VersionedVariantBuilder<TBuilder> = { sinceVersion, variantBuilder };

    return new WalletBuilder<HList.Append<TBuilders, VariantBuilder.VersionedVariantBuilder<TBuilder>>>({
      variants: HList.append(this.#buildState.variants, newBuilder),
    });
  }

  /**
   * Builds a wallet like implementation.
   */
  build(
    ...[maybeConfiguration]: WalletBuilder.BuildArguments<TBuilders>
  ): WalletLike.BaseWalletClass<
    VariantBuilder.VersionedVariantsOf<TBuilders>,
    WalletBuilder.FullConfiguration<TBuilders>
  > {
    type Variants = VariantBuilder.VersionedVariantsOf<TBuilders>;

    if (this.#buildState.variants.length == 0) {
      throw new WalletRuntimeError({ message: 'Empty variants list' });
    }

    const variants: Variants = this.#buildState.variants.map(
      ({ sinceVersion, variantBuilder }): Variant.VersionedVariant<Variant.AnyVariant> => ({
        sinceVersion,
        variant: variantBuilder.build(maybeConfiguration ?? {}),
      }),
    ) as Variants;

    type WalletRuntime = Runtime.Runtime<Variants>;
    type WalletState = Variant.StateOf<HList.Each<Variants>>;

    return class BaseWallet implements WalletLike.WalletLike<Variants> {
      static readonly configuration: WalletBuilder.FullConfiguration<TBuilders> = (maybeConfiguration ??
        {}) as WalletBuilder.FullConfiguration<TBuilders>;

      static allVariants(): Variants {
        return variants;
      }

      static allVariantsRecord(): Variant.VariantRecord<Variants> {
        return Variant.makeVersionedRecord(BaseWallet.allVariants());
      }

      static startEmpty<T extends WalletLike.AnyWalletClass<Variants>>(WalletClass: T): WalletLike.WalletOf<T> {
        return Effect.gen(this, function* () {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          const initialState: Variant.StateOf<HList.Head<Variants>> = yield* (
            HList.head(BaseWallet.allVariants()) as Variant.AnyVersionedVariant
          ).variant.migrateState(null);

          return BaseWallet.startFirst(WalletClass, initialState);
        }).pipe(Effect.runSync);
      }

      static startFirst<T extends WalletLike.AnyWalletClass<Variants>>(
        WalletClass: T,
        state: StateOf<HList.Head<Variants>>,
      ): WalletLike.WalletOf<T> {
        return Effect.gen(this, function* () {
          const scope = yield* Scope.make();

          const runtime = yield* Runtime.initHead({ variants, state }).pipe(Effect.provideService(Scope.Scope, scope));

          return new WalletClass(runtime, scope) as WalletLike.WalletOf<T>;
        }).pipe(Effect.runSync);
      }

      static start<T extends WalletLike.AnyWalletClass<Variants>, Tag extends string | symbol>(
        WalletClass: T,
        tag: Tag,
        state: Variant.StateOf<HList.Find<Variants, { variant: Poly.WithTag<Tag> }>>,
      ): WalletLike.WalletOf<T> {
        return Effect.gen(this, function* () {
          const scope = yield* Scope.make();

          const runtime = yield* Runtime.init({ variants, tag, state }).pipe(Effect.provideService(Scope.Scope, scope));

          return new WalletClass(runtime, scope) as WalletLike.WalletOf<T>;
        }).pipe(Effect.runSync);
      }

      readonly runtime: WalletRuntime;
      readonly runtimeScope: Scope.CloseableScope;
      readonly rawState: rx.Observable<ProtocolState.ProtocolState<WalletState>>;

      get syncComplete(): boolean {
        const { sourceGap, applyGap } = Effect.runSync(this.runtime.progress);
        return sourceGap === 0n && applyGap === 0n;
      }

      constructor(runtime: Runtime.Runtime<Variants>, runtimeScope: Scope.CloseableScope) {
        this.runtime = runtime;
        this.runtimeScope = runtimeScope;
        this.rawState = ObservableOps.fromStream(runtime.stateChanges).pipe(
          rx.shareReplay({ refCount: true, bufferSize: 1 }),
        );
      }

      stop(): Promise<void> {
        return Scope.close(this.runtimeScope, Exit.void).pipe(Effect.runPromise);
      }
    };
  }
}

export declare namespace WalletBuilder {
  /**
   * The internal build state of {@link WalletBuilder}.
   *
   * @remarks
   * Represents the collection of configured variants and their configuration.
   */
  type BuildState<TBuilders extends VariantBuilder.AnyVersionedVariantBuilder[]> = {
    readonly variants: TBuilders;
  };

  /**
   * Allows properly expressing no need for configuration if an empty one needs to be provided
   */
  export type BuildArguments<TBuilders extends VariantBuilder.AnyVersionedVariantBuilder[]> =
    VoidIfEmpty<FullConfiguration<TBuilders>> extends undefined ? [] : [FullConfiguration<TBuilders>];

  export type FullConfiguration<TBuilders extends VariantBuilder.AnyVersionedVariantBuilder[]> =
    Types.UnionToIntersection<Configurations<TBuilders>>;

  type VoidIfEmpty<TObject> = keyof TObject extends never ? undefined : TObject;

  type Configurations<TBuilders extends VariantBuilder.AnyVersionedVariantBuilder[]> = VariantBuilder.ConfigurationOf<
    HList.Each<TBuilders>
  >;
}

================
File: packages/runtime/.npmignore
================
*.ts.map

================
File: packages/runtime/.prettierignore
================
dist/
coverage/
reports/

================
File: packages/runtime/eslint.config.mjs
================
import { packageConfig } from '../../eslint.config.mjs';

export default packageConfig();

================
File: packages/runtime/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/test/**/*.ts", "src/**/*.test.ts"]
}

================
File: packages/runtime/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [{ "path": "./tsconfig.build.json" }, { "path": "./tsconfig.test.json" }]
}

================
File: packages/runtime/tsconfig.publish.json
================
{
  "extends": "./tsconfig.build.json",
  "compilerOptions": {
    "sourceMap": false,
    "declarationMap": false
  }
}

================
File: packages/runtime/tsconfig.test.json
================
{
  "extends": "./tsconfig.json",
  "include": ["test/**/*.ts", "src/**/*.ts"]
}

================
File: packages/runtime/vitest.config.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/// <reference types="vitest" />
/// <reference types="vitest/globals" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage',
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }],
    ],
  },
});

================
File: packages/shielded-wallet/src/test/genTxs.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { FileSystem } from '@effect/platform';
import { Effect, Scope } from 'effect';
import path from 'path';
import { StartedNetwork } from 'testcontainers';
import { TestTransactions } from '@midnight-ntwrk/wallet-sdk-node-client/testing';
import { PlatformError } from '@effect/platform/Error';
import { NodeContext } from '@effect/platform-node';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';

const paths = new (class {
  currentDir = path.dirname(new URL(import.meta.url).pathname);
  outputPath = path.resolve(this.currentDir, 'tmp');
  fileName = 'test-txs.json';
})();

export const getTestTxsPath = (fileName: string = paths.fileName): string => `${paths.outputPath}/${fileName}`;

export const makeFakeTx = (
  value: bigint,
): ledger.Transaction<ledger.SignatureEnabled, ledger.PreProof, ledger.PreBinding> => {
  const shieldedTokenType = ledger.shieldedToken();
  const recipient = ledger.ZswapSecretKeys.fromSeed(new Uint8Array(32).fill(0));
  const coin = ledger.createShieldedCoinInfo(shieldedTokenType.raw, value);
  const unprovenOutput = ledger.ZswapOutput.new(coin, 0, recipient.coinPublicKey, recipient.encryptionPublicKey);
  const unprovenOffer = ledger.ZswapOffer.fromOutput(unprovenOutput, shieldedTokenType.raw, value);
  return ledger.Transaction.fromParts(NetworkId.NetworkId.Undeployed, unprovenOffer);
};

const cleanDir = () =>
  Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    yield* fs.remove(getTestTxsPath(), { force: true, recursive: true });
  });

export const generateTxs = (
  nodeUrl: string,
  proofServerUrl: string,
  network: StartedNetwork,
  fileName: string = paths.fileName,
): Effect.Effect<void, Error | PlatformError, Scope.Scope> =>
  Effect.gen(function* () {
    yield* cleanDir();
    yield* TestTransactions.generateTestTransactions(nodeUrl, proofServerUrl, network, paths.outputPath, fileName);
  }).pipe(Effect.provide(NodeContext.layer));

================
File: packages/shielded-wallet/src/test/testUtils.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';

/**
 * Temporary function until the ledger fixes imbalances.get()
 *
 * @param imbalances
 * @param rawTokenType
 * @returns bigint
 */
export const getNonDustImbalance = (
  imbalances: Map<ledger.TokenType, bigint>,
  rawTokenType: ledger.RawTokenType,
): bigint => {
  const [, value] = Array.from(imbalances.entries()).find(([t, value]) =>
    t.tag !== 'dust' && t.raw == rawTokenType ? value : undefined,
  ) ?? [undefined, BigInt(0)];

  return value;
};

================
File: packages/shielded-wallet/src/v1/test/coinsAndBalances.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Record, Array, pipe } from 'effect';
import * as fc from 'fast-check';
import { describe, expect, it } from 'vitest';
import { makeDefaultCoinsAndBalancesCapability, AvailableCoin, PendingCoin } from '../CoinsAndBalances.js';
import { CoreWallet } from '../CoreWallet.js';

type ShieldedTokenType = { tokenType: ledger.ShieldedTokenType; value: bigint };

const amountArbitrary = fc.bigInt({ min: 1n, max: 1000n });
const tokenTypeArbitrary = fc.constantFrom(ledger.shieldedToken(), {
  tag: 'shielded',
  raw: ledger.sampleRawTokenType(),
});
const coinArbitrary = fc.record({
  value: amountArbitrary,
  tokenType: tokenTypeArbitrary,
});

const toAvailableCoin = (c: ShieldedTokenType, secretKeys: ledger.ZswapSecretKeys): AvailableCoin => {
  const coin = ledger.createShieldedCoinInfo(c.tokenType.raw, BigInt(c.value));
  return {
    coin: { ...coin, mt_index: 0n },
    commitment: ledger.coinCommitment(coin, secretKeys.coinPublicKey),
    nullifier: ledger.coinNullifier(coin, secretKeys.coinSecretKey),
  };
};

const toPendingCoin = (c: ShieldedTokenType, secretKeys: ledger.ZswapSecretKeys): PendingCoin => {
  const coin = ledger.createShieldedCoinInfo(c.tokenType.raw, BigInt(c.value));
  return {
    coin,
    ttl: new Date(0),
    commitment: ledger.coinCommitment(coin, secretKeys.coinPublicKey),
    nullifier: ledger.coinNullifier(coin, secretKeys.coinSecretKey),
  };
};

const createInitialState = (secretKeys: ledger.ZswapSecretKeys, coins: AvailableCoin[]): ledger.ZswapLocalState => {
  const finalOffer = pipe(
    coins,
    Array.map(({ coin }) =>
      ledger.ZswapOffer.fromOutput(
        ledger.ZswapOutput.new(coin, 0, secretKeys.coinPublicKey, secretKeys.encryptionPublicKey),
        coin.type,
        coin.value,
      ),
    ),
    (offers) => (offers.length > 0 ? offers.reduce((acc, offer) => acc.merge(offer)) : undefined),
  );

  const tx = ledger.Transaction.fromParts(NetworkId.NetworkId.Undeployed, finalOffer).eraseProofs();

  return tx.guaranteedOffer
    ? new ledger.ZswapLocalState().apply(secretKeys, tx.guaranteedOffer)
    : new ledger.ZswapLocalState();
};

const applyPendingCoinValues = (
  state: ledger.ZswapLocalState,
  secretKeys: ledger.ZswapSecretKeys,
  coins: PendingCoin[],
): ledger.ZswapLocalState =>
  pipe(
    coins,
    Array.reduce(state, (currentState, { coin }) => currentState.watchFor(secretKeys.coinPublicKey, coin)),
  );

const issueSpendingOfCoins = (
  state: ledger.ZswapLocalState,
  secretKeys: ledger.ZswapSecretKeys,
  coins: AvailableCoin[],
): ledger.ZswapLocalState =>
  pipe(
    coins,
    Array.reduce(state, (currentState, { coin }) => {
      const coinToSpend = [...currentState.coins].find(
        (c) => c.value === coin.value && c.type === coin.type && c.nonce === coin.nonce,
      );
      if (!coinToSpend) {
        throw new Error(`Could not find coin with value ${coin.value}n, type ${coin.type}, and nonce ${coin.nonce}`);
      }
      const [newLocalState, _] = currentState.spend(secretKeys, coinToSpend, 0);
      return newLocalState;
    }),
  );

function groupByTokenType<T extends AvailableCoin | PendingCoin>(coins: readonly T[]): Record<string, bigint[]> {
  return pipe(
    coins,
    Array.groupBy((c) => c.coin.type),
    Record.map((arr) => arr.map((c) => c.coin.value)),
    Record.map((arr) => arr.slice().sort((a, b) => Number(a - b))),
  );
}

describe('DefaultCoinsAndBalancesCapability', () => {
  it('should return correct balances and coins when wallet has no pending coins and no pending balances', () => {
    fc.assert(
      fc.property(fc.array(coinArbitrary), (coinInputs) => {
        const secretKeys = ledger.ZswapSecretKeys.fromSeed(new Uint8Array(32).fill(1));
        const setupAvailableCoins: AvailableCoin[] = coinInputs.map((c) =>
          toAvailableCoin(c as { tokenType: { raw: string; tag: 'shielded' }; value: bigint }, secretKeys),
        );
        const networkId = NetworkId.NetworkId.Undeployed;
        const capability = makeDefaultCoinsAndBalancesCapability();

        const localState = createInitialState(secretKeys, setupAvailableCoins);
        const state = CoreWallet.init(localState, secretKeys, networkId);
        const pendingBalances = capability.getPendingBalances(state);
        const availableBalances = capability.getAvailableBalances(state);
        const totalBalances = capability.getTotalBalances(state);
        const pendingCoins = capability.getPendingCoins(state);
        const availableCoins = capability.getAvailableCoins(state);
        const totalCoins = capability.getTotalCoins(state);

        const availableCoinsbyType = groupByTokenType(availableCoins);
        Object.entries(availableCoinsbyType).forEach(([tokenType, values]) => {
          const sum = values.reduce((a, b) => a + b, 0n);
          expect(availableBalances[tokenType]).toEqual(sum);
          expect(totalBalances[tokenType]).toEqual(sum);
          expect(availableCoinsbyType[tokenType]).toEqual(values);
          expect(groupByTokenType(totalCoins)[tokenType]).toEqual(values);
        });

        expect(pendingBalances).toEqual({});
        expect(groupByTokenType(pendingCoins)).toEqual({});
      }),
      { numRuns: 10 },
    );
  });

  it('should return correct balances and coins when wallet has a pending coin and a pending balance', () => {
    fc.assert(
      fc.property(fc.array(coinArbitrary), fc.array(coinArbitrary), (fixtureAvailableCoins, fixturePendingCoins) => {
        const secretKeys = ledger.ZswapSecretKeys.fromSeed(new Uint8Array(32).fill(1));
        const setupAvailableCoins: AvailableCoin[] = fixtureAvailableCoins.map((c) =>
          toAvailableCoin(c as ShieldedTokenType, secretKeys),
        );
        const setupPendingCoins: PendingCoin[] = fixturePendingCoins.map((c) =>
          toPendingCoin(c as ShieldedTokenType, secretKeys),
        );
        const networkId = NetworkId.NetworkId.Undeployed;
        const capability = makeDefaultCoinsAndBalancesCapability();

        let localState = createInitialState(secretKeys, setupAvailableCoins);
        localState = applyPendingCoinValues(localState, secretKeys, setupPendingCoins);
        const state = CoreWallet.init(localState, secretKeys, networkId);
        const availableBalances = capability.getAvailableBalances(state);
        const pendingBalances = capability.getPendingBalances(state);
        const totalBalances = capability.getTotalBalances(state);
        const availableCoins = capability.getAvailableCoins(state);
        const pendingCoins = capability.getPendingCoins(state);
        const totalCoins = capability.getTotalCoins(state);

        const byTypeAvailable = groupByTokenType(availableCoins);
        const byTypePending = groupByTokenType(pendingCoins);
        const byTypeTotal = groupByTokenType(totalCoins);

        const allTokenTypes: string[] = Object.keys(byTypeAvailable)
          .concat(Object.keys(byTypePending))
          .filter((value, index, self) => self.indexOf(value) === index);

        allTokenTypes.forEach((tokenType: string) => {
          const available = byTypeAvailable[tokenType] || [];
          const pending = byTypePending[tokenType] || [];
          const total = byTypeTotal[tokenType] || [];

          const availableSum = available.reduce((a, b) => a + b, 0n);
          const pendingSum = pending.reduce((a, b) => a + b, 0n);
          const totalSum = availableSum + pendingSum;

          expect(availableBalances[tokenType] ?? 0n).toEqual(availableSum);
          expect(pendingBalances[tokenType] ?? 0n).toEqual(pendingSum);
          expect(totalBalances[tokenType] ?? 0n).toEqual(totalSum);

          const expectedAvailable = fixtureAvailableCoins
            .filter((c) => (c.tokenType as { raw: string }).raw === tokenType)
            .map((c) => c.value);
          const expectedPending = fixturePendingCoins
            .filter((c) => (c.tokenType as { raw: string }).raw === tokenType)
            .map((c) => c.value);
          const expectedTotal = expectedAvailable.concat(expectedPending);

          const bigintCompare = (a: bigint, b: bigint) => (a < b ? -1 : a > b ? 1 : 0);
          const sortedAvailable = pipe(available, Array.sort(bigintCompare));
          const sortedExpectedAvailable = pipe(expectedAvailable, Array.sort(bigintCompare));
          const sortedPending = pipe(pending, Array.sort(bigintCompare));
          const sortedExpectedPending = pipe(expectedPending, Array.sort(bigintCompare));
          const sortedTotal = pipe(total, Array.sort(bigintCompare));
          const sortedExpectedTotal = pipe(expectedTotal, Array.sort(bigintCompare));

          expect(sortedAvailable).toEqual(sortedExpectedAvailable);
          expect(sortedPending).toEqual(sortedExpectedPending);
          expect(sortedTotal).toEqual(sortedExpectedTotal);
        });
      }),
      { numRuns: 10 },
    );
  });

  it('should return correct balances and coins when wallet has a pending spend', () => {
    fc.assert(
      fc.property(fc.array(coinArbitrary), fc.integer({ min: 0, max: 3 }), (availableInputs, numSpends) => {
        const secretKeys = ledger.ZswapSecretKeys.fromSeed(new Uint8Array(32).fill(1));
        const setupAvailableCoins: AvailableCoin[] = availableInputs.map((c) =>
          toAvailableCoin(c as ShieldedTokenType, secretKeys),
        );

        const spendsRaw = setupAvailableCoins.slice(0, Math.min(numSpends, setupAvailableCoins.length - 1));

        const seen = new Set();
        const spends = spendsRaw.filter((c) => {
          if (seen.has(c.coin.nonce)) return false;
          seen.add(c.coin.nonce);
          return true;
        });
        const networkId = NetworkId.NetworkId.Undeployed;
        const capability = makeDefaultCoinsAndBalancesCapability();

        const initialState = createInitialState(secretKeys, setupAvailableCoins);

        // Get initial balances before spending
        const stateBeforeSpends = CoreWallet.init(initialState, secretKeys, networkId);
        const initialAvailableBalances = capability.getAvailableBalances(stateBeforeSpends);

        const localState = issueSpendingOfCoins(initialState, secretKeys, spends);
        const state = CoreWallet.init(localState, secretKeys, networkId);
        const pendingBalances = capability.getPendingBalances(state);
        const availableBalances = capability.getAvailableBalances(state);
        const totalBalances = capability.getTotalBalances(state);
        const pendingCoins = capability.getPendingCoins(state);
        const availableCoinsResult = capability.getAvailableCoins(state);
        const totalCoins = capability.getTotalCoins(state);

        const byTypeRemaining = groupByTokenType(availableCoinsResult);
        Object.entries(byTypeRemaining).forEach(([tokenType, values]) => {
          const sum = values.reduce((a, b) => a + b, 0n);
          expect(availableBalances[tokenType]).toEqual(sum);
          expect(totalBalances[tokenType]).toEqual(sum);
          expect(byTypeRemaining[tokenType]).toEqual(values);
          expect(groupByTokenType(totalCoins)[tokenType]).toEqual(values);
        });
        expect(pendingBalances).toEqual({});
        expect(groupByTokenType(pendingCoins)).toEqual({});

        // Verify that available balances decreased by the correct amount from spends
        const byTypeSpent = groupByTokenType(spends);
        Object.entries(byTypeSpent).forEach(([tokenType, values]) => {
          const spentSum = values.reduce((a, b) => a + b, 0n);
          const initialBalance = initialAvailableBalances[tokenType] ?? 0n;
          const finalBalance = availableBalances[tokenType] ?? 0n;
          expect(finalBalance).toEqual(initialBalance - spentSum);
        });

        expect(state.state.pendingSpends.size).toBe(spends.length);
      }),
      { numRuns: 10 },
    );
  });
});

================
File: packages/shielded-wallet/src/v1/test/keys.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { describe, it, expect } from 'vitest';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { makeDefaultKeysCapability } from '../Keys.js';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { CoreWallet } from '../CoreWallet.js';
import * as fc from 'fast-check';

const seedArbitrary = fc.uint8Array({ minLength: 32, maxLength: 32 });
const differentSeedsArbitrary = fc
  .uniqueArray(seedArbitrary, { minLength: 2, maxLength: 2 })
  .map(([seed1, seed2]) => [seed1, seed2]);

describe('DefaultKeysCapability', () => {
  describe('when generating keys and addresses', () => {
    it('should generate consistent coin public keys for any seed', () => {
      fc.assert(
        fc.property(seedArbitrary, (seed) => {
          const networkId = NetworkId.NetworkId.Undeployed;
          const state1 = CoreWallet.initEmpty(ledger.ZswapSecretKeys.fromSeed(seed), networkId);
          const state2 = CoreWallet.initEmpty(ledger.ZswapSecretKeys.fromSeed(seed), networkId);
          const capability = makeDefaultKeysCapability();

          const coinPublicKey1 = capability.getCoinPublicKey(state1);
          const coinPublicKey2 = capability.getCoinPublicKey(state2);

          expect(coinPublicKey1.data).toEqual(coinPublicKey2.data);
        }),
      );
    });

    it('should generate consistent encryption public keys for any seed', () => {
      fc.assert(
        fc.property(seedArbitrary, (seed) => {
          const networkId = NetworkId.NetworkId.Undeployed;
          const state1 = CoreWallet.initEmpty(ledger.ZswapSecretKeys.fromSeed(seed), networkId);
          const state2 = CoreWallet.initEmpty(ledger.ZswapSecretKeys.fromSeed(seed), networkId);
          const capability = makeDefaultKeysCapability();

          const encryptionPublicKey1 = capability.getEncryptionPublicKey(state1);
          const encryptionPublicKey2 = capability.getEncryptionPublicKey(state2);

          expect(encryptionPublicKey1.data).toEqual(encryptionPublicKey2.data);
        }),
      );
    });

    it('should generate addresses composed of coin and encryption public keys for any seed', () => {
      fc.assert(
        fc.property(seedArbitrary, (seed) => {
          const secretKeys = ledger.ZswapSecretKeys.fromSeed(seed);
          const state = CoreWallet.initEmpty(secretKeys, NetworkId.NetworkId.Undeployed);
          const capability = makeDefaultKeysCapability();

          const coinPublicKey = capability.getCoinPublicKey(state);
          const encryptionPublicKey = capability.getEncryptionPublicKey(state);
          const address = capability.getAddress(state);

          expect(address.coinPublicKey.data).toEqual(coinPublicKey.data);
          expect(address.encryptionPublicKey.data).toEqual(encryptionPublicKey.data);
        }),
      );
    });

    it('should generate different coin public keys for different seeds', () => {
      fc.assert(
        fc.property(differentSeedsArbitrary, ([seed1, seed2]) => {
          const secretKeys1 = ledger.ZswapSecretKeys.fromSeed(seed1);
          const secretKeys2 = ledger.ZswapSecretKeys.fromSeed(seed2);
          const state1 = CoreWallet.initEmpty(secretKeys1, NetworkId.NetworkId.Undeployed);
          const state2 = CoreWallet.initEmpty(secretKeys2, NetworkId.NetworkId.Undeployed);
          const capability = makeDefaultKeysCapability();

          const coinPublicKey1 = capability.getCoinPublicKey(state1);
          const coinPublicKey2 = capability.getCoinPublicKey(state2);

          expect(coinPublicKey1.data).not.toEqual(coinPublicKey2.data);
        }),
      );
    });

    it('should generate different encryption public keys for different seeds', () => {
      fc.assert(
        fc.property(differentSeedsArbitrary, ([seed1, seed2]) => {
          const secretKeys1 = ledger.ZswapSecretKeys.fromSeed(seed1);
          const secretKeys2 = ledger.ZswapSecretKeys.fromSeed(seed2);
          const state1 = CoreWallet.initEmpty(secretKeys1, NetworkId.NetworkId.Undeployed);
          const state2 = CoreWallet.initEmpty(secretKeys2, NetworkId.NetworkId.Undeployed);
          const capability = makeDefaultKeysCapability();

          const encryptionPublicKey1 = capability.getEncryptionPublicKey(state1);
          const encryptionPublicKey2 = capability.getEncryptionPublicKey(state2);

          expect(encryptionPublicKey1.data).not.toEqual(encryptionPublicKey2.data);
        }),
      );
    });

    it('should generate different addresses for different seeds', () => {
      fc.assert(
        fc.property(differentSeedsArbitrary, ([seed1, seed2]) => {
          const secretKeys1 = ledger.ZswapSecretKeys.fromSeed(seed1);
          const secretKeys2 = ledger.ZswapSecretKeys.fromSeed(seed2);
          const state1 = CoreWallet.initEmpty(secretKeys1, NetworkId.NetworkId.Undeployed);
          const state2 = CoreWallet.initEmpty(secretKeys2, NetworkId.NetworkId.Undeployed);
          const capability = makeDefaultKeysCapability();

          const address1 = capability.getAddress(state1);
          const address2 = capability.getAddress(state2);

          expect(address1.coinPublicKey.data).not.toEqual(address2.coinPublicKey.data);
          expect(address1.encryptionPublicKey.data).not.toEqual(address2.encryptionPublicKey.data);
        }),
      );
    });
  });

  describe('when constructing addresses', () => {
    it('should construct addresses from coin and encryption public keys for any seed', () => {
      fc.assert(
        fc.property(seedArbitrary, (seed) => {
          const secretKeys = ledger.ZswapSecretKeys.fromSeed(seed);
          const state = CoreWallet.initEmpty(secretKeys, NetworkId.NetworkId.Undeployed);
          const capability = makeDefaultKeysCapability();

          const coinPublicKey = capability.getCoinPublicKey(state);
          const encryptionPublicKey = capability.getEncryptionPublicKey(state);
          const address = capability.getAddress(state);

          // Address should be composed of the individual public keys
          expect(address.coinPublicKey.data).toEqual(coinPublicKey.data);
          expect(address.encryptionPublicKey.data).toEqual(encryptionPublicKey.data);
        }),
      );
    });
  });
});

================
File: packages/shielded-wallet/src/v1/test/proving.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Effect } from 'effect';
import { describe, expect, it } from 'vitest';
import { makeSimulatorProvingService } from '../Proving.js';
import { BALANCE_TRANSACTION_TO_PROVE, NOTHING_TO_PROVE, TRANSACTION_TO_PROVE } from '../ProvingRecipe.js';
import { getNonDustImbalance } from '../../test/testUtils.js';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';

const makeTransaction = () => {
  const seed = Buffer.alloc(32, 0);
  const recipient = ledger.ZswapSecretKeys.fromSeed(seed);
  const amount = 42n;
  const shieldedTokenType = ledger.shieldedToken();
  const coin = ledger.createShieldedCoinInfo(shieldedTokenType.raw, amount);
  const output = ledger.ZswapOutput.new(coin, 0, recipient.coinPublicKey, recipient.encryptionPublicKey);
  const offer = ledger.ZswapOffer.fromOutput(output, shieldedTokenType.raw, amount);
  return ledger.Transaction.fromParts(NetworkId.NetworkId.Undeployed, offer);
};

describe('Simulator proving service', () => {
  const testUnprovenTx = makeTransaction();
  const testErasedTx = makeTransaction().eraseProofs();

  const recipes = [
    { recipe: { type: NOTHING_TO_PROVE, transaction: testErasedTx }, expectedImbalance: -42n },
    {
      recipe: {
        type: BALANCE_TRANSACTION_TO_PROVE,
        transactionToBalance: testErasedTx,
        transactionToProve: testUnprovenTx,
      },
      expectedImbalance: -84n,
    },
    { recipe: { type: TRANSACTION_TO_PROVE, transaction: testUnprovenTx }, expectedImbalance: -42n },
  ] as const;

  it.each(recipes)(
    'does transform proving recipe into final, proof-erased transaction',
    async ({ recipe, expectedImbalance }) => {
      const service = makeSimulatorProvingService();
      const finalTx: ledger.ProofErasedTransaction = await service.prove(recipe).pipe(Effect.runPromise);

      expect(finalTx).toBeInstanceOf(ledger.Transaction);
      expect(getNonDustImbalance(finalTx.imbalances(0), ledger.shieldedToken().raw)).toEqual(expectedImbalance);
    },
  );
});

================
File: packages/shielded-wallet/src/v1/test/serialization.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { OtherWalletError } from '../WalletError.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Array as Arr, pipe } from 'effect';
import * as fc from 'fast-check';
import { describe, expect, it, vi } from 'vitest';
import { makeDefaultV1SerializationCapability } from '../Serialization.js';
import { Either } from 'effect';
import { CoreWallet } from '../CoreWallet.js';
import { EitherOps } from '@midnight-ntwrk/wallet-sdk-utilities';

const minutes = (mins: number) => 1_000 * 60 * mins;
vi.setConfig({ testTimeout: minutes(1) });

const tokenTypeArbitrary = (maxSize: number) => {
  const number = fc.nat(maxSize);
  const types = Array(number).map(() => ledger.sampleRawTokenType());
  const tokenTypeArbitrary = fc.constantFrom(...types);

  const nativeTokenTypeArbitrary = fc.constant((ledger.shieldedToken() as { tag: 'shielded'; raw: string }).raw);
  return fc.oneof({ weight: 1, arbitrary: nativeTokenTypeArbitrary }, { weight: 1, arbitrary: tokenTypeArbitrary });
};
const secretKeysArbitrary: fc.Arbitrary<ledger.ZswapSecretKeys> = fc
  .uint8Array({ minLength: 32, maxLength: 32 })
  .map((seed) => ledger.ZswapSecretKeys.fromSeed(seed));

type OutputPreimage = { coin: ledger.ShieldedCoinInfo; recipient: ledger.ZswapSecretKeys };
const outputPreimageArbitrary = (
  keysArbitrary: fc.Arbitrary<ledger.ZswapSecretKeys>,
  tokenTypeArbitrary: fc.Arbitrary<ledger.RawTokenType>,
): fc.Arbitrary<OutputPreimage> => {
  return fc.record({
    coin: fc.record({
      type: tokenTypeArbitrary,
      value: fc.nat().map(BigInt),
      nonce: fc.uint8Array({ minLength: 32, maxLength: 32 }).map((bytes) => Buffer.from(bytes).toString('hex')),
    }),
    recipient: keysArbitrary,
  });
};
const transactionArbitrary = (
  outputPreimageArbitrary: fc.Arbitrary<OutputPreimage>,
  depth: number,
): fc.Arbitrary<{
  outputPreimages: OutputPreimage[];
  offer: ledger.ZswapOffer<ledger.PreProof>;
}> => {
  return fc.array(outputPreimageArbitrary, { maxLength: depth, minLength: 1 }).map((outputPreimages) => {
    return {
      outputPreimages,
      offer: pipe(
        outputPreimages,
        Arr.map((preimage) => {
          const output = ledger.ZswapOutput.new(
            preimage.coin,
            0,
            preimage.recipient.coinPublicKey,
            preimage.recipient.encryptionPublicKey,
          );
          return ledger.ZswapOffer.fromOutput(output, preimage.coin.type, preimage.coin.value);
        }),
        (arr) => arr.reduce((offerA, offerB) => offerA.merge(offerB)), // effect lacks equivalent "fold" definition for Array,
      ),
    };
  });
};
const walletArbitrary = (txDepth: number) => {
  return secretKeysArbitrary
    .chain((keys) => {
      return fc
        .array(transactionArbitrary(outputPreimageArbitrary(fc.constant(keys), tokenTypeArbitrary(3)), 5), {
          maxLength: txDepth,
        })
        .map((transactions) => ({ transactions, keys }));
    })
    .chain((acc) => {
      return fc.string().map((networkId) => ({ ...acc, networkId }));
    })
    .map(({ transactions, keys, networkId }) => {
      const state: ledger.ZswapLocalState = transactions.reduce(
        (state: ledger.ZswapLocalState, tx): ledger.ZswapLocalState => {
          return state.apply(keys, tx.offer);
        },
        new ledger.ZswapLocalState(),
      );
      const wallet = CoreWallet.init(state, keys, networkId);

      return {
        keys,
        transactions,
        wallet,
        networkId,
      };
    });
};

describe('V1 Wallet serialization', () => {
  it.each([
    { seed: '0000000000000000000000000000000000000000000000000000000000000001' },
    { seed: '0000000000000000000000000000000000000000000000000000000000000002' },
    { seed: '0000000000000000000000000000000000000000000000000000000000000003' },
    { seed: '0000000000000000000000000000000000000000000000000000000000000004' },
  ])('maintains serialize ◦ deserialize == id property, including transaction history', ({ seed }) => {
    const networkId = NetworkId.NetworkId.Undeployed;
    const capability = makeDefaultV1SerializationCapability();
    const keys = ledger.ZswapSecretKeys.fromSeed(Buffer.from(seed, 'hex'));
    const wallet = CoreWallet.initEmpty(keys, networkId);

    const firstIteration = capability.serialize(wallet);

    const restored = pipe(capability.deserialize(null, firstIteration), EitherOps.getOrThrowLeft);
    const secondIteration = capability.serialize(restored);

    expect(firstIteration).toEqual(secondIteration);
  });
  it('maintains serialize ◦ deserialize == id property', () => {
    const capability = makeDefaultV1SerializationCapability();
    fc.assert(
      fc.property(walletArbitrary(10), ({ wallet }) => {
        const firstIteration = capability.serialize(wallet);
        const restored = pipe(capability.deserialize(null, firstIteration), EitherOps.getOrThrowLeft);
        const secondIteration = capability.serialize(restored);

        //We can't meaningfully compare equality, so we compare the result of second serialization
        expect(firstIteration).toEqual(secondIteration);
      }),
      {
        numRuns: 10,
      },
    );
  });

  it('handles invalid JSON strings gracefully', () => {
    const capability = makeDefaultV1SerializationCapability();

    fc.assert(
      fc.property(fc.string(), (invalidJson) => {
        const result = capability.deserialize(null, invalidJson);

        expect(Either.isLeft(result)).toBe(true);
        if (Either.isLeft(result)) {
          expect(result.left instanceof OtherWalletError).toBe(true);
        }
      }),
    );
  });

  it('handles random valid JSON strings gracefully', () => {
    const capability = makeDefaultV1SerializationCapability();

    fc.assert(
      fc.property(fc.json(), (randomJsonValue) => {
        const result = capability.deserialize(null, randomJsonValue);

        expect(Either.isLeft(result)).toBe(true);
        if (Either.isLeft(result)) {
          expect(result.left instanceof OtherWalletError).toBe(true);
        }
      }),
    );
  });
});

================
File: packages/shielded-wallet/src/v1/test/submission.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { describe, vi, it, expect, afterAll, beforeAll } from 'vitest';
import { TestTransactions } from '@midnight-ntwrk/wallet-sdk-node-client/testing';
import { TestContainers } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import { Chunk, Effect, Option, pipe, Stream, Console, Exit, Scope } from 'effect';
import { makeDefaultSubmissionService } from '../Submission.js';
import { PolkadotNodeClient } from '@midnight-ntwrk/wallet-sdk-node-client/effect';
import { NodeContext } from '@effect/platform-node';
import { generateTxs, getTestTxsPath } from '../../test/genTxs.js';
import { StartedTestContainer } from 'testcontainers';
import { randomUUID } from 'crypto';

vi.setConfig({ testTimeout: 200_000, hookTimeout: 100_000 });

const getExtrinsicHashes = (client: PolkadotNodeClient, blockHash: string): Effect.Effect<string[]> => {
  return Effect.promise(() => client.api.rpc.chain.getBlock(blockHash)).pipe(
    Effect.map((block) => block.block.extrinsics.toArray().map((extrinsic) => extrinsic.hash.toString())),
  );
};
const getFinalizedBlockHashes = (client: PolkadotNodeClient): Effect.Effect<string[]> => {
  return Effect.promise(() => client.api.rpc.chain.getFinalizedHead()).pipe(
    Effect.flatMap((lastFinalizedHash) =>
      Stream.unfoldEffect(lastFinalizedHash, (lastHash) => {
        return Effect.promise(() => client.api.rpc.chain.getBlock(lastHash)).pipe(
          Effect.map((block) => {
            if (block.block.header.number.toNumber() >= 1) {
              return Option.some([block, block.block.header.parentHash] as const);
            } else {
              return Option.none();
            }
          }),
        );
      }).pipe(
        Stream.map((block) => block.block.hash.toString()),
        Stream.runCollect,
        Effect.map((chunk) => Chunk.toArray(chunk)),
      ),
    ),
  );
};

const initEnv = (proofServerUrl: string, TxsFileName: string) =>
  Effect.gen(function* () {
    const network = yield* TestContainers.createNetwork();
    const node = yield* TestContainers.runNodeContainer((c) =>
      c.withNetwork(network).withNetworkAliases('midnight-node'),
    );
    yield* generateTxs(`ws://midnight-node:9944`, proofServerUrl, network, TxsFileName);
    const nodeURL = new URL(`ws://127.0.0.1:${node.getMappedPort(9944)}`);
    const submission = makeDefaultSubmissionService({
      relayURL: nodeURL,
    });
    yield* Effect.addFinalizer(() => submission.close().pipe(Effect.andThen(Console.log('Closed submission service'))));
    const testTx = yield* TestTransactions.load(getTestTxsPath(TxsFileName)).pipe(Effect.map((txs) => txs.initial_tx));
    return { nodeURL, submission, testTx };
  });

describe.skip('Default Submission', () => {
  let scope: Scope.CloseableScope;
  let proofServer: StartedTestContainer;

  beforeAll(async () => {
    await Effect.gen(function* () {
      scope = yield* Scope.make();

      proofServer = yield* TestContainers.runProofServerContainer().pipe(Effect.provideService(Scope.Scope, scope));

      return [proofServer, scope];
    }).pipe(Effect.provide(NodeContext.layer), Effect.scoped, Effect.runPromise);
  });

  afterAll(async () => {
    if (scope) {
      await pipe(Scope.close(scope, Exit.void), Effect.runPromise);
    }
  });

  it('submits and exits cleanly', async () => {
    const result = await pipe(
      Effect.gen(function* () {
        const { submission, testTx } = yield* initEnv(
          `http://127.0.0.1:${proofServer.getMappedPort(6300)}`,
          `${randomUUID()}.json`,
        );
        yield* submission.submitTransaction(testTx, 'Submitted');
      }),
      Effect.scoped,
      Effect.provide(NodeContext.layer),
      Effect.runPromiseExit,
    );

    expect(Exit.isSuccess(result)).toBe(true);
  });

  it.only('submits transactions waiting for submission event', async () => {
    const { submissionResult, checkResult } = await pipe(
      Effect.gen(function* () {
        const { submission, nodeURL, testTx } = yield* initEnv(
          `http://127.0.0.1:${proofServer.getMappedPort(6300)}`,
          `${randomUUID()}.json`,
        );
        const submissionResult = yield* submission.submitTransaction(testTx, 'Submitted');
        const checkResult = yield* PolkadotNodeClient.make({ nodeURL: nodeURL }).pipe(
          Effect.flatMap((client) => Effect.promise(() => client.api.rpc.author.pendingExtrinsics())),
          Effect.map((extrinsics) => extrinsics.toArray().map((extrinsic) => extrinsic.hash.toHex())),
        );

        return { submissionResult, checkResult };
      }),
      Effect.scoped,
      Effect.provide(NodeContext.layer),
      Effect.runPromise,
    );

    expect(checkResult).toContain(submissionResult.txHash);
  });

  it('submits transactions waiting for in-block event', async () => {
    const { submissionResult, checkResult } = await pipe(
      Effect.gen(function* () {
        const { submission, nodeURL, testTx } = yield* initEnv(
          `http://127.0.0.1:${proofServer.getMappedPort(6300)}`,
          `${randomUUID()}.json`,
        );
        const submissionResult = yield* submission.submitTransaction(testTx, 'InBlock');
        const checkResult = yield* PolkadotNodeClient.make({ nodeURL: nodeURL }).pipe(
          Effect.flatMap((client) => getExtrinsicHashes(client, submissionResult.blockHash)),
        );

        return { submissionResult, checkResult };
      }),
      Effect.scoped,
      Effect.provide(NodeContext.layer),
      Effect.runPromise,
    );

    expect(checkResult).toContain(submissionResult.txHash);
  });

  /**
   * Leaving only this test as these have become very memory intensive
   * and also, practically this validates all of the above and below.
   */
  it('submits transactions waiting for finalized event', async () => {
    const { submissionResult, checkResult } = await pipe(
      Effect.gen(function* () {
        const { submission, nodeURL, testTx } = yield* initEnv(
          `http://127.0.0.1:${proofServer.getMappedPort(6300)}`,
          `${randomUUID()}.json`,
        );
        const submissionResult = yield* submission.submitTransaction(testTx, 'Finalized');
        const checkResult = yield* PolkadotNodeClient.make({ nodeURL: nodeURL }).pipe(
          Effect.flatMap((client) =>
            Effect.all({
              blockExtrinsicHashes: getExtrinsicHashes(client, submissionResult.blockHash),
              allFinalizedBlockHashes: getFinalizedBlockHashes(client),
            }),
          ),
        );

        return { submissionResult, checkResult };
      }),
      Effect.scoped,
      Effect.provide(NodeContext.layer),
      Effect.runPromise,
    );

    expect(checkResult.allFinalizedBlockHashes).toContain(submissionResult.blockHash);
    expect(checkResult.blockExtrinsicHashes).toContain(submissionResult.txHash);
  });

  it('exits cleanly', () => {
    return Effect.gen(function* () {
      const { submission } = yield* initEnv(
        `http://127.0.0.1:${proofServer.getMappedPort(6300)}`,
        `${randomUUID()}.json`,
      );
      yield* submission.close();
    }).pipe(Effect.scoped, Effect.provide(NodeContext.layer), Effect.runPromise);
  });
});

================
File: packages/shielded-wallet/src/v1/test/syncProgress.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { describe, it, expect } from 'vitest';
import { SyncProgress, type SyncProgressData } from '../SyncProgress.js';

describe('SyncProgress', () => {
  describe('isCompleteWithin', () => {
    describe('when connected', () => {
      it('should return true when applyLag is within default maxGap (50)', () => {
        const data: SyncProgressData = {
          appliedIndex: 100n,
          highestRelevantWalletIndex: 120n, // applyLag = 20
          highestIndex: 200n,
          highestRelevantIndex: 120n,
          isConnected: true,
        };

        const result = SyncProgress.isCompleteWithin(data);
        expect(result).toBe(true);
      });

      it('should return true when applyLag equals default maxGap (50)', () => {
        const data: SyncProgressData = {
          appliedIndex: 100n,
          highestRelevantWalletIndex: 150n, // applyLag = 50
          highestIndex: 200n,
          highestRelevantIndex: 150n,
          isConnected: true,
        };

        const result = SyncProgress.isCompleteWithin(data);
        expect(result).toBe(true);
      });

      it('should return false when applyLag exceeds default maxGap (50)', () => {
        const data: SyncProgressData = {
          appliedIndex: 100n,
          highestRelevantWalletIndex: 160n, // applyLag = 60
          highestIndex: 200n,
          highestRelevantIndex: 160n,
          isConnected: true,
        };

        const result = SyncProgress.isCompleteWithin(data);
        expect(result).toBe(false);
      });

      it('should return true when appliedIndex is greater than highestRelevantWalletIndex (negative applyLag)', () => {
        const data: SyncProgressData = {
          appliedIndex: 150n,
          highestRelevantWalletIndex: 100n, // applyLag = 50
          highestIndex: 200n,
          highestRelevantIndex: 100n,
          isConnected: true,
        };

        const result = SyncProgress.isCompleteWithin(data);
        expect(result).toBe(true);
      });

      it('should return true when indices are equal (applyLag = 0)', () => {
        const data: SyncProgressData = {
          appliedIndex: 100n,
          highestRelevantWalletIndex: 100n, // applyLag = 0
          highestIndex: 200n,
          highestRelevantIndex: 100n,
          isConnected: true,
        };

        const result = SyncProgress.isCompleteWithin(data);
        expect(result).toBe(true);
      });
    });

    describe('when not connected', () => {
      it('should return false even when applyLag is within default maxGap (50)', () => {
        const data: SyncProgressData = {
          appliedIndex: 100n,
          highestRelevantWalletIndex: 120n, // applyLag = 20
          highestIndex: 200n,
          highestRelevantIndex: 120n,
          isConnected: false,
        };

        const result = SyncProgress.isCompleteWithin(data);
        expect(result).toBe(false);
      });

      it('should return false when applyLag is zero but not connected', () => {
        const data: SyncProgressData = {
          appliedIndex: 100n,
          highestRelevantWalletIndex: 100n, // applyLag = 0
          highestIndex: 200n,
          highestRelevantIndex: 100n,
          isConnected: false,
        };

        const result = SyncProgress.isCompleteWithin(data);
        expect(result).toBe(false);
      });
    });

    describe('with custom maxGap parameter', () => {
      it('should respect custom maxGap when connected', () => {
        const data: SyncProgressData = {
          appliedIndex: 100n,
          highestRelevantWalletIndex: 120n, // applyLag = 20
          highestIndex: 200n,
          highestRelevantIndex: 120n,
          isConnected: true,
        };

        const resultWithSmallGap = SyncProgress.isCompleteWithin(data, 10n);
        const resultWithLargeGap = SyncProgress.isCompleteWithin(data, 30n);

        expect(resultWithSmallGap).toBe(false); // 20 > 10
        expect(resultWithLargeGap).toBe(true); // 20 <= 30
      });

      it('should return false with custom maxGap when not connected', () => {
        const data: SyncProgressData = {
          appliedIndex: 100n,
          highestRelevantWalletIndex: 120n, // applyLag = 20
          highestIndex: 200n,
          highestRelevantIndex: 120n,
          isConnected: false,
        };

        const result = SyncProgress.isCompleteWithin(data, 100n);
        expect(result).toBe(false);
      });

      it('should handle zero maxGap', () => {
        const data: SyncProgressData = {
          appliedIndex: 100n,
          highestRelevantWalletIndex: 100n, // applyLag = 0
          highestIndex: 200n,
          highestRelevantIndex: 100n,
          isConnected: true,
        };

        const result = SyncProgress.isCompleteWithin(data, 0n);
        expect(result).toBe(true); // 0 <= 0
      });
    });
  });
});

================
File: packages/shielded-wallet/src/v1/test/transacting.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import {
  ShieldedAddress,
  ShieldedCoinPublicKey,
  ShieldedEncryptionPublicKey,
} from '@midnight-ntwrk/wallet-sdk-address-format';
import { chooseCoin } from '@midnight-ntwrk/wallet-sdk-capabilities';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Array as Arr, Effect, Iterable, Order, pipe, Record } from 'effect';
import { describe, expect, it } from 'vitest';
import { ArrayOps, EitherOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import { makeDefaultCoinsAndBalancesCapability } from '../CoinsAndBalances.js';
import { makeDefaultKeysCapability } from '../Keys.js';
import { makeSimulatorProvingService } from '../Proving.js';
import { BalanceTransactionToProve, NOTHING_TO_PROVE } from '../ProvingRecipe.js';
import { CoreWallet } from '../CoreWallet.js';
import {
  DefaultTransactingConfiguration,
  DefaultTransactingContext,
  makeSimulatorTransactingCapability,
  TokenTransfer,
} from '../Transacting.js';
import { getNonDustImbalance } from '../../test/testUtils.js';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { OtherWalletError } from '../WalletError.js';
import { Either } from 'effect';

const shieldedValue = (value: number): bigint => BigInt(value * 10 ** 6);

const shieldedTokenType = ledger.shieldedToken();
const rawShieldedTokenType = shieldedTokenType.raw;

const defaultConfig: DefaultTransactingConfiguration = {
  networkId: NetworkId.NetworkId.Undeployed,
};
const defaultContext: DefaultTransactingContext = {
  coinSelection: chooseCoin,
  coinsAndBalancesCapability: makeDefaultCoinsAndBalancesCapability(),
  keysCapability: makeDefaultKeysCapability(),
};

const coinsAndBalances = makeDefaultCoinsAndBalancesCapability();
const getAvailableCoins = (state: CoreWallet): readonly ledger.QualifiedShieldedCoinInfo[] => {
  return coinsAndBalances.getAvailableCoins(state).map((c) => c.coin);
};

type TestWallet = {
  readonly keys: ledger.ZswapSecretKeys;
  readonly wallet: CoreWallet;
};

type WalletEntry = {
  readonly keys: ledger.ZswapSecretKeys;
  readonly coins: ReadonlyArray<bigint | { tokenType: ledger.RawTokenType; value: bigint }>;
};
const prepareWallets = <Names extends string>(desired: Record<Names, WalletEntry>): Record<Names, TestWallet> => {
  const offer = pipe(
    Record.values(desired),
    Arr.flatMap((aWalletEntry: WalletEntry) =>
      Arr.map(aWalletEntry.coins, (coin) => ({ keys: aWalletEntry.keys, coin })),
    ),
    Arr.map(({ keys, coin }) =>
      makeOutputOffer({
        recipient: keys,
        coin: typeof coin === 'bigint' ? coin : ledger.createShieldedCoinInfo(coin.tokenType, coin.value),
      }),
    ),
    ArrayOps.assertNonEmpty,
    ArrayOps.fold((offerA: ledger.ZswapOffer<ledger.PreProof>, offerB: ledger.ZswapOffer<ledger.PreProof>) =>
      offerA.merge(offerB),
    ),
  );

  return pipe(
    desired,
    Record.map((entry) => ({
      keys: entry.keys,
      wallet: CoreWallet.apply(CoreWallet.initEmpty(entry.keys, NetworkId.NetworkId.Undeployed), entry.keys, offer),
    })),
  );
};

const orderCoinByValue = Order.mapInput(Order.bigint, (coin: { value: bigint }) => coin.value);

const makeOutputOffer = (args: {
  recipient: ledger.ZswapSecretKeys | TestWallet;
  coin: ledger.ShieldedCoinInfo | bigint;
  segment?: 0 | 1;
}): ledger.ZswapOffer<ledger.PreProof> => {
  const keys: ledger.ZswapSecretKeys =
    args.recipient instanceof ledger.ZswapSecretKeys ? args.recipient : args.recipient.keys;
  const coinToUse =
    typeof args.coin === 'bigint' ? ledger.createShieldedCoinInfo(rawShieldedTokenType, args.coin) : args.coin;
  const output = ledger.ZswapOutput.new(coinToUse, args.segment ?? 0, keys.coinPublicKey, keys.encryptionPublicKey);
  return ledger.ZswapOffer.fromOutput(output, coinToUse.type, coinToUse.value);
};

const encodeAddress = (keys: ledger.ZswapSecretKeys): string => {
  return ShieldedAddress.codec
    .encode(
      NetworkId.NetworkId.Undeployed,
      new ShieldedAddress(
        ShieldedCoinPublicKey.fromHexString(keys.coinPublicKey),
        ShieldedEncryptionPublicKey.fromHexString(keys.encryptionPublicKey),
      ),
    )
    .asString();
};

const makeTransferOutput = (args: {
  recipient: ledger.ZswapSecretKeys | TestWallet;
  coin: bigint | { tokenType: ledger.RawTokenType; value: bigint };
}): TokenTransfer => {
  const typeAndValue = typeof args.coin == 'bigint' ? { tokenType: rawShieldedTokenType, value: args.coin } : args.coin;
  const keys = args.recipient instanceof ledger.ZswapSecretKeys ? args.recipient : args.recipient.keys;
  return {
    type: typeAndValue.tokenType,
    amount: typeAndValue.value,
    receiverAddress: encodeAddress(keys),
  };
};

/*
 TODO: these tests work too much against zswap.LocalState
 Instead, they should be using coins and balances capabilities more, to not depend much on the underlying data
*/
describe('V1 Wallet Transacting', () => {
  describe('when balancing', () => {
    it('balances a transaction containing just outputs', async () => {
      const wallets = prepareWallets({
        A: {
          keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)),
          coins: [shieldedValue(1), shieldedValue(2), shieldedValue(3)],
        },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const proving = makeSimulatorProvingService();
      const transactionValue = shieldedValue(4);
      const tx = pipe(transactionValue, (value) => {
        const offer = makeOutputOffer({ recipient: wallets.B, coin: value });
        return ledger.Transaction.fromParts(NetworkId.NetworkId.Undeployed, offer).eraseProofs();
      });

      return Effect.gen(function* () {
        const result = EitherOps.getOrThrowLeft(transacting.balanceTransaction(wallets.A.keys, wallets.A.wallet, tx));
        const recipe = result.recipe as BalanceTransactionToProve<ledger.ProofErasedTransaction>;
        const proven = yield* proving.prove(recipe);

        expect(recipe.transactionToProve.guaranteedOffer?.deltas.get(rawShieldedTokenType)).toEqual(transactionValue);
        expect(proven.guaranteedOffer?.deltas.get(rawShieldedTokenType)).toBeUndefined();
      }).pipe(Effect.runPromise);
    });

    it('balances a transaction with a fallible offer', () => {
      const wallets = prepareWallets({
        A: {
          keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)),
          coins: [shieldedValue(1), shieldedValue(2), shieldedValue(3)],
        },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const proving = makeSimulatorProvingService();
      const transactionValueFallible = shieldedValue(2);
      const transactionValueGuaranteed = shieldedValue(2);
      const guaranteedOffer = makeOutputOffer({ recipient: wallets.B, coin: transactionValueGuaranteed });
      const fallibleOffer = makeOutputOffer({ recipient: wallets.B, coin: transactionValueFallible, segment: 1 });
      const tx = ledger.Transaction.fromParts(
        NetworkId.NetworkId.Undeployed,
        guaranteedOffer,
        fallibleOffer,
      ).eraseProofs();

      return Effect.gen(function* () {
        const result = EitherOps.getOrThrowLeft(transacting.balanceTransaction(wallets.A.keys, wallets.A.wallet, tx));
        const recipe = result.recipe as BalanceTransactionToProve<ledger.ProofErasedTransaction>;
        const proven = yield* proving.prove(recipe);
        expect(
          recipe.transactionToProve.fallibleOffer
            ?.entries()
            .map(([_, delta]) => delta.deltas.get(rawShieldedTokenType) ?? 0n)
            .reduce((acc, curr) => acc + curr, 0n),
        ).toEqual(transactionValueFallible);

        expect(recipe.transactionToProve.guaranteedOffer?.deltas.get(rawShieldedTokenType)).toBeGreaterThanOrEqual(
          transactionValueGuaranteed,
        );
        expect(proven.guaranteedOffer?.deltas.get(rawShieldedTokenType)).toBeUndefined();
      }).pipe(Effect.runPromise);
    });

    it('books coins used in balancing', () => {
      const wallets = prepareWallets({
        A: {
          keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)),
          coins: [shieldedValue(1), shieldedValue(2), shieldedValue(3)],
        },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const transactionValueFallible = shieldedValue(2);
      const transactionValueGuaranteed = shieldedValue(2);
      const guaranteedOffer = makeOutputOffer({ recipient: wallets.B, coin: transactionValueGuaranteed });
      const fallibleOffer = makeOutputOffer({ recipient: wallets.B, coin: transactionValueFallible, segment: 1 });
      const tx = ledger.Transaction.fromParts(
        NetworkId.NetworkId.Undeployed,
        guaranteedOffer,
        fallibleOffer,
      ).eraseProofs();

      const result = EitherOps.getOrThrowLeft(transacting.balanceTransaction(wallets.A.keys, wallets.A.wallet, tx));

      expect(getAvailableCoins(result.newState).length).toBe(0);
      expect(
        Arr.sort(
          result.newState.state.pendingSpends.values().map(([coin]) => coin),
          orderCoinByValue,
        ),
      ).toEqual(Arr.sort(wallets.A.wallet.state.coins, orderCoinByValue));
    });

    it('watches for change coins from balancing', () => {
      const wallets = prepareWallets({
        A: {
          keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)),
          coins: [shieldedValue(1), shieldedValue(2), shieldedValue(3)],
        },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const transactionValueFallible = shieldedValue(2);
      const transactionValueGuaranteed = shieldedValue(2);
      const guaranteedOffer = makeOutputOffer({ recipient: wallets.B, coin: transactionValueGuaranteed });
      const fallibleOffer = makeOutputOffer({ recipient: wallets.B, coin: transactionValueFallible, segment: 1 });
      const tx = ledger.Transaction.fromParts(
        NetworkId.NetworkId.Undeployed,
        guaranteedOffer,
        fallibleOffer,
      ).eraseProofs();

      const result = EitherOps.getOrThrowLeft(transacting.balanceTransaction(wallets.A.keys, wallets.A.wallet, tx));

      const pendingOutputs = Array.from(result.newState.state.pendingOutputs.values());
      expect(pendingOutputs.length).toEqual(2);
      pendingOutputs.forEach(([output]) => {
        // Knowing that default coin selection is "smaller-first", and that fallible sections needs to be balanced first to properly pay fees in the guaranteed one,
        // It leaves fallible of value 2 to be balanced with coins of value 1 and 2
        // and guaranteed of value 2 to be balanced with coin of value 3
        expect(output.value).toBeLessThanOrEqual(shieldedValue(1));
      });
    });

    it('raises an error if there are not enough tokens for balancing', () => {
      const wallets = prepareWallets({
        A: {
          keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)),
          coins: [shieldedValue(1), shieldedValue(1), shieldedValue(1)],
        },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const transactionValueFallible = shieldedValue(3);
      const changeCoin = ledger.createShieldedCoinInfo(rawShieldedTokenType, shieldedValue(3));
      const guaranteedOffer = makeOutputOffer({ recipient: wallets.A, coin: changeCoin });
      const fallibleOffer = makeOutputOffer({ recipient: wallets.B, coin: transactionValueFallible, segment: 1 });
      const tx = ledger.Transaction.fromParts(
        NetworkId.NetworkId.Undeployed,
        guaranteedOffer,
        fallibleOffer,
      ).eraseProofs();

      const result = transacting.balanceTransaction(wallets.A.keys, wallets.A.wallet, tx);

      expect(() => EitherOps.getOrThrowLeft(result)).toThrow();
    });

    it('does not try to spend booked coins for balancing', () => {
      const wallets = prepareWallets({
        A: {
          keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)),
          coins: [shieldedValue(1), shieldedValue(2), shieldedValue(3)],
        },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const transactionValueFallible = shieldedValue(2);
      const transactionValueGuaranteed = shieldedValue(2);
      const guaranteedOffer = makeOutputOffer({ recipient: wallets.B, coin: transactionValueGuaranteed });
      const fallibleOffer = makeOutputOffer({ recipient: wallets.B, coin: transactionValueFallible, segment: 1 });
      const tx = ledger.Transaction.fromParts(
        NetworkId.NetworkId.Undeployed,
        guaranteedOffer,
        fallibleOffer,
      ).eraseProofs();

      const result = EitherOps.getOrThrowLeft(transacting.balanceTransaction(wallets.A.keys, wallets.A.wallet, tx));
      const anotherTx = pipe(makeOutputOffer({ recipient: wallets.B, coin: shieldedValue(1) }), (offer) =>
        ledger.Transaction.fromParts(NetworkId.NetworkId.Undeployed, offer).eraseProofs(),
      );

      const secondResult = transacting.balanceTransaction(wallets.A.keys, result.newState, anotherTx);

      expect(() => EitherOps.getOrThrowLeft(secondResult)).toThrow();
    });
  });

  describe('when transferring', () => {
    it('prepares a transfer', () => {
      const wallets = prepareWallets({
        A: {
          keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)),
          coins: [shieldedValue(1), shieldedValue(2), shieldedValue(3)],
        },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const proving = makeSimulatorProvingService();

      return Effect.gen(function* () {
        const result = yield* EitherOps.toEffect(
          transacting.makeTransfer(wallets.A.keys, wallets.A.wallet, [
            makeTransferOutput({ recipient: wallets.B, coin: shieldedValue(2) }),
          ]),
        );
        const proven = yield* proving.prove(result.recipe);

        expect(proven.guaranteedOffer?.deltas.get(rawShieldedTokenType)).toBeUndefined();
      }).pipe(Effect.runPromise);
    });

    it('books coins used in transfer', () => {
      const initialCoinValues = [shieldedValue(1), shieldedValue(2), shieldedValue(3)];
      const transferValue = shieldedValue(2);
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: initialCoinValues },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);

      return Effect.gen(function* () {
        const result = yield* EitherOps.toEffect(
          transacting.makeTransfer(wallets.A.keys, wallets.A.wallet, [
            makeTransferOutput({ recipient: wallets.B, coin: transferValue }),
          ]),
        );

        const bookedCoinValues = result.newState.state.pendingSpends
          .values()
          .map(([c]) => c.value)
          .toArray();
        const availableCoinValues = getAvailableCoins(result.newState).map((c) => c.value);
        const sumValues = ArrayOps.sumBigInt([...bookedCoinValues, ...availableCoinValues]);
        const bookedCoinsSum = ArrayOps.sumBigInt(bookedCoinValues);

        expect(sumValues).toEqual(ArrayOps.sumBigInt(initialCoinValues));
        expect(Arr.sort([...bookedCoinValues, ...availableCoinValues], Order.bigint)).toEqual(initialCoinValues);
        expect(bookedCoinsSum).toBeGreaterThanOrEqual(transferValue);
      }).pipe(Effect.runPromise);
    });

    it('watches for change coins from a transfer', () => {
      const initialCoinValues = [shieldedValue(1), shieldedValue(2), shieldedValue(3)];
      const transferValue = shieldedValue(2);
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: initialCoinValues },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);

      const result = EitherOps.getOrThrowLeft(
        transacting.makeTransfer(wallets.A.keys, wallets.A.wallet, [
          makeTransferOutput({ recipient: wallets.B, coin: transferValue }),
        ]),
      );

      const availableCoinValues = getAvailableCoins(result.newState).map((c) => c.value);
      const pendingCoinValues = result.newState.state.pendingOutputs
        .values()
        .map(([c]) => c.value)
        .toArray();
      const sumValues: bigint = pipe([pendingCoinValues, availableCoinValues], Arr.flatten, ArrayOps.sumBigInt);

      //Final total balance needs to be within range of 1 dust from original one with subtracted transfer value
      expect(sumValues).toBeGreaterThanOrEqual(
        ArrayOps.sumBigInt(initialCoinValues) - transferValue - shieldedValue(1),
      );
      expect(sumValues).toEqual(ArrayOps.sumBigInt(initialCoinValues) - transferValue);
      pendingCoinValues.forEach((value) => {
        expect(value).toEqual(shieldedValue(1)); //knowing coin selection, we do not expect bigger pending coin
      });
    });

    it('raises an error if there are not enough tokens for transfer', () => {
      const initialCoinValues = [shieldedValue(1), shieldedValue(2), shieldedValue(3)];
      const transferValue = shieldedValue(6);
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: initialCoinValues },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);

      const result = transacting.makeTransfer(wallets.A.keys, wallets.A.wallet, [
        makeTransferOutput({ recipient: wallets.B, coin: transferValue }),
      ]);

      expect(() => EitherOps.getOrThrowLeft(result)).toThrow();
    });

    it('raises an error with correct message when transfer has zero amount', () => {
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: [shieldedValue(1)] },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);

      const result = transacting.makeTransfer(wallets.A.keys, wallets.A.wallet, [
        makeTransferOutput({ recipient: wallets.B, coin: 0n }),
      ]);

      expect(Either.isLeft(result)).toBe(true);
      if (Either.isLeft(result)) {
        expect(result.left).toBeInstanceOf(OtherWalletError);
        expect(result.left.message).toBe('The amount needs to be positive');
      }
    });

    it('raises an error with correct message when transfer has no positive amounts', () => {
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: [shieldedValue(1)] },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);

      const result = transacting.makeTransfer(wallets.A.keys, wallets.A.wallet, [
        makeTransferOutput({ recipient: wallets.B, coin: 0n }),
        makeTransferOutput({ recipient: wallets.B, coin: 0n }),
      ]);

      expect(Either.isLeft(result)).toBe(true);
      if (Either.isLeft(result)) {
        expect(result.left).toBeInstanceOf(OtherWalletError);
        expect(result.left.message).toBe('The amount needs to be positive');
      }
    });

    it('does not try to spend booked coins for a transfer', () => {
      const initialCoinValues = [shieldedValue(1), shieldedValue(2), shieldedValue(3)];
      const transferValue = shieldedValue(5);
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: initialCoinValues },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const result = EitherOps.getOrThrowLeft(
        transacting.makeTransfer(wallets.A.keys, wallets.A.wallet, [
          makeTransferOutput({ recipient: wallets.B, coin: transferValue }),
        ]),
      );
      const secondResult = transacting.makeTransfer(wallets.A.keys, result.newState, [
        makeTransferOutput({ recipient: wallets.B, coin: shieldedValue(1) }),
      ]);

      expect(() => EitherOps.getOrThrowLeft(secondResult)).toThrow();
    });
  });

  describe('when handling swaps', () => {
    it('inits a swap with dust input and non-dust output', () => {
      const theOtherTokenType = ledger.sampleRawTokenType();
      const theOtherTokenAmount = 10_000n;
      const initialCoinValues = [shieldedValue(1), shieldedValue(2), shieldedValue(3)];
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: initialCoinValues },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const proving = makeSimulatorProvingService();

      return Effect.gen(function* () {
        const result = yield* EitherOps.toEffect(
          transacting.initSwap(wallets.A.keys, wallets.A.wallet, { [rawShieldedTokenType]: shieldedValue(1) }, [
            makeTransferOutput({
              recipient: wallets.A,
              coin: { tokenType: theOtherTokenType, value: theOtherTokenAmount },
            }),
          ]),
        );
        const proven: ledger.ProofErasedTransaction = yield* proving.prove(result.recipe);
        const imbalances = proven.imbalances(0);
        expect(new Set(imbalances.keys().filter((key) => key.tag === 'shielded'))).toEqual(
          new Set([shieldedTokenType, { tag: 'shielded', raw: theOtherTokenType }]),
        );
        expect(getNonDustImbalance(imbalances, rawShieldedTokenType)).not.toBeUndefined();
        expect(getNonDustImbalance(imbalances, rawShieldedTokenType)).toBe(shieldedValue(1));
        expect(getNonDustImbalance(imbalances, theOtherTokenType)).toEqual(-1n * theOtherTokenAmount);
      }).pipe(Effect.runPromise);
    });

    it('inits a swap with non-dust input and dust output', () => {
      const theOtherTokenType = ledger.sampleRawTokenType();
      const theOtherTokenAmount = 10_000n;
      const initialCoinValues = [
        shieldedValue(1),
        shieldedValue(2),
        shieldedValue(3),
        { tokenType: theOtherTokenType, value: theOtherTokenAmount },
      ];
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: initialCoinValues },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const proving = makeSimulatorProvingService();

      return Effect.gen(function* () {
        const result = yield* EitherOps.toEffect(
          transacting.initSwap(wallets.A.keys, wallets.A.wallet, { [theOtherTokenType]: theOtherTokenAmount }, [
            makeTransferOutput({
              recipient: wallets.A,
              coin: shieldedValue(1),
            }),
          ]),
        );
        const proven: ledger.ProofErasedTransaction = yield* proving.prove(result.recipe);
        const imbalances = proven.imbalances(0);
        expect(new Set(imbalances.keys())).toEqual(
          new Set([shieldedTokenType, { tag: 'shielded', raw: theOtherTokenType }]),
        );
        expect(getNonDustImbalance(imbalances, rawShieldedTokenType)).toBeLessThan(0n);
        expect(getNonDustImbalance(imbalances, rawShieldedTokenType)).toEqual(-1n * shieldedValue(1));
        expect(getNonDustImbalance(imbalances, theOtherTokenType)).toEqual(theOtherTokenAmount);
      }).pipe(Effect.runPromise);
    });

    it('inits a swap with non-dust input and non-dust output', () => {
      const theOtherTokenType1 = ledger.sampleRawTokenType();
      const theOtherTokenAmount1 = 10_000n;
      const theOtherTokenType2 = ledger.sampleRawTokenType();
      const theOtherTokenAmount2 = 10_000n;
      const initialCoinValues = [
        shieldedValue(1),
        shieldedValue(2),
        shieldedValue(3),
        { tokenType: theOtherTokenType1, value: theOtherTokenAmount1 },
      ];
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: initialCoinValues },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const proving = makeSimulatorProvingService();

      return Effect.gen(function* () {
        const result = yield* EitherOps.toEffect(
          transacting.initSwap(wallets.A.keys, wallets.A.wallet, { [theOtherTokenType1]: theOtherTokenAmount1 }, [
            makeTransferOutput({
              recipient: wallets.A,
              coin: { tokenType: theOtherTokenType2, value: theOtherTokenAmount2 },
            }),
          ]),
        );
        const proven: ledger.ProofErasedTransaction = yield* proving.prove(result.recipe);
        const imbalances = proven.imbalances(0);

        expect(new Set(imbalances.keys())).toEqual(
          new Set([
            { tag: 'shielded', raw: theOtherTokenType1 },
            { tag: 'shielded', raw: theOtherTokenType2 },
          ]),
        );

        expect(getNonDustImbalance(imbalances, theOtherTokenType1)).toEqual(theOtherTokenAmount1);
        expect(getNonDustImbalance(imbalances, theOtherTokenType2)).toEqual(-1n * theOtherTokenAmount2);
      }).pipe(Effect.runPromise);
    });

    it('balances a swap', () => {
      const theOtherTokenType = ledger.sampleRawTokenType();
      const theOtherTokenAmount = 10_000n;
      const dustAmount = shieldedValue(1);
      const wallets = prepareWallets({
        A: {
          keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)),
          coins: [shieldedValue(1), shieldedValue(2), shieldedValue(3)],
        },
        B: {
          keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)),
          coins: [shieldedValue(1), { tokenType: theOtherTokenType, value: theOtherTokenAmount }],
        },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const proving = makeSimulatorProvingService();

      return Effect.gen(function* () {
        const result = yield* EitherOps.toEffect(
          transacting.initSwap(wallets.A.keys, wallets.A.wallet, { [rawShieldedTokenType]: dustAmount }, [
            makeTransferOutput({
              recipient: wallets.A,
              coin: { tokenType: theOtherTokenType, value: theOtherTokenAmount },
            }),
          ]),
        );
        const proven: ledger.ProofErasedTransaction = yield* proving.prove(result.recipe);
        const balancedResult = yield* EitherOps.toEffect(
          transacting.balanceTransaction(wallets.B.keys, wallets.B.wallet, proven),
        );
        const balancedProven = yield* proving.prove(balancedResult.recipe);

        const imbalances = balancedProven.imbalances(0);

        expect(new Set(imbalances.keys()).size).toBe(0);
        expect(getNonDustImbalance(imbalances, rawShieldedTokenType)).toBe(0n);
      }).pipe(Effect.runPromise);
    });

    it('books coins spent in a swap', () => {
      const theOtherTokenType = ledger.sampleRawTokenType();
      const theOtherTokenAmount = 10_000n;
      const initialCoinValues = [shieldedValue(1), shieldedValue(2), shieldedValue(3)];
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: initialCoinValues },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);

      const result = EitherOps.getOrThrowLeft(
        transacting.initSwap(wallets.A.keys, wallets.A.wallet, { [rawShieldedTokenType]: shieldedValue(1) }, [
          makeTransferOutput({
            recipient: wallets.A,
            coin: { tokenType: theOtherTokenType, value: theOtherTokenAmount },
          }),
        ]),
      );
      const bookedCoins = pipe(
        result.newState.state.pendingOutputs.values(),
        Iterable.map(([coin]) => ({ type: coin.type, value: coin.value })),
        Arr.sort(orderCoinByValue),
      );

      expect(bookedCoins).toEqual([{ type: theOtherTokenType, value: theOtherTokenAmount }]);
    });

    it('watches for coins expected to be received from a swap', () => {
      const theOtherTokenType = ledger.sampleRawTokenType();
      const theOtherTokenAmount = 10_000n;
      const dustAmount = shieldedValue(1);
      const initialCoinValues = [shieldedValue(1), shieldedValue(2), shieldedValue(3)];
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: initialCoinValues },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);

      const result = EitherOps.getOrThrowLeft(
        transacting.initSwap(wallets.A.keys, wallets.A.wallet, { [rawShieldedTokenType]: dustAmount }, [
          makeTransferOutput({
            recipient: wallets.A,
            coin: { tokenType: theOtherTokenType, value: theOtherTokenAmount },
          }),
        ]),
      );
      const expectedCoins = pipe(
        result.newState.state.pendingOutputs.values(),
        Record.fromIterableWith(([coin]) => [coin.type, coin.value]),
      );

      expect(new Set(Record.keys(expectedCoins))).toEqual(new Set([theOtherTokenType]));
      expect(expectedCoins[theOtherTokenType]).toEqual(theOtherTokenAmount);
    });

    it('raises an error if there are not enough tokens for swap', () => {
      const theOtherTokenType = ledger.sampleRawTokenType();
      const theOtherTokenAmount = 10_000n;
      const dustAmount = shieldedValue(1);
      const initialCoinValues = [shieldedValue(1), shieldedValue(2), shieldedValue(3)];
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: initialCoinValues },
        B: {
          keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)),
          coins: [{ tokenType: theOtherTokenType, value: theOtherTokenAmount }],
        },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);

      const resultA = transacting.initSwap(
        wallets.A.keys,
        wallets.A.wallet,
        { [theOtherTokenType]: theOtherTokenAmount },
        [makeTransferOutput({ recipient: wallets.A, coin: dustAmount })],
      );

      const resultB = transacting.initSwap(wallets.B.keys, wallets.B.wallet, { [rawShieldedTokenType]: dustAmount }, [
        makeTransferOutput({
          recipient: wallets.B,
          coin: { tokenType: theOtherTokenType, value: theOtherTokenAmount },
        }),
      ]);

      expect(() => EitherOps.getOrThrowLeft(resultA)).toThrow();
      expect(() => EitherOps.getOrThrowLeft(resultB)).toThrow();
    });

    it('raises an error with correct message when swap has non-positive outputs', () => {
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: [shieldedValue(1)] },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);

      const result = transacting.initSwap(wallets.A.keys, wallets.A.wallet, {}, [
        makeTransferOutput({ recipient: wallets.B, coin: 0n }),
      ]);

      expect(Either.isLeft(result)).toBe(true);
      if (Either.isLeft(result)) {
        expect(result.left).toBeInstanceOf(OtherWalletError);
        expect(result.left.message).toBe('The amount needs to be positive');
      }
    });

    it('raises an error with correct message when swap has non-positive inputs', () => {
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: [shieldedValue(1)] },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);

      const result = transacting.initSwap(wallets.A.keys, wallets.A.wallet, { [rawShieldedTokenType]: 0n }, [
        makeTransferOutput({ recipient: wallets.B, coin: shieldedValue(1) }),
      ]);

      expect(Either.isLeft(result)).toBe(true);
      if (Either.isLeft(result)) {
        expect(result.left).toBeInstanceOf(OtherWalletError);
        expect(result.left.message).toBe('The input amounts need to be positive');
      }
    });

    it('does not try to use booked coins for a swap', () => {
      const theOtherTokenType = ledger.sampleRawTokenType();
      const theOtherTokenAmount = 10_000n;
      const dustAmount = shieldedValue(1);
      const initialCoinValues = [shieldedValue(3)];
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: initialCoinValues },
        B: {
          keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)),
          coins: [],
        },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);

      const firstResult = EitherOps.getOrThrowLeft(
        transacting.makeTransfer(wallets.A.keys, wallets.A.wallet, [
          makeTransferOutput({ recipient: wallets.B, coin: dustAmount }),
        ]),
      );
      const secondResult = transacting.initSwap(
        wallets.A.keys,
        firstResult.newState,
        { [rawShieldedTokenType]: dustAmount },
        [
          makeTransferOutput({
            recipient: wallets.A,
            coin: { tokenType: theOtherTokenType, value: theOtherTokenAmount },
          }),
        ],
      );

      expect(() => EitherOps.getOrThrowLeft(secondResult)).toThrow();
    });
  });

  /**
   *
   * .applyFailed is missing from ZswapLocalState [https://shielded.atlassian.net/browse/PM-19678]
   */
  describe.skip('when reverting and cancelling transactions', () => {
    it('reverts a transaction (e.g. due to a submission failure), releasing booked coins', () => {
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: [shieldedValue(3)] },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const proving = makeSimulatorProvingService();

      return Effect.gen(function* () {
        const result = yield* EitherOps.toEffect(
          transacting.makeTransfer(wallets.A.keys, wallets.A.wallet, [
            makeTransferOutput({ recipient: wallets.B, coin: shieldedValue(2) }),
          ]),
        );
        const proven = yield* proving.prove(result.recipe);
        const afterRevert: CoreWallet = EitherOps.getOrThrowLeft(transacting.revert(result.newState, proven));

        expect(getAvailableCoins(afterRevert).map((coin) => ({ type: coin.type, value: coin.value }))).toEqual([
          { type: rawShieldedTokenType, value: shieldedValue(3) },
        ]);
        expect(afterRevert.state.pendingSpends.size).toEqual(0);
      }).pipe(Effect.runPromise);
    });

    it('reverts a transaction (e.g. due to a submission failure), cancelling coin watches', () => {
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: [shieldedValue(3)] },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const proving = makeSimulatorProvingService();

      return Effect.gen(function* () {
        const result = yield* EitherOps.toEffect(
          transacting.makeTransfer(wallets.A.keys, wallets.A.wallet, [
            makeTransferOutput({ recipient: wallets.B, coin: shieldedValue(2) }),
          ]),
        );
        const proven = yield* proving.prove(result.recipe);
        const afterRevert: CoreWallet = EitherOps.getOrThrowLeft(transacting.revert(result.newState, proven));

        expect(afterRevert.state.pendingOutputs.size).toEqual(0);
      }).pipe(Effect.runPromise);
    });

    it('reverts a transaction merged with some other one, releasing booked coins', () => {
      const theOtherTokenType = ledger.sampleRawTokenType();
      const theOtherTokenAmount = 10_000n;
      const dustAmount = shieldedValue(1);
      const initialCoinValues = [shieldedValue(3)];
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: initialCoinValues },
        B: {
          keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)),
          coins: [{ tokenType: theOtherTokenType, value: theOtherTokenAmount }],
        },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const proving = makeSimulatorProvingService();

      return Effect.gen(function* () {
        const result = yield* EitherOps.toEffect(
          transacting.initSwap(wallets.A.keys, wallets.A.wallet, { [rawShieldedTokenType]: dustAmount }, [
            makeTransferOutput({
              recipient: wallets.A,
              coin: { tokenType: theOtherTokenType, value: theOtherTokenAmount },
            }),
          ]),
        );
        const proven: ledger.ProofErasedTransaction = yield* proving.prove(result.recipe);
        const balancedResult = yield* EitherOps.toEffect(
          transacting.balanceTransaction(wallets.B.keys, wallets.B.wallet, proven),
        );
        const balancedProven = yield* proving.prove(balancedResult.recipe);

        const afterRevertA: CoreWallet = EitherOps.getOrThrowLeft(transacting.revert(result.newState, balancedProven));
        const afterRevertB: CoreWallet = EitherOps.getOrThrowLeft(
          transacting.revert(balancedResult.newState, balancedProven),
        );

        expect(afterRevertA.state.pendingSpends.size).toEqual(0);
        expect(afterRevertB.state.pendingSpends.size).toEqual(0);
      }).pipe(Effect.runPromise);
    });

    it('reverts a transaction merged with some other one, cancelling coin watches', () => {
      const theOtherTokenType = ledger.sampleRawTokenType();
      const theOtherTokenAmount = 10_000n;
      const dustAmount = shieldedValue(1);
      const initialCoinValues = [shieldedValue(3)];
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: initialCoinValues },
        B: {
          keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)),
          coins: [{ tokenType: theOtherTokenType, value: theOtherTokenAmount }],
        },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const proving = makeSimulatorProvingService();

      return Effect.gen(function* () {
        const result = yield* EitherOps.toEffect(
          transacting.initSwap(wallets.A.keys, wallets.A.wallet, { [rawShieldedTokenType]: dustAmount }, [
            makeTransferOutput({
              recipient: wallets.A,
              coin: { tokenType: theOtherTokenType, value: theOtherTokenAmount },
            }),
          ]),
        );
        const proven: ledger.ProofErasedTransaction = yield* proving.prove(result.recipe);
        const balancedResult = yield* EitherOps.toEffect(
          transacting.balanceTransaction(wallets.B.keys, wallets.B.wallet, proven),
        );
        const balancedProven = yield* proving.prove(balancedResult.recipe);

        const afterRevertA: CoreWallet = EitherOps.getOrThrowLeft(transacting.revert(result.newState, balancedProven));
        const afterRevertB: CoreWallet = EitherOps.getOrThrowLeft(
          transacting.revert(balancedResult.newState, balancedProven),
        );

        expect(afterRevertA.state.pendingOutputs.size).toEqual(0);
        expect(afterRevertB.state.pendingOutputs.size).toEqual(0);
      }).pipe(Effect.runPromise);
    });

    it('reverts a transaction, releasing booked coins from fallible offer', () => {
      const theOtherTokenType = ledger.sampleRawTokenType();
      const theOtherTokenAmount = 10_000n;
      const initialCoinValues = [shieldedValue(3), { tokenType: theOtherTokenType, value: theOtherTokenAmount }];
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: initialCoinValues },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const proving = makeSimulatorProvingService();

      return Effect.gen(function* () {
        const fallibleOffer = makeOutputOffer({
          coin: ledger.createShieldedCoinInfo(theOtherTokenType, theOtherTokenAmount),
          recipient: wallets.B,
          segment: 1,
        });
        const guaranteedOffer = makeOutputOffer({
          coin: shieldedValue(1),
          recipient: wallets.B,
          segment: 0,
        });
        const txToBalance = ledger.Transaction.fromParts(
          NetworkId.NetworkId.Undeployed,
          guaranteedOffer,
          fallibleOffer,
        ).eraseProofs();

        const balanceResult = yield* EitherOps.toEffect(
          transacting.balanceTransaction(wallets.A.keys, wallets.A.wallet, txToBalance),
        );
        const balancedProven: ledger.ProofErasedTransaction = yield* proving.prove(balanceResult.recipe);

        const afterRevert: CoreWallet = EitherOps.getOrThrowLeft(
          transacting.revert(balanceResult.newState, balancedProven),
        );

        expect(
          Arr.sort(
            afterRevert.state.coins
              .values()
              .map((coin) => ({ type: coin.type, value: coin.value }))
              .toArray(),
            orderCoinByValue,
          ),
        ).toEqual([
          { type: theOtherTokenType, value: theOtherTokenAmount },
          { type: rawShieldedTokenType, value: shieldedValue(3) },
        ]);
        expect(afterRevert.state.pendingSpends.size).toEqual(0);
      }).pipe(Effect.runPromise);
    });

    it('reverts a transaction, cancelling coin watches from fallible offer', () => {
      const theOtherTokenType = ledger.sampleRawTokenType();
      const theOtherTokenAmount = 10_000n;
      const initialCoinValues = [shieldedValue(3), { tokenType: theOtherTokenType, value: theOtherTokenAmount }];
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: initialCoinValues },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);
      const proving = makeSimulatorProvingService();

      return Effect.gen(function* () {
        const fallibleOffer = makeOutputOffer({
          coin: ledger.createShieldedCoinInfo(theOtherTokenType, theOtherTokenAmount),
          recipient: wallets.B,
          segment: 1,
        });
        const guaranteedOffer = makeOutputOffer({
          coin: shieldedValue(1),
          recipient: wallets.B,
          segment: 0,
        });
        const txToBalance = ledger.Transaction.fromParts(
          NetworkId.NetworkId.Undeployed,
          guaranteedOffer,
          fallibleOffer,
        ).eraseProofs();

        const balanceResult = yield* EitherOps.toEffect(
          transacting.balanceTransaction(wallets.A.keys, wallets.A.wallet, txToBalance),
        );
        const balancedProven: ledger.ProofErasedTransaction = yield* proving.prove(balanceResult.recipe);

        const afterRevert: CoreWallet = EitherOps.getOrThrowLeft(
          transacting.revert(balanceResult.newState, balancedProven),
        );

        expect(afterRevert.state.pendingOutputs.size).toEqual(0);
      }).pipe(Effect.runPromise);
    });

    it('reverts a balancing recipe (e.g. due to user cancelling it), releasing booked coins from both fallible and guaranteed offer', () => {
      const theOtherTokenType = ledger.sampleRawTokenType();
      const theOtherTokenAmount = 10_000n;
      const initialCoinValues = [shieldedValue(3), { tokenType: theOtherTokenType, value: theOtherTokenAmount }];
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: initialCoinValues },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);

      const fallibleOffer = makeOutputOffer({
        coin: ledger.createShieldedCoinInfo(theOtherTokenType, theOtherTokenAmount),
        recipient: wallets.B,
        segment: 1,
      });
      const guaranteedOffer = makeOutputOffer({
        coin: shieldedValue(1),
        recipient: wallets.B,
        segment: 0,
      });
      const txToBalance = ledger.Transaction.fromParts(
        NetworkId.NetworkId.Undeployed,
        guaranteedOffer,
        fallibleOffer,
      ).eraseProofs();

      const balanceResult = EitherOps.getOrThrowLeft(
        transacting.balanceTransaction(wallets.A.keys, wallets.A.wallet, txToBalance),
      );

      const afterRevert: CoreWallet = EitherOps.getOrThrowLeft(
        transacting.revertRecipe(balanceResult.newState, balanceResult.recipe),
      );

      expect(
        Arr.sort(
          afterRevert.state.coins
            .values()
            .map((coin) => ({ type: coin.type, value: coin.value }))
            .toArray(),
          orderCoinByValue,
        ),
      ).toEqual([
        { type: theOtherTokenType, value: theOtherTokenAmount },
        { type: rawShieldedTokenType, value: shieldedValue(3) },
      ]);
      expect(afterRevert.state.pendingSpends.size).toEqual(0);
    });

    it('reverts a balancing recipe (e.g. due to user cancelling it), cancelling coin watches from both fallible and guaranteed offer', () => {
      const theOtherTokenType = ledger.sampleRawTokenType();
      const theOtherTokenAmount = 10_000n;
      const initialCoinValues = [shieldedValue(3), { tokenType: theOtherTokenType, value: theOtherTokenAmount }];
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: initialCoinValues },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);

      const fallibleOffer = makeOutputOffer({
        coin: ledger.createShieldedCoinInfo(theOtherTokenType, theOtherTokenAmount),
        recipient: wallets.B,
        segment: 1,
      });
      const guaranteedOffer = makeOutputOffer({
        coin: shieldedValue(1),
        recipient: wallets.B,
        segment: 0,
      });
      const txToBalance = ledger.Transaction.fromParts(
        NetworkId.NetworkId.Undeployed,
        guaranteedOffer,
        fallibleOffer,
      ).eraseProofs();

      const balanceResult = EitherOps.getOrThrowLeft(
        transacting.balanceTransaction(wallets.A.keys, wallets.A.wallet, txToBalance),
      );

      const afterRevert: CoreWallet = EitherOps.getOrThrowLeft(
        transacting.revertRecipe(balanceResult.newState, balanceResult.recipe),
      );

      expect(afterRevert.state.pendingOutputs.size).toEqual(0);
    });

    it('reverts a transfer recipe, releasing booked coins', () => {
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: [shieldedValue(3)] },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);

      const result = EitherOps.getOrThrowLeft(
        transacting.makeTransfer(wallets.A.keys, wallets.A.wallet, [
          makeTransferOutput({ recipient: wallets.B, coin: shieldedValue(2) }),
        ]),
      );
      const afterRevert: CoreWallet = EitherOps.getOrThrowLeft(
        transacting.revertRecipe(result.newState, result.recipe),
      );

      expect(
        afterRevert.state.coins
          .values()
          .map((coin) => ({ type: coin.type, value: coin.value }))
          .toArray(),
      ).toEqual([{ type: rawShieldedTokenType, value: shieldedValue(3) }]);
      expect(afterRevert.state.pendingSpends.size).toEqual(0);
    });

    it('reverts a transfer recipe, cancelling coin watches', () => {
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: [shieldedValue(3)] },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);

      const result = EitherOps.getOrThrowLeft(
        transacting.makeTransfer(wallets.A.keys, wallets.A.wallet, [
          makeTransferOutput({ recipient: wallets.B, coin: shieldedValue(2) }),
        ]),
      );
      const afterRevert: CoreWallet = EitherOps.getOrThrowLeft(
        transacting.revertRecipe(result.newState, result.recipe),
      );

      expect(afterRevert.state.pendingOutputs.size).toEqual(0);
    });

    it('does nothing reverting a "nothing to prove" recipe', () => {
      const wallets = prepareWallets({
        A: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0)), coins: [shieldedValue(3)] },
        B: { keys: ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)), coins: [] },
      });
      const transacting = makeSimulatorTransactingCapability(defaultConfig, () => defaultContext);

      const result = EitherOps.getOrThrowLeft(
        transacting.makeTransfer(wallets.A.keys, wallets.A.wallet, [
          makeTransferOutput({ recipient: wallets.B, coin: shieldedValue(2) }),
        ]),
      );

      const afterRevert: CoreWallet = EitherOps.getOrThrowLeft(
        transacting.revertRecipe(result.newState, {
          type: NOTHING_TO_PROVE,
          transaction: pipe(
            makeOutputOffer({ recipient: wallets.A, coin: shieldedValue(1) }),
            (offer) => ledger.Transaction.fromParts(NetworkId.NetworkId.Undeployed, offer),
            (tx) => tx.eraseProofs(),
          ),
        }),
      );

      expect(afterRevert).toBe(result.newState);
    });
  });
});

================
File: packages/shielded-wallet/src/v1/test/v1.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { describe, it, expect, vi } from 'vitest';
import { DefaultV1Variant, V1Builder } from '../V1Builder.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { WalletError } from '../WalletError.js';
import { Effect, Either, Encoding, Option, pipe, Ref, SubscriptionRef } from 'effect';
import { SubmissionService } from '../Submission.js';
import { makeDefaultTransactingCapability } from '../Transacting.js';
import { NodeContext } from '@effect/platform-node';
import { WalletSeed, NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { makeDefaultCoinsAndBalancesCapability } from '../CoinsAndBalances.js';
import { chooseCoin } from '@midnight-ntwrk/wallet-sdk-capabilities';
import { makeDefaultKeysCapability } from '../Keys.js';
import { CoreWallet } from '../CoreWallet.js';
import { makeFakeTx } from '../../test/genTxs.js';

describe('V1 Variant', () => {
  it('gracefully stops submission service', async () => {
    const makeFakeSubmission = Ref.make<boolean>(false).pipe(
      Effect.map((ref) => ({
        wasClosedRef: ref,
        submitTransaction: () =>
          Effect.fail(WalletError.submission(new Error('This submission implementation does not submit'))),
        close: (): Effect.Effect<void> => Ref.set(ref, true),
      })),
    );

    const result = await Effect.gen(function* () {
      const fakeSubmission = yield* makeFakeSubmission;
      const variant: DefaultV1Variant = new V1Builder()
        .withDefaults()
        .withSubmission(() => fakeSubmission)
        .build({
          networkId: NetworkId.NetworkId.Undeployed,
          relayURL: new URL('http://localhost:9944'),
          indexerClientConnection: {
            indexerHttpUrl: 'http://localhost:8080',
          },
          provingServerUrl: new URL('http://localhost:6300'),
        });
      const secretKeys = ledger.ZswapSecretKeys.fromSeed(
        WalletSeed.fromString('0000000000000000000000000000000000000000000000000000000000000001'),
      );
      const initialState = CoreWallet.initEmpty(secretKeys, NetworkId.NetworkId.Undeployed);
      yield* variant.start({ stateRef: yield* SubscriptionRef.make(initialState) });
      return fakeSubmission.wasClosedRef;
    }).pipe(
      Effect.scoped,
      Effect.flatMap((ref) => Ref.get(ref)),
      Effect.runPromise,
    );

    //Having the wallet start and end before getting ref allows to meaningfully read
    // its state as a sign whether close was called or not
    expect(result).toBe(true);
  });

  it('reverts transaction, which failed submission', async () => {
    const config = {
      networkId: NetworkId.NetworkId.Undeployed,
      relayURL: new URL('http://localhost:9944'),
      indexerClientConnection: {
        indexerHttpUrl: 'http://localhost:8080',
      },
      provingServerUrl: new URL('http://localhost:6300'),
    };
    const expectedState = CoreWallet.initEmpty(
      ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1)),
      NetworkId.NetworkId.Undeployed,
    );
    const testProgram = Effect.gen(function* () {
      const theTransaction = makeFakeTx(100n) as unknown as ledger.FinalizedTransaction; // @TODO optimize
      const failingSubmission: SubmissionService<ledger.FinalizedTransaction> = {
        submitTransaction: () => Effect.fail(WalletError.submission(new Error('boo!'))),
        close: () => Effect.void,
      };
      const transacting = makeDefaultTransactingCapability(config, () => ({
        coinsAndBalancesCapability: makeDefaultCoinsAndBalancesCapability(),
        coinSelection: chooseCoin,
        keysCapability: makeDefaultKeysCapability(),
      }));
      const spiedRevert = vi.spyOn(transacting, 'revert');
      spiedRevert.mockImplementation((state, transaction) => {
        if (Encoding.encodeHex(transaction.serialize()) === Encoding.encodeHex(theTransaction.serialize())) {
          // Returning a completely different state allows to later test that it is properly connected, without invoking the actual logic
          return Either.right(expectedState);
        } else {
          return Either.left(WalletError.other('Unexpected tx'));
        }
      });

      const variant = new V1Builder()
        .withDefaults()
        .withSubmission(() => failingSubmission)
        .withTransacting(() => transacting)
        .build(config);
      const secretKeys = ledger.ZswapSecretKeys.fromSeed(
        WalletSeed.fromString('0000000000000000000000000000000000000000000000000000000000000001'),
      );
      const initialState = CoreWallet.empty(secretKeys, NetworkId.NetworkId.Undeployed);
      const stateRef = yield* SubscriptionRef.make(initialState);
      const running = yield* variant.start({ stateRef: stateRef });
      const submissionResult = yield* running.submitTransaction(theTransaction).pipe(Effect.either);
      const lastState = yield* SubscriptionRef.get(stateRef);

      return { submissionResult, lastState };
    });

    const result = await pipe(testProgram, Effect.scoped, Effect.provide(NodeContext.layer), Effect.runPromise);

    expect(pipe(result.submissionResult, Either.getLeft, Option.getOrThrow).message).toMatch('boo!');
    expect(result.lastState).toBe(expectedState);
  });
});

================
File: packages/shielded-wallet/src/v1/CoinsAndBalances.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { CoreWallet } from './CoreWallet.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { pipe, Array } from 'effect';
import { RecordOps } from '@midnight-ntwrk/wallet-sdk-utilities';

export type AvailableCoin = {
  coin: ledger.QualifiedShieldedCoinInfo;
  commitment: ledger.CoinCommitment;
  nullifier: ledger.Nullifier;
};

export type PendingCoin = {
  coin: ledger.ShieldedCoinInfo;
  ttl: Date | undefined;
  commitment: ledger.CoinCommitment;
  nullifier: ledger.Nullifier;
};

export type Coin = AvailableCoin | PendingCoin;

export type Balances = Record<ledger.RawTokenType, bigint>;

export type CoinsAndBalancesCapability<TState> = {
  getAvailableBalances(state: TState): Balances;
  getPendingBalances(state: TState): Balances;
  getTotalBalances(state: TState): Balances;
  getAvailableCoins(state: TState): readonly AvailableCoin[];
  getPendingCoins(state: TState): readonly PendingCoin[];
  getTotalCoins(state: TState): ReadonlyArray<AvailableCoin | PendingCoin>;
};

const calculateBalances = <T extends AvailableCoin | PendingCoin>(coins: T[]): Balances =>
  coins.reduce(
    (acc: Balances, { coin }) => ({
      ...acc,
      [coin.type]: acc[coin.type] === undefined ? coin.value : acc[coin.type] + coin.value,
    }),
    {},
  );

export const makeDefaultCoinsAndBalancesCapability = (): CoinsAndBalancesCapability<CoreWallet> => {
  const getAvailableBalances = (state: CoreWallet): Balances => {
    const availableCoins = getAvailableCoins(state);

    return calculateBalances(availableCoins);
  };

  const getPendingBalances = (state: CoreWallet): Balances => {
    const pendingCoins = getPendingCoins(state);

    return calculateBalances(pendingCoins);
  };

  const getTotalBalances = (state: CoreWallet): Balances => {
    const availableBalances = getAvailableBalances(state);
    const pendingBalances = getPendingBalances(state);

    return pipe(
      [availableBalances, pendingBalances],
      RecordOps.mergeWithAccumulator(0n, (a, b) => a + b),
    );
  };

  const getAvailableCoins = (state: CoreWallet): AvailableCoin[] => {
    const pendingSpends = new Set([...state.state.pendingSpends.values()].map(([coin]) => coin.nonce));
    return pipe(
      [...state.state.coins],
      Array.filter((coin) => !pendingSpends.has(coin.nonce)),
      Array.map((coin) => {
        return {
          coin,
          commitment: state.coinHashes[coin.nonce].commitment,
          nullifier: state.coinHashes[coin.nonce].nullifier,
        };
      }),
    );
  };

  const getPendingCoins = (state: CoreWallet): PendingCoin[] =>
    pipe(
      [...state.state.pendingOutputs.values()],
      Array.map(([coin, ttl]) => ({
        coin,
        ttl,
        commitment: state.coinHashes[coin.nonce].commitment,
        nullifier: state.coinHashes[coin.nonce].nullifier,
      })),
    );

  const getTotalCoins = (state: CoreWallet): Array<Coin> => [...getAvailableCoins(state), ...getPendingCoins(state)];

  return {
    getAvailableBalances,
    getPendingBalances,
    getTotalBalances,
    getAvailableCoins,
    getPendingCoins,
    getTotalCoins,
  };
};

================
File: packages/shielded-wallet/src/v1/CoreWallet.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Either, Iterable, pipe, Record, Array as Arr } from 'effect';
import { createSyncProgress, SyncProgress, SyncProgressData } from './SyncProgress.js';
import { InvalidCoinHashesError, WalletError } from './WalletError.js';

export type PublicKeys = {
  coinPublicKey: ledger.CoinPublicKey;
  encryptionPublicKey: ledger.EncPublicKey;
};
export const PublicKeys = {
  fromSecretKeys: (secretKeys: ledger.ZswapSecretKeys): PublicKeys => {
    return {
      coinPublicKey: secretKeys.coinPublicKey,
      encryptionPublicKey: secretKeys.encryptionPublicKey,
    };
  },
};

export type CoinHashesMap = Readonly<
  Record<ledger.Nonce, { nullifier: ledger.Nullifier; commitment: ledger.CoinCommitment }>
>;
export const CoinHashesMap = {
  empty: {} satisfies CoinHashesMap,
  pickAllCoins(state: ledger.ZswapLocalState): readonly ledger.ShieldedCoinInfo[] {
    return [...state.coins, ...state.pendingOutputs.values().map(([coin]) => coin)];
  },
  assertValid(map: CoinHashesMap, state: ledger.ZswapLocalState): Either.Either<void, Set<ledger.Nonce>> {
    const coins = CoinHashesMap.pickAllCoins(state);
    const coinNonces = new Set(Iterable.map(coins, (coin) => coin.nonce));
    const definedNonces = new Set(Object.keys(map));
    const missingNonces = coinNonces.difference(definedNonces);
    return missingNonces.size === 0 ? Either.void : Either.left(missingNonces);
  },
  updateWithCoins(
    secretKeys: ledger.ZswapSecretKeys,
    existing: CoinHashesMap,
    coins: Iterable<ledger.ShieldedCoinInfo>,
  ): CoinHashesMap {
    return Record.fromIterableWith(coins, (coin) => [
      coin.nonce,
      existing[coin.nonce] ?? {
        commitment: ledger.coinCommitment(coin, secretKeys.coinPublicKey),
        nullifier: ledger.coinNullifier(coin, secretKeys.coinSecretKey),
      },
    ]);
  },
  updateWithNewCoins(
    secretKeys: ledger.ZswapSecretKeys,
    existing: CoinHashesMap,
    coins: Iterable<ledger.ShieldedCoinInfo>,
  ): CoinHashesMap {
    const newMap = CoinHashesMap.updateWithCoins(secretKeys, CoinHashesMap.empty, coins);
    return Record.union(existing, newMap, (a) => a);
  },
  init(secretKeys: ledger.ZswapSecretKeys, coins: Iterable<ledger.ShieldedCoinInfo>): CoinHashesMap {
    return CoinHashesMap.updateWithCoins(secretKeys, {}, coins);
  },
};

export type CoreWallet = Readonly<{
  state: ledger.ZswapLocalState;
  publicKeys: PublicKeys;
  protocolVersion: ProtocolVersion.ProtocolVersion;
  progress: SyncProgress;
  networkId: string;
  txHistoryArray: readonly ledger.FinalizedTransaction[];
  coinHashes: CoinHashesMap;
}>;

export const CoreWallet = {
  init(localState: ledger.ZswapLocalState, secretKeys: ledger.ZswapSecretKeys, networkId: string): CoreWallet {
    const publicKeys = PublicKeys.fromSecretKeys(secretKeys);
    const coinHashes = CoinHashesMap.init(secretKeys, CoinHashesMap.pickAllCoins(localState));
    const progress = createSyncProgress();
    const protocolVersion = ProtocolVersion.MinSupportedVersion;
    return { state: localState, publicKeys, networkId, coinHashes, txHistoryArray: [], progress, protocolVersion };
  },

  empty(publicKeys: PublicKeys, networkId: string): CoreWallet {
    return {
      state: new ledger.ZswapLocalState(),
      publicKeys,
      networkId,
      coinHashes: CoinHashesMap.empty,
      txHistoryArray: [],
      progress: createSyncProgress(),
      protocolVersion: ProtocolVersion.MinSupportedVersion,
    };
  },

  restore(
    localState: ledger.ZswapLocalState,
    secretKeys: ledger.ZswapSecretKeys,
    txHistory: readonly ledger.FinalizedTransaction[],
    syncProgress: Omit<SyncProgressData, 'isConnected'>,
    protocolVersion: bigint,
    networkId: string,
  ): CoreWallet {
    const publicKeys = PublicKeys.fromSecretKeys(secretKeys);
    const coinHashes = CoinHashesMap.init(secretKeys, CoinHashesMap.pickAllCoins(localState));
    return {
      state: localState,
      publicKeys,
      networkId,
      coinHashes,
      txHistoryArray: txHistory,
      progress: createSyncProgress(syncProgress),
      protocolVersion: ProtocolVersion.ProtocolVersion(protocolVersion),
    };
  },

  restoreWithCoinHashes(
    publicKeys: PublicKeys,
    localState: ledger.ZswapLocalState,
    txHistory: readonly ledger.FinalizedTransaction[],
    coinHashes: CoinHashesMap,
    syncProgress: SyncProgressData,
    protocolVersion: bigint,
    networkId: string,
  ): Either.Either<CoreWallet, WalletError> {
    return CoinHashesMap.assertValid(coinHashes, localState).pipe(
      Either.mapBoth({
        onLeft: (missingNonces) =>
          new InvalidCoinHashesError({ message: 'Missing coin hashes for coins present in the state', missingNonces }),
        onRight: () => ({
          state: localState,
          publicKeys,
          networkId,
          coinHashes,
          txHistoryArray: txHistory,
          progress: createSyncProgress(syncProgress),
          protocolVersion: ProtocolVersion.ProtocolVersion(protocolVersion),
        }),
      }),
    );
  },

  initEmpty(keys: ledger.ZswapSecretKeys, networkId: string): CoreWallet {
    return this.empty(PublicKeys.fromSecretKeys(keys), networkId);
  },

  applyCollapsedUpdate(wallet: CoreWallet, collapsed: ledger.MerkleTreeCollapsedUpdate): CoreWallet {
    const newState = wallet.state.applyCollapsedUpdate(collapsed);
    return { ...wallet, state: newState };
  },

  apply<TOffer extends ledger.ZswapOffer<ledger.Proofish>>(
    wallet: CoreWallet,
    secretKeys: ledger.ZswapSecretKeys,
    offer: TOffer,
  ): CoreWallet {
    const newState = wallet.state.apply(secretKeys, offer);
    const newCoinHashes = CoinHashesMap.updateWithCoins(
      secretKeys,
      wallet.coinHashes,
      CoinHashesMap.pickAllCoins(newState),
    );
    return { ...wallet, state: newState, coinHashes: newCoinHashes };
  },

  replayEvents(wallet: CoreWallet, secretKeys: ledger.ZswapSecretKeys, events: ledger.Event[]): CoreWallet {
    const newState = wallet.state.replayEvents(secretKeys, events);
    const newCoinHashes = CoinHashesMap.updateWithCoins(
      secretKeys,
      wallet.coinHashes,
      CoinHashesMap.pickAllCoins(newState),
    );

    return { ...wallet, state: newState, coinHashes: newCoinHashes };
  },

  updateProgress(
    wallet: CoreWallet,
    {
      appliedIndex,
      highestRelevantWalletIndex,
      highestIndex,
      highestRelevantIndex,
      isConnected,
    }: Partial<SyncProgressData>,
  ): CoreWallet {
    const updatedProgress = createSyncProgress({
      appliedIndex: appliedIndex ?? wallet.progress.appliedIndex,
      highestRelevantWalletIndex: highestRelevantWalletIndex ?? wallet.progress.highestRelevantWalletIndex,
      highestIndex: highestIndex ?? wallet.progress.highestIndex,
      highestRelevantIndex: highestRelevantIndex ?? wallet.progress.highestRelevantIndex,
      isConnected: isConnected ?? wallet.progress.isConnected,
    });
    return { ...wallet, progress: updatedProgress };
  },

  addTransaction(wallet: CoreWallet, tx: ledger.FinalizedTransaction): CoreWallet {
    return { ...wallet, txHistoryArray: [...wallet.txHistoryArray, tx] };
  },

  /* not implemented until this is done https://shielded.atlassian.net/browse/PM-19678 */
  revertTransaction<TTx extends ledger.Transaction<ledger.Signaturish, ledger.Proofish, ledger.Bindingish>>(
    wallet: CoreWallet,
    _tx: TTx,
  ): CoreWallet {
    return wallet;
  },

  updateTxHistory(wallet: CoreWallet, newTxs: readonly ledger.FinalizedTransaction[]): CoreWallet {
    return { ...wallet, txHistoryArray: [...wallet.txHistoryArray, ...newTxs] };
  },

  spendCoins(
    wallet: CoreWallet,
    secretKeys: ledger.ZswapSecretKeys,
    coins: ReadonlyArray<ledger.QualifiedShieldedCoinInfo>,
    segment: number,
  ): [ReadonlyArray<ledger.ZswapOffer<ledger.PreProof>>, CoreWallet] {
    const [offers, newLocalState] = pipe(
      coins,
      Arr.reduce(
        [[], wallet.state] as [ReadonlyArray<ledger.ZswapOffer<ledger.PreProof>>, ledger.ZswapLocalState],
        ([accOffers, localState], coinToSpend) => {
          const [nextState, newInput] = localState.spend(secretKeys, coinToSpend, segment);
          const inputOffer = ledger.ZswapOffer.fromInput(newInput, coinToSpend.type, coinToSpend.value);
          return [accOffers.concat([inputOffer]), nextState] as [
            ReadonlyArray<ledger.ZswapOffer<ledger.PreProof>>,
            ledger.ZswapLocalState,
          ];
        },
      ),
    );
    const updated: CoreWallet = { ...wallet, state: newLocalState };
    return [offers, updated];
  },

  watchCoins(
    wallet: CoreWallet,
    secretKeys: ledger.ZswapSecretKeys,
    coins: ReadonlyArray<ledger.ShieldedCoinInfo>,
  ): CoreWallet {
    const newLocalState = coins.reduce(
      (localState: ledger.ZswapLocalState, coin) => localState.watchFor(wallet.publicKeys.coinPublicKey, coin),
      wallet.state,
    );
    const newCoinHashes = CoinHashesMap.updateWithNewCoins(secretKeys, wallet.coinHashes, coins);
    return { ...wallet, state: newLocalState, coinHashes: newCoinHashes };
  },
};

================
File: packages/shielded-wallet/src/v1/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * from './V1Builder.js';
export * as Sync from './Sync.js';
export * as SyncProgress from './SyncProgress.js';
export * as Transacting from './Transacting.js';
export * as TransactionHistory from './TransactionHistory.js';
export * as Serialization from './Serialization.js';
export * as Proving from './Proving.js';
export * as ProvingRecipe from './ProvingRecipe.js';
export * as CoinsAndBalances from './CoinsAndBalances.js';
export * as Keys from './Keys.js';
export * from './RunningV1Variant.js';
export * as Simulator from './Simulator.js';
export * as Submission from './Submission.js';
export * as WalletError from './WalletError.js';
export * from './CoreWallet.js';
export * from './Transaction.js';

================
File: packages/shielded-wallet/src/v1/Keys.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import type { CoreWallet } from './CoreWallet.js';
import {
  ShieldedAddress,
  ShieldedCoinPublicKey,
  ShieldedEncryptionPublicKey,
} from '@midnight-ntwrk/wallet-sdk-address-format';

export type KeysCapability<TState> = {
  getCoinPublicKey(state: TState): ShieldedCoinPublicKey;
  getEncryptionPublicKey(state: TState): ShieldedEncryptionPublicKey;
  getAddress(state: TState): ShieldedAddress;
};

export const makeDefaultKeysCapability = (): KeysCapability<CoreWallet> => {
  return {
    getCoinPublicKey: (state: CoreWallet): ShieldedCoinPublicKey => {
      return new ShieldedCoinPublicKey(Buffer.from(state.publicKeys.coinPublicKey, 'hex'));
    },
    getEncryptionPublicKey: (state: CoreWallet): ShieldedEncryptionPublicKey => {
      return new ShieldedEncryptionPublicKey(Buffer.from(state.publicKeys.encryptionPublicKey, 'hex'));
    },
    getAddress: (state: CoreWallet): ShieldedAddress => {
      const coinPublicKey = new ShieldedCoinPublicKey(Buffer.from(state.publicKeys.coinPublicKey, 'hex'));
      const encryptionPublicKey = new ShieldedEncryptionPublicKey(
        Buffer.from(state.publicKeys.encryptionPublicKey, 'hex'),
      );
      return new ShieldedAddress(coinPublicKey, encryptionPublicKey);
    },
  };
};

================
File: packages/shielded-wallet/src/v1/Proving.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { HttpProverClient, ProverClient } from '@midnight-ntwrk/wallet-sdk-prover-client/effect';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Effect, pipe } from 'effect';
import { ProvingRecipe } from './ProvingRecipe.js';
import { ProvingError, WalletError } from './WalletError.js';

export interface ProvingService<TTransaction> {
  prove(recipe: ProvingRecipe<TTransaction>): Effect.Effect<TTransaction, WalletError>;
}

export type DefaultProvingConfiguration = {
  provingServerUrl: URL;
};

export const makeDefaultProvingService = (
  configuration: DefaultProvingConfiguration,
): ProvingService<ledger.FinalizedTransaction> => {
  const clientLayer = HttpProverClient.layer({
    url: configuration.provingServerUrl,
  });

  return {
    prove(recipe: ProvingRecipe<ledger.FinalizedTransaction>): Effect.Effect<ledger.FinalizedTransaction, WalletError> {
      switch (recipe.type) {
        case 'BalanceTransactionToProve':
          return pipe(
            ProverClient.ProverClient,
            Effect.flatMap((client) =>
              client.proveTransaction(recipe.transactionToProve, ledger.CostModel.initialCostModel()),
            ),
            Effect.map((provenTx) => recipe.transactionToBalance.merge(provenTx.bind())),
            Effect.provide(clientLayer),
            Effect.catchAll((error) =>
              Effect.fail(
                new ProvingError({
                  message: error.message,
                  cause: error,
                }),
              ),
            ),
          );
        case 'TransactionToProve':
          return pipe(
            ProverClient.ProverClient,
            Effect.flatMap((client) =>
              client.proveTransaction(recipe.transaction, ledger.CostModel.initialCostModel()),
            ),
            Effect.map((proven) => proven.bind()),
            Effect.provide(clientLayer),
            Effect.catchAll((error) =>
              Effect.fail(
                new ProvingError({
                  message: error.message,
                  cause: error,
                }),
              ),
            ),
          );
        case 'NothingToProve':
          return Effect.succeed(recipe.transaction);
      }
    },
  };
};

export const makeSimulatorProvingService = (): ProvingService<ledger.ProofErasedTransaction> => {
  return {
    prove(
      recipe: ProvingRecipe<ledger.ProofErasedTransaction>,
    ): Effect.Effect<ledger.ProofErasedTransaction, WalletError> {
      switch (recipe.type) {
        case 'BalanceTransactionToProve':
          return pipe(
            Effect.succeed(recipe.transactionToProve.eraseProofs()),
            Effect.map((proven) => recipe.transactionToBalance.merge(proven)),
          );
        case 'TransactionToProve':
          return Effect.succeed(recipe.transaction.eraseProofs());
        case 'NothingToProve':
          return Effect.succeed(recipe.transaction);
      }
    },
  };
};

================
File: packages/shielded-wallet/src/v1/ProvingRecipe.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
export const TRANSACTION_TO_PROVE = 'TransactionToProve';
export const BALANCE_TRANSACTION_TO_PROVE = 'BalanceTransactionToProve';
export const NOTHING_TO_PROVE = 'NothingToProve';

export type TransactionToProve = {
  readonly type: typeof TRANSACTION_TO_PROVE;
  readonly transaction: ledger.UnprovenTransaction;
};

export type BalanceTransactionToProve<Transaction> = {
  readonly type: typeof BALANCE_TRANSACTION_TO_PROVE;
  readonly transactionToProve: ledger.UnprovenTransaction;
  readonly transactionToBalance: Transaction;
};

export type NothingToProve<Transaction> = {
  readonly type: typeof NOTHING_TO_PROVE;
  readonly transaction: Transaction;
};

export type ProvingRecipe<Transaction> =
  | TransactionToProve
  | BalanceTransactionToProve<Transaction>
  | NothingToProve<Transaction>;

================
File: packages/shielded-wallet/src/v1/Serialization.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, ParseResult, Either, pipe, Schema } from 'effect';
import { WalletError } from './WalletError.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { CoreWallet } from './CoreWallet.js';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';

export type SerializationCapability<TWallet, TAux, TSerialized> = {
  serialize(wallet: TWallet): TSerialized;
  deserialize(aux: TAux, data: TSerialized): Either.Either<TWallet, WalletError>;
};

export type DefaultSerializationConfiguration = {
  networkId: NetworkId.NetworkId;
};

const TxSchema = Schema.declare(
  (input: unknown): input is ledger.FinalizedTransaction => input instanceof ledger.Transaction,
).annotations({
  identifier: 'ledger.Transaction',
});

const StateSchema = Schema.declare(
  (input: unknown): input is ledger.ZswapLocalState => input instanceof ledger.ZswapLocalState,
).annotations({
  identifier: 'ledger.ZswapLocalState',
});

const Uint8ArraySchema = Schema.declare(
  (input: unknown): input is Uint8Array => input instanceof Uint8Array,
).annotations({
  identifier: 'Uint8Array',
});

const TxFromUint8Array = (): Schema.Schema<ledger.FinalizedTransaction, Uint8Array> =>
  Schema.asSchema(
    Schema.transformOrFail(Uint8ArraySchema, TxSchema, {
      encode: (tx) => {
        return Effect.try({
          try: () => {
            return tx.serialize();
          },
          catch: (err) => {
            return new ParseResult.Unexpected(err, 'Could not serialize transaction');
          },
        });
      },
      decode: (bytes) =>
        Effect.try({
          try: () => ledger.Transaction.deserialize('signature', 'proof', 'binding', bytes),
          catch: (err) => {
            return new ParseResult.Unexpected(err, 'Could not deserialize transaction');
          },
        }),
    }),
  );

const StateFromUInt8Array = (): Schema.Schema<ledger.ZswapLocalState, Uint8Array> =>
  Schema.asSchema(
    Schema.transformOrFail(Uint8ArraySchema, StateSchema, {
      encode: (state) => {
        return Effect.try({
          try: () => {
            return state.serialize();
          },
          catch: (err) => {
            return new ParseResult.Unexpected(err, 'Could not serialize local state');
          },
        });
      },
      decode: (bytes) =>
        Effect.try({
          try: () => ledger.ZswapLocalState.deserialize(bytes),
          catch: (err) => {
            return new ParseResult.Unexpected(err, 'Could not deserialize local state');
          },
        }),
    }),
  );

const HexedTx = (): Schema.Schema<ledger.FinalizedTransaction, string> =>
  pipe(Schema.Uint8ArrayFromHex, Schema.compose(TxFromUint8Array()));

const HexedState = (): Schema.Schema<ledger.ZswapLocalState, string> =>
  pipe(Schema.Uint8ArrayFromHex, Schema.compose(StateFromUInt8Array()));

type TxSchema = Schema.Schema.Type<ReturnType<typeof HexedTx>>;

export const makeDefaultV1SerializationCapability = (): SerializationCapability<CoreWallet, null, string> => {
  const SnapshotSchema = Schema.Struct({
    publicKeys: Schema.Struct({
      coinPublicKey: Schema.String,
      encryptionPublicKey: Schema.String,
    }),
    txHistory: Schema.Array(HexedTx()),
    state: HexedState(),
    protocolVersion: Schema.BigInt,
    offset: Schema.optional(Schema.BigInt),
    networkId: Schema.String,
    coinHashes: Schema.Record({
      key: Schema.String,
      value: Schema.Struct({ nullifier: Schema.String, commitment: Schema.String }),
    }),
  });

  type Snapshot = Schema.Schema.Type<typeof SnapshotSchema>;
  return {
    serialize: (wallet) => {
      const buildSnapshot = (w: CoreWallet): Snapshot => ({
        publicKeys: w.publicKeys,
        txHistory: w.txHistoryArray,
        state: w.state,
        protocolVersion: w.protocolVersion,
        networkId: w.networkId,
        offset: w.progress?.appliedIndex,
        coinHashes: w.coinHashes,
      });

      return pipe(wallet, buildSnapshot, Schema.encodeSync(SnapshotSchema), JSON.stringify);
    },
    deserialize: (aux, serialized): Either.Either<CoreWallet, WalletError> => {
      return pipe(
        serialized,
        Schema.decodeUnknownEither(Schema.parseJson(SnapshotSchema)),
        Either.mapLeft((err) => WalletError.other(err)),
        Either.flatMap((snapshot: Snapshot) =>
          CoreWallet.restoreWithCoinHashes(
            snapshot.publicKeys,
            snapshot.state,
            snapshot.txHistory,
            snapshot.coinHashes,
            {
              appliedIndex: snapshot.offset ?? 0n,
              highestRelevantWalletIndex: 0n,
              highestIndex: 0n,
              highestRelevantIndex: 0n,
              isConnected: false,
            },
            snapshot.protocolVersion,
            snapshot.networkId,
          ),
        ),
      );
    },
  };
};

================
File: packages/shielded-wallet/src/v1/Simulator.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Array as Arr, Effect, Encoding, pipe, Scope, Stream, SubscriptionRef, Clock } from 'effect';
import { ArrayOps, EitherOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import * as crypto from 'crypto';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';

export type SimulatorState = Readonly<{
  ledger: ledger.LedgerState;
  lastTxResult: ledger.TransactionResult;
  lastTxNumber: bigint;
}>;

const simpleHash = (input: string): Effect.Effect<string> => {
  return Encoding.decodeHex(input).pipe(
    EitherOps.toEffect,
    Effect.andThen((parsed) => Effect.promise(() => crypto.subtle.digest('SHA-256', parsed))),
    Effect.andThen((out) => Encoding.encodeHex(new Uint8Array(out))),
    Effect.orDie,
  );
};

const wellFormedStrictness = (
  params: {
    enforceBalancing?: boolean;
    verifyNativeProofs?: boolean;
    verifyContractProofs?: boolean;
    enforceLimits?: boolean;
    verifySignatures?: boolean;
  } = {},
): ledger.WellFormedStrictness => {
  const strictness = new ledger.WellFormedStrictness();

  // Note: Enforce balancing should be true by default outside genesis mints
  strictness.enforceBalancing = params?.enforceBalancing ?? false;
  strictness.verifyNativeProofs = params?.verifyNativeProofs ?? false;
  strictness.verifyContractProofs = params?.verifyContractProofs ?? false;
  strictness.enforceLimits = params?.enforceLimits ?? false;
  strictness.verifySignatures = params?.verifySignatures ?? false;

  return strictness;
};

export class Simulator {
  static nextBlockContext = (number: bigint): Effect.Effect<ledger.BlockContext> =>
    pipe(
      number.toString(16),
      (str) => (str.length % 2 == 0 ? str : str.padStart(str.length + 1, '0')),
      simpleHash,
      Effect.map((hash) => ({
        parentBlockHash: hash,
        secondsSinceEpoch: number,
        secondsSinceEpochErr: 1,
      })),
    );

  static init(
    genesisMints: Readonly<
      Arr.NonEmptyArray<{ amount: bigint; type: ledger.RawTokenType; recipient: ledger.ZswapSecretKeys }>
    >,
  ): Effect.Effect<Simulator, never, Scope.Scope> {
    const emptyState = ledger.LedgerState.blank(NetworkId.NetworkId.Undeployed);
    const noStrictness = wellFormedStrictness();

    const makeTransactions = (context: ledger.BlockContext) =>
      Effect.gen(function* () {
        const nowMillis = yield* Clock.currentTimeMillis;
        const verificationTime = new Date(nowMillis);

        const tx = pipe(
          genesisMints,
          Arr.map((transfer) => {
            const coin = ledger.createShieldedCoinInfo(transfer.type, transfer.amount);
            const output = ledger.ZswapOutput.new(
              coin,
              0,
              transfer.recipient.coinPublicKey,
              transfer.recipient.encryptionPublicKey,
            );
            return ledger.ZswapOffer.fromOutput<ledger.PreProof>(output, transfer.type, transfer.amount);
          }),
          ArrayOps.fold((acc, offer) => acc.merge(offer)),
          (offer) => ledger.Transaction.fromParts(NetworkId.NetworkId.Undeployed, offer).eraseProofs(),
          (tx) => tx.wellFormed(emptyState, noStrictness, verificationTime),
        );

        const [initialState, initialResult] = emptyState.apply(tx, new ledger.TransactionContext(emptyState, context));
        const postBlockUpdateState = initialState.postBlockUpdate(verificationTime);

        return {
          initialResult,
          initialState: postBlockUpdateState,
          tx,
        } as const;
      });

    return Effect.gen(function* () {
      const context = yield* Simulator.nextBlockContext(0n);
      const init = yield* makeTransactions(context);
      const initialState = {
        ledger: init.initialState,
        lastTxResult: init.initialResult,
        lastTxNumber: 0n,
      };
      const ref = yield* SubscriptionRef.make<SimulatorState>(initialState);
      const changesStream = yield* Stream.share(ref.changes, {
        capacity: 'unbounded',
        replay: Number.MAX_SAFE_INTEGER,
      });
      yield* pipe(changesStream, Stream.runDrain, Effect.forkScoped);
      return new Simulator(ref, changesStream);
    });
  }

  readonly #stateRef: SubscriptionRef.SubscriptionRef<SimulatorState>;

  readonly state$: Stream.Stream<SimulatorState>;

  constructor(stateRef: SubscriptionRef.SubscriptionRef<SimulatorState>, state$: Stream.Stream<SimulatorState>) {
    this.#stateRef = stateRef;
    this.state$ = state$;
  }

  submitRegularTx(tx: ledger.ProofErasedTransaction): Effect.Effect<{ blockNumber: bigint; blockHash: string }> {
    return pipe(
      this.#stateRef,
      SubscriptionRef.modifyEffect((simulatorState) =>
        Effect.gen(function* () {
          const nextNumber = simulatorState.lastTxNumber + 1n;
          const context = yield* Simulator.nextBlockContext(nextNumber);
          const nowMillis = yield* Clock.currentTimeMillis;
          const verificationTime = new Date(nowMillis);

          const noStrictness = wellFormedStrictness();
          const verifiedTx = tx.wellFormed(simulatorState.ledger, noStrictness, verificationTime);

          const [newState, result] = simulatorState.ledger.apply(
            verifiedTx,
            new ledger.TransactionContext(simulatorState.ledger, context),
          );

          const postBlockUpdatedState = newState.postBlockUpdate(verificationTime);

          const newSimulatorState = {
            ...simulatorState,
            ledger: postBlockUpdatedState,
            lastTxResult: result,
            lastTxNumber: nextNumber,
          };

          const output = {
            blockNumber: nextNumber,
            blockHash: context.parentBlockHash,
          };

          return [output, newSimulatorState];
        }),
      ),
    );
  }
}

================
File: packages/shielded-wallet/src/v1/Submission.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Deferred, Effect, Encoding, Exit, pipe, Scope } from 'effect';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { WalletError } from './WalletError.js';
import { Simulator } from './Simulator.js';
import {
  NodeClient,
  NodeClientError,
  PolkadotNodeClient,
  SubmissionEvent as SubmissionEventImported,
} from '@midnight-ntwrk/wallet-sdk-node-client/effect';

export const SubmissionEvent = SubmissionEventImported;
export type SubmissionEvent = SubmissionEventImported.SubmissionEvent;
export declare namespace SubmissionEventCases {
  export type Finalized = SubmissionEventImported.Cases.Finalized;
  export type Submitted = SubmissionEventImported.Cases.Submitted;
  export type InBlock = SubmissionEventImported.Cases.InBlock;
}

export type SubmitTransactionMethod<TTransaction> = {
  (transaction: TTransaction, waitForStatus: 'Submitted'): Effect.Effect<SubmissionEventCases.Submitted, WalletError>;
  (transaction: TTransaction, waitForStatus: 'InBlock'): Effect.Effect<SubmissionEventCases.InBlock, WalletError>;
  (transaction: TTransaction, waitForStatus: 'Finalized'): Effect.Effect<SubmissionEventCases.Finalized, WalletError>;
  (transaction: TTransaction): Effect.Effect<SubmissionEventCases.InBlock, WalletError>;
  (
    transaction: TTransaction,
    waitForStatus?: 'Submitted' | 'InBlock' | 'Finalized',
  ): Effect.Effect<SubmissionEvent, WalletError>;
};

export interface SubmissionService<TTransaction> {
  submitTransaction: SubmitTransactionMethod<TTransaction>;
  close(): Effect.Effect<void>;
}

export type DefaultSubmissionConfiguration = {
  relayURL: URL;
};
export const makeDefaultSubmissionService = (
  config: DefaultSubmissionConfiguration,
): SubmissionService<ledger.FinalizedTransaction> => {
  //Using Deferred under the hood + allowing for "close" method in the service allows to keep resource usage in check and a synchronous API
  type ScopeAndClient = { scope: Scope.CloseableScope; client: NodeClient.Service };

  const scopeAndClientDeferred = Deferred.make<ScopeAndClient, NodeClientError.NodeClientError>().pipe(Effect.runSync);

  const makeScopeAndClient: Effect.Effect<ScopeAndClient, NodeClientError.NodeClientError> = Effect.gen(function* () {
    const scope = yield* Scope.make();
    const client = yield* PolkadotNodeClient.make({
      nodeURL: config.relayURL,
    }).pipe(Effect.provideService(Scope.Scope, scope));

    return { scope, client };
  });

  void pipe(scopeAndClientDeferred, Deferred.complete(makeScopeAndClient), Effect.runPromise);

  const submit = (transaction: ledger.FinalizedTransaction, waitForStatus: SubmissionEvent['_tag'] = 'InBlock') => {
    return pipe(
      NodeClient.sendMidnightTransactionAndWait(transaction.serialize(), waitForStatus),
      Effect.provideServiceEffect(
        NodeClient.NodeClient,
        pipe(
          scopeAndClientDeferred,
          Deferred.await,
          Effect.map(({ client }) => client),
        ),
      ),
      Effect.mapError((err) => WalletError.submission(err)),
    );
  };

  return {
    submitTransaction: submit as SubmitTransactionMethod<ledger.FinalizedTransaction>,
    close(): Effect.Effect<void> {
      return pipe(
        scopeAndClientDeferred,
        Deferred.await,
        Effect.flatMap(({ scope }) => Scope.close(scope, Exit.void)),
        Effect.ignoreLogged,
      );
    },
  };
};

export type SimulatorSubmissionConfiguration = {
  simulator: Simulator;
};
export const makeSimulatorSubmissionService =
  (waitForStatus: 'Submitted' | 'InBlock' | 'Finalized' = 'InBlock') =>
  (config: SimulatorSubmissionConfiguration): SubmissionService<ledger.ProofErasedTransaction> => {
    const submit = (transaction: ledger.ProofErasedTransaction): Effect.Effect<SubmissionEvent, WalletError> => {
      const serializedTx = transaction.serialize();
      return config.simulator.submitRegularTx(transaction).pipe(
        Effect.map((output) => {
          // Let's mimic node's client behavior here
          switch (waitForStatus) {
            case 'Submitted':
              return SubmissionEvent.Submitted({
                tx: serializedTx,
                txHash: Encoding.encodeHex(serializedTx.subarray(0, 32)),
              });
            case 'InBlock':
              return SubmissionEvent.InBlock({
                tx: serializedTx,
                blockHash: output.blockHash,
                blockHeight: output.blockNumber,
                txHash: Encoding.encodeHex(serializedTx.subarray(0, 32)),
              });
            case 'Finalized':
              return SubmissionEvent.Finalized({
                tx: serializedTx,
                blockHash: output.blockHash,
                blockHeight: output.blockNumber,
                txHash: Encoding.encodeHex(serializedTx.subarray(0, 32)),
              });
          }
        }),
      );
    };

    return {
      submitTransaction: submit as SubmitTransactionMethod<ledger.ProofErasedTransaction>,
      close: (): Effect.Effect<void> => Effect.void,
    };
  };

================
File: packages/shielded-wallet/src/v1/Sync.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Effect, ParseResult, Scope, Stream, Schema, pipe, Either } from 'effect';
import { CoreWallet } from './CoreWallet.js';
import { Simulator, SimulatorState } from './Simulator.js';
import { ZswapEvents } from '@midnight-ntwrk/wallet-sdk-indexer-client';
import { WsSubscriptionClient, ConnectionHelper } from '@midnight-ntwrk/wallet-sdk-indexer-client/effect';
import { SyncWalletError, WalletError } from './WalletError.js';
import { WsURL } from '@midnight-ntwrk/wallet-sdk-utilities/networking';
import { TransactionHistoryCapability } from './TransactionHistory.js';
import { EitherOps } from '@midnight-ntwrk/wallet-sdk-utilities';

export interface SyncService<TState, TStartAux, TUpdate> {
  updates: (state: TState, auxData: TStartAux) => Stream.Stream<TUpdate, WalletError, Scope.Scope>;
}

export interface SyncCapability<TState, TUpdate> {
  applyUpdate: (state: TState, update: TUpdate) => TState;
}

export type IndexerClientConnection = {
  indexerHttpUrl: string;
  indexerWsUrl?: string;
};

export type DefaultSyncConfiguration = {
  indexerClientConnection: IndexerClientConnection;
};

export type DefaultSyncContext = {
  transactionHistoryCapability: TransactionHistoryCapability<CoreWallet, ledger.FinalizedTransaction>;
};

const Uint8ArraySchema = Schema.declare(
  (input: unknown): input is Uint8Array => input instanceof Uint8Array,
).annotations({
  identifier: 'Uint8Array',
});

type SecretKeysResource = <A>(cb: (keys: ledger.ZswapSecretKeys) => A) => A;
export const SecretKeysResource = {
  create: (secretKeys: ledger.ZswapSecretKeys): SecretKeysResource => {
    /**
     * TODO: future Ledger version will include `clear` function to clear the secret keys,
     * it is intentend to be used here instead of `null`
     */
    let sk: ledger.ZswapSecretKeys | null = secretKeys;
    return (cb) => {
      if (sk === null) {
        throw new Error('Secret keys have been consumed');
      }
      const result = cb(sk);
      sk = null;
      return result;
    };
  },
};

export type WalletSyncUpdate = {
  update: EventsSyncUpdate;
  secretKeys: SecretKeysResource;
};
export const WalletSyncUpdate = {
  create: (update: EventsSyncUpdate, secretKeys: ledger.ZswapSecretKeys): WalletSyncUpdate => {
    return {
      update,
      secretKeys: SecretKeysResource.create(secretKeys),
    };
  },
};

const LedgerEventSchema = Schema.declare(
  (input: unknown): input is ledger.Event => input instanceof ledger.Event,
).annotations({
  identifier: 'ledger.Event',
});

const LedgerEventFromUint8Array: Schema.Schema<ledger.Event, Uint8Array> = Schema.transformOrFail(
  Uint8ArraySchema,
  LedgerEventSchema,
  {
    encode: (event) =>
      Effect.try({
        try: () => event.serialize(),
        catch: (error) => new ParseResult.Unexpected(error, 'Could not serialize ledger event'),
      }),
    decode: (bytes) =>
      Effect.try({
        try: () => ledger.Event.deserialize(bytes),
        catch: (error) => new ParseResult.Unexpected(error, 'Could not deserialize ledger event'),
      }),
  },
);

const HexedLedgerEvent: Schema.Schema<ledger.Event, string> = pipe(
  Schema.Uint8ArrayFromHex,
  Schema.compose(LedgerEventFromUint8Array),
);

const EventsSyncUpdatePayload = Schema.Struct({
  id: Schema.Number,
  raw: Schema.String,
  maxId: Schema.Number,
});

export const EventsSyncUpdate = Schema.TaggedStruct('EventsSyncUpdate', {
  id: Schema.Number,
  maxId: Schema.Number,
  event: LedgerEventSchema,
});

export type EventsSyncUpdate = Schema.Schema.Type<typeof EventsSyncUpdate>;

const EventsSyncUpdateFromPayload = Schema.transformOrFail(EventsSyncUpdatePayload, EventsSyncUpdate, {
  decode: (input) =>
    pipe(
      Schema.decodeUnknownEither(HexedLedgerEvent)(input.raw),
      Either.map((event) => ({
        _tag: 'EventsSyncUpdate' as const,
        id: input.id,
        maxId: input.maxId,
        event,
      })),
      Either.mapLeft((error) => new ParseResult.Unexpected(error, 'Failed to decode ledger event payload')),
      EitherOps.toEffect,
    ),
  encode: (output) =>
    pipe(
      Schema.encodeEither(HexedLedgerEvent)(output.event),
      Either.map((raw) => ({
        id: output.id,
        raw,
        maxId: output.maxId,
      })),
      Either.mapLeft((error) => new ParseResult.Unexpected(error, 'Failed to encode ledger event payload')),
      EitherOps.toEffect,
    ),
});

export const makeEventsSyncService = (
  config: DefaultSyncConfiguration,
): SyncService<CoreWallet, ledger.ZswapSecretKeys, WalletSyncUpdate> => {
  return {
    updates: (
      state: CoreWallet,
      secretKeys: ledger.ZswapSecretKeys,
    ): Stream.Stream<WalletSyncUpdate, WalletError, Scope.Scope> => {
      const { indexerClientConnection } = config;

      const webSocketUrlResult = ConnectionHelper.createWebSocketUrl(
        indexerClientConnection.indexerHttpUrl,
        indexerClientConnection.indexerWsUrl,
      );
      if (Either.isLeft(webSocketUrlResult)) {
        return Stream.fail(
          new SyncWalletError(
            new Error(`Could not derive WebSocket URL from indexer HTTP URL: ${webSocketUrlResult.left.message}`),
          ),
        );
      }

      const indexerWsUrlResult = WsURL.make(webSocketUrlResult.right);

      if (Either.isLeft(indexerWsUrlResult)) {
        return Stream.fail(
          new SyncWalletError(new Error(`Invalid indexer WS URL: ${indexerWsUrlResult.left.message}`)),
        );
      }

      const indexerWsUrl = indexerWsUrlResult.right;
      const appliedIndex = state.progress?.appliedIndex ?? 0n;

      return pipe(
        ZswapEvents.run({ id: Number(appliedIndex) }),
        Stream.provideLayer(WsSubscriptionClient.layer({ url: indexerWsUrl })),
        Stream.mapError((error) => new SyncWalletError(error)),
        Stream.mapEffect((subscription) =>
          pipe(
            Schema.decodeUnknownEither(EventsSyncUpdateFromPayload)(subscription.zswapLedgerEvents),
            Either.mapLeft((err) => new SyncWalletError(err)),
            EitherOps.toEffect,
          ),
        ),
        Stream.map((data) => WalletSyncUpdate.create(data, secretKeys)),
      );
    },
  };
};

export const makeEventsSyncCapability = (): SyncCapability<CoreWallet, WalletSyncUpdate> => {
  return {
    applyUpdate: (state: CoreWallet, wrappedUpdate: WalletSyncUpdate): CoreWallet => {
      const nextIndex = BigInt(wrappedUpdate.update.id);
      const highestRelevantWalletIndex = BigInt(wrappedUpdate.update.maxId);
      // in case the nextIndex is less than or equal to the appliedIndex
      // just update highestRelevantWalletIndex
      if (nextIndex <= state.progress.appliedIndex) {
        return CoreWallet.updateProgress(state, {
          highestRelevantWalletIndex,
          isConnected: true,
        });
      }

      return wrappedUpdate.secretKeys((keys) => {
        return CoreWallet.updateProgress(CoreWallet.replayEvents(state, keys, [wrappedUpdate.update.event]), {
          highestRelevantWalletIndex,
          appliedIndex: nextIndex,
          isConnected: true,
        });
      });
    },
  };
};

export type SimulatorSyncConfiguration = {
  simulator: Simulator;
};

export type SimulatorSyncUpdate = {
  update: SimulatorState;
  secretKeys: ledger.ZswapSecretKeys;
};

export const makeSimulatorSyncService = (
  config: SimulatorSyncConfiguration,
): SyncService<CoreWallet, ledger.ZswapSecretKeys, SimulatorSyncUpdate> => {
  return {
    updates: (_state: CoreWallet, secretKeys: ledger.ZswapSecretKeys) =>
      config.simulator.state$.pipe(Stream.map((state) => ({ update: state, secretKeys: secretKeys }))),
  };
};

export const makeSimulatorSyncCapability = (): SyncCapability<CoreWallet, SimulatorSyncUpdate> => {
  return {
    applyUpdate: (state: CoreWallet, update: SimulatorSyncUpdate) => {
      const {
        update: {
          lastTxResult: { events },
        },
        secretKeys,
      } = update;

      return CoreWallet.replayEvents(state, secretKeys, events);
    },
  };
};

================
File: packages/shielded-wallet/src/v1/SyncProgress.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export interface SyncProgressData {
  readonly appliedIndex: bigint;
  readonly highestRelevantWalletIndex: bigint;
  readonly highestIndex: bigint;
  readonly highestRelevantIndex: bigint;
  readonly isConnected: boolean;
}

export interface SyncProgressOps {
  isCompleteWithin(data: SyncProgressData, maxGap?: bigint): boolean;
}

export interface SyncProgress extends SyncProgressData {
  isStrictlyComplete(): boolean;
  isCompleteWithin(maxGap?: bigint): boolean;
}

export const SyncProgress: SyncProgressOps = {
  isCompleteWithin(data: SyncProgressData, maxGap: bigint = 50n): boolean {
    const applyLag = BigInt(Math.abs(Number(data.highestRelevantWalletIndex - data.appliedIndex)));
    return data.isConnected && applyLag <= maxGap;
  },
};

export const createSyncProgress = (
  params: {
    appliedIndex?: bigint;
    highestRelevantWalletIndex?: bigint;
    highestIndex?: bigint;
    highestRelevantIndex?: bigint;
    isConnected?: boolean;
  } = {},
): SyncProgress => {
  const {
    appliedIndex = 0n,
    highestRelevantWalletIndex = 0n,
    highestIndex = 0n,
    highestRelevantIndex = 0n,
    isConnected = false,
  } = params;

  const data: SyncProgressData = {
    appliedIndex,
    highestRelevantWalletIndex,
    highestIndex,
    highestRelevantIndex,
    isConnected,
  };

  return {
    ...data,

    isStrictlyComplete(): boolean {
      return SyncProgress.isCompleteWithin(this, 0n);
    },

    isCompleteWithin(maxGap?: bigint): boolean {
      return SyncProgress.isCompleteWithin(this, maxGap);
    },
  };
};

================
File: packages/shielded-wallet/src/v1/Transaction.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { pipe } from 'effect';
import { Imbalances } from '@midnight-ntwrk/wallet-sdk-capabilities';
import { TransactionImbalances } from './TransactionImbalances.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';

export type TransactionTrait<Tx> = {
  getImbalances(tx: Tx): TransactionImbalances;
  id(tx: Tx): string;
};
export const TransactionTrait = new (class {
  default: TransactionTrait<ledger.FinalizedTransaction> = {
    getImbalances(tx: ledger.FinalizedTransaction): TransactionImbalances {
      return TransactionTrait.shared.getImbalances(tx);
    },
    id(tx) {
      return tx.identifiers().at(0)!;
    },
  };
  proofErased: TransactionTrait<ledger.ProofErasedTransaction> = {
    getImbalances(tx): TransactionImbalances {
      return TransactionTrait.shared.getImbalances(tx);
    },
    id(tx) {
      return tx.identifiers().at(0)!;
    },
  };
  unproven: TransactionTrait<ledger.UnprovenTransaction> = {
    getImbalances(tx: ledger.UnprovenTransaction): TransactionImbalances {
      return TransactionTrait.shared.getImbalances(tx);
    },
    id(tx) {
      return tx.identifiers().at(0)!;
    },
  };

  shared = {
    getImbalances(
      tx: ledger.FinalizedTransaction | ledger.UnprovenTransaction | ledger.ProofErasedTransaction,
    ): TransactionImbalances {
      const guaranteedImbalances = TransactionTrait.shared.getGuaranteedImbalances(tx);
      const fallibleImbalances = TransactionTrait.shared.getFallibleImbalances(tx);

      return pipe({
        guaranteed: guaranteedImbalances,
        fallible: fallibleImbalances,
        fees: 0n,
      });
    },
    getGuaranteedImbalances: (
      tx: ledger.FinalizedTransaction | ledger.UnprovenTransaction | ledger.ProofErasedTransaction,
    ): Imbalances => {
      const rawGuaranteedImbalances = tx
        .imbalances(0)
        .entries()
        .filter(([token]) => token.tag === 'shielded')
        .map(([token, value]) => {
          return [(token as { tag: 'shielded'; raw: string }).raw.toString(), value] as [string, bigint];
        });

      return Imbalances.fromEntries(rawGuaranteedImbalances);
    },
    getFallibleImbalances: (
      tx: ledger.FinalizedTransaction | ledger.UnprovenTransaction | ledger.ProofErasedTransaction,
    ): Imbalances => {
      try {
        const rawFallibleImbalances = tx
          .imbalances(1)
          .entries()
          .filter(([token]) => token.tag === 'shielded')
          .map(([token, value]) => {
            return [(token as { tag: 'shielded'; raw: string }).raw.toString(), value] as [string, bigint];
          });
        return Imbalances.fromEntries(rawFallibleImbalances);
      } catch {
        return Imbalances.empty();
      }
    },
  };
})();

================
File: packages/shielded-wallet/src/v1/TransactionHistory.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { CoreWallet } from './CoreWallet.js';

export type ProgressUpdate = {
  appliedIndex: bigint | undefined;
  highestRelevantWalletIndex: bigint | undefined;
  highestIndex: bigint | undefined;
  highestRelevantIndex: bigint | undefined;
};

export type TransactionHistoryCapability<TState, TTransaction> = {
  updateTxHistory(state: TState, newTxs: TTransaction[]): TState;
  transactionHistory(state: TState): readonly TTransaction[];
  progress(state: TState): ProgressUpdate;
};

export const makeDefaultTransactionHistoryCapability = (): TransactionHistoryCapability<
  CoreWallet,
  ledger.FinalizedTransaction
> => {
  return {
    updateTxHistory: (state: CoreWallet, newTxs: ledger.FinalizedTransaction[]): CoreWallet => {
      return newTxs.reduce((acc, tx) => CoreWallet.addTransaction(acc, tx), state);
    },
    transactionHistory: (state: CoreWallet): readonly ledger.FinalizedTransaction[] => {
      return state.txHistoryArray;
    },
    progress: (state: CoreWallet): ProgressUpdate => {
      return {
        appliedIndex: state.progress.appliedIndex,
        highestRelevantWalletIndex: state.progress.highestRelevantWalletIndex,
        highestIndex: state.progress.highestIndex,
        highestRelevantIndex: state.progress.highestRelevantIndex,
      };
    },
  };
};

export const makeSimulatorTransactionHistoryCapability = (): TransactionHistoryCapability<
  CoreWallet,
  ledger.ProofErasedTransaction
> => {
  return {
    updateTxHistory: (state: CoreWallet, newTxs: ledger.ProofErasedTransaction[]): CoreWallet => {
      return CoreWallet.updateTxHistory(state, newTxs as unknown as readonly ledger.FinalizedTransaction[]); // @TODO fix this cast
    },
    transactionHistory: (state: CoreWallet): readonly ledger.ProofErasedTransaction[] => {
      return state.txHistoryArray as unknown as readonly ledger.ProofErasedTransaction[]; // @TODO fix this cast
    },
    progress: (state: CoreWallet): ProgressUpdate => {
      return {
        appliedIndex: state.progress.appliedIndex,
        highestRelevantWalletIndex: state.progress.highestRelevantWalletIndex,
        highestIndex: state.progress.highestIndex,
        highestRelevantIndex: state.progress.highestRelevantIndex,
      };
    },
  };
};

export const makeDiscardTransactionHistoryCapability = (): TransactionHistoryCapability<
  CoreWallet,
  ledger.FinalizedTransaction
> => {
  return {
    updateTxHistory: (state: CoreWallet): CoreWallet => {
      return state;
    },
    transactionHistory: (state: CoreWallet): readonly ledger.FinalizedTransaction[] => {
      return state.txHistoryArray;
    },
    progress: (state: CoreWallet): ProgressUpdate => {
      return {
        appliedIndex: state.progress.appliedIndex,
        highestRelevantWalletIndex: state.progress.highestRelevantWalletIndex,
        highestIndex: state.progress.highestIndex,
        highestRelevantIndex: state.progress.highestRelevantIndex,
      };
    },
  };
};

================
File: packages/shielded-wallet/src/v1/TransactionImbalances.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Imbalances, TransactionCostModel } from '@midnight-ntwrk/wallet-sdk-capabilities';

export const ShieldedCostModel: TransactionCostModel = {
  inputFeeOverhead: 0n,
  outputFeeOverhead: 0n,
};

export type TransactionImbalances = Readonly<{
  guaranteed: Imbalances;
  fallible: Imbalances;
}>;
export const TransactionImbalances = new (class {
  empty = (): TransactionImbalances => {
    return {
      guaranteed: Imbalances.empty(),
      fallible: Imbalances.empty(),
    };
  };

  areBalanced = (imbalances: TransactionImbalances): boolean => {
    const areFallibleAllZeroes = imbalances.fallible.entries().every(([, value]) => value === 0n);

    const areGuaranteedAllZeroes = imbalances.guaranteed.entries().every(([, value]) => value === 0n);

    return areFallibleAllZeroes && areGuaranteedAllZeroes;
  };
})();

================
File: packages/shielded-wallet/src/v1/WalletError.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Data } from 'effect';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { LedgerOps } from '@midnight-ntwrk/wallet-sdk-utilities';

export const WalletError = {
  proving(err: Error): WalletError {
    return new ProvingError({
      message: `Wallet proving error: ${err.message}`,
      cause: err,
    });
  },

  other(err: unknown): WalletError {
    let message: string;
    if (err) {
      if (typeof err == 'object' && 'message' in err) {
        message = String(err.message);
      } else if (typeof err == 'string') {
        message = err;
      } else {
        message = '';
      }
    } else {
      message = '';
    }
    return new OtherWalletError({ message: `Other wallet error: ${message}`, cause: err });
  },

  submission(err: unknown): WalletError {
    const message: string = err && typeof err == 'object' && 'message' in err ? String(err.message) : '';
    return new SubmissionError({ message: `Transaction submission error: ${message}`, cause: err });
  },
};
export type WalletError =
  | ProvingError
  | OtherWalletError
  | InsufficientFundsError
  | SubmissionError
  | AddressError
  | SyncWalletError
  | InvalidCoinHashesError
  | TransactingError
  | LedgerOps.LedgerError;

export class ProvingError extends Data.TaggedError('Wallet.Proving')<{
  message: string;
  cause: Error;
}> {}

export class OtherWalletError extends Data.TaggedError('Wallet.Other')<{
  message: string;
  cause?: unknown;
}> {}

export class SyncWalletError extends Data.TaggedError('Wallet.Sync')<{
  message: string;
  cause?: unknown;
}> {}

export class SubmissionError extends Data.TaggedError('Wallet.SubmissionWalletError')<{
  message: string;
  cause?: unknown;
}> {}

export class InsufficientFundsError extends Data.TaggedError('Wallet.InsufficientFunds')<{
  message: string;
  tokenType: ledger.RawTokenType;
  amount: bigint;
}> {}

export class AddressError extends Data.TaggedError('Wallet.Address')<{
  message: string;
  originalAddress: string;
  cause?: unknown;
}> {}

export class InvalidCoinHashesError extends Data.TaggedError('Wallet.InvalidCoinHashes')<{
  message: string;
  missingNonces: Set<ledger.Nonce>;
}> {}

export class TransactingError extends Data.TaggedError('Wallet.Transacting')<{
  message: string;
  cause?: unknown;
}> {}

================
File: packages/shielded-wallet/src/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * from './ShieldedWallet.js';

================
File: packages/shielded-wallet/.npmignore
================
*.ts.map

================
File: packages/shielded-wallet/.prettierignore
================
dist/
coverage/
reports/

================
File: packages/shielded-wallet/eslint.config.mjs
================
import { packageConfig } from '../../eslint.config.mjs';

export default packageConfig();

================
File: packages/shielded-wallet/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/test/**/*.ts", "src/**/*.test.ts"]
}

================
File: packages/shielded-wallet/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [{ "path": "./tsconfig.build.json" }, { "path": "./tsconfig.test.json" }]
}

================
File: packages/shielded-wallet/tsconfig.publish.json
================
{
  "extends": "./tsconfig.build.json",
  "compilerOptions": {
    "sourceMap": false,
    "declarationMap": false
  }
}

================
File: packages/shielded-wallet/tsconfig.test.json
================
{
  "extends": "./tsconfig.json",
  "include": ["test/**/*.ts", "src/**/*.ts"]
}

================
File: packages/unshielded-wallet/src/storage/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * from './InMemoryTransactionHistoryStorage.js';
export * from './NoOpTransactionHistoryStorage.js';
export * from './TransactionHistoryStorage.js';

================
File: packages/unshielded-wallet/src/storage/InMemoryTransactionHistoryStorage.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Either, Schema } from 'effect';
import {
  TransactionHistoryStorage,
  TransactionHistoryEntrySchema,
  TransactionHistoryEntry,
  TransactionHash,
} from './TransactionHistoryStorage.js';

const TransactionHistorySchema = Schema.Map({
  key: Schema.String,
  value: TransactionHistoryEntrySchema,
});

export type TransactionHistory = Schema.Schema.Type<typeof TransactionHistorySchema>;

const TransactionHistoryEncoder = Schema.encodeSync(TransactionHistorySchema);
const TransactionHistoryDecoder = Schema.decodeUnknownEither(TransactionHistorySchema);

/**
 * In-memory implementation of the TransactionHistoryStorage interface.
 *
 * TODO: Implement update method with callback api when needed in the future
 */
export class InMemoryTransactionHistoryStorage implements TransactionHistoryStorage {
  private entries: TransactionHistory;

  constructor(entries?: TransactionHistory) {
    this.entries = entries || new Map<TransactionHash, TransactionHistoryEntry>();
  }

  create(entry: TransactionHistoryEntry): Promise<void> {
    this.entries.set(entry.hash, entry);
    return Promise.resolve();
  }

  delete(hash: TransactionHash): Promise<TransactionHistoryEntry | undefined> {
    const existingEntry = this.entries.get(hash);

    if (!existingEntry) {
      return Promise.resolve(undefined);
    }

    this.entries.delete(hash);

    return Promise.resolve(existingEntry);
  }

  async *getAll(): AsyncIterableIterator<TransactionHistoryEntry> {
    for (const entry of this.entries.values()) {
      yield await Promise.resolve(entry);
    }
  }

  get(hash: TransactionHash): Promise<TransactionHistoryEntry | undefined> {
    return Promise.resolve(this.entries.get(hash));
  }

  serialize(): string {
    const result = TransactionHistoryEncoder(this.entries);

    return JSON.stringify(result);
  }

  reset(): void {
    this.entries.clear();
  }

  static fromSerialized(serializedHistory: string): InMemoryTransactionHistoryStorage {
    const schema = JSON.parse(serializedHistory) as unknown;

    const decoded = Either.getOrElse(TransactionHistoryDecoder(schema), (error) => {
      throw new Error(`Failed to decode transaction history: ${error.message}`);
    });

    return new InMemoryTransactionHistoryStorage(decoded);
  }
}

================
File: packages/unshielded-wallet/src/storage/NoOpTransactionHistoryStorage.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { TransactionHistoryStorage, TransactionHash, TransactionHistoryEntry } from './TransactionHistoryStorage.js';

export class NoOpTransactionHistoryStorage implements TransactionHistoryStorage {
  create(_entry: TransactionHistoryEntry): Promise<void> {
    return Promise.resolve();
  }

  delete(_hash: TransactionHash): Promise<TransactionHistoryEntry | undefined> {
    return Promise.resolve(undefined);
  }

  async *getAll(): AsyncIterableIterator<TransactionHistoryEntry> {
    return Promise.resolve(yield* []);
  }

  get(_hash: TransactionHash): Promise<TransactionHistoryEntry | undefined> {
    return Promise.resolve(undefined);
  }

  serialize(): string {
    return JSON.stringify({});
  }

  static deserialize(_serialized: string): NoOpTransactionHistoryStorage {
    return new NoOpTransactionHistoryStorage();
  }
}

================
File: packages/unshielded-wallet/src/v1/test/testUtils.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { sampleIntentHash } from '@midnight-ntwrk/ledger-v6';
import { UnshieldedUpdate, UpdateStatus, UtxoWithMeta } from '../UnshieldedState.js';

export const generateMockUtxoWithMeta = (owner: string, type: string): UtxoWithMeta =>
  new UtxoWithMeta({
    utxo: generateMockLedgerUtxo(owner, type),
    meta: {
      ctime: new Date(),
      registeredForDustGeneration: true,
    },
  });

export const generateMockLedgerUtxo = (owner: string, type: string): ledger.Utxo => ({
  value: BigInt(Math.ceil(Math.random() * 100)),
  owner,
  type,
  intentHash: sampleIntentHash(),
  outputNo: Math.floor(Math.random() * 100),
});

export const generateMockUpdate = (
  status: UpdateStatus,
  createdOutputsAmount: number,
  spentOutputsAmount: number,
  owner: string = 'owner1',
  type: string = 'type1',
): UnshieldedUpdate => {
  const createdUtxos = Array.from({ length: createdOutputsAmount }, () => generateMockUtxoWithMeta(owner, type));
  const spentUtxos = Array.from({ length: spentOutputsAmount }, () => generateMockUtxoWithMeta(owner, type));

  return {
    createdUtxos,
    spentUtxos,
    status,
  };
};

export const seedHex = (length: number = 64, seed: number = 42): string =>
  Array.from({ length }, (_, i) => ((seed + i) % 16).toString(16)).join('');

export const blockTime = (blockTime: Date): bigint => BigInt(Math.ceil(+blockTime / 1000));

================
File: packages/unshielded-wallet/src/v1/test/UnshieldedState.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Either, HashMap, pipe } from 'effect';
import { describe, expect, it } from 'vitest';
import { UnshieldedState, UnshieldedUpdate } from '../UnshieldedState.js';
import { UtxoNotFoundError } from '../WalletError.js';
import { generateMockUpdate, generateMockUtxoWithMeta } from './testUtils.js';

const getOrThrow = <E, A>(either: Either.Either<A, E>): A =>
  pipe(
    either,
    Either.getOrThrowWith((e) => new Error(`Unexpected error: ${JSON.stringify(e)}`)),
  );

describe('UnshieldedState', () => {
  it('should apply a successful update', () => {
    const state = pipe(
      UnshieldedState.empty(),
      (s) => UnshieldedState.applyUpdate(s, generateMockUpdate('SUCCESS', 1, 0)),
      getOrThrow,
    );

    expect(HashMap.size(state.availableUtxos)).toEqual(1);
    expect(HashMap.size(state.pendingUtxos)).toEqual(0);
  });

  it('should apply update with multiple created outputs', () => {
    const state = pipe(
      UnshieldedState.empty(),
      (s) => UnshieldedState.applyUpdate(s, generateMockUpdate('SUCCESS', 3, 0)),
      getOrThrow,
    );

    expect(HashMap.size(state.availableUtxos)).toEqual(3);
    expect(HashMap.size(state.pendingUtxos)).toEqual(0);
  });

  it('should spend a utxo', () => {
    const update = generateMockUpdate('SUCCESS', 1, 0);

    const state = pipe(
      UnshieldedState.empty(),
      (s) => UnshieldedState.applyUpdate(s, update),
      getOrThrow,
      (s) => UnshieldedState.spend(s, update.createdUtxos[0]),
      getOrThrow,
    );

    expect(HashMap.size(state.availableUtxos)).toEqual(0);
    expect(HashMap.size(state.pendingUtxos)).toEqual(1);
  });

  it('should fail to spend a utxo that does not exist', () => {
    const update = generateMockUpdate('SUCCESS', 1, 0);

    const result = pipe(
      UnshieldedState.empty(),
      (s) => UnshieldedState.applyUpdate(s, update),
      getOrThrow,
      (s) => UnshieldedState.spend(s, generateMockUtxoWithMeta('owner21', 'type12')),
    );

    expect(Either.isLeft(result)).toBe(true);
    pipe(
      result,
      Either.mapLeft((e) => expect(e).toBeInstanceOf(UtxoNotFoundError)),
    );
  });

  it('should rollback a spend', () => {
    const update = generateMockUpdate('SUCCESS', 1, 0);
    const utxoToSpend = update.createdUtxos[0];

    const state = pipe(
      UnshieldedState.empty(),
      (s) => UnshieldedState.applyUpdate(s, update),
      getOrThrow,
      (s) => UnshieldedState.spend(s, utxoToSpend),
      getOrThrow,
      (s) => UnshieldedState.rollbackSpend(s, utxoToSpend),
      getOrThrow,
    );

    expect(HashMap.size(state.availableUtxos)).toEqual(1);
    expect(HashMap.size(state.pendingUtxos)).toEqual(0);
  });

  it('should apply a failed update (restore spent utxos)', () => {
    const update = generateMockUpdate('SUCCESS', 1, 0);
    const utxoToSpend = update.createdUtxos[0];

    const failedUpdate: UnshieldedUpdate = {
      createdUtxos: [],
      spentUtxos: [utxoToSpend],
      status: 'FAILURE',
    };

    const state = pipe(
      UnshieldedState.empty(),
      (s) => UnshieldedState.applyUpdate(s, update),
      getOrThrow,
      (s) => UnshieldedState.spend(s, utxoToSpend),
      getOrThrow,
      (s) => UnshieldedState.applyFailedUpdate(s, failedUpdate),
      getOrThrow,
    );

    expect(HashMap.size(state.availableUtxos)).toEqual(1);
    expect(HashMap.size(state.pendingUtxos)).toEqual(0);
  });

  it('should reject applying update with wrong status', () => {
    const result = pipe(UnshieldedState.empty(), (s) =>
      UnshieldedState.applyUpdate(s, generateMockUpdate('FAILURE', 1, 0)),
    );

    expect(Either.isLeft(result)).toBe(true);
  });

  it('should reject applying failed update with wrong status', () => {
    const result = pipe(UnshieldedState.empty(), (s) =>
      UnshieldedState.applyFailedUpdate(s, generateMockUpdate('SUCCESS', 0, 1)),
    );

    expect(Either.isLeft(result)).toBe(true);
  });

  it('should restore state from arrays', () => {
    const utxo1 = generateMockUtxoWithMeta('owner1', 'type1');
    const utxo2 = generateMockUtxoWithMeta('owner2', 'type2');
    const pendingUtxo = generateMockUtxoWithMeta('owner3', 'type3');

    const state = UnshieldedState.restore([utxo1, utxo2], [pendingUtxo]);

    expect(HashMap.size(state.availableUtxos)).toEqual(2);
    expect(HashMap.size(state.pendingUtxos)).toEqual(1);
  });

  it('should convert state to arrays', () => {
    const utxo1 = generateMockUtxoWithMeta('owner1', 'type1');
    const utxo2 = generateMockUtxoWithMeta('owner2', 'type2');
    const pendingUtxo = generateMockUtxoWithMeta('owner3', 'type3');

    const arrays = pipe(UnshieldedState.restore([utxo1, utxo2], [pendingUtxo]), UnshieldedState.toArrays);

    expect(arrays.availableUtxos.length).toEqual(2);
    expect(arrays.pendingUtxos.length).toEqual(1);
  });

  it('should spend by utxo (ledger.Utxo)', () => {
    const update = generateMockUpdate('SUCCESS', 1, 0);

    const state = pipe(
      UnshieldedState.empty(),
      (s) => UnshieldedState.applyUpdate(s, update),
      getOrThrow,
      (s) => UnshieldedState.spendByUtxo(s, update.createdUtxos[0].utxo),
      getOrThrow,
    );

    expect(HashMap.size(state.availableUtxos)).toEqual(0);
    expect(HashMap.size(state.pendingUtxos)).toEqual(1);
  });

  it('should rollback spend by utxo (ledger.Utxo)', () => {
    const update = generateMockUpdate('SUCCESS', 1, 0);
    const utxoToSpend = update.createdUtxos[0];

    const state = pipe(
      UnshieldedState.empty(),
      (s) => UnshieldedState.applyUpdate(s, update),
      getOrThrow,
      (s) => UnshieldedState.spend(s, utxoToSpend),
      getOrThrow,
      (s) => UnshieldedState.rollbackSpendByUtxo(s, utxoToSpend.utxo),
      getOrThrow,
    );

    expect(HashMap.size(state.availableUtxos)).toEqual(1);
    expect(HashMap.size(state.pendingUtxos)).toEqual(0);
  });
});

================
File: packages/unshielded-wallet/.prettierignore
================
dist/
coverage/
reports/

================
File: packages/unshielded-wallet/eslint.config.mjs
================
import { packageConfig } from '../../eslint.config.mjs';

export default packageConfig();

================
File: packages/unshielded-wallet/README.md
================
# Wallet SDK Unshielded Wallet

TBD

================
File: packages/unshielded-wallet/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/test/**/*.ts", "src/**/*.test.ts"]
}

================
File: packages/unshielded-wallet/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [
    {
      "path": "./tsconfig.build.json"
    },
    {
      "path": "./tsconfig.test.json"
    }
  ]
}

================
File: packages/unshielded-wallet/tsconfig.publish.json
================
{
  "extends": "./tsconfig.build.json",
  "compilerOptions": {
    "sourceMap": false,
    "declarationMap": false
  }
}

================
File: packages/unshielded-wallet/tsconfig.test.json
================
{
  "extends": "./tsconfig.json",
  "include": ["test/**/*.ts", "src/**/*.ts"]
}

================
File: packages/utilities/src/networking/ClientServerErrors.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Data } from 'effect';

/**
 * An error representing a connection or client-side error.
 *
 * @remarks
 * This error typically indicates a connection issue with a target server, or when the client has submitted some
 * data that could not be processed.
 */
export class ClientError extends Data.TaggedError('ClientError')<{
  readonly message: string;

  readonly cause?: unknown;
}> {}

/**
 * An error representing a server-side error.
 */
export class ServerError extends Data.TaggedError('ServerError')<{
  readonly message: string;
}> {}

================
File: packages/utilities/src/networking/HttpURL.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Either } from 'effect';
import * as Brand from 'effect/Brand';
import { InvalidProtocolSchemeError } from './URLError.js';

/**
 * A 'HTTP' URL.
 */
export type HttpUrl = Brand.Branded<URL, 'HttpURL'>;
/**
 * Constructs a 'HTTP' URL from a source URL, ensuring that the protocol is correct.
 */
export const HttpURL = Brand.refined<HttpUrl>(
  (url) => url.protocol === 'http:' || url.protocol === 'https:',
  (url) => Brand.error(`Invalid protocol scheme '${url.protocol}'. Expected 'http:' or 'https:'`),
);

/**
 * Constructs a new {@link HttpURL} from a given string.
 *
 * @param url The URL to be made into a HTTP URL.
 * @returns An `Either` that represents the valid HTTP URL constructed from `url`; or an
 * {@link InvalidProtocolSchemeError}.
 */
export const make: (url: URL | string) => Either.Either<HttpUrl, InvalidProtocolSchemeError> = (url) => {
  const targetURL = new URL(url);
  try {
    return Either.right(HttpURL(targetURL));
  } catch (err: unknown) {
    return Either.left(new InvalidProtocolSchemeError({ message: String(err), invalidScheme: targetURL.protocol }));
  }
};

================
File: packages/utilities/src/networking/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * as HttpURL from './HttpURL.js';
export * as WsURL from './WsURL.js';
export * from './URLError.js';
export * from './ClientServerErrors.js';

================
File: packages/utilities/src/networking/URLError.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Data } from 'effect';

/**
 * A configuration error where the protocol scheme of a given server URL was unexpected (e.g., used
 * `'ftp:'` rather than `'http:'` for a server running over HTTP).
 */
export class InvalidProtocolSchemeError extends Data.TaggedError('InvalidProtocolSchemeError')<{
  /** A message describing the error. */
  readonly message: string;

  /** The scheme that caused the error. */
  readonly invalidScheme: string;
}> {
  static readonly tag = 'InvalidProtocolSchemeError' as const;
}

export class FailedToDeriveWebSocketUrlError extends Data.TaggedError('FailedToDeriveWebSocketUrlError')<{
  /** A message describing the error. */
  readonly message: string;

  readonly cause?: unknown;
}> {
  static readonly tag = 'FailedToDeriveWebSocketUrlError' as const;
}

export type URLError = InvalidProtocolSchemeError | FailedToDeriveWebSocketUrlError;

================
File: packages/utilities/src/networking/WsURL.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Either } from 'effect';
import * as Brand from 'effect/Brand';
import { InvalidProtocolSchemeError } from './URLError.js';

/**
 * A 'HTTP' URL.
 */
export type WsURL = Brand.Branded<URL, 'WsURL'>;
/**
 * Constructs a 'WS' URL from a source URL, ensuring that the protocol is correct.
 */
export const WsURL = Brand.refined<WsURL>(
  (url) => url.protocol === 'ws:' || url.protocol === 'wss:',
  (url) => Brand.error(`Invalid protocol scheme '${url.protocol}'. Expected 'ws:' or 'wss:'`),
);

/**
 * Constructs a new {@link WsURL} from a given string.
 *
 * @param url The URL to be made into a WebSocket URL.
 * @returns An `Either` that represents the valid WebSocket URL constructed from `url`; or an
 * {@link InvalidProtocolSchemeError}.
 */
export const make: (url: URL | string) => Either.Either<WsURL, InvalidProtocolSchemeError> = (url) => {
  const targetURL = new URL(url);
  try {
    return Either.right(WsURL(targetURL));
  } catch (err: unknown) {
    return Either.left(new InvalidProtocolSchemeError({ message: String(err), invalidScheme: targetURL.protocol }));
  }
};

================
File: packages/utilities/src/test/hlist.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { describe, expect, it } from 'vitest';
import {
  Append,
  append,
  Each,
  Empty,
  empty,
  find,
  Find,
  foldLeft,
  foldRight,
  head,
  Head,
  headOr,
  HeadOr,
  Prepend,
  prepend,
  reverse,
  Reverse,
  Tail,
  Tails,
} from '../hlist.js';
import type { Equal, Expect } from '../testUtils.js';

describe('HList', () => {
  it('properly prepends to the list', () => {
    const addedNumber = prepend(empty, 1);
    const addedString = prepend(addedNumber, 'foo');

    type List = Prepend<Prepend<Empty, number>, string>;
    type _1 = Expect<Equal<List, [string, number]>>;
    type _2 = Expect<Equal<typeof addedNumber, [number]>>;
    type _3 = Expect<Equal<typeof addedString, [string, number]>>;

    expect(addedNumber).toEqual([1]);
    expect(addedString).toEqual(['foo', 1]);
  });

  it('properly appends to the list', () => {
    const addedNumber = append(empty, 1);
    const addedString = append(addedNumber, 'foo');

    type List = Append<Append<Empty, number>, string>;
    type _1 = Expect<Equal<List, [number, string]>>;
    type _2 = Expect<Equal<typeof addedNumber, [number]>>;
    type _3 = Expect<Equal<typeof addedString, [number, string]>>;

    expect(addedNumber).toEqual([1]);
    expect(addedString).toEqual([1, 'foo']);
  });

  it('properly gets first element', () => {
    const appendedNumber = append(empty, 1 as const);
    const appendedString = append(appendedNumber, 'foo' as const);
    const prependedString = prepend(appendedNumber, 'foo' as const);
    const appendedString2 = append(appendedString, 'bar' as const);
    const prependedString2 = prepend(prependedString, 'bar' as const);
    const prependedObject = prepend(prependedString2, { foo: 'bar' } as const);

    type _1 = Expect<Equal<Head<[number, string]>, number>>;
    type _2 = Expect<Equal<Head<[number]>, number>>;
    type _3 = Expect<Equal<Head<[number, 1, 2]>, number>>;
    type _4 = Expect<Equal<Head<[]>, never>>;

    expect(() => head(empty)).toThrow();
    expect(head(appendedNumber)).toEqual(1);
    type _5 = Expect<Equal<Head<typeof appendedNumber>, 1>>;
    expect(head(appendedString)).toEqual(1);
    type _6 = Expect<Equal<Head<typeof appendedString>, 1>>;
    expect(head(prependedString)).toEqual('foo');
    type _7 = Expect<Equal<Head<typeof prependedString>, 'foo'>>;
    expect(head(appendedString2)).toEqual(1);
    type _8 = Expect<Equal<Head<typeof appendedString2>, 1>>;
    expect(head(prependedString2)).toEqual('bar');
    type _9 = Expect<Equal<Head<typeof prependedString2>, 'bar'>>;
    expect(head(prependedObject).foo).toEqual('bar');
    type _10 = Expect<Equal<Head<typeof prependedObject>, Readonly<{ foo: 'bar' }>>>;
  });

  it('allows to get first element, with providing a default', () => {
    const appendedNumber = append(empty, 1 as const);
    const appendedString = append(appendedNumber, 'foo' as const);
    const prependedString = prepend(appendedNumber, 'foo' as const);
    const appendedString2 = append(appendedString, 'bar' as const);
    const prependedString2 = prepend(prependedString, 'bar' as const);

    type _1 = Expect<Equal<HeadOr<[number, string], boolean>, number>>;
    type _2 = Expect<Equal<HeadOr<[number], boolean>, number>>;
    type _3 = Expect<Equal<HeadOr<[number, 1, 2], boolean>, number>>;
    type _4 = Expect<Equal<HeadOr<[], boolean>, boolean>>;

    expect(headOr(empty, () => null)).toBeNull();
    expect(headOr(appendedNumber, () => null)).toEqual(1);
    type _5 = Expect<Equal<HeadOr<typeof appendedNumber, boolean>, 1>>;
    expect(headOr(appendedString, () => null)).toEqual(1);
    type _6 = Expect<Equal<HeadOr<typeof appendedString, boolean>, 1>>;
    expect(headOr(prependedString, () => null)).toEqual('foo');
    type _7 = Expect<Equal<HeadOr<typeof prependedString, boolean>, 'foo'>>;
    expect(headOr(appendedString2, () => null)).toEqual(1);
    type _8 = Expect<Equal<HeadOr<typeof appendedString2, boolean>, 1>>;
    expect(headOr(prependedString2, () => null)).toEqual('bar');
    type _9 = Expect<Equal<HeadOr<typeof prependedString2, boolean>, 'bar'>>;
  });

  it('properly reverses the list', () => {
    const appendedNumber = append(empty, 1 as const);
    const appendedString = append(appendedNumber, 'foo' as const);
    const prependedString = prepend(appendedNumber, 'foo' as const);
    const appendedString2 = append(appendedString, 'bar' as const);
    const prependedString2 = prepend(prependedString, 'bar' as const);

    type _1 = Expect<Equal<Reverse<[number]>, [number]>>;
    type _2 = Expect<Equal<Reverse<Empty>, Empty>>;
    type _3 = Expect<Equal<Reverse<[number, string]>, [string, number]>>;

    expect(reverse(empty)).toEqual(empty);
    type _4 = Expect<Equal<Reverse<typeof empty>, Empty>>;
    expect(reverse(appendedNumber)).toEqual(appendedNumber);
    type _5 = Expect<Equal<Reverse<typeof appendedNumber>, [1]>>;
    expect(reverse(appendedString)).toEqual(prependedString);
    type _6 = Expect<Equal<Reverse<typeof appendedString>, ['foo', 1]>>;
    expect(reverse(prependedString2)).toEqual(appendedString2);
    type _7 = Expect<Equal<Reverse<typeof prependedString2>, [1, 'foo', 'bar']>>;
  });

  it('properly explodes list into union of its elements', () => {
    type _1 = Expect<Equal<Each<[string, number]>, string | number>>;
    type _2 = Expect<Equal<Each<[number, string]>, string | number>>;
    type _3 = Expect<Equal<Each<[]>, never>>;
    type _4 = Expect<Equal<Each<[string, number, boolean]>, string | number | boolean>>;
  });

  it('properly finds element matching given predicate', () => {
    type WithStringValue = {
      value: string;
    };
    type WithNumberValue = {
      value: number;
    };
    type WithTag<Tag extends string | symbol> = {
      tag: Tag;
    };
    type TestList = [
      WithNumberValue,
      WithNumberValue & WithTag<'foo'>,
      WithStringValue,
      WithStringValue & WithTag<'bar'>,
    ];
    const testList: TestList = [
      { value: 42 },
      { value: 11, tag: 'foo' },
      { value: 'ooo' },
      { value: 'aaa', tag: 'bar' },
    ];
    const unknownValuePredicate = (value: unknown): value is { value: unknown } =>
      typeof value === 'object' && value != null && 'value' in value;
    const stringValuePredicate = (value: unknown): value is { value: string } =>
      unknownValuePredicate(value) && typeof value.value === 'string';
    const stringTagPredicate = (value: unknown): value is { tag: string } =>
      typeof value === 'object' && value != null && 'tag' in value && typeof value.tag === 'string';
    const barTagPredicate = (value: unknown): value is { tag: 'bar' } =>
      stringTagPredicate(value) && value.tag == 'bar';

    type _1 = Expect<Equal<Find<[string, number], string>, string>>;
    type _2 = Expect<Equal<Find<[string, number], number>, number>>;
    type _3 = Expect<Equal<Find<['foo', 'bar', number], string>, 'foo'>>;
    type _4 = Expect<Equal<Find<[number, 'foo', 'bar'], string>, 'foo'>>;
    type _5 = Expect<Equal<Find<TestList, { value: unknown }>, WithNumberValue>>;
    type _6 = Expect<Equal<Find<TestList, { value: string }>, WithStringValue>>;
    type _7 = Expect<Equal<Find<TestList, { tag: string }>, WithNumberValue & WithTag<'foo'>>>;
    type _8 = Expect<Equal<Find<TestList, { tag: 'bar' }>, WithStringValue & WithTag<'bar'>>>;

    const found1 = find(testList, unknownValuePredicate);
    expect(found1).toEqual({ value: 42 });
    type _9 = Expect<Equal<typeof found1, WithNumberValue>>;
    const found2 = find(testList, stringValuePredicate);
    expect(found2).toEqual({ value: 'ooo' });
    type _10 = Expect<Equal<typeof found2, WithStringValue>>;
    const found3 = find(testList, stringTagPredicate);
    expect(found3).toEqual({ value: 11, tag: 'foo' });
    type _11 = Expect<Equal<typeof found3, WithNumberValue & WithTag<'foo'>>>;
    const found4 = find(testList, barTagPredicate);
    expect(found4).toEqual({ value: 'aaa', tag: 'bar' });
    type _12 = Expect<Equal<typeof found4, WithStringValue & WithTag<'bar'>>>;
  });

  describe('folds', () => {
    type NumberVariant = {
      __polyTag__: 'NumberVariant';
      number: number;
    };

    const stringTag: unique symbol = Symbol('StringTag');
    type StringVariant = {
      __polyTag__: typeof stringTag;
      string: string;
    };

    type TestList = [NumberVariant, StringVariant];
    const testList: TestList = [
      { __polyTag__: 'NumberVariant', number: 42 },
      { __polyTag__: stringTag, string: 'foo' },
    ];

    it('left', () => {
      const folded = foldLeft(testList, 'init', (acc) => ({
        NumberVariant: (variant: NumberVariant) => acc + `,number:${variant.number}`,
        [stringTag]: (variant: StringVariant) => acc + `,string:${variant.string}`,
      }));
      type _1 = Expect<Equal<typeof folded, string>>;
      expect(folded).toEqual('init,number:42,string:foo');
    });

    it('right', () => {
      const folded = foldRight(testList, 'init', (acc) => ({
        NumberVariant: (variant: NumberVariant) => acc + `,number:${variant.number}`,
        [stringTag]: (variant: StringVariant) => acc + `,string:${variant.string}`,
      }));
      type _1 = Expect<Equal<typeof folded, string>>;
      expect(folded).toEqual('init,string:foo,number:42');
    });
  });

  it('properly infers tail type', () => {
    type _1 = Expect<Equal<Tail<[]>, []>>;
    type _2 = Expect<Equal<Tail<[string]>, []>>;
    type _3 = Expect<Equal<Tail<[string, number]>, [number]>>;
    type _4 = Expect<Equal<Tail<[string, number, boolean]>, [number, boolean]>>;
  });

  it('properly infers all tails type', () => {
    type _1 = Expect<Equal<Tails<[]>, []>>;
    type _2 = Expect<Equal<Tails<[string]>, []>>;
    type _3 = Expect<Equal<Tails<[string, number]>, [number] | []>>;
    type _4 = Expect<Equal<Tails<[string, number, boolean]>, [number, boolean] | [boolean] | []>>;
  });
});

================
File: packages/utilities/src/test/observable.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Fiber, identity, Stream } from 'effect';
import * as rx from 'rxjs';
import { describe, expect, it, vi } from 'vitest';
import * as ObservableOps from '../ObservableOps.js';

describe('Observable', () => {
  const makeGenerator = (iterations: number) => {
    let iteration = 0;

    // eslint-disable-next-line @typescript-eslint/require-await
    const generator = async function* () {
      while (iteration < iterations) {
        yield iteration++;
      }
    };

    return {
      generator,
      iterationsYielded: () => iteration,
    };
  };

  const MAX_ITERATIONS = 100;
  const TAKEN_ITERATIONS = 10;

  describe('toStream', () => {
    it('should close underlying Observable', async () => {
      const { generator, iterationsYielded } = makeGenerator(MAX_ITERATIONS);

      const observable = rx.from(generator());
      const stream = ObservableOps.toStream(observable).pipe(Stream.takeWhile((i) => i < TAKEN_ITERATIONS));
      const collected = await Effect.runPromise(Stream.runCollect(stream));

      expect(collected.length).toEqual(TAKEN_ITERATIONS);
      expect(iterationsYielded()).toBeLessThan(MAX_ITERATIONS);
    });
  });

  describe('fromStream', () => {
    it('should close underlying Stream', async () => {
      const { generator, iterationsYielded } = makeGenerator(MAX_ITERATIONS);

      const stream = Stream.fromAsyncIterable(generator(), identity);
      const observable = ObservableOps.fromStream(stream).pipe(rx.takeWhile((i) => i < TAKEN_ITERATIONS));
      const collected = await rx.lastValueFrom(observable.pipe(rx.toArray()));

      expect(collected.length).toEqual(TAKEN_ITERATIONS);
      expect(iterationsYielded()).toBeLessThan(MAX_ITERATIONS);
    });

    it('should cleanup allocated resource in underlying Stream', async () => {
      const { generator } = makeGenerator(MAX_ITERATIONS);
      const anyResource = 'A Resource';
      const cleanupFn = vi.fn((_) => Effect.void);

      const runStream = Effect.gen(function* () {
        // Create a stream that makes use of a resource.
        const stream = Stream.acquireRelease(Effect.succeed(anyResource), cleanupFn).pipe(
          Stream.flatMap(() => Stream.fromAsyncIterable(generator(), identity)),
        );
        const observable = ObservableOps.fromStream(stream).pipe(rx.takeWhile((i) => i < TAKEN_ITERATIONS));

        yield* Effect.promise(() => rx.lastValueFrom(observable.pipe(rx.toArray())));
      });

      // Fork the `runStream` Effect and await its completion. This will ensure that stream finalization
      // will have completed...
      await Effect.runPromise(
        Effect.gen(function* () {
          yield* Fiber.await(yield* Effect.fork(runStream));
        }),
      );

      // ...allowing us to assert that the cleanup function was executed for the resource.
      expect(cleanupFn).toHaveBeenCalledWith(anyResource, expect.any(Object));
    });
  });

  describe('with chained Observables', () => {
    it('should close all underlying elements', async () => {
      const { generator, iterationsYielded } = makeGenerator(MAX_ITERATIONS);

      const observable = rx.from(generator());
      const stream = ObservableOps.toStream(observable);
      const chainedObservable = ObservableOps.fromStream(stream).pipe(rx.takeWhile((i) => i < TAKEN_ITERATIONS));
      const collected = await rx.lastValueFrom(chainedObservable.pipe(rx.toArray()));

      expect(collected.length).toEqual(TAKEN_ITERATIONS);
      expect(iterationsYielded()).toBeLessThan(MAX_ITERATIONS);
    });
  });
});

================
File: packages/utilities/src/test/polyFunction.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import type { Equal, Expect } from '../testUtils.js';
import { dispatch, PolyFunction, TagOf } from '../polyFunction.js';
import { describe, expect, it } from 'vitest';

describe('PolyFunction', () => {
  type NumberVariant = {
    __polyTag__: 'NumberVariant';
    number: number;
  };

  const stringTag: unique symbol = Symbol('StringTag');
  type StringVariant = {
    __polyTag__: typeof stringTag;
    string: string;
  };

  it('properly infers tag', () => {
    type _1 = Expect<Equal<TagOf<NumberVariant>, 'NumberVariant'>>;
    type _2 = Expect<Equal<TagOf<StringVariant>, typeof stringTag>>;
  });

  it('properly builds poly function type for single variant', () => {
    type Foo = 'foo';
    type _1 = Expect<Equal<PolyFunction<NumberVariant, Foo>, { NumberVariant: (variant: NumberVariant) => Foo }>>;
    type _2 = Expect<Equal<PolyFunction<StringVariant, Foo>, { [stringTag]: (variant: StringVariant) => Foo }>>;
  });

  it('properly builds poly function type for multiple variants', () => {
    type Foo = 'foo';
    type _1 = Expect<
      Equal<
        PolyFunction<NumberVariant | StringVariant, Foo>,
        {
          NumberVariant: (variant: NumberVariant) => Foo;
          [stringTag]: (variant: StringVariant) => Foo;
        }
      >
    >;
  });

  it('provides a union of arguments if multiple variants have the same tag', () => {
    type Foo = 'foo';
    type Variant11 = {
      __polyTag__: 'Variant1';
      value: string;
    };
    type Variant12 = {
      __polyTag__: 'Variant1';
      value: number;
    };
    type Variant2 = {
      __polyTag__: 'Variant2';
      values: string[];
    };

    type _1 = Expect<
      Equal<
        PolyFunction<Variant11 | Variant12 | Variant2, Foo>,
        {
          Variant1: (variant: Variant11 | Variant12) => Foo;
          Variant2: (variant: Variant2) => Foo;
        }
      >
    >;
    const impl: PolyFunction<Variant11 | Variant12 | Variant2, string> = {
      Variant1: (variant) => {
        switch (typeof variant.value) {
          case 'string':
            return `variant11:${variant.value}`;
          case 'number':
            return `variant12:${variant.value.toString(16)}`;
        }
      },
      Variant2: (variant) => {
        return `variant2:${variant.values.join(',')}`;
      },
    };

    expect(dispatch({ __polyTag__: 'Variant1', value: 'foo' }, impl)).toEqual('variant11:foo');
    expect(dispatch({ __polyTag__: 'Variant1', value: 42 }, impl)).toEqual('variant12:2a');
    expect(dispatch({ __polyTag__: 'Variant2', values: ['a', 'b', 'c'] }, impl)).toEqual('variant2:a,b,c');
  });

  it('dispatches the call correctly', () => {
    const impl: PolyFunction<NumberVariant | StringVariant, string> = {
      NumberVariant: (variant: NumberVariant) => `number:${variant.number}`,
      [stringTag]: (variant: StringVariant) => `string:${variant.string}`,
    };

    expect(dispatch({ __polyTag__: 'NumberVariant', number: 42 }, impl)).toEqual('number:42');
    expect(dispatch({ __polyTag__: stringTag, string: 'foo' }, impl)).toEqual('string:foo');
  });

  it('throws an error if dispatch target is not provided in the polyFunction', () => {
    const impl = {
      NumberVariant: (variant: NumberVariant) => `number:${variant.number}`,
      // [stringTag]: (variant: StringVariant) => `string:${variant.string}`,
    } as PolyFunction<NumberVariant | StringVariant, string>;

    expect(dispatch({ __polyTag__: 'NumberVariant', number: 42 }, impl)).toEqual('number:42');
    expect(() => dispatch({ __polyTag__: stringTag, string: 'foo' }, impl)).toThrow(String(stringTag));
  });
});

================
File: packages/utilities/src/testing/compose.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as path from 'node:path';
import { fileURLToPath } from 'node:url';

/**
 * Gets the absolute path to the repository root directory.
 *
 * @returns The absolute path to the repository root
 */
export function getRepositoryRoot(): string {
  const currentFile = fileURLToPath(import.meta.url);
  const currentDir = path.dirname(currentFile);

  return path.resolve(currentDir, '../../../../');
}

/**
 * Gets the absolute path to the docker compose directory.
 *
 * @returns The absolute path to the compose directory
 */
export function getComposeDirectory(): string {
  const repoRoot = getRepositoryRoot();
  return path.join(repoRoot, 'infra', 'compose');
}

/**
 * Options for building test environment variables.
 */
export interface BuildTestEnvironmentVariablesOptions {
  /**
   * Additional environment variables to include.
   * These will be merged with the variables collected from process.env.
   */
  additionalVars?: Record<string, string>;
}

/**
 * Builds and validates environment variables for test containers.
 * Throws an error if any required environment variable from envVarsToPass is missing.
 *
 * @param envVarsToPass - Array of environment variable names to collect from process.env
 * @param options - Optional configuration for building environment variables
 * @returns Record of environment variables to pass to Docker Compose
 */
export function buildTestEnvironmentVariables(
  envVarsToPass: readonly string[],
  options?: BuildTestEnvironmentVariablesOptions,
): Record<string, string> {
  // Add any additional vars first (so they can be overridden by process.env vars if needed)
  const environmentVars: Record<string, string> = {
    ...options?.additionalVars,
  };

  // Collect and validate required environment variables
  for (const envVar of envVarsToPass) {
    const value = process.env[envVar];
    if (value) {
      environmentVars[envVar] = value;
    } else {
      throw new Error(
        `Required environment variable ${envVar} is not set. Please ensure it is exported in your shell or CI environment.`,
      );
    }
  }

  return environmentVars;
}

================
File: packages/utilities/src/testing/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * as TestContainers from './test-containers.js';
export * from './compose.js';

================
File: packages/utilities/src/testing/test-containers.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, identity, Scope } from 'effect';
import { GenericContainer, Network, StartedNetwork, Wait, type StartedTestContainer } from 'testcontainers';
import { getPortPromise } from 'portfinder';

export const createNetwork = (): Effect.Effect<StartedNetwork, never, Scope.Scope> =>
  Effect.acquireRelease(
    Effect.promise(() => new Network().start()),
    (net) => Effect.promise(() => net.stop()),
  );

const startContainer = (container: GenericContainer): Effect.Effect<StartedTestContainer, Error, Scope.Scope> => {
  return Effect.acquireRelease(
    Effect.promise(() => container.start()),
    (container) => Effect.promise(() => container.stop({ timeout: 5_000 })),
  );
};

export const runNodeContainer = (
  adjustment: (t: GenericContainer) => GenericContainer = identity,
): Effect.Effect<StartedTestContainer, Error, Scope.Scope> => {
  const container = new GenericContainer('ghcr.io/midnight-ntwrk/midnight-node:0.18.0-rc.4')
    .withEnvironment({
      CFG_PRESET: 'dev',
      SIDECHAIN_BLOCK_BENEFICIARY: '04bcf7ad3be7a5c790460be82a713af570f22e0f801f6659ab8e84a52be6969e',
    })
    .withExposedPorts(9944)
    .withWaitStrategy(Wait.forListeningPorts());
  return startContainer(adjustment(container));
};

export const runProofServerContainer = (
  adjustment: (t: GenericContainer) => GenericContainer = identity,
): Effect.Effect<StartedTestContainer, Error, Scope.Scope> => {
  const container = new GenericContainer('ghcr.io/midnight-ntwrk/proof-server:6.1.0-alpha.5')
    .withEnvironment({
      RUST_BACKTRACE: 'full',
    })
    .withExposedPorts(6300)
    .withCommand(['midnight-proof-server -v'])
    .withWaitStrategy(Wait.forListeningPorts());

  return startContainer(adjustment(container));
};

export const runTxGenerator = (
  config: {
    nodeUrl: string;
    destPath: string;
    fileName: string;
    txsPerBatch: number;
    batches: number;
  },
  adjustment: (t: GenericContainer) => GenericContainer = identity,
): Effect.Effect<StartedTestContainer, Error, Scope.Scope> => {
  const container: GenericContainer = new GenericContainer('ghcr.io/midnight-ntwrk/midnight-node-toolkit:0.18.0-rc.4')
    .withBindMounts([{ source: config.destPath, target: '/tmp', mode: 'rw' }])
    .withCommand([
      'generate-txs',
      '--src-url',
      config.nodeUrl,
      '--dest-file',
      `/tmp/${config.fileName}`,
      'batches',
      '--num-batches',
      String(config.batches),
      '--num-txs-per-batch',
      String(config.txsPerBatch),
    ])
    .withWaitStrategy(Wait.forLogMessage('✓ generated transactions'));

  return startContainer(adjustment(container));
};

export const findAvailablePort: Effect.Effect<number> = Effect.promise(() => getPortPromise());

================
File: packages/utilities/src/ArrayOps.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { NonEmptyReadonlyArray, reduce, match } from 'effect/Array';
import { dual } from 'effect/Function';

export const fold: {
  <T>(folder: (acc: T, item: T) => T): (arr: NonEmptyReadonlyArray<T>) => T;
  <T>(arr: NonEmptyReadonlyArray<T>, folder: (acc: T, item: T) => T): T;
} = dual(2, <T>(arr: NonEmptyReadonlyArray<T>, folder: (acc: T, item: T) => T): T => arr.reduce(folder));

export type Monoid<T> = {
  empty: T;
  combine: (a: T, b: T) => T;
};

export const generalSum: {
  <T>(monoid: Monoid<T>): (arr: ReadonlyArray<T>) => T;
  <T>(arr: ReadonlyArray<T>, monoid: Monoid<T>): T;
} = dual(2, <T>(arr: ReadonlyArray<T>, monoid: Monoid<T>): T => reduce(arr, monoid.empty, monoid.combine));

const numberAdditionMonoid: Monoid<number> = {
  empty: 0,
  combine: (a, b) => a + b,
};

const bigintAdditionMonoid: Monoid<bigint> = {
  empty: 0n,
  combine: (a, b) => a + b,
};

export const sumNumber: (arr: ReadonlyArray<number>) => number = generalSum(numberAdditionMonoid);

export const sumBigInt: (arr: ReadonlyArray<bigint>) => bigint = generalSum(bigintAdditionMonoid);

export const assertNonEmpty = <T>(arr: ReadonlyArray<T>): NonEmptyReadonlyArray<T> => {
  return match(arr, {
    onNonEmpty: (refined) => refined,
    onEmpty: () => {
      throw new Error('Expected non-empty array');
    },
  });
};

================
File: packages/utilities/src/BlobOps.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Browser-compatible utility for converting a Blob to Uint8Array.
 * Uses arrayBuffer() instead of bytes() for broader browser support.
 *
 * @param blob The Blob to convert to bytes
 * @returns A Promise that resolves to a Uint8Array containing the blob's bytes
 */
export const getBytes = (blob: Blob): Promise<Uint8Array> => blob.arrayBuffer().then((ab) => new Uint8Array(ab));

================
File: packages/utilities/src/DateOps.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export const dateToSeconds = (date: Date): bigint => {
  return BigInt(Math.floor(date.getTime() / 1000));
};

export const secondsToDate = (seconds: bigint | number): Date => {
  return new Date(Number(seconds) * 1000);
};

export const addSeconds = (time: Date, seconds: bigint | number): Date => {
  return new Date(+time + Number(seconds) * 1000);
};

================
File: packages/utilities/src/EitherOps.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Either, Data } from 'effect';
import { dual } from 'effect/Function';

export const toEffect = <L, R>(either: Either.Either<R, L>): Effect.Effect<R, L> => {
  return Either.match(either, {
    onLeft: (l) => Effect.fail(l),
    onRight: (r) => Effect.succeed(r),
  });
};

export const flatMapLeft: {
  <R, L, L2>(either: Either.Either<R, L>, cb: (l: L) => Either.Either<R, L2>): Either.Either<R, L2>;
  <R, L, L2>(cb: (l: L) => Either.Either<R, L2>): (either: Either.Either<R, L>) => Either.Either<R, L2>;
} = dual(2, <R, L, L2>(either: Either.Either<R, L>, cb: (l: L) => Either.Either<R, L2>) => {
  return Either.match(either, {
    onRight: (r) => Either.right(r),
    onLeft: cb,
  });
});

export class LeftError<L> extends Data.TaggedError('LeftError')<{ message: string; cause: L }> {
  constructor({ cause }: { cause: L }) {
    super({ message: 'Unexpected left value', cause });
  }
}

export const getOrThrowLeft = <L, R>(either: Either.Either<R, L>): R => {
  return Either.match(either, {
    onRight: (r) => r,
    onLeft: (l) => {
      throw new LeftError({ cause: l });
    },
  });
};

================
File: packages/utilities/src/Fluent.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export declare namespace Fluent {
  /**
   * Exclude named methods from `T` so that they are no longer callable.
   */
  type ExcludeMethod<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
}

================
File: packages/utilities/src/hlist.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/* eslint-disable @typescript-eslint/no-explicit-any */
import { dispatch, PolyFunction, WithTag } from './polyFunction.js';

/**
 * Heterogeneous list - as in - list, where elements have different types
 * Here - more as an additional API over TS's tuple type
 */
export type Empty = [];
export type NonEmpty<T> = T extends Array<infer E> ? [E, ...T] : never;
export type Prepend<List extends unknown[], Element> = [Element, ...List];
export type Append<List extends unknown[], Element> = [...List, Element];
export type Reverse<List extends unknown[]> = List extends [...infer Init, infer Last]
  ? [Last, ...Reverse<Init>]
  : List extends []
    ? []
    : never;

export type HeadOr<List, Default> = List extends [infer TheHead, ...any[]]
  ? TheHead
  : List extends []
    ? Default
    : never;
export type Head<List extends any[]> = HeadOr<List, never>;

export type Tail<List extends unknown[]> = List extends [unknown, ...infer Tail] ? Tail : [];

export type Tails<List extends unknown[]> = List extends [unknown, ...infer Tail] ? Tails<Tail> | Tail : [];

export type Each<List extends unknown[]> = List[number];

export type Find<List extends any[], Predicate> = List extends [infer TheHead, ...infer Rest]
  ? TheHead extends Predicate
    ? TheHead
    : Find<Rest, Predicate>
  : never;

export const empty: Empty = [];

export const prepend = <List extends unknown[], Element>(list: List, element: Element): Prepend<List, Element> => {
  return [element, ...list];
};

export const append = <List extends unknown[], Element>(list: List, element: Element): Append<List, Element> => {
  return [...list, element];
};

export function headOr<List extends unknown[], Default>(list: List, def: () => Default): HeadOr<List, Default> {
  if (list.length == 0) {
    return def() as HeadOr<List, Default>;
  } else {
    return list.at(0) as Head<List>;
  }
}

export const head = <List extends unknown[]>(list: List): Head<List> => {
  return headOr(list, () => {
    throw new Error('Cannot get head from empty hlist');
  });
};

export const tail = <List extends unknown[]>(list: List): Tail<List> => {
  return list.toSpliced(0, 1) as Tail<List>;
};

export const reverse = <List extends unknown[]>(list: List): Reverse<List> => {
  return list.toReversed() as Reverse<List>;
};

export const find = <List extends unknown[], Predicate>(
  list: List,
  predicate: (value: Each<List>) => value is Predicate,
): Find<List, Predicate> => {
  return list.find(predicate) as Find<List, Predicate>;
};

export const foldLeft = <List extends WithTag<string | symbol>[], Acc>(
  list: List,
  acc: Acc,
  folder: (acc: Acc) => PolyFunction<Each<List>, Acc>,
): Acc => {
  return list.reduce((acc, item) => dispatch(item, folder(acc)), acc);
};
export const foldRight = <List extends WithTag<string | symbol>[], Acc>(
  list: List,
  acc: Acc,
  folder: (acc: Acc) => PolyFunction<Each<List>, Acc>,
): Acc => {
  return list.reduceRight((acc, item) => dispatch(item, folder(acc)), acc);
};

================
File: packages/utilities/src/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * as ArrayOps from './ArrayOps.js';
export * as BlobOps from './BlobOps.js';
export * as DateOps from './DateOps.js';
export * as EitherOps from './EitherOps.js';
export * as Fluent from './Fluent.js';
export * as HList from './hlist.js';
export * as LedgerOps from './LedgerOps.js';
export * as ObservableOps from './ObservableOps.js';
export * as Poly from './polyFunction.js';
export * as RecordOps from './RecordOps.js';

================
File: packages/utilities/src/LedgerOps.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Either, Data } from 'effect';

export class LedgerError extends Data.TaggedError('LedgerError')<{
  readonly message: string;
  readonly cause?: unknown;
}> {}

export const ledgerTry = <A>(fn: () => A): Either.Either<A, LedgerError> => {
  return Either.try({
    try: fn,
    catch: (error) => {
      const message = error instanceof Error ? error.message : `${error?.toString()}`;
      return new LedgerError({ message: `Error from ledger: ${message}`, cause: error });
    },
  });
};

export const generateHex = (len: number): string => {
  return Buffer.from(crypto.getRandomValues(new Uint8Array(len / 2))).toString('hex');
};

export const randomNonce = (): string => generateHex(64);

================
File: packages/utilities/src/ObservableOps.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Stream, Fiber, Option, Chunk } from 'effect';
import { Observable } from 'rxjs';

/**
 * A utility that creates a Rx.js `Observable` from a given Effect `Stream`.
 *
 * @param stream The Effect `Stream` from which an `Observable` is required.
 * @returns A Rx.js `Observable` that consumes the elements from `stream`.
 */
export const fromStream = <A, E = never>(stream: Stream.Stream<A, E>): Observable<A> =>
  new Observable<A>((subscriber) => {
    const fiber = Effect.runFork(
      Effect.scoped(
        Effect.gen(function* () {
          const pull = yield* Stream.toPull(stream);

          while (true) {
            const shouldBreak = yield* Effect.match(pull, {
              onSuccess(values) {
                Chunk.forEach(values, (element) => {
                  subscriber.next(element);
                });
                return false;
              },
              onFailure(error) {
                return Option.match(error, {
                  onNone() {
                    subscriber.complete();
                    return true; // Stream has completed, signal the break.
                  },
                  onSome: (err) => {
                    subscriber.error(err);
                    return true;
                  },
                });
              },
            });
            if (shouldBreak) break;
          }
        }),
      ),
    );

    // Ensure that if the subscription ends we also dispose of the fiber pulling from the stream.
    subscriber.add(() => Effect.runFork(Fiber.interrupt(fiber)));
  });

/**
 * A utility that creates an Effect `Stream` from a given Rx.js `Observable`.
 *
 * @param observable The Rx.js `Observable` from which a `Stream` is required.
 * @returns A `Stream` the consumes elements from `observable`.
 */
export const toStream = <A, E = never>(observable: Observable<A>): Stream.Stream<A, E> =>
  Stream.async<A, E>((emit) => {
    const subscription = observable.subscribe({
      next: (value) => void emit.single(value),
      error: (err) => void emit.fail(err as E),
      complete: () => void emit.end(),
    });

    return Effect.sync(() => subscription.unsubscribe());
  });

================
File: packages/utilities/src/polyFunction.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export type WithTag<T extends string | symbol> = {
  __polyTag__: T;
};
export type TagOf<T> = T extends WithTag<infer Tag> ? Tag : never;

export type WithTagFrom<T> = WithTag<TagOf<T>>;
/**
 * Polymorphic function - function defined for multiple types at once
 * Leveraging tagging mechanics it can predictably work at runtime and be quite intuitively defined by hand
 */
export type PolyFunction<Variants extends WithTag<string | symbol>, T> = {
  [V in Variants as TagOf<V>]: (variant: V) => T;
};

export const getTag = <TTag extends string | symbol>(t: WithTag<TTag>): TTag => t.__polyTag__;

export const dispatch = <TVariant extends WithTag<string | symbol>, TResult>(
  subject: TVariant,
  impl: PolyFunction<TVariant, TResult>,
): TResult => {
  if (subject.__polyTag__ in impl) {
    //Sadly, the type casts below are needed because eslint or TS limitations
    const subjectTag = subject.__polyTag__ as TagOf<TVariant>;
    const chosen = impl[subjectTag] as (v: TVariant) => TResult;
    return chosen(subject);
  } else {
    throw new Error(`Not found implementation for ${String(subject.__polyTag__)}`);
  }
};

================
File: packages/utilities/src/RecordOps.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export const merge =
  <K extends string | number | symbol, T>(combine: (a: T, b: T) => T) =>
  (records: Array<Record<K, T>>): Record<K, T> => {
    const result: Record<K, T> = {} as Record<K, T>;
    for (const record of records) {
      for (const key in record) {
        if (Object.hasOwn(result, key)) {
          result[key] = combine(result[key], record[key]);
        } else {
          result[key] = record[key];
        }
      }
    }
    return result;
  };

export const mergeWithAccumulator =
  <K extends string | number | symbol, T, S>(mempty: S, combine: (acc: S, b: T) => S) =>
  (records: Array<Record<K, T>>): Record<K, S> => {
    const result: Record<K, S> = {} as Record<K, S>;
    for (const record of records) {
      for (const key in record) {
        if (Object.hasOwn(result, key)) {
          result[key] = combine(result[key], record[key]);
        } else {
          result[key] = combine(mempty, record[key]);
        }
      }
    }
    return result;
  };

================
File: packages/utilities/src/testUtils.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * A utility type that ensures that a given type is `true` or otherwise forces a compile time error.
 */
export type Expect<T extends true> = T;

/**
 * A utility type that exactly compares two types for equality.
 */
export type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? true : false;

export type ItemType<T> = T extends ReadonlyArray<infer R> ? R : never;

================
File: packages/utilities/src/types.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * A utility type that checks whether type A can be assigned to type To
 * It appears to be useful when exact inferred type are slightly too complex to express and we want the express
 * a slightly simplified type rule like Expect<CanAssign<{foo: number}, object & {foo: number}>>
 */
export type CanAssign<A, To> = A extends To ? true : false;

/**
 * A utility type that ensures that a given type is `true` or otherwise forces a compile time error.
 */
export type Expect<T extends true> = T;

export type ItemType<T> = T extends ReadonlyArray<infer R> ? R : never;

/**
 * A utility type that exactly compares two types for equality.
 */
export type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? true : false;

================
File: packages/utilities/.npmignore
================
*.ts.map

================
File: packages/utilities/.prettierignore
================
dist/
coverage/
reports/

================
File: packages/utilities/CHANGELOG.md
================
# @midnight-ntwrk/wallet-sdk-utilities

## 1.0.0-beta.7

### Patch Changes

- 976628a: Provide getBytes to allow browser compliant bytes for Blob
- 1db4280: chore: bump ledger to version 6.1.0-beta.5

## 1.0.0-beta.6

### Patch Changes

- 2a0d132: chore: force re-release after workspace failure

## 1.0.0-beta.5

### Patch Changes

- ae22baf: chore: initialize baseline release after introducing Changesets

================
File: packages/utilities/eslint.config.mjs
================
import { packageConfig } from '../../eslint.config.mjs';

export default packageConfig();

================
File: packages/utilities/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/test/**/*.ts", "src/**/*.test.ts"]
}

================
File: packages/utilities/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [{ "path": "./tsconfig.build.json" }, { "path": "./tsconfig.test.json" }]
}

================
File: packages/utilities/tsconfig.publish.json
================
{
  "extends": "./tsconfig.build.json",
  "compilerOptions": {
    "sourceMap": false,
    "declarationMap": false
  }
}

================
File: packages/utilities/tsconfig.test.json
================
{
  "extends": "./tsconfig.json",
  "include": ["test/**/*.ts", "src/**/*.ts"]
}

================
File: packages/utilities/vitest.config.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/// <reference types="vitest" />
/// <reference types="vitest/globals" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage',
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }],
    ],
  },
});

================
File: packages/wallet-integration-tests/src/arbitraries.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import {
  ShieldedAddress,
  ShieldedCoinPublicKey,
  ShieldedEncryptionPublicKey,
} from '@midnight-ntwrk/wallet-sdk-address-format';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import * as fc from 'fast-check';
import { Record } from 'effect';

import { Transacting } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
type TokenTransfer = Transacting.TokenTransfer;

export const recipientArbitrary = fc
  .uint8Array({ minLength: 32, maxLength: 32 })
  .map((bytes) => ledger.ZswapSecretKeys.fromSeed(bytes));

export const shieldedAddressArbitrary = (whoArb: fc.Arbitrary<ledger.ZswapSecretKeys>): fc.Arbitrary<ShieldedAddress> =>
  whoArb.map(
    (who) =>
      new ShieldedAddress(
        new ShieldedCoinPublicKey(Buffer.from(who.coinPublicKey, 'hex')),
        new ShieldedEncryptionPublicKey(Buffer.from(who.encryptionPublicKey, 'hex')),
      ),
  );

export const outputsArbitrary = <TRecipient>(
  balances: Record<ledger.RawTokenType, bigint>,
  recipientArb: fc.Arbitrary<TRecipient>,
): fc.Arbitrary<
  ReadonlyArray<{
    readonly amount: bigint;
    readonly type: ledger.RawTokenType;
    readonly receiverAddress: TRecipient;
  }>
> => {
  const coinTypeArbitrary: fc.Arbitrary<ledger.RawTokenType> = fc.constantFrom(...Object.keys(balances));
  const outputArbitrary = coinTypeArbitrary.chain((coinType) =>
    fc.record({
      type: fc.constant(coinType),
      amount: fc.bigInt({ max: balances[coinType], min: 1n }),
      receiverAddress: recipientArb,
    }),
  );
  return fc.array(outputArbitrary, { size: 'xsmall', minLength: 1 }).filter((transfers) => {
    const transferBalances = transfers.reduce((acc: Record<string, bigint>, transfer) => {
      return {
        ...acc,
        [transfer.type]: acc[transfer.type] === undefined ? transfer.amount : acc[transfer.type] + transfer.amount,
      };
    }, {});

    return Object.entries(transferBalances).every(([tokenType, transferAmount]) => {
      const availableAmount = balances[tokenType] ?? 0n;

      return availableAmount > transferAmount;
    });
  });
};

export const swapParamsArbitrary = (
  balances: Record<ledger.RawTokenType, bigint>,
  selfAddress: string,
): fc.Arbitrary<{
  inputs: Record<ledger.RawTokenType, bigint>;
  outputs: TokenTransfer[];
}> => {
  const availableTypes = Record.keys(balances);
  const valueAssignments: fc.Arbitrary<Record<ledger.RawTokenType, bigint>> = availableTypes.reduce(
    (accArbitrary: fc.Arbitrary<Record<ledger.RawTokenType, bigint>>, tokenType) => {
      return accArbitrary.chain((acc) => {
        return fc.bigInt({ min: 1n, max: balances[tokenType] - 1_000_000n }).map((value) => ({
          ...acc,
          [tokenType]: value,
        }));
      });
    },
    fc.constant({}),
  );
  const inputOutputTypeAssignments = fc
    .integer({ min: 0, max: availableTypes.length })
    .chain((inputTypesCount) => {
      return fc
        .integer({ min: 0, max: availableTypes.length - inputTypesCount })
        .map((outputTypesCount) => ({ inputTypesCount, outputTypesCount }));
    })
    .chain(({ inputTypesCount, outputTypesCount }) => {
      return fc
        .shuffledSubarray(availableTypes, { minLength: availableTypes.length, maxLength: availableTypes.length })
        .map((shuffledTypes) => {
          const inputTypes = shuffledTypes.splice(0, inputTypesCount);
          const outputTypes = shuffledTypes.splice(0, outputTypesCount);
          return { inputTypes, outputTypes };
        });
    });
  return fc
    .record({
      valueAssignments: valueAssignments,
      inputOutputTypeAssignments: inputOutputTypeAssignments,
    })
    .map((params) => {
      const inputs: Record<ledger.RawTokenType, bigint> = params.inputOutputTypeAssignments.inputTypes.reduce(
        (acc, type) => ({
          ...acc,
          [type]: params.valueAssignments[type],
        }),
        {},
      );
      const outputs = params.inputOutputTypeAssignments.outputTypes.map((outputType): TokenTransfer => {
        return {
          amount: params.valueAssignments[outputType],
          type: outputType,
          receiverAddress: selfAddress,
        };
      });

      return { inputs, outputs };
    });
};

================
File: packages/wallet-integration-tests/test/simulation-mode.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { ShieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';
import { CustomShieldedWallet } from '@midnight-ntwrk/wallet-sdk-shielded';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import {
  Proving,
  Simulator,
  Submission,
  Sync,
  Transacting,
  TransactionHistory,
  V1Builder,
} from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import { Effect, pipe } from 'effect';
import * as rx from 'rxjs';
import { describe, expect, it, vi } from 'vitest';

vi.setConfig({ testTimeout: 100_000 });

const shieldedTokenType = (ledger.shieldedToken() as { tag: 'shielded'; raw: string }).raw;

describe('Working in simulation mode', () => {
  it('allows to make transactions', async () => {
    return Effect.gen(function* () {
      const senderKeys = ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 0));
      const receiverKeys = ledger.ZswapSecretKeys.fromSeed(Buffer.alloc(32, 1));

      const genesisMints = [
        {
          amount: 10_000_000n,
          type: shieldedTokenType,
          recipient: senderKeys,
        },
      ] as const;
      const simulator = yield* Simulator.Simulator.init(genesisMints);

      const Wallet = CustomShieldedWallet(
        {
          simulator,
          networkId: NetworkId.NetworkId.Undeployed,
        },
        new V1Builder()
          .withTransactionType<ledger.ProofErasedTransaction>()
          .withProving(Proving.makeSimulatorProvingService)
          .withCoinSelectionDefaults()
          .withTransacting(Transacting.makeSimulatorTransactingCapability)
          .withTransactionHistory(TransactionHistory.makeSimulatorTransactionHistoryCapability)
          .withSync(Sync.makeSimulatorSyncService, Sync.makeSimulatorSyncCapability)
          .withCoinsAndBalancesDefaults()
          .withKeysDefaults()
          .withSubmission(Submission.makeSimulatorSubmissionService())
          .withSerializationDefaults(),
      );

      const senderWallet = Wallet.startWithSecretKeys(senderKeys);
      const receiverWallet = Wallet.startWithSecretKeys(receiverKeys);

      yield* Effect.promise(() => senderWallet.start(senderKeys));
      yield* Effect.promise(() => receiverWallet.start(receiverKeys));

      yield* Effect.promise(() => {
        return pipe(
          senderWallet.state,
          rx.filter((s) => s.availableCoins.length > 0),
          rx.firstValueFrom,
        );
      });

      yield* Effect.promise(async () => {
        const recipe = await senderWallet.transferTransaction(senderKeys, [
          {
            type: shieldedTokenType,
            amount: 42n,
            receiverAddress: await receiverWallet
              .getAddress()
              .then((addr) => ShieldedAddress.codec.encode(Wallet.configuration.networkId, addr).asString()),
          },
        ]);
        const tx = await senderWallet.finalizeTransaction(recipe);
        await senderWallet.submitTransaction(tx);
      }).pipe(Effect.forkScoped);

      const finalBalance = yield* Effect.promise(() =>
        pipe(
          receiverWallet.state,
          rx.filter((state) => state.availableCoins.length > 0),
          rx.map((state) => state.balances[shieldedTokenType] ?? 0n),
          (a) => rx.firstValueFrom(a),
        ),
      );

      expect(finalBalance).toEqual(42n);
    }).pipe(Effect.scoped, Effect.runPromise);
  });
});

================
File: packages/wallet-integration-tests/test/utils.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { HDWallet, Roles } from '@midnight-ntwrk/wallet-sdk-hd';

/**
 * Temporary function until the ledger fixes imbalances.get()
 *
 * @param imbalances
 * @param rawTokenType
 * @returns bigint
 */
export const getNonDustImbalance = (
  imbalances: Map<ledger.TokenType, bigint>,
  rawTokenType: ledger.RawTokenType,
): bigint => {
  const [, value] = Array.from(imbalances.entries()).find(([t, value]) =>
    t.tag !== 'dust' && t.raw == rawTokenType ? value : undefined,
  ) ?? [undefined, BigInt(0)];

  return value;
};

export const getShieldedSeed = (seed: string): Uint8Array => {
  const seedBuffer = Buffer.from(seed, 'hex');
  const hdWalletResult = HDWallet.fromSeed(seedBuffer);

  const { hdWallet } = hdWalletResult as {
    type: 'seedOk';
    hdWallet: HDWallet;
  };

  const derivationResult = hdWallet.selectAccount(0).selectRole(Roles.Zswap).deriveKeyAt(0);

  if (derivationResult.type === 'keyOutOfBounds') {
    throw new Error('Key derivation out of bounds');
  }

  return Buffer.from(derivationResult.key);
};

================
File: packages/wallet-integration-tests/eslint.config.mjs
================
import { packageConfig } from '../../eslint.config.mjs';

export default packageConfig();

================
File: packages/wallet-integration-tests/tsconfig.json
================
{
  "extends": "../../tsconfig.base.json",
  "files": [],
  "references": [{ "path": "./tsconfig.test.json" }]
}

================
File: packages/wallet-integration-tests/tsconfig.test.json
================
{
  "extends": "./tsconfig.json",
  "include": ["test/**/*.ts", "src/**/*.ts"]
}

================
File: .env.example
================
# Environment Configuration for Midnight Wallet SDK
#
# This file contains environment variables used for configuring the Midnight Wallet SDK
# for local development and testing. Copy this file to .env and fill in the values.
#
# Note: The .env file is excluded from git (see .gitignore) and will not be committed.
# When copying to .env, you may remove this header and other comments if desired.

# NETWORK: Specifies which Midnight network to use for wallet operations.
# Default value for local development.
NETWORK=undeployed

# DEPLOYMENT: Specifies which deployment environment to use.
# Default value for local development.
DEPLOYMENT=local

# APP_INFRA_* variables: Configuration for local infrastructure (Docker Compose)
#
# These environment variables are used when running tests against the local Docker Compose
# setup, which includes the indexer-standalone container.
#
# For detailed information about indexer configuration options, see:
# https://github.com/midnightntwrk/midnight-indexer?tab=readme-ov-file#running
#
# Note: This project uses only the indexer-standalone component from the Midnight Indexer.

# APP_INFRA_SECRET: Hex-encoded 32-byte secret used by the indexer-standalone
# to encrypt stored sensitive data. This is required when running tests against
# the indexer-standalone container.
#
# Generate a secure secret using one of these commands:
#   Linux/macOS: openssl rand -hex 32
#   This will output 64 hex characters (32 bytes).
#
# IMPORTANT: Generate a unique secret for your environment.
APP_INFRA_SECRET=

================
File: DEV_GUIDE.md
================
# Developer Guide

This document is intended for maintainers and contributors to the **Midnight Wallet** repository.  
It describes the internal development and **release management** process used to maintain consistent, automated
versioning and publishing.

---

## 📚 Overview

We use **[Changesets](https://github.com/changesets/changesets)** to handle versioning and changelog generation, and the
**[Changesets GitHub Action](https://github.com/changesets/action)** to automate the creation of release pull requests
and publishing to our package registry.

This setup ensures that:

- Each meaningful change is explicitly versioned.

- Changelogs are consistent and automatically generated.

- Releases are automated, reproducible, and traceable.

---

## Branching Strategy

We use a simple, linear workflow:

- `feat/*` → New features

- `fix/*` → Bug fixes

- `chore/*` → Maintenance and build-related updates

**Rules**

- Open PRs from `feat/*`, `fix/*`, or `chore/*` → merge into `main` after review and green CI.

- Do **not** bump versions or edit changelogs manually — Changesets handles this.

Reserved branch (automated):

- `changeset-release/main` → Created and maintained by the **Changesets GitHub Action**.  
  This branch is used to automatically generate a **“chore: release”** pull request containing:
  - Version bumps for affected packages

  - Updated changelogs

  - (Normally) removal of processed `.changeset` files once a stable release is made

  When this **release PR** is merged into `main`, the same GitHub Action:
  - Publishes new versions to the package registry

  - Pushes git tags for each released version

  - Commits changelog and version updates back to `main`

Behavior of the Automated Release Pull Request:

The Changesets GitHub Action maintains a single automated pull request, typically named `chore: release` — or
`chore: release (<tag>)` during pre-release mode (for example, `chore: release (beta)` or `chore: release (rc)`). It is
created from the latest commit on `main` as a new branch named `changeset-release/main`, which the action updates
automatically to stay in sync with ongoing changes.

**When Left Open**

If the release PR remains open, subsequent merges into main (that include new .changeset files) will automatically
trigger the workflow to update the same PR. In most cases, you won’t see additional commits appear in the PR history —
instead, the existing “version bump” commit is force-pushed with updated content. This happens because the Changesets
Action regenerates the release commit and changelog each time to reflect the latest changes. The PR effectively stays in
sync with main, always representing the next release version.

💡 This is expected behavior — it ensures that you always have a single, up-to-date release PR, rather than many
separate ones.

**When Closed**

If you manually close the release PR without merging, the release branch (`changeset-release/main`) still exists
remotely. The next time the GitHub Action runs (for example, after new commits land on `main`), it will detect that
there are unreleased changes and automatically recreate the PR.

In practice, there’s rarely a reason to close the PR manually — since it will simply be recreated on the next run. The
only valid reason to close it might be to temporarily disable automated releases or clean up stale state — but the PR
will return as soon as the release workflow runs again.

> 💡 During **pre-release (beta) mode**, the `.changeset` files are **not removed** after publishing.  
> They remain in place so that subsequent beta releases (e.g., `1.0.0-beta.1`, `1.0.0-beta.2`, etc.) can be generated
> incrementally.  
> Once the repository exits beta mode, the next stable release will remove all processed `.changeset` files as usual.

---

## Versioning with Changesets

We use **[Semantic Versioning (SemVer)](https://semver.org/)**:

MAJOR.MINOR.PATCH

| Type    | Example | When                               |
| ------- | ------- | ---------------------------------- |
| `major` | `2.0.0` | Breaking changes                   |
| `minor` | `1.2.0` | Backwards-compatible features      |
| `patch` | `1.2.1` | Bug fixes or internal improvements |

---

### How We Manage Versions and Releases

We use the **[Changesets](https://github.com/changesets/changesets)** library to automate versioning and releases.

Changesets helps us:

- Track what changed between releases

- Automatically determine version bumps (major/minor/patch)

- Generate changelogs

- Create automated release pull requests

- Publish new versions

In short, it removes manual version management — developers just describe their changes, and Changesets does the rest.

---

### What Is a “Changeset”?

A **changeset** is a small Markdown file that describes what changed and how it should affect versioning.  
Each changeset acts as a lightweight _"release note draft"_ for the automation system and is stored inside the
`.changeset/` directory.

When you create a changeset using `yarn changeset add`, it automatically generates a uniquely named file (e.g.
`.changeset/bright-shoes-add.md`).

The name is randomly generated to avoid collisions and has no special meaning — the content of the file is what defines
the actual versioning behavior.

Each changeset tells Changesets:

- Which package(s) were affected

- What type of version bump to apply

- A short summary for the changelog

For example:

```markdown
---
'@midnight-ntwrk/wallet-sdk-shielded': patch
---

feat: remove new coins from shielded tx balancer api
```

When merged into main, these .changeset files are picked up by the GitHub Action to:

Generate or update the automated `chore: release` pull request

- Update changelogs

- Prepare new version tags

- Publish packages once the release PR is merged

---

### Adding a Changeset

When your PR introduces a change that should be released, you need to create a Changeset:

```bash
yarn changeset add
```

This is an interactive command that guides you through selecting the affected packages and defining how the release
should behave.

---

Selecting Packages:

When prompted, you’ll see two groups: `changed packages` and `unchanged packages`.

```
🦋  Which packages would you like to include? …
◉ changed packages
  ◉ @midnight-ntwrk/wallet-sdk-shielded
◯ unchanged packages
  ◯ @midnight-ntwrk/wallet-sdk-abstractions
  ◯ @midnight-ntwrk/wallet-sdk-address-format
  ◯ @midnight-ntwrk/wallet-sdk-capabilities
  ◯ @midnight-ntwrk/wallet-sdk-dust-wallet
  ◯ @midnight-ntwrk/wallet-sdk-facade
  ◯ @midnight-ntwrk/wallet-sdk-hd
  ◯ @midnight-ntwrk/wallet-sdk-indexer-client
  ◯ @midnight-ntwrk/wallet-sdk-node-client
  ◯ @midnight-ntwrk/wallet-sdk-prover-client
```

You should generally select only the main parent changed packages. Changesets automatically includes all dependent
internal packages where required.

> ⚠️ While you can select unchanged packages to force a release, this is almost never needed. Changesets automatically
> detects which packages have changed by analyzing their package.json and source content.

Packages that are private or explicitly ignored in the .changeset/config.json will not be included. For example, we
currently ignore test-related packages:

```json
"ignore": ["@midnight/wallet-e2e-tests", "@midnight-ntwrk/wallet-integration-tests"],
```

---

Choosing the Version Bump

After selecting packages, you’ll choose the version bump type:

- major → breaking change

- minor → new feature (backwards-compatible)

- patch → small fix or internal improvement

Then you’ll add a short summary, which will later appear in the generated `CHANGELOG.md` files.

---

### Important: What Happens (and What Doesn’t)

At this stage, no actual version numbers are changed — the .changeset file you create is simply a record of what should
happen during the next release.

When the Changesets GitHub Action later generates the automated release PR (`chore: release`):

- It applies the recorded version bumps to the relevant packages.

- It updates each package’s CHANGELOG.md.

- It also updates dependent packages (if any) to reference the newly bumped versions.

> 💡 Running `yarn changeset add` only creates the release instructions. The real version and dependency updates happen
> automatically inside the release PR.

---

### Running the Check for Missing Changesets

You should generally run `yarn changeset add` at the very end of your PR, once your code changes are complete and ready
for review.

There is a GitHub workflow that validates this — it will fail your PR if changes are detected but no changeset is
present.

You can also verify this locally:

```bash
yarn changeset:check
```

Internally, this runs:

```bash
yarn changeset status --since=origin/main --verbose
```

If packages have changed but no changeset was added, you'll see an error like:

```
🦋  error Some packages have been changed but no changesets were found. Run `changeset add` to resolve this error.
🦋  error If this change doesn't need a release, run `changeset add --empty`.

```

---

### Empty Changesets

If your change doesn’t require a new release — for example, documentation updates, typo fixes, or internal-only changes
— you can add an empty changeset:

```bash
yarn changeset add --empty

```

An empty changeset acts as an explicit acknowledgment that "these changes do not warrant a version bump." It allows CI
checks to pass while keeping release history accurate and intentional.

---

### Pre-release (Beta) Mode

In some cases, we need to publish **pre-release (beta)** versions before making a full stable release — for example, to
share early builds for testing or internal validation.

Changesets supports this workflow through **pre-release mode**, which allows versions such as:

```
1.0.0-beta.1
1.0.0-beta.2
1.0.0-beta.3
```

These are normal semantic versions, but with a pre-release tag (`-beta` in this case).  
This lets us release and iterate on beta versions before promoting the same code to a stable version.

---

#### Checking If You’re in Pre-release Mode

There isn’t a dedicated CLI command that explicitly reports “pre-release mode,” but you can easily verify it by
inspecting the `.changeset/pre.json` file:

```bash
cat .changeset/pre.json
```

- If the file exists and "mode" is set to "pre", the repository is currently in pre-release mode — new versions will be
  published with a prerelease tag (e.g., -beta). The prerelease tag can be confirmed by checking the contents of the
  "tag" attribute in the JSON.

- If the file exists and "mode" is set to "exit", prerelease mode has been exited, and the next release will be a normal
  stable release. The `.changeset/pre.json` file will remain until the next stable release is published, at which point
  it is automatically deleted.

- If the file does not exist, the repository is not in prerelease mode, and all releases are standard stable versions.

---

#### Entering Pre-release Mode

To start publishing beta versions, run:

```bash
yarn changeset pre enter beta
```

The final argument (beta in this case) defines the tag name used for prerelease versions — both for the version suffix
(e.g. `1.0.0-beta.1`) and for the package repository dist-tag. You can use any tag name such as alpha, rc, next, or
preview, depending on your release strategy.

> ⚠️ **Note**: You can only enter prerelease mode if the repository is not already in prerelease mode. If you try to run
> this command while already in prerelease mode, you’ll see an error like:

```
🦋  error `changeset pre enter` cannot be run when in pre mode
🦋  info If you're trying to exit pre mode, run `changeset pre exit`
```

In that case, you must exit pre-release mode first by following the instructions below, under the section _Exiting
Pre-release Mode_.

This command performs the following:

- Enables pre-release mode for the repository.

- Adds a `.changeset/pre.json` file which marks that the project is in pre-release state.

- Tells Changesets and the GitHub Action that all future version bumps should use the selected prerelease suffix (e.g.,
  -beta, -alpha, -rc).

- Keeps `.changeset` files after each release so that new beta versions can continue building on the same set of
  changes.

While in pre-release mode, when the Changesets GitHub Action runs, it will:

- Create or update the automated `chore: release` PR as usual.

- The GitHub Action will create or update the release PR with a title that includes the prerelease tag (e.g.,
  `chore: release (beta)`), indicating that the repository is in prerelease mode.

- Apply version bumps that include the pre-release tag (e.g., 1.3.0-beta.1 → 1.3.0-beta.2).

- Not remove any `.changeset` files after merging — they remain for future beta iterations.

- Publish new versions to the registry using the same tag name for both the version suffix and the npm dist-tag  
  (e.g., a prerelease entered with `beta` produces versions like `1.3.0-beta.1` published under the `beta` dist-tag).

This allows a continuous stream of beta versions without consuming your pending .changeset files.

---

#### Exiting Pre-release Mode

Once you are ready to move from a pre-release version to a stable release, run:

```bash
yarn changeset pre exit
```

This command:

- Updates `.changeset/pre.json` to set "mode": "exit", marking that prerelease mode has been exited.
- Stops generating further prerelease (-beta, -alpha, etc.) versions.
- Prepares the next release to be a normal stable release (no prerelease suffix).

What happens next (on the next stable release PR):

- The Changesets GitHub Action creates a standard `chore: release` PR with stable SemVer versions (e.g., 1.3.0 instead
  of 1.3.0-beta.3).

- The release PR title no longer includes the prerelease tag — it will simply be `chore: release`, indicating a normal
  stable release.

- All relevant `.changeset` files are consumed and removed as part of that PR.

- After the PR is merged and publish completes, `.changeset/pre.json` is deleted automatically  
  _(the file remains with `"mode": "exit"` until that stable release is merged)._

- Packages are published under the default latest dist-tag.

You can re-enter prerelease mode later (for example, starting a new beta, rc or next cycle) by following the section
_Entering Pre-release Mode_.

---

### Simulating the Release Process (Locally)

It can sometimes be helpful to preview what the automated release PR will look like — including version bumps and
generated changelogs — before the GitHub Action runs.

#### ⚠️ Important Notes

Before running any simulation commands, please read carefully:

- **Run on a clean working tree.**  
  Ensure there are no uncommitted changes before running. This command modifies multiple files (`package.json`,
  `CHANGELOG.md`, etc.).

- **Never commit or push these changes.**  
  The simulation is for **local inspection only** and should not be checked in.  
  The real version bumps and changelog updates are applied automatically by the GitHub Action when the release PR is
  created.

- After reviewing the output, you can safely revert your workspace:

  ```bash
  git reset --hard
  ```

### Running the Simulation

You can simulate the release process locally using:

```bash
yarn changeset:version
```

or directly with:

```bash
yarn changeset version
```

This command takes all pending .changeset files and applies the exact same logic that the Changesets GitHub Action would
during the creation of the automated `chore: release` PR. It will:

- Update version numbers in the affected package.json files.

- Update or generate the corresponding CHANGELOG.md entries.

- (In a monorepo) bump any dependent packages automatically.

This allows you to review exactly what will happen once the release PR is created — without pushing or triggering any
automated workflows.

> 💡 This is a great way to verify version bump behavior and generated changelogs before merging your PR — especially
> when working with multiple interdependent packages.

================
File: docs/decisions/0000-use-markdown-architectural-decision-records.md
================
# Use Markdown Architectural Decision Records

## Context and Problem Statement

We want to record architectural decisions made in this project. Which format and structure should these records follow?

## Considered Options

- [MADR](https://adr.github.io/madr/) 2.1.2 – The Markdown Architectural Decision Records
- [Michael Nygard's template](http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions) – The first
  incarnation of the term "ADR"
- [Sustainable Architectural Decisions](https://www.infoq.com/articles/sustainable-architectural-design-decisions) – The
  Y-Statements
- Other templates listed at <https://github.com/joelparkerhenderson/architecture_decision_record>
- Formless – No conventions for file format and structure

## Decision Outcome

Chosen option: "MADR 2.1.2", because

- Implicit assumptions should be made explicit. Design documentation is important to enable people understanding the
  decisions later on. See also
  [A rational design process: How and why to fake it](https://doi.org/10.1109/TSE.1986.6312940).
- The MADR format is lean and fits our development style.
- The MADR structure is comprehensible and facilitates usage & maintenance.
- The MADR project is vivid.
- Version 2.1.2 is the latest one available when starting to document ADRs.

================
File: docs/decisions/0001-bloc-wallet-state.md
================
# BLoC pattern for push-based notifications of state updates

_Note: This ADR was written with the original Scala implementation in mind, but the principles and decision rationale
remain relevant for the current TypeScript implementation._

Technical Story: [PM-5500](https://input-output.atlassian.net/browse/PM-5500)

## Context and Problem Statement

The objective of this change is to pay the tech debt from the decision taken on another change, so the context and
problem statement is still the same. See [ADR-0005](0005-wallet-balance-observable.md).

## Decision Drivers

The decision drivers are the same as in `ADR-0005`, except for time which is no longer a concern:

- Simplicity of implementation.
- How many third-party dependencies are needed.
- Reusability.
- Testability.

## Considered Options

The considered options are also the same as in `ADR-0005`, except for options **5** and **6** which, without time as a
decision driver, don't even qualify as options.

1. Use **monix-reactive** and implement a _Bloc_ pattern similar to what was done in Mocked Node.
2. Use **fs2** `Topic` to implement publish-subscriber.
3. Use **cats-effect** primitives to implement publish-subscriber.
4. Reuse Mocked Node's `bloc` module.

## Decision Outcome

Chosen option: **2**: "Use **fs2** `Topic` to implement publish-subscriber", because it satisfies all the decision
drivers.

### Positive Consequences

- We already have fs2 as a dependency so there's no extra third-party dependency to add.
- fs2 interacts nicely with cats and cats-effect, making this implementation flexible for future improvements.
- Implementation is fairly simple (less than 100 lines of code) and easy to test
- This is highly reusable because it works for Scala on JVM and Scala.js, and thus it's easy to package for Javascript
  and Typescript
- It's idiomatic for Scala developers

**Note:** In `ADR-0005` it was stated that _`Topic` is meant to be pull-based meaning that the producer (the one that
updates local state with transactions) would be blocked if consumers can't keep up_. But this isn't true with newer fs2
versions that expose a `Topic.subscribeUnbounded` method, with which we can implement a push-based API without
workarounds.

## Pros and Cons of the Options

Pros and cons also stay the same for the rest of the options as in `ADR-0005`.

## Links <!-- optional -->

- [ADR-0005](0005-wallet-balance-observable.md)

================
File: docs/decisions/0002-abstract-over-wallet.md
================
# Use Markdown Architectural Decision Records

- Status: accepted

_Note: This ADR was written with the original Scala implementation in mind, but the principles and decision rationale
remain relevant for the current TypeScript implementation._

## Context and Problem Statement

Traditional architecture with interfaces and services is not flexible when comes to designing different types of wallet
with different capabilities. Adding new type of wallet result with obligation to adapt all services to support it. We
want to avoid it and have a simple way to support new wallet types.

## Considered Options

- Traditional architecture with interfaces and services
- Abstraction over Wallet type and wallet capabilities described by type classes

## Decision Outcome

Chosen option: `Abstraction over Wallet type`, because it will gives us flexibility for quickly preparing new wallet
types.

### Positive Consequences

- Services are abstracted over wallet type - no need to adapt them to different wallet types
- Adding new wallet by just implementing its data container and capability type classes

### Negative Consequences

- Higher entry threshold than traditional design
- Services are abstracted over wallet type - operations on the wallet are not available from scratch
- Possibility of necessary adoption of future typescript code due to usage of implicit arguments by wallet builder
  (wallet as a library)

### Example

New approach

Visible characteristics:

- Wallet is only a container for data
- Capabilities implementations can be instantiated and tested separately
- Capabilities implementations are provided to service implicitly by compiler

```scala
trait BlockProcessing[Wallet] {
  def applyBlock(wallet: Wallet, block: Block): Wallet
}

case class SimpleWallet private (state: LocalState)

object SimpleWallet {
  implicit val blockProcessing: BlockProcessing[SimpleWallet] = new BlockProcessing[SimpleWallet] {
    override def applyBlock(wallet: SimpleWallet, block: Block): SimpleWallet = SimpleWallet(state.apply(block))
  }
}

object SyncService {
  def handleBlocks[W: BlockProcessing](wallet: W, blocks: Stream[Block]): Stream[W] = {
    blocks.scanLeft(wallet) {
      (wallet, block) => implicitly[BlockProcessing[W]].applyBlock(wallet, block)
    }
  }
}
```

Traditional approach

Visible characteristics:

- Wallet is a container and service
- Composing more capabilities requires creating one super wallet-service implementation
- Capabilities implementations are provided to service explicitly

```scala
trait BlockProcessing[Wallet] {
  def applyBlock(block: Block): Wallet
}

case class SimpleWallet private (state: LocalState) extends BlockProcessing[SimpleWallet] {
  override def applyBlock(block: Block): SimpleWallet = SimpleWallet(state.apply(block))
}

class SyncService[W <: BlockProcessing[W]](wallet: W) {
  def handleBlocks(blocks: Stream[Block]): Stream[W] = {
    blocks.scanLeft(wallet) {
      (wallet, block) => wallet.applyBlock(block)
    }
  }
}
```

================
File: docs/decisions/index.md
================
# Architectural Decision Log

This log lists the architectural decisions for Midnight Wallet.

<!--
Regenerate the content by running the following from the root :

"adr-log -i -d docs/decisions -e template.md"

You can install the required package globally by running "npm install -g adr-log"
-->

<!-- adrlog -->

- [ADR-0000](0000-use-markdown-architectural-decision-records.md) - Use Markdown Architectural Decision Records
- [ADR-0001](0001-bloc-wallet-state.md) - BLoC pattern for push-based notifications of state updates
- [ADR-0002](0002-abstract-over-wallet.md) - Use Markdown Architectural Decision Records
- [ADR-0003](0003-descaling-wallet.md) - Descaling Wallet
- [ADR-0004](0004-use-effect.md) - Use [Effect](https://effect.website/)
- [ADR-0005](0005-using-tsc-to-build-projects.md) - Use TSC to build projects
- [ADR-0006](0006-structure-for-flexibility-and-robustness.md) - Structure for flexibility and robustness with Variants,
  Builders and Facades

<!-- adrlogstop -->

For new ADRs, please use [template.md](template.md) as basis. More information on MADR is available at
<https://adr.github.io/madr/>. General information about architectural decision records is available at
<https://adr.github.io/>.

================
File: docs/decisions/template.md
================
# [short title of solved problem and solution]

- Status: [proposed | rejected | accepted | deprecated | … | superseded by [ADR-0005](0005-example.md)]
  <!-- optional -->
- Deciders: [list everyone involved in the decision] <!-- optional -->
- Date: [YYYY-MM-DD when the decision was last updated] <!-- optional -->

Technical Story: [description | ticket/issue URL] <!-- optional -->

## Context and Problem Statement

[Describe the context and problem statement, e.g., in free form using two to three sentences. You may want to articulate
the problem in form of a question.]

## Decision Drivers <!-- optional -->

- [driver 1, e.g., a force, facing concern, …]
- [driver 2, e.g., a force, facing concern, …]
- … <!-- numbers of drivers can vary -->

## Considered Options

- [option 1]
- [option 2]
- [option 3]
- … <!-- numbers of options can vary -->

## Decision Outcome

Chosen option: "[option 1]", because [justification. e.g., only option, which meets k.o. criterion decision driver |
which resolves force force | … | comes out best (see below)].

### Positive Consequences <!-- optional -->

- [e.g., improvement of quality attribute satisfaction, follow-up decisions required, …]
- …

### Negative Consequences <!-- optional -->

- [e.g., compromising quality attribute, follow-up decisions required, …]
- …

## Pros and Cons of the Options <!-- optional -->

### [option 1]

[example | description | pointer to more information | …] <!-- optional -->

- Good, because [argument a]
- Good, because [argument b]
- Bad, because [argument c]
- … <!-- numbers of pros and cons can vary -->

### [option 2]

[example | description | pointer to more information | …] <!-- optional -->

- Good, because [argument a]
- Good, because [argument b]
- Bad, because [argument c]
- … <!-- numbers of pros and cons can vary -->

### [option 3]

[example | description | pointer to more information | …] <!-- optional -->

- Good, because [argument a]
- Good, because [argument b]
- Bad, because [argument c]
- … <!-- numbers of pros and cons can vary -->

## Links <!-- optional -->

- [Link type] [Link to ADR] <!-- example: Refined by [ADR-0005](0005-example.md) -->
- … <!-- numbers of links can vary -->

================
File: docs/Design.md
================
# Wallet SDK Design

This document is compilation of the design of the Wallet SDK. Some parts of it are captured (through
[ADRs](./decisions/)), some (high-level) are captured in this
[IcePanel diagram](https://app.icepanel.io/landscapes/yERCUolKk91aYF1pzsql/versions/latest/diagrams/editor?diagram=JwWBu6RYGg&model=onccvco5c4p&overlay_tab=tags&x1=-1463.3&y1=-830.7&x2=2295.3&y2=1129.3),
and some are more ephemeral.

## High-level structure

Midnight implements 3 kinds of tokens/resources, which wallet needs to be aware of:

- Night and other unshielded tokens
- Dust for paying fees
- Custom shielded tokens

Each of them uses a different address and way of proving credentials to use the tokens/resources, as well as each of
them needs a completely different state to operate on. For that reason, Midnight Wallet SDK is conceptually split into 4
components:

- Unshielded wallet
- Dust wallet
- Shielded wallet
- Wallet Facade

The diagram belows shows their relationships and, when selecting a component, provides more context to it. Its original
is created in IcePanel and can be found at https://s.icepanel.io/qSrUvJk8tEUSRP/iPN0

![](./wallet-component-diagram.svg)

## Single wallet structure

Each of the wallets follows the same structure - front facing adapter providing API compatible with the Wallet Facade,
variant-based specific implementation(s) of the wallet, Runtime orchestrating the variants and Wallet Builder allowing
to register all the variants.

```mermaid
classDiagram

note for AWalletFacadeAPI "API allowing the facade to use wallet"
namespace Facade {
    class WalletFacade

    class AWalletFacadeAPI {
        <<interface>>
    }

    class FacadeAPIAdapter
}

note for AWallet "Specific implementation of a wallet
(e.g. shielded one).Offers a domain-specific API across
all variants it comprises. Each variant is an independent
implementation for specific set of protocol versions"

note for AWalletPolyFunction "Inferred type for dispatching
between multiple variant implementations
without knowing which one is active in the runtime.
Essentially a version of the visitor pattern"

namespace Wallet {
    class AWallet

    class AWalletVariant1

    class AWalletVariant2

    class AWalletPolyFunction~T~ {
        callVariant1(variant: AWalletVariant1) T
        callVariant2(variant: AWalletVariant2) T
    }
}

note for WalletRuntime "Generic orchestrator of variants.
The exact type of AWalletPolyFunction
is inferred based on variants held"

namespace Runtime {
    class WalletBase {
        <<abstract>>
        Observable<State> state
        #dispatch~T~(fn: AWalletPolyFunction~T~) T


    }

    class WalletRuntime {
        dispatch~T~(fn: AWalletPolyFunction~T~) T
    }

    class WalletBuilder {
        addVariant(protocolVersion: Int, variant: RuntimeVariant)
    }

    class RuntimeVariant {
        <<interface>>
        +String tag
        startSync() Stream~StateChange~
        migrateFromPrevious(previousState: PreviousVariantState) OwnVariantState
    }
}

AWalletFacadeAPI <|.. FacadeAPIAdapter
WalletFacade o-- AWalletFacadeAPI
FacadeAPIAdapter o-- AWallet
WalletBase <|-- AWallet
WalletBase o-- WalletRuntime
WalletBuilder --> WalletBase : builds instance with specified variants
RuntimeVariant  <|..  AWalletVariant1
RuntimeVariant  <|..  AWalletVariant2
WalletRuntime o-- "n" RuntimeVariant : manages lifecycle of
AWallet o-- "n" AWalletPolyFunction : implements its API with implementations of
```

Structure like this has many benefits:

- it enables seamless wallet state migration in case of hard-forks using a uniform framework
- each variant can be very independent implementation (even coming from a separate package), with a completely different
  API (which is important for WASM-based libraries produced by wasm-bindgen)
- unnecessary code can be decomissioned
- code for upcoming hard-forks can be implemented and tested in isolation, before integrating with the facades
- users of the SDK can replace some variants with their own implementation if really needed

## Single Variant structure

Even though the framework established around Runtime does not enforce much of a structure, to bring consistency,
predictability and robustness to a variant implementation, structure as presented below is desired, it is fully
implemented with the shielded wallet default variant:

```mermaid
classDiagram

class State

namespace Runtime {
    class RuntimeVariant {
        <<interface>>
        +String tag
        startSync() Stream~StateChange~
        migrateFromPrevious(previousState: PreviousVariantState) OwnVariantState
    }
}

namespace Effect {
    class SubscriptionRef
}

note for CapabilityA "This is a shared capability interface.
E.g. something as foundational as balances"
namespace CommonCapabilities {
    class CapabilityA~State~ {
        <<interface>>
        doA(state: State, aParam: AParam) State
    }

    class ServiceA {
        <<interface>>
        provideAParam() Effect~AParam~
    }
}

note for CapabilityC "This is a variant-specific
capability declaration"
namespace AVariant {
    class CapabilityC {
        <<interface>>
        doC(state: State, cParam: CParam) StateAndCResult
    }

    class ServiceB {
        <<interface>>
        streamB() Stream<BItem>
    }

    class CapabilityAImpl {

    }

    class ServiceAImpl {

    }

    class ServiceBImpl {

    }

    class CapabilityCImpl {

    }

    class TheVariant

    class AVariantBuilder {
        withA(service: ServiceA, capability: CapabilityA) VariantBuilder
        withB(service: ServiceB) VariantBuilder
        withC(capability: CapabilityC) VariantBuilder
    }

    class VariantDomainAPI {
        <<interface>>
    }
}

RuntimeVariant <|.. TheVariant
AVariantBuilder o-- CapabilityA
AVariantBuilder o-- ServiceA
AVariantBuilder o-- ServiceB
AVariantBuilder o-- CapabilityC
AVariantBuilder --> TheVariant : builds and configures instance of
TheVariant o-- CapabilityA
TheVariant o-- ServiceA
TheVariant o-- ServiceB
TheVariant o-- CapabilityC
TheVariant o-- SubscriptionRef
VariantDomainAPI <|.. TheVariant

CapabilityA <|.. CapabilityAImpl
ServiceA <|.. ServiceAImpl
ServiceB <|.. ServiceBImpl
CapabilityC <|.. CapabilityCImpl

CapabilityAImpl --> State
CapabilityCImpl --> State

SubscriptionRef o-- State
```

This structure emerged from a couple of decisions taken together:

1. To follow a Bloc-like API. That is one, where the state is a stream that can be subscribed to, and can only be
   modified in a controlled and encapsulated way - through dedicated methods in our case (originally BLoC pattern
   accepts events as the only input, but in JS world it would make it look like Redux, which is not necessarily a
   feature).
2. To separate state operations from synchronization and atomicity concerns
3. To leverage `Effect` library and immutability to the extent possible

### State type

This is the core domain datatype of wallet variant and the state type that the Runtime attaches with a variant. It needs
to maintain its invariants at all times, even in the presence of multiple concurrent writers (like sync mechanism and
user requests related to transactions). It also should enable testing most of the wallet behavior on a unit level to
provide a quick feedback loop to the developer. It also has a special meaning in the context of the Runtime. This state
needs to be always complete and enable restoring wallet variant from it. So it either needs to contain all data needed
for operation or it needs to contain proper links to resolve all the data. Alternatively, a variant may use a different
type internally. In such case a bi-directional mapping is needed between the state type present in variant's declaration
(and used by Runtime) and the one used internally.

### Services and capabilities

Many aspects of wallet software functionality can be compartmentalized into feature-specific interfaces. Also, depending
on context, some of them might or might not be needed in certain situation at all. For that reason all wallet variant
functionality is meant to be separated into _Services_ and _Capabilities_.

A _Service_ is a possibly asynchronous or side-effecting object, giving access to some data or performing some
additional processing steps.

A _Capability_ is a purely functional extension to _State_ interface, which focuses on specific functionality.

For example:

- for synchronization there is both service and a capability - service receives some initial state to know how to start
  and returns a stream of updates, while capability has function, which takes current state, an update and returns new
  state with the update applied
- for transacting there is a capability, which receives current state, details of a request regarding transaction to be
  created, and returns ready-to-finalize transaction recipe together with new state (with, e.g. coins/UTxOs booked for
  the transaction)
- for finalization/proving, there is a service only, which takes a transaction recipe and turns that into a ready
  transaction
- for coins, there is a capability only, which lists available coins, as well as computes different kinds of balances
  (available, total, pending)

### Summary and code example

Immutability, combined with allowing only pure functional, synchronous operations on the state, covers a lot of what is
required to implement a wallet robustly. It is the same foundation that enables e.g. Redux or the Elm architecture. But
there needs to be a way to hold the state itself and to update it in relation to side-effecting operations. This is
achieved by leveraging Effect's `SubscriptionRef` and implementing a Bloc-like API. Below is a simplified code sample,
though this exact structure is implemented fully for the initial shielded wallet variant.

```ts
// Foo.ts - some foo functionality, which comprises both a service and a capability
class AFoo {}
class FooId {}
class SomeFooData {}

// By default the state type is abstracted over in the interface, so that same API can apply to different kinds of wallets/variants
interface FooService<TState> {
    produceFooData(state: TState): Effect<SomeFooData>;
}

interface FooCapability<TState> {
    addFoo(state: TState, foo: AFoo, data: SomeFooData): TState;
    // This operation can fail, thus it returns either to communicate
    // that together with exact type of possible error
    somePossiblyFailing(state: TState, id: FooId): Either<TState, FooError>;
}

// For services and capabilities it does not make much of a difference whether they are implemented as classes or not
class DefaultFooService implements FooService<VariantState> {
    produceFooData(state: VariantState): Effect<SomeFooData> {
        /* ... */
    }
}

class DefaultFooCapability implements FooCapability<VariantState> {
    addFoo(state: VariantState, foo: AFoo, data: SomeFooData): VariantState {
        /* ... */
    }
}

// VariantState.ts - the variant state, usually implemented using following pattern
// It can leverage e.g. branded types for better encapsulation
// An alternative in form of a class is fine, but implementing immutability with
// classes is cumbersome in TS, using Effect's Data can help here a bit
type VariantState = Readonly<{
    foos: Foo[];
}>;
// Preferably it implements the basic operations, so that capabilities have something to build on top of
const VariantState = {
    addFoo: (state: VariantState, newFoo: Foo): VariantState => { /* ... */};
    maybeRemove(state: VariantState, id: FooId): Either<VariantState, VariantError> => { /* ... */ };
};

// Variant.ts - the variant, gathering everything together
class Variant {
  readonly state: Stream.Stream<VariantState>;
  readonly #ref: SubscriptionRef<VariantState>;
  readonly foo: {service: FooService<VariantState>, capability: FooCapability<VariantState>};

  constructor(ref: SubscriptionRef<VariantState>, foo: {service: FooService<VariantState>, capability: FooCapability<VariantState>}) {
    this.#ref = ref;
    this.state = SubscriptionRef.changes(ref);
    this.foo = foo;
  }

  addFoo(foo: Foo): Effect<void> {
    return SubscriptionRef.updateEffect(this.#ref, (state) => {
        return pipe(
            this.foo.service.produceFooData(state),
            Effect.map(fooData => this.foo.capability.addFoo(state, foo, fooData)),
        );
    });
  }

  somePossiblyFailing(fooId: FooId): Effect<void, VariantError> {
    return SubscriptionRef.updateEffect(this.#ref, (state) => {
        return this.foo.capability.somePossiblyFailing(state, fooId).pipe(
            Effect.fromEither
        )
    })
  }
}

// VariantBuilder.ts - builder of the variant; it can be very simplified, just to meet the requirements of the Runtime, as well as a fully-fledged, with high degree of a customization available
class VariantBuilder {
    #foo: {service: FooService<VariantState>, capability: FooCapability<VariantState>};

    withFoo(service: FooService<VariantState>, capability: FooCapability<VariantState>) {
        this.#foo = {service, capability};
    }

    build() {
        const ref = makeRef();
        return new Variant(ref, this.#foo);
    }
}
```

## Links and references

- [Impureim sandwich](https://blog.ploeh.dk/2020/03/02/impureim-sandwich/) - on a functional design
- [BLoC Architecture](https://dev.to/wednesdaysol/guide-to-implementing-bloc-architecture-in-flutter-3j79) - on BLoC
  architecture.
- [What is the BLoc pattern?](https://www.flutterclutter.dev/flutter/basics/what-is-the-bloc-pattern/2021/2084/) - one
  of the original documents on BLoC
- The approach for state management does remind an actor model to some extent (state is managed through a dedicated
  component, all updates are serialized into a single sequence), this series of posts seems to lay out well the 'whys'
  and 'hows': [Thinking in Actors - Part 1](https://jeremycarterau.substack.com/p/thinking-in-actors-part-1),
  [Thinking in Actors - Part 2](https://jeremycarterau.substack.com/p/thinking-in-actors-part-2),
  [Thinking in Actors - Part 3](https://jeremycarterau.substack.com/p/thinking-in-actors-part-3)

================
File: infra/compose/docker-compose-remote-dynamic.yml
================
services:
  proof-server:
    image: 'ghcr.io/midnight-ntwrk/proof-server:6.1.0-alpha.5'
    container_name: proof-server_$TESTCONTAINERS_UID
    cap_drop:
      - ALL
    security_opt:
      - no-new-privileges:true
    ports:
      - '127.0.0.1::6300'
    environment:
      RUST_BACKTRACE: 'full'
      EXTRA_ARGS: -v
    healthcheck:
      test: ['CMD', 'curl', '-f', 'http://localhost:6300/version']
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

================
File: packages/abstractions/CHANGELOG.md
================
# @midnight-ntwrk/wallet-sdk-abstractions

## 1.0.0-beta.9

### Patch Changes

- a06ccf3: Adds missing main property in the package.json file for the abstractions package

## 1.0.0-beta.8

### Minor Changes

- 646c8df: chore: add network id for qanet

### Patch Changes

- 1db4280: chore: bump ledger to version 6.1.0-beta.5

## 1.0.0-beta.7

### Patch Changes

- 2a0d132: chore: force re-release after workspace failure

## 1.0.0-beta.6

### Patch Changes

- ae22baf: chore: initialize baseline release after introducing Changesets

================
File: packages/capabilities/README.md
================
# Midnight Wallet SDK Capabilities

This package provides a range of capabilities used only internally by the wallet when implementing
`@midnight-ntwrk/wallet-api`. The version of the package is focused only in transaction balancing.

================
File: packages/docs-snippets/src/snippets/balancing.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { generateRandomSeed } from '@midnight-ntwrk/wallet-sdk-hd';
import { Buffer } from 'buffer';
import * as rx from 'rxjs';
import { initWalletWithSeed } from '../utils.ts';

const sender = await initWalletWithSeed(
  Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex'),
);
const receiver = await initWalletWithSeed(Buffer.from(generateRandomSeed()));

const initialSenderState = await rx.firstValueFrom(sender.wallet.state().pipe(rx.filter((s) => s.isSynced)));
const initialBalance = initialSenderState.unshielded.balances[ledger.nativeToken().raw] ?? 0n;

const makeTransactionBlueprint = () => {
  const unshieldedOffer = ledger.UnshieldedOffer.new(
    [],
    [
      {
        value: initialBalance,
        owner: receiver.unshieldedKeystore.getAddress(),
        type: ledger.nativeToken().raw,
      },
    ],
    [],
  );
  const intent = ledger.Intent.new(new Date(Date.now() + 30 * 60 * 1000));
  intent.fallibleUnshieldedOffer = unshieldedOffer;
  return ledger.Transaction.fromParts('undeployed', undefined, undefined, intent);
};

await sender.wallet
  .balanceTransaction(
    sender.shieldedSecretKeys,
    sender.dustSecretKey,
    makeTransactionBlueprint(),
    new Date(Date.now() + 30 * 60 * 1000),
  )
  .then((recipe) => {
    let tx: ledger.UnprovenTransaction;
    switch (recipe.type) {
      case 'TransactionToProve':
        tx = recipe.transaction;
        break;
      case 'BalanceTransactionToProve':
        throw new Error('Unexpected recipe type');
      default:
        throw new Error('Unexpected recipe type');
    }
    return sender.wallet.signTransaction(tx, (payload) => sender.unshieldedKeystore.signData(payload));
  })
  .then((tx) => sender.wallet.finalizeTransaction({ type: 'TransactionToProve', transaction: tx }))
  .then((finalizedTransaction) => sender.wallet.submitTransaction(finalizedTransaction));

const finalSenderState = await rx.firstValueFrom(sender.wallet.state().pipe(rx.filter((s) => s.isSynced)));
const receiverState = await rx.firstValueFrom(
  receiver.wallet.state().pipe(
    rx.filter((s) => s.isSynced),
    rx.filter((s) => (s.unshielded.balances[ledger.nativeToken().raw] ?? 0n) !== 0n),
  ),
);

console.log('Unshielded transfer by balancing completed');
console.log(
  'Did sender send all its Night?',
  (finalSenderState.unshielded.balances[ledger.nativeToken().raw] ?? 0n) === 0n,
);
console.log(
  'Did receiver receive all the Night?',
  (receiverState.unshielded.balances[ledger.nativeToken().raw] ?? 0n) === initialBalance,
);

await receiver.wallet.stop();
await sender.wallet.stop();

================
File: packages/docs-snippets/src/snippets/combined-transfer.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { initWalletWithSeed } from '../utils.ts';
import * as rx from 'rxjs';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Buffer } from 'buffer';
import { generateRandomSeed } from '@midnight-ntwrk/wallet-sdk-hd';
import { MidnightBech32m } from '@midnight-ntwrk/wallet-sdk-address-format';

const sender = await initWalletWithSeed(
  Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex'),
);
const receiver = await initWalletWithSeed(Buffer.from(generateRandomSeed()));

await rx.firstValueFrom(sender.wallet.state().pipe(rx.filter((s) => s.isSynced)));

const receiverAddress = await rx.firstValueFrom(
  receiver.wallet.state().pipe(
    rx.filter((s) => s.isSynced),
    rx.map((s) => MidnightBech32m.encode('undeployed', s.shielded.address).toString()),
  ),
);

await sender.wallet
  .transferTransaction(
    sender.shieldedSecretKeys,
    sender.dustSecretKey,
    [
      {
        type: 'unshielded',
        outputs: [
          {
            amount: 1_000_000n,
            receiverAddress: receiver.unshieldedKeystore.getBech32Address().toString(),
            type: ledger.unshieldedToken().raw,
          },
        ],
      },
      {
        type: 'shielded',
        outputs: [
          {
            amount: 1_000_000n,
            receiverAddress,
            type: ledger.shieldedToken().raw,
          },
        ],
      },
    ],
    new Date(Date.now() + 30 * 60 * 1000),
  )
  .then((recipe) =>
    sender.wallet.signTransaction(recipe.transaction, (payload) => sender.unshieldedKeystore.signData(payload)),
  )
  .then((tx) => sender.wallet.finalizeTransaction({ type: 'TransactionToProve', transaction: tx }))
  .then((finalizedTransaction) => sender.wallet.submitTransaction(finalizedTransaction));

const receiverState = await rx.firstValueFrom(
  receiver.wallet.state().pipe(
    rx.filter((s) => s.isSynced),
    rx.filter((s) => {
      const nightBalance = s.unshielded.balances[ledger.unshieldedToken().raw] ?? 0n;
      return nightBalance > 0n;
    }),
  ),
);

console.log('Transfer completed;');
console.log('  Night balance:', receiverState.unshielded.balances[ledger.unshieldedToken().raw] ?? 0n);
console.log('  shielded token balance:', receiverState.shielded.balances[ledger.shieldedToken().raw] ?? 0n);

await receiver.wallet.stop();
await sender.wallet.stop();

================
File: packages/docs-snippets/src/snippets/designation.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// #region setup
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Buffer } from 'buffer';
import * as rx from 'rxjs';
import { initWalletWithSeed } from '../utils.ts';
import { generateRandomSeed } from '@midnight-ntwrk/wallet-sdk-hd';

const sender = await initWalletWithSeed(
  Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex'),
);
const { wallet, unshieldedKeystore } = await initWalletWithSeed(Buffer.from(generateRandomSeed()));

await rx.firstValueFrom(sender.wallet.state().pipe(rx.filter((s) => s.isSynced)));

await sender.wallet
  .transferTransaction(
    sender.shieldedSecretKeys,
    sender.dustSecretKey,
    [
      {
        type: 'unshielded',
        outputs: [
          {
            amount: 500_000_000_000_000n,
            receiverAddress: unshieldedKeystore.getBech32Address().toString(),
            type: ledger.nativeToken().raw,
          },
        ],
      },
    ],
    new Date(Date.now() + 30 * 60 * 1000),
  )
  .then((recipe) =>
    sender.wallet.signTransaction(recipe.transaction, (payload) => sender.unshieldedKeystore.signData(payload)),
  )
  .then((tx) => sender.wallet.finalizeTransaction({ type: 'TransactionToProve', transaction: tx }))
  .then((finalizedTransaction) => sender.wallet.submitTransaction(finalizedTransaction))
  .then(() =>
    rx.firstValueFrom(
      wallet.state().pipe(
        rx.filter((s) => s.isSynced),
        rx.filter((s) => {
          const nightBalance = s.unshielded.balances[ledger.nativeToken().raw] ?? 0n;
          return nightBalance > 0n;
        }),
      ),
    ),
  );

await sender.wallet.stop();
await new Promise((resolve) => setTimeout(resolve, 1 * 60 * 1000));

// #endregion

const stateBefore = await rx.firstValueFrom(wallet.state().pipe(rx.filter((s) => s.isSynced)));
console.log('Generating dust before designation:', stateBefore.dust.availableCoins.length > 0);

await wallet
  .registerNightUtxosForDustGeneration(
    stateBefore.unshielded.availableCoins,
    unshieldedKeystore.getPublicKey(),
    (payload) => unshieldedKeystore.signData(payload),
  )
  .then((recipe) => wallet.finalizeTransaction(recipe))
  .then((finalizedTransaction) => wallet.submitTransaction(finalizedTransaction));

const stateAfter = await rx.firstValueFrom(
  wallet.state().pipe(
    rx.filter((s) => s.isSynced),
    rx.filter((s) => s.dust.availableCoins.length > 0),
  ),
);

console.log('Generating dust after designation:', stateAfter.dust.availableCoins.length > 0);

await wallet.stop();

================
File: packages/docs-snippets/src/snippets/shielded-transfer.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { initWalletWithSeed } from '../utils.ts';
import * as rx from 'rxjs';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Buffer } from 'buffer';
import { MidnightBech32m } from '@midnight-ntwrk/wallet-sdk-address-format';
import { generateRandomSeed } from '@midnight-ntwrk/wallet-sdk-hd';

const sender = await initWalletWithSeed(
  Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex'),
);
const receiver = await initWalletWithSeed(Buffer.from(generateRandomSeed()));

await rx.firstValueFrom(sender.wallet.state().pipe(rx.filter((s) => s.isSynced)));

const receiverAddress = await rx.firstValueFrom(
  receiver.wallet.state().pipe(
    rx.filter((s) => s.isSynced),
    rx.map((s) => MidnightBech32m.encode('undeployed', s.shielded.address).toString()),
  ),
);

await sender.wallet
  .transferTransaction(
    sender.shieldedSecretKeys,
    sender.dustSecretKey,
    [
      {
        type: 'shielded',
        outputs: [
          {
            amount: 1_000_000n,
            receiverAddress,
            type: ledger.shieldedToken().raw,
          },
        ],
      },
    ],
    new Date(Date.now() + 30 * 60 * 1000),
  )
  .then((recipe) =>
    sender.wallet.signTransaction(recipe.transaction, (payload) => sender.unshieldedKeystore.signData(payload)),
  )
  .then((tx) => sender.wallet.finalizeTransaction({ type: 'TransactionToProve', transaction: tx }))
  .then((finalizedTransaction) => sender.wallet.submitTransaction(finalizedTransaction));

const receiverState = await rx.firstValueFrom(
  receiver.wallet.state().pipe(
    rx.filter((s) => s.isSynced),
    rx.filter((s) => s.shielded.availableCoins.length > 0),
  ),
);

console.log(
  'Shielded transfer completed; shielded balance:',
  receiverState.shielded.balances[ledger.shieldedToken().raw] ?? 0n,
);

await receiver.wallet.stop();
await sender.wallet.stop();

================
File: packages/docs-snippets/src/snippets/unshielded-transfer.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { initWalletWithSeed } from '../utils.ts';
import * as rx from 'rxjs';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Buffer } from 'buffer';
import { generateRandomSeed } from '@midnight-ntwrk/wallet-sdk-hd';

const sender = await initWalletWithSeed(
  Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex'),
);
const receiver = await initWalletWithSeed(Buffer.from(generateRandomSeed()));

await rx.firstValueFrom(sender.wallet.state().pipe(rx.filter((s) => s.isSynced)));

await sender.wallet
  .transferTransaction(
    sender.shieldedSecretKeys,
    sender.dustSecretKey,
    [
      {
        type: 'unshielded',
        outputs: [
          {
            amount: 1_000_000n,
            receiverAddress: receiver.unshieldedKeystore.getBech32Address().toString(),
            type: ledger.unshieldedToken().raw,
          },
        ],
      },
    ],
    new Date(Date.now() + 30 * 60 * 1000),
  )
  .then((recipe) =>
    sender.wallet.signTransaction(recipe.transaction, (payload) => sender.unshieldedKeystore.signData(payload)),
  )
  .then((tx) => sender.wallet.finalizeTransaction({ type: 'TransactionToProve', transaction: tx }))
  .then((finalizedTransaction) => sender.wallet.submitTransaction(finalizedTransaction));

const receiverState = await rx.firstValueFrom(
  receiver.wallet.state().pipe(
    rx.filter((s) => s.isSynced),
    rx.filter((s) => {
      const nightBalance = s.unshielded.balances[ledger.unshieldedToken().raw] ?? 0n;
      return nightBalance > 0n;
    }),
  ),
);

console.log(
  'Unshielded transfer completed; night balance:',
  receiverState.unshielded.balances[ledger.unshieldedToken().raw] ?? 0n,
);

await receiver.wallet.stop();
await sender.wallet.stop();

================
File: packages/docs-snippets/src/test/__snapshots__/test-snippets.test.ts.snap
================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Snippet outputs > with network > should output the correct result for 'balancing' 1`] = `
[
  "Unshielded transfer by balancing completed
Did sender send all its Night? false
Did receiver receive all the Night? true
",
]
`;

exports[`Snippet outputs > with network > should output the correct result for 'combined-transfer' 1`] = `
[
  "Transfer completed;
  Night balance: 1000000n
  shielded token balance: 1000000n
",
]
`;

exports[`Snippet outputs > with network > should output the correct result for 'designation' 1`] = `
[
  "Generating dust before designation: false
Generating dust after designation: true
",
]
`;

exports[`Snippet outputs > with network > should output the correct result for 'initialization' 1`] = `
[
  "Synced state:
{
  shielded: {
    balances: {
      '0000000000000000000000000000000000000000000000000000000000000000': 2500000000000000n,
      '0000000000000000000000000000000000000000000000000000000000000001': 500000000000000n,
      '0000000000000000000000000000000000000000000000000000000000000002': 500000000000000n
    },
    availableCoins: [
      {
        coin: {
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          nonce: '1798ac8ed7e701e1f01a083ba4375ae2d9ac50c12f15c01358dc56ad38a95303',
          value: 500000000000000n,
          mt_index: 27n
        },
        commitment: 'ffec3ad9e58b3764608efdecfcb3fabeb981859e596544bb04e994449bc58d28',
        nullifier: '111d3ae56d92966e7d39f25c087f735ee6a98d4688a12b66051bb1f59b51475f'
      },
      {
        coin: {
          type: '0000000000000000000000000000000000000000000000000000000000000001',
          nonce: '25bae4bf1f5348d9f18bd67de5a7ed1850a7bc9643d09911ed19c2fe9188b56f',
          value: 500000000000000n,
          mt_index: 1n
        },
        commitment: '091553393243a7279f6af3ab943448f0c8278bcccb7418519a2e99fd45d8da0d',
        nullifier: '356a80e0b6ee6e2194320d796ae65aeadd241449cabc55c8fd7cd76d15ff814e'
      },
      {
        coin: {
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          nonce: 'dc5d3f068d5e57fe4482ec9f18206db4701f761c80d2ab1cd627eecb4cefcbac',
          value: 500000000000000n,
          mt_index: 9n
        },
        commitment: '52d84fac4ad72f5878d919738cf437d0553b523b817d8f783cc32f5d592a8b60',
        nullifier: '3ff4e009587042ec0ec68a2c700e6f6e636edbda2a972d0cba4a5d66032869ea'
      },
      {
        coin: {
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          nonce: 'fa3a6316f5f1467106460093649f736a24dad01bd82dc652ce209269bcfa15cb',
          value: 500000000000000n,
          mt_index: 0n
        },
        commitment: '023e970a3813ab8fa4202d1159fe7068af63dc9b7d7106650c495655ab8726af',
        nullifier: '595e34df4645095d4b4f23157ded89310d62b3b165cf6774b4f57e7f7fd153a3'
      },
      {
        coin: {
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          nonce: '06014a5577a0e6332600d5d2e8aa8c39a2ea87be69c8f397ac3bb2cacb9f1126',
          value: 500000000000000n,
          mt_index: 23n
        },
        commitment: 'e4b0e7c9a9b36dae46ebed7322c5780e64eace60c1351eb85b671d1870620402',
        nullifier: 'b4ef5c785e72c3420611cb1b617482284c134a71b1aaf57d228463d658eae00e'
      },
      {
        coin: {
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          nonce: '5e5943683d95c237825538e20f287975fbf25020f21a7ef0fae8bef8517fbbff',
          value: 500000000000000n,
          mt_index: 18n
        },
        commitment: '9f15cf932d1f31a7c9c8fbb030d1c7e11e6a36972dcccb9494032d470963a4bd',
        nullifier: 'df667c741d2d74f8c11cd9f685fc95ed8aae235c0f7b75dfc69bbca10c8e9683'
      },
      {
        coin: {
          type: '0000000000000000000000000000000000000000000000000000000000000002',
          nonce: 'cdec51cff753c64b32fc4f566c113497af9d9330e98200a48e3ed01f955be071',
          value: 500000000000000n,
          mt_index: 11n
        },
        commitment: '5a60840cc2465ecd227f128f2c9bc55072ef8a6c038b4d19935dbc173ac0b6d5',
        nullifier: 'f5c6444c7ef771b2ded6f2b0bd5e47d87305e76b88c1534894b0615982e3d268'
      }
    ],
    pendingCoins: [],
    totalCoins: [
      {
        coin: {
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          nonce: '1798ac8ed7e701e1f01a083ba4375ae2d9ac50c12f15c01358dc56ad38a95303',
          value: 500000000000000n,
          mt_index: 27n
        },
        commitment: 'ffec3ad9e58b3764608efdecfcb3fabeb981859e596544bb04e994449bc58d28',
        nullifier: '111d3ae56d92966e7d39f25c087f735ee6a98d4688a12b66051bb1f59b51475f'
      },
      {
        coin: {
          type: '0000000000000000000000000000000000000000000000000000000000000001',
          nonce: '25bae4bf1f5348d9f18bd67de5a7ed1850a7bc9643d09911ed19c2fe9188b56f',
          value: 500000000000000n,
          mt_index: 1n
        },
        commitment: '091553393243a7279f6af3ab943448f0c8278bcccb7418519a2e99fd45d8da0d',
        nullifier: '356a80e0b6ee6e2194320d796ae65aeadd241449cabc55c8fd7cd76d15ff814e'
      },
      {
        coin: {
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          nonce: 'dc5d3f068d5e57fe4482ec9f18206db4701f761c80d2ab1cd627eecb4cefcbac',
          value: 500000000000000n,
          mt_index: 9n
        },
        commitment: '52d84fac4ad72f5878d919738cf437d0553b523b817d8f783cc32f5d592a8b60',
        nullifier: '3ff4e009587042ec0ec68a2c700e6f6e636edbda2a972d0cba4a5d66032869ea'
      },
      {
        coin: {
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          nonce: 'fa3a6316f5f1467106460093649f736a24dad01bd82dc652ce209269bcfa15cb',
          value: 500000000000000n,
          mt_index: 0n
        },
        commitment: '023e970a3813ab8fa4202d1159fe7068af63dc9b7d7106650c495655ab8726af',
        nullifier: '595e34df4645095d4b4f23157ded89310d62b3b165cf6774b4f57e7f7fd153a3'
      },
      {
        coin: {
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          nonce: '06014a5577a0e6332600d5d2e8aa8c39a2ea87be69c8f397ac3bb2cacb9f1126',
          value: 500000000000000n,
          mt_index: 23n
        },
        commitment: 'e4b0e7c9a9b36dae46ebed7322c5780e64eace60c1351eb85b671d1870620402',
        nullifier: 'b4ef5c785e72c3420611cb1b617482284c134a71b1aaf57d228463d658eae00e'
      },
      {
        coin: {
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          nonce: '5e5943683d95c237825538e20f287975fbf25020f21a7ef0fae8bef8517fbbff',
          value: 500000000000000n,
          mt_index: 18n
        },
        commitment: '9f15cf932d1f31a7c9c8fbb030d1c7e11e6a36972dcccb9494032d470963a4bd',
        nullifier: 'df667c741d2d74f8c11cd9f685fc95ed8aae235c0f7b75dfc69bbca10c8e9683'
      },
      {
        coin: {
          type: '0000000000000000000000000000000000000000000000000000000000000002',
          nonce: 'cdec51cff753c64b32fc4f566c113497af9d9330e98200a48e3ed01f955be071',
          value: 500000000000000n,
          mt_index: 11n
        },
        commitment: '5a60840cc2465ecd227f128f2c9bc55072ef8a6c038b4d19935dbc173ac0b6d5',
        nullifier: 'f5c6444c7ef771b2ded6f2b0bd5e47d87305e76b88c1534894b0615982e3d268'
      }
    ],
    progress: {
      appliedIndex: 29n,
      highestRelevantWalletIndex: 29n,
      highestIndex: 0n,
      highestRelevantIndex: 0n
    },
    transactionHistory: [],
    coinPublicKey: ShieldedCoinPublicKey {
      data: Buffer(32) [Uint8Array] [
        170,  13, 114, 187, 119, 234,  70, 249,
        134, 168,   0, 198, 109, 117, 196, 228,
         40, 169,  91, 215, 225,  36,  79,  30,
        208,  89,  55,  78,  98, 102, 235, 152
      ]
    },
    encryptionPublicKey: ShieldedEncryptionPublicKey {
      data: Buffer(32) [Uint8Array] [
        182,  46,  99,  10,   3,   1, 113, 181,
        225,  26, 242,  72, 127,   1,   3, 230,
         80, 204, 112,  63,  40,  77,  10,  71,
        139,  42,  58, 189, 249, 113,  91, 112
      ]
    },
    address: ShieldedAddress {
      coinPublicKey: ShieldedCoinPublicKey {
        data: Buffer(32) [Uint8Array] [
          170,  13, 114, 187, 119, 234,  70, 249,
          134, 168,   0, 198, 109, 117, 196, 228,
           40, 169,  91, 215, 225,  36,  79,  30,
          208,  89,  55,  78,  98, 102, 235, 152
        ]
      },
      encryptionPublicKey: ShieldedEncryptionPublicKey {
        data: Buffer(32) [Uint8Array] [
          182,  46,  99,  10,   3,   1, 113, 181,
          225,  26, 242,  72, 127,   1,   3, 230,
           80, 204, 112,  63,  40,  77,  10,  71,
          139,  42,  58, 189, 249, 113,  91, 112
        ]
      },
      [Symbol(MidnightBech32m)]: Bech32mCodec {
        type: 'shield-addr',
        dataToBytes: [Function (anonymous)],
        dataFromBytes: [Function (anonymous)]
      }
    }
  },
  unshielded: {
    balances: {
      '0000000000000000000000000000000000000000000000000000000000000000': 2500000000000000n
    },
    availableCoins: [
      {
        utxo: {
          value: 500000000000000n,
          owner: 'mn_addr_undeployed1h3ssm5ru2t6eqy4g3she78zlxn96e36ms6pq996aduvmateh9p9sk96u7s',
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          intentHash: '671fc41b74cc5a23ca53e6fb618ec04fa89a8aa142bff83932b1be160599edf6',
          outputNo: 0
        },
        meta: {
          ctime: 2025-08-05T12:00:00.000Z,
          registeredForDustGeneration: true
        }
      },
      {
        utxo: {
          value: 500000000000000n,
          owner: 'mn_addr_undeployed1h3ssm5ru2t6eqy4g3she78zlxn96e36ms6pq996aduvmateh9p9sk96u7s',
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          intentHash: '59a28165ce6b386da2b1ba78a319f6c250510646a2f1bddcbe507ecc0230b5d3',
          outputNo: 0
        },
        meta: {
          ctime: 2025-08-05T12:00:00.000Z,
          registeredForDustGeneration: true
        }
      },
      {
        utxo: {
          value: 500000000000000n,
          owner: 'mn_addr_undeployed1h3ssm5ru2t6eqy4g3she78zlxn96e36ms6pq996aduvmateh9p9sk96u7s',
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          intentHash: 'e9d4d140177940ed001455c2278d7f26c881f3899874ce2ab4a70deda33283b0',
          outputNo: 0
        },
        meta: {
          ctime: 2025-08-05T12:00:00.000Z,
          registeredForDustGeneration: true
        }
      },
      {
        utxo: {
          value: 500000000000000n,
          owner: 'mn_addr_undeployed1h3ssm5ru2t6eqy4g3she78zlxn96e36ms6pq996aduvmateh9p9sk96u7s',
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          intentHash: '90aaed75d94757eac47aeebb956be58f9f66d1e0e62f2e76d10b35f463e30122',
          outputNo: 0
        },
        meta: {
          ctime: 2025-08-05T12:00:00.000Z,
          registeredForDustGeneration: true
        }
      },
      {
        utxo: {
          value: 500000000000000n,
          owner: 'mn_addr_undeployed1h3ssm5ru2t6eqy4g3she78zlxn96e36ms6pq996aduvmateh9p9sk96u7s',
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          intentHash: 'c230c54a599a3d3472c5ee3f350c94745f1231412a4be729ea9f40db5e6776df',
          outputNo: 0
        },
        meta: {
          ctime: 2025-08-05T12:00:00.000Z,
          registeredForDustGeneration: true
        }
      }
    ],
    pendingCoins: [],
    totalCoins: [
      {
        utxo: {
          value: 500000000000000n,
          owner: 'mn_addr_undeployed1h3ssm5ru2t6eqy4g3she78zlxn96e36ms6pq996aduvmateh9p9sk96u7s',
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          intentHash: '671fc41b74cc5a23ca53e6fb618ec04fa89a8aa142bff83932b1be160599edf6',
          outputNo: 0
        },
        meta: {
          ctime: 2025-08-05T12:00:00.000Z,
          registeredForDustGeneration: true
        }
      },
      {
        utxo: {
          value: 500000000000000n,
          owner: 'mn_addr_undeployed1h3ssm5ru2t6eqy4g3she78zlxn96e36ms6pq996aduvmateh9p9sk96u7s',
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          intentHash: '59a28165ce6b386da2b1ba78a319f6c250510646a2f1bddcbe507ecc0230b5d3',
          outputNo: 0
        },
        meta: {
          ctime: 2025-08-05T12:00:00.000Z,
          registeredForDustGeneration: true
        }
      },
      {
        utxo: {
          value: 500000000000000n,
          owner: 'mn_addr_undeployed1h3ssm5ru2t6eqy4g3she78zlxn96e36ms6pq996aduvmateh9p9sk96u7s',
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          intentHash: 'e9d4d140177940ed001455c2278d7f26c881f3899874ce2ab4a70deda33283b0',
          outputNo: 0
        },
        meta: {
          ctime: 2025-08-05T12:00:00.000Z,
          registeredForDustGeneration: true
        }
      },
      {
        utxo: {
          value: 500000000000000n,
          owner: 'mn_addr_undeployed1h3ssm5ru2t6eqy4g3she78zlxn96e36ms6pq996aduvmateh9p9sk96u7s',
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          intentHash: '90aaed75d94757eac47aeebb956be58f9f66d1e0e62f2e76d10b35f463e30122',
          outputNo: 0
        },
        meta: {
          ctime: 2025-08-05T12:00:00.000Z,
          registeredForDustGeneration: true
        }
      },
      {
        utxo: {
          value: 500000000000000n,
          owner: 'mn_addr_undeployed1h3ssm5ru2t6eqy4g3she78zlxn96e36ms6pq996aduvmateh9p9sk96u7s',
          type: '0000000000000000000000000000000000000000000000000000000000000000',
          intentHash: 'c230c54a599a3d3472c5ee3f350c94745f1231412a4be729ea9f40db5e6776df',
          outputNo: 0
        },
        meta: {
          ctime: 2025-08-05T12:00:00.000Z,
          registeredForDustGeneration: true
        }
      }
    ],
    progress: {
      appliedId: 9n,
      highestTransactionId: 9n,
      isConnected: true,
      isStrictlyComplete: [Function: isStrictlyComplete],
      isCompleteWithin: [Function: isCompleteWithin]
    },
    transactionHistory: {
      create: [AsyncFunction: create],
      get: [AsyncFunction: get],
      getAll: [Function: getAll],
      delete: [AsyncFunction: delete]
    },
    address: UnshieldedAddress {
      data: Buffer(32) [Uint8Array] [
        188,  97,  13, 208, 124,  82, 245, 144,
         18, 168, 140,  47, 159,  28,  95,  52,
        203, 172, 199,  91, 134, 130,   2, 151,
         93, 111,  25, 190, 175,  55,  40,  75
      ],
      [Symbol(MidnightBech32m)]: Bech32mCodec {
        type: 'addr',
        dataToBytes: [Function (anonymous)],
        dataFromBytes: [Function (anonymous)]
      }
    }
  },
  dust: {
    totalCoins: [
      {
        initialValue: 0n,
        owner: 11886380015789543296729785856017363359697744265386149017101029008360306658047n,
        nonce: 21244438981981165169535492398728640016197515410260931870373091119927574907692n,
        seq: 0,
        ctime: 2025-08-05T12:00:00.000Z,
        backingNight: 'c7b64d5aa64262705b14735aa8eba798d072aa962ac1cb7f9da9693421410552',
        mtIndex: 0n
      },
      {
        initialValue: 0n,
        owner: 11886380015789543296729785856017363359697744265386149017101029008360306658047n,
        nonce: 10201937588921233514150480458058716854505989540471671208389698426511273575017n,
        seq: 0,
        ctime: 2025-08-05T12:00:00.000Z,
        backingNight: 'bcdd9308b7628d6ac16c4c2f24af8aa682efdd74ea7e7b916ff0e929c94673a5',
        mtIndex: 3n
      },
      {
        initialValue: 0n,
        owner: 11886380015789543296729785856017363359697744265386149017101029008360306658047n,
        nonce: 51650264525838247949097738603662528505715289147975900086387689489660233750160n,
        seq: 0,
        ctime: 2025-08-05T12:00:00.000Z,
        backingNight: 'a0e20f7430cba8ff3d41df6b58afdc7f4469d665b06c34248198f94882f6b954',
        mtIndex: 4n
      },
      {
        initialValue: 0n,
        owner: 11886380015789543296729785856017363359697744265386149017101029008360306658047n,
        nonce: 38928378401809425349843606453780343090755438120443610805949457881565929985374n,
        seq: 0,
        ctime: 2025-08-05T12:00:00.000Z,
        backingNight: '368ac08998feed02b8f9f3556601040809a701b9be539df5ce0c34736a5d3da4',
        mtIndex: 2n
      },
      {
        initialValue: 0n,
        owner: 11886380015789543296729785856017363359697744265386149017101029008360306658047n,
        nonce: 38503609416955855980699368356981187447552854849706744377315252397264307048452n,
        seq: 0,
        ctime: 2025-08-05T12:00:00.000Z,
        backingNight: 'ba356be982b6a8b77635cb5e8602d2889049c6f0080af6cd7403feab3b71eadf',
        mtIndex: 1n
      }
    ],
    availableCoins: [
      {
        initialValue: 0n,
        owner: 11886380015789543296729785856017363359697744265386149017101029008360306658047n,
        nonce: 21244438981981165169535492398728640016197515410260931870373091119927574907692n,
        seq: 0,
        ctime: 2025-08-05T12:00:00.000Z,
        backingNight: 'c7b64d5aa64262705b14735aa8eba798d072aa962ac1cb7f9da9693421410552',
        mtIndex: 0n
      },
      {
        initialValue: 0n,
        owner: 11886380015789543296729785856017363359697744265386149017101029008360306658047n,
        nonce: 10201937588921233514150480458058716854505989540471671208389698426511273575017n,
        seq: 0,
        ctime: 2025-08-05T12:00:00.000Z,
        backingNight: 'bcdd9308b7628d6ac16c4c2f24af8aa682efdd74ea7e7b916ff0e929c94673a5',
        mtIndex: 3n
      },
      {
        initialValue: 0n,
        owner: 11886380015789543296729785856017363359697744265386149017101029008360306658047n,
        nonce: 51650264525838247949097738603662528505715289147975900086387689489660233750160n,
        seq: 0,
        ctime: 2025-08-05T12:00:00.000Z,
        backingNight: 'a0e20f7430cba8ff3d41df6b58afdc7f4469d665b06c34248198f94882f6b954',
        mtIndex: 4n
      },
      {
        initialValue: 0n,
        owner: 11886380015789543296729785856017363359697744265386149017101029008360306658047n,
        nonce: 38928378401809425349843606453780343090755438120443610805949457881565929985374n,
        seq: 0,
        ctime: 2025-08-05T12:00:00.000Z,
        backingNight: '368ac08998feed02b8f9f3556601040809a701b9be539df5ce0c34736a5d3da4',
        mtIndex: 2n
      },
      {
        initialValue: 0n,
        owner: 11886380015789543296729785856017363359697744265386149017101029008360306658047n,
        nonce: 38503609416955855980699368356981187447552854849706744377315252397264307048452n,
        seq: 0,
        ctime: 2025-08-05T12:00:00.000Z,
        backingNight: 'ba356be982b6a8b77635cb5e8602d2889049c6f0080af6cd7403feab3b71eadf',
        mtIndex: 1n
      }
    ],
    pendingCoins: [],
    progress: {
      appliedIndex: 50n,
      highestRelevantWalletIndex: 50n,
      highestIndex: 0n,
      highestRelevantIndex: 0n
    },
    dustPublicKey: 11886380015789543296729785856017363359697744265386149017101029008360306658047n,
    dustAddress: 'mn_dust_undeployed1w0l54txthpu8q05j9j9ttk3j5dyu5766dc9zkz2s435vdglzwdr35dw790y'
  }
}
",
]
`;

exports[`Snippet outputs > with network > should output the correct result for 'shielded-transfer' 1`] = `
[
  "Shielded transfer completed; shielded balance: 1000000n
",
]
`;

exports[`Snippet outputs > with network > should output the correct result for 'swap' 1`] = `
[
  "Does Alice have specific shielded coin before swap? false
Does Bob have specific shielded coin before swap? false
Does Alice have specific shielded coin after swap? true
Does Bob have specific shielded coin after swap? true
",
]
`;

exports[`Snippet outputs > with network > should output the correct result for 'unshielded-transfer' 1`] = `
[
  "Unshielded transfer completed; night balance: 1000000n
",
]
`;

exports[`Snippet outputs > without network > should output the correct result for 'addresses' 1`] = `
[
  "unshielded address mn_addr_undeployed13h0e3c2m7rcfem6wvjljnyjmxy5rkg9kkwcldzt73ya5pv7c4p8skzgqwj
 are unshielded addresses equal? true
mainnet unshielded address mn_addr13h0e3c2m7rcfem6wvjljnyjmxy5rkg9kkwcldzt73ya5pv7c4p8shdxvu5
 are mainnet unshielded addresses equal? true
shielded address mn_shield-addr_undeployed12p0cn6f9dtlw74r44pg8mwwjwkr74nuekt4xx560764703qeeuvqsjk0cyf658cmttf8m30tldatpacryugm70ql8n9j3400ge3v7ecjaqvru
 are shielded addresses equal? true
dust address mn_dust_undeployed1da40n96p3afrvs84zhuw354z755hhus5e3g49j0aw3c4gte3kmksnd5awz
 are dust addresses equal? true
",
]
`;

exports[`Snippet outputs > without network > should output the correct result for 'hd' 1`] = `
[
  "seed 0000000000000000000000000000000000000000000000000000000000000000
unshielded(Night) secret key 22b8e577b3f638b2b361f36fd62d7138ed489d9afe3da5f7c325e2d0a95ae043
shielded:
  seed 9690d4013e42e6739d9496f836b2cbd4339451c02a00624b86e9fb15cc4197a8
  coin secret key 6d69646e696768743a7a737761702d636f696e2d7365637265742d6b65795b76315d3af9e01827aa841edfbf90bb11a207e0df140dbec913dca5025fd588b8ec102aab
  encryption secret key 6fc92f70f2e4b474b6a184ec0bc8d78aa19c3c153bd8283907b36a7a6556fcb1
dust:
  seed b9b76cce66828aa6bd798abbb15b012331a6aa1e5f99e678724c37463b5775a1
  public key 1a4773e2a3c668ac50092b0a6e5a7bca49a332dab58a2c923e7078b8cbac4aff
",
]
`;

================
File: packages/docs-snippets/vitest.config.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/// <reference types="vitest" />
/// <reference types="vitest/globals" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    setupFiles: ['../../setup-env.ts'],
    environment: 'node',
    globals: true,
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage',
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }],
    ],
  },
});

================
File: packages/dust-wallet/src/DustCoreWallet.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import {
  Bindingish,
  DustLocalState,
  DustNullifier,
  DustParameters,
  DustPublicKey,
  DustSecretKey,
  Proofish,
  Signaturish,
  Transaction,
  Event,
} from '@midnight-ntwrk/ledger-v6';
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { SyncProgress } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import { DateOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import { Array as Arr, pipe } from 'effect';
import { DustToken, DustTokenWithNullifier } from './types/Dust.js';
import { CoinWithValue } from './CoinsAndBalances.js';
import { NetworkId, UnprovenDustSpend } from './types/ledger.js';

export type PublicKey = {
  publicKey: DustPublicKey;
};

export const PublicKey = {
  fromSecretKey: (secretKey: DustSecretKey): PublicKey => {
    return {
      publicKey: secretKey.publicKey,
    };
  },
};

export class DustCoreWallet {
  readonly state: DustLocalState;
  readonly publicKey: PublicKey;
  readonly protocolVersion: ProtocolVersion.ProtocolVersion;

  readonly progress: SyncProgress.SyncProgress;
  readonly networkId: NetworkId;
  readonly pendingDustTokens: Array<DustTokenWithNullifier>;

  constructor(
    state: DustLocalState,
    publicKey: PublicKey,
    networkId: NetworkId,
    pendingDustTokens: Array<DustTokenWithNullifier> = [],
    syncProgress?: Omit<SyncProgress.SyncProgressData, 'isConnected'>,
    protocolVersion: ProtocolVersion.ProtocolVersion = ProtocolVersion.MinSupportedVersion,
  ) {
    this.state = state;
    this.publicKey = publicKey;
    this.networkId = networkId;
    this.pendingDustTokens = pendingDustTokens;
    this.protocolVersion = protocolVersion;
    this.progress = syncProgress ? SyncProgress.createSyncProgress(syncProgress) : SyncProgress.createSyncProgress();
  }

  static init(localState: DustLocalState, secretKey: DustSecretKey, networkId: NetworkId): DustCoreWallet {
    return new DustCoreWallet(localState, PublicKey.fromSecretKey(secretKey), networkId);
  }

  static readonly initEmpty = (
    dustParameters: DustParameters,
    secretKey: DustSecretKey,
    networkId: NetworkId,
  ): DustCoreWallet => {
    return DustCoreWallet.empty(new DustLocalState(dustParameters), PublicKey.fromSecretKey(secretKey), networkId);
  };

  static empty(localState: DustLocalState, publicKey: PublicKey, networkId: NetworkId): DustCoreWallet {
    return new DustCoreWallet(localState, publicKey, networkId);
  }

  static restore(
    localState: DustLocalState,
    publicKey: PublicKey,
    pendingTokens: Array<DustTokenWithNullifier>,
    syncProgress: SyncProgress.SyncProgressData,
    protocolVersion: bigint,
    networkId: NetworkId,
  ): DustCoreWallet {
    return new DustCoreWallet(
      localState,
      publicKey,
      networkId,
      pendingTokens,
      syncProgress,
      ProtocolVersion.ProtocolVersion(protocolVersion),
    );
  }

  applyEvents(secretKey: DustSecretKey, events: Event[], currentTime: Date): DustCoreWallet {
    if (!events.length) return this;

    // TODO: replace currentTime with `updatedState.syncTime` introduced in ledger-6.2.0-rc.1
    const updatedState = this.state.replayEvents(secretKey, events).processTtls(currentTime);

    let updatedPending = this.pendingDustTokens;
    if (updatedPending.length) {
      const newAvailable = updatedState.utxos.map((utxo) => utxo.nonce);
      updatedPending = updatedPending.filter((pendingToken) => newAvailable.includes(pendingToken.nonce));
    }

    return new DustCoreWallet(updatedState, this.publicKey, this.networkId, updatedPending, this.progress);
  }

  applyFailed(tx: Transaction<Signaturish, Proofish, Bindingish>): DustCoreWallet {
    const removedPending: DustNullifier[] = [];
    let updatedState = this.state;
    if (tx.intents) {
      const pendingTokensMap = DustCoreWallet.pendingDustTokensToMap(this.pendingDustTokens);
      for (const intent of tx.intents.values()) {
        if (intent.dustActions && intent.dustActions.spends) {
          for (const spend of intent.dustActions.spends) {
            const pending = pendingTokensMap.get(spend.oldNullifier);
            if (pending === undefined) continue;
            removedPending.push(spend.oldNullifier);
            updatedState = updatedState.processTtls(
              DateOps.addSeconds(pending.ctime, this.state.params.dustGracePeriodSeconds),
            );
          }
        }
      }
    }
    const pendingLeft = this.pendingDustTokens.filter((token) => !removedPending.includes(token.nullifier));
    return new DustCoreWallet(updatedState, this.publicKey, this.networkId, pendingLeft, this.progress);
  }

  revertTransaction<TTransaction extends Transaction<Signaturish, Proofish, Bindingish>>(
    tx: TTransaction,
  ): DustCoreWallet {
    return this.applyFailed(tx);
  }

  updateProgress({
    appliedIndex,
    highestRelevantWalletIndex,
    highestIndex,
    highestRelevantIndex,
    isConnected,
  }: Partial<SyncProgress.SyncProgressData>): DustCoreWallet {
    const updatedProgress = SyncProgress.createSyncProgress({
      appliedIndex: appliedIndex ?? this.progress.appliedIndex,
      highestRelevantWalletIndex: highestRelevantWalletIndex ?? this.progress.highestRelevantWalletIndex,
      highestIndex: highestIndex ?? this.progress.highestIndex,
      highestRelevantIndex: highestRelevantIndex ?? this.progress.highestRelevantIndex,
      isConnected: isConnected ?? this.progress.isConnected,
    });

    return new DustCoreWallet(this.state, this.publicKey, this.networkId, this.pendingDustTokens, updatedProgress);
  }

  spendCoins(
    secretKey: DustSecretKey,
    coins: ReadonlyArray<CoinWithValue<DustToken>>,
    currentTime: Date,
  ): [ReadonlyArray<UnprovenDustSpend>, DustCoreWallet] {
    const [output, newState, newPending] = pipe(
      coins,
      Arr.reduce(
        [[], this.state, this.pendingDustTokens],
        (
          [spends, localState]: [ReadonlyArray<UnprovenDustSpend>, DustLocalState, Array<DustTokenWithNullifier>],
          { token: coinToSpend, value: takeFee },
        ) => {
          const [newState, dustSpend] = localState.spend(secretKey, coinToSpend, takeFee, currentTime);
          const newPending = [...this.pendingDustTokens, { ...coinToSpend, nullifier: dustSpend.oldNullifier }];
          return [Arr.append(spends, dustSpend), newState, newPending];
        },
      ),
    );
    const updatedState = new DustCoreWallet(newState, this.publicKey, this.networkId, newPending, this.progress);
    return [output, updatedState];
  }

  static pendingDustTokensToMap(tokens: Array<DustTokenWithNullifier>): Map<DustNullifier, DustToken> {
    return new Map<DustNullifier, DustToken>(tokens.map(({ nullifier, ...token }) => [nullifier, token]));
  }
}

================
File: packages/dust-wallet/src/DustWallet.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import {
  DustParameters,
  DustPublicKey,
  DustSecretKey,
  FinalizedTransaction,
  Signature,
  SignatureVerifyingKey,
  UnprovenTransaction,
} from '@midnight-ntwrk/ledger-v6';
import { ProtocolState, ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { DustAddress } from '@midnight-ntwrk/wallet-sdk-address-format';
import { Runtime, WalletBuilder } from '@midnight-ntwrk/wallet-sdk-runtime';
import { Variant, WalletLike } from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
import { ProvingRecipe, TransactionHistory } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import { Effect, Either, Scope } from 'effect';
import * as rx from 'rxjs';
import { Balance, CoinsAndBalancesCapability } from './CoinsAndBalances.js';
import { DustCoreWallet } from './DustCoreWallet.js';
import { KeysCapability } from './Keys.js';
import { V1Tag } from './RunningV1Variant.js';
import { SerializationCapability } from './Serialization.js';
import { SubmitTransactionMethod } from './Submission.js';
import { DustToken, DustTokenFullInfo, UtxoWithMeta } from './types/Dust.js';
import { AnyTransaction } from './types/ledger.js';
import { DefaultV1Configuration, DefaultV1Variant, V1Builder } from './V1Builder.js';

export type DustWalletCapabilities = {
  serialization: SerializationCapability<DustCoreWallet, null, string>;
  coinsAndBalances: CoinsAndBalancesCapability<DustCoreWallet>;
  keys: KeysCapability<DustCoreWallet>;
};

export class DustWalletState {
  static readonly mapState =
    (capabilities: DustWalletCapabilities) =>
    (state: ProtocolState.ProtocolState<DustCoreWallet>): DustWalletState => {
      return new DustWalletState(state, capabilities);
    };

  readonly protocolVersion: ProtocolVersion.ProtocolVersion;
  readonly state: DustCoreWallet;
  readonly capabilities: DustWalletCapabilities;

  get totalCoins(): readonly DustToken[] {
    return this.capabilities.coinsAndBalances.getTotalCoins(this.state);
  }

  get availableCoins(): readonly DustToken[] {
    return this.capabilities.coinsAndBalances.getAvailableCoins(this.state);
  }

  get pendingCoins(): readonly DustToken[] {
    return this.capabilities.coinsAndBalances.getPendingCoins(this.state);
  }

  get dustPublicKey(): DustPublicKey {
    return this.capabilities.keys.getDustPublicKey(this.state);
  }

  get dustAddress(): string {
    return DustAddress.encodePublicKey(this.state.networkId, this.dustPublicKey);
  }

  get progress(): TransactionHistory.ProgressUpdate {
    return {
      appliedIndex: this.state.progress.appliedIndex,
      highestRelevantWalletIndex: this.state.progress.highestRelevantWalletIndex,
      highestIndex: this.state.progress.highestIndex,
      highestRelevantIndex: this.state.progress.highestRelevantIndex,
    };
  }

  constructor(state: ProtocolState.ProtocolState<DustCoreWallet>, capabilities: DustWalletCapabilities) {
    this.protocolVersion = state.version;
    this.state = state.state;
    this.capabilities = capabilities;
  }

  walletBalance(time: Date): Balance {
    return this.capabilities.coinsAndBalances.getWalletBalance(this.state, time);
  }

  availableCoinsWithFullInfo(time: Date): readonly DustTokenFullInfo[] {
    return this.capabilities.coinsAndBalances.getAvailableCoinsWithFullInfo(this.state, time);
  }

  serialize(): string {
    return this.capabilities.serialization.serialize(this.state);
  }
}

export interface DustWallet extends WalletLike.WalletLike<[Variant.VersionedVariant<DefaultV1Variant>]> {
  readonly state: rx.Observable<DustWalletState>;

  start(secretKey: DustSecretKey): Promise<void>;

  createDustGenerationTransaction(
    currentTime: Date | undefined,
    ttl: Date,
    nightUtxos: Array<UtxoWithMeta>,
    nightVerifyingKey: SignatureVerifyingKey,
    dustReceiverAddress: string | undefined,
  ): Promise<UnprovenTransaction>;

  addDustGenerationSignature(
    transaction: UnprovenTransaction,
    signature: Signature,
  ): Promise<ProvingRecipe.ProvingRecipe<FinalizedTransaction>>;

  calculateFee(transaction: AnyTransaction): Promise<bigint>;

  addFeePayment(
    secretKey: DustSecretKey,
    transaction: UnprovenTransaction,
    ttl: Date,
    currentTime?: Date,
  ): Promise<ProvingRecipe.ProvingRecipe<FinalizedTransaction>>;

  finalizeTransaction(recipe: ProvingRecipe.ProvingRecipe<FinalizedTransaction>): Promise<FinalizedTransaction>;

  readonly submitTransaction: SubmitTransactionMethod<FinalizedTransaction>;

  serializeState(): Promise<string>;

  waitForSyncedState(allowedGap?: bigint): Promise<DustWalletState>;
}

export interface DustWalletClass extends WalletLike.BaseWalletClass<[Variant.VersionedVariant<DefaultV1Variant>]> {
  startWithSeed(seed: Uint8Array, dustParameters: DustParameters): DustWallet;
  startWithSecretKey(secretKey: DustSecretKey, dustParameters: DustParameters): DustWallet;
  restore(serializedState: string): DustWallet;
}

export function DustWallet(configuration: DefaultV1Configuration): DustWalletClass {
  const BaseWallet = WalletBuilder.init()
    .withVariant(ProtocolVersion.MinSupportedVersion, new V1Builder().withDefaults())
    .build(configuration);

  return class DustWalletImplementation extends BaseWallet implements DustWallet {
    static startWithSeed(seed: Uint8Array, dustParameters: DustParameters): DustWalletImplementation {
      const dustSecretKey = DustSecretKey.fromSeed(seed);
      return DustWalletImplementation.startFirst(
        DustWalletImplementation,
        DustCoreWallet.initEmpty(dustParameters, dustSecretKey, configuration.networkId),
      );
    }

    static startWithSecretKey(secretKey: DustSecretKey, dustParameters: DustParameters): DustWalletImplementation {
      return DustWalletImplementation.startFirst(
        DustWalletImplementation,
        DustCoreWallet.initEmpty(dustParameters, secretKey, configuration.networkId),
      );
    }

    static restore(serializedState: string): DustWalletImplementation {
      const deserialized: DustCoreWallet = DustWalletImplementation.allVariantsRecord()
        [V1Tag].variant.deserializeState(serializedState)
        .pipe(Either.getOrThrow);
      return DustWalletImplementation.startFirst(DustWalletImplementation, deserialized);
    }

    readonly state: rx.Observable<DustWalletState>;

    constructor(runtime: Runtime.Runtime<[Variant.VersionedVariant<DefaultV1Variant>]>, scope: Scope.CloseableScope) {
      super(runtime, scope);
      this.state = this.rawState.pipe(
        rx.map(DustWalletState.mapState(DustWalletImplementation.allVariantsRecord()[V1Tag].variant)),
        rx.shareReplay({ refCount: true, bufferSize: 1 }),
      );
    }

    start(secretKey: DustSecretKey): Promise<void> {
      return this.runtime.dispatch({ [V1Tag]: (v1) => v1.startSyncInBackground(secretKey) }).pipe(Effect.runPromise);
    }

    createDustGenerationTransaction(
      currentTime: Date | undefined,
      ttl: Date,
      nightUtxos: Array<UtxoWithMeta>,
      nightVerifyingKey: SignatureVerifyingKey,
      dustReceiverAddress: string | undefined,
    ): Promise<UnprovenTransaction> {
      return this.runtime
        .dispatch({
          [V1Tag]: (v1) =>
            v1.createDustGenerationTransaction(currentTime, ttl, nightUtxos, nightVerifyingKey, dustReceiverAddress),
        })
        .pipe(Effect.runPromise);
    }

    addDustGenerationSignature(
      transaction: UnprovenTransaction,
      signature: Signature,
    ): Promise<ProvingRecipe.ProvingRecipe<FinalizedTransaction>> {
      return this.runtime
        .dispatch({
          [V1Tag]: (v1) => v1.addDustGenerationSignature(transaction, signature),
        })
        .pipe(Effect.runPromise);
    }

    calculateFee(transaction: AnyTransaction): Promise<bigint> {
      return this.runtime
        .dispatch({
          [V1Tag]: (v1) => v1.calculateFee(transaction),
        })
        .pipe(Effect.runPromise);
    }

    addFeePayment(
      secretKey: DustSecretKey,
      transaction: UnprovenTransaction,
      ttl: Date,
      currentTime?: Date,
    ): Promise<ProvingRecipe.ProvingRecipe<FinalizedTransaction>> {
      return this.runtime
        .dispatch({
          [V1Tag]: (v1) => v1.addFeePayment(secretKey, transaction, ttl, currentTime),
        })
        .pipe(Effect.runPromise);
    }

    finalizeTransaction(recipe: ProvingRecipe.ProvingRecipe<FinalizedTransaction>): Promise<FinalizedTransaction> {
      return this.runtime
        .dispatch({
          [V1Tag]: (v1) => v1.finalizeTransaction(recipe),
        })
        .pipe(Effect.runPromise);
    }

    submitTransaction: SubmitTransactionMethod<FinalizedTransaction> = ((
      tx: FinalizedTransaction,
      waitForStatus: 'Submitted' | 'InBlock' | 'Finalized' = 'InBlock',
    ) => {
      return this.runtime
        .dispatch({ [V1Tag]: (v1) => v1.submitTransaction(tx, waitForStatus) })
        .pipe(Effect.runPromise);
    }) as unknown as SubmitTransactionMethod<FinalizedTransaction>;

    waitForSyncedState(allowedGap: bigint = 0n): Promise<DustWalletState> {
      return rx.firstValueFrom(
        this.state.pipe(rx.filter((state) => state.state.progress.isCompleteWithin(allowedGap))),
      );
    }

    /**
     * Serializes the most recent state
     * It's preferable to use [[DustWalletState.serialize]] instead, to know exactly, which state is serialized
     */
    serializeState(): Promise<string> {
      return rx.firstValueFrom(this.state).then((state) => state.serialize());
    }
  };
}

================
File: packages/dust-wallet/src/Simulator.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Either, Encoding, pipe, Scope, Stream, SubscriptionRef } from 'effect';
import {
  LedgerState,
  BlockContext,
  UserAddress,
  ClaimRewardsTransaction,
  SignatureErased,
  SignatureVerifyingKey,
  Transaction,
  WellFormedStrictness,
  TransactionResult,
  TransactionContext,
  ProofErasedTransaction,
  SyntheticCost,
} from '@midnight-ntwrk/ledger-v6';
import { DateOps, EitherOps, LedgerOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import * as crypto from 'crypto';
import { NetworkId } from './types/ledger.js';

export type SimulatorState = Readonly<{
  networkId: NetworkId;
  ledger: LedgerState;
  lastTx: ProofErasedTransaction | undefined;
  lastTxResult: TransactionResult | undefined;
  lastTxNumber: bigint;
}>;

const simpleHash = (input: string): Effect.Effect<string> => {
  return Encoding.decodeHex(input).pipe(
    EitherOps.toEffect,
    Effect.andThen((parsed) => Effect.promise(() => crypto.subtle.digest('SHA-256', parsed))),
    Effect.andThen((out) => Encoding.encodeHex(new Uint8Array(out))),
    Effect.orDie,
  );
};

export class Simulator {
  static blockHash = (blockTime: Date): Effect.Effect<string> =>
    pipe(
      DateOps.dateToSeconds(blockTime).toString(16),
      (str) => (str.length % 2 == 0 ? str : str.padStart(str.length + 1, '0')),
      simpleHash,
    );

  static nextBlockContext = (blockTime: Date): Effect.Effect<BlockContext> =>
    pipe(
      Simulator.blockHash(blockTime),
      Effect.map((hash) => ({
        parentBlockHash: hash,
        secondsSinceEpoch: DateOps.dateToSeconds(blockTime),
        secondsSinceEpochErr: 1,
      })),
    );

  static init(networkId: NetworkId): Effect.Effect<Simulator, never, Scope.Scope> {
    return Effect.gen(function* () {
      const initialState = {
        networkId,
        ledger: LedgerState.blank(networkId),
        lastTx: undefined,
        lastTxResult: undefined,
        lastTxNumber: 0n,
      };
      const ref = yield* SubscriptionRef.make<SimulatorState>(initialState);
      const changesStream = yield* Stream.share(ref.changes, {
        capacity: 'unbounded',
        replay: Number.MAX_SAFE_INTEGER,
      });
      yield* pipe(changesStream, Stream.runDrain, Effect.forkScoped);
      return new Simulator(ref, changesStream);
    });
  }

  static apply(
    simulatorState: SimulatorState,
    tx: ProofErasedTransaction,
    strictness: WellFormedStrictness,
    blockContext: BlockContext,
    blockFullness?: SyntheticCost,
  ): Either.Either<[{ blockNumber: bigint; blockHash: string }, SimulatorState], LedgerOps.LedgerError> {
    return LedgerOps.ledgerTry(() => {
      blockFullness = blockFullness ?? tx.cost(simulatorState.ledger.parameters);
      const blockNumber = blockContext.secondsSinceEpoch;
      const blockTime = DateOps.secondsToDate(blockNumber);
      const verifiedTransaction = tx.wellFormed(simulatorState.ledger, strictness, blockTime);
      const transactionContext = new TransactionContext(simulatorState.ledger, blockContext);
      const [newLedgerState, txResult] = simulatorState.ledger.apply(verifiedTransaction, transactionContext);

      const newSimulatorState = {
        ...simulatorState,
        ledger: newLedgerState.postBlockUpdate(blockTime, blockFullness),
        lastTx: tx,
        lastTxResult: txResult,
        lastTxNumber: blockNumber,
      };

      const output = {
        blockNumber,
        blockHash: blockContext.parentBlockHash,
      };

      return [output, newSimulatorState];
    });
  }

  readonly #stateRef: SubscriptionRef.SubscriptionRef<SimulatorState>;

  readonly state$: Stream.Stream<SimulatorState>;

  constructor(stateRef: SubscriptionRef.SubscriptionRef<SimulatorState>, state$: Stream.Stream<SimulatorState>) {
    this.#stateRef = stateRef;
    this.state$ = state$;
  }

  getLatestState(): Effect.Effect<SimulatorState> {
    return SubscriptionRef.get(this.#stateRef);
  }

  rewardNight(
    recipient: UserAddress,
    amount: bigint,
    verifyingKey: SignatureVerifyingKey,
  ): Effect.Effect<{ blockNumber: bigint; blockHash: string }, LedgerOps.LedgerError> {
    return SubscriptionRef.modifyEffect(this.#stateRef, (simulatorState) =>
      Effect.gen(function* () {
        const nextNumber = DateOps.secondsToDate(simulatorState.lastTxNumber + 1n);
        const newLedgerState = yield* LedgerOps.ledgerTry(() =>
          simulatorState.ledger.testingDistributeNight(recipient, amount, nextNumber),
        );
        const newSimulatorState = {
          ...simulatorState,
          ledger: newLedgerState,
        };

        const signature = new SignatureErased();
        const claimRewardsTransaction = new ClaimRewardsTransaction(
          signature.instance,
          newSimulatorState.networkId,
          amount,
          verifyingKey,
          LedgerOps.randomNonce(),
          signature,
        );
        const tx = Transaction.fromRewards(claimRewardsTransaction).eraseProofs();
        const blockContext = yield* Simulator.nextBlockContext(nextNumber);
        return yield* Simulator.apply(newSimulatorState, tx, new WellFormedStrictness(), blockContext);
      }),
    );
  }

  submitRegularTx(
    tx: ProofErasedTransaction,
    blockFullness?: SyntheticCost,
  ): Effect.Effect<{ blockNumber: bigint; blockHash: string }, LedgerOps.LedgerError> {
    return SubscriptionRef.modifyEffect(this.#stateRef, (simulatorState) =>
      Effect.gen(function* () {
        const nextNumber = DateOps.secondsToDate(simulatorState.lastTxNumber + 1n);
        const context = yield* Simulator.nextBlockContext(nextNumber);
        return yield* Simulator.apply(simulatorState, tx, new WellFormedStrictness(), context, blockFullness);
      }),
    );
  }

  fastForward(lastTxNumber: bigint): Effect.Effect<undefined, LedgerOps.LedgerError> {
    return SubscriptionRef.modify(this.#stateRef, (simulatorState) => {
      return [
        undefined,
        {
          ...simulatorState,
          lastTxNumber,
          lastTx: undefined,
          lastTxResult: undefined,
        },
      ];
    });
  }
}

================
File: packages/dust-wallet/src/Sync.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Either, Layer, ParseResult, pipe, Schema, Scope, Stream } from 'effect';
import { DustSecretKey, Event as LedgerEvent, LedgerParameters } from '@midnight-ntwrk/ledger-v6';
import { BlockHash, DustLedgerEvents } from '@midnight-ntwrk/wallet-sdk-indexer-client';
import {
  WsSubscriptionClient,
  HttpQueryClient,
  ConnectionHelper,
  SubscriptionClient,
  QueryClient,
} from '@midnight-ntwrk/wallet-sdk-indexer-client/effect';
import { DateOps, EitherOps, LedgerOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import { URLError, WsURL } from '@midnight-ntwrk/wallet-sdk-utilities/networking';
import { WalletError } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import { Simulator, SimulatorState } from './Simulator.js';
import { DustCoreWallet } from './DustCoreWallet.js';
import { NetworkId } from './types/ledger.js';
import { Uint8ArraySchema } from './Serialization.js';

export interface SyncService<TState, TStartAux, TUpdate> {
  updates: (state: TState, auxData: TStartAux) => Stream.Stream<TUpdate, WalletError.WalletError, Scope.Scope>;
  blockData: () => Effect.Effect<BlockData, WalletError.WalletError>;
}

// TODO: use schema instead
export interface BlockData {
  hash: string;
  height: number;
  ledgerParameters: LedgerParameters;
  timestamp: Date;
}

export interface SyncCapability<TState, TUpdate> {
  applyUpdate: (state: TState, update: TUpdate) => TState;
}

export type IndexerClientConnection = {
  indexerHttpUrl: string;
  indexerWsUrl?: string;
};

export type DefaultSyncConfiguration = {
  indexerClientConnection: IndexerClientConnection;
  networkId: NetworkId;
};

export type SimulatorSyncConfiguration = {
  simulator: Simulator;
  networkId: NetworkId;
};

export type SimulatorSyncUpdate = {
  update: SimulatorState;
  secretKey: DustSecretKey;
};

type SecretKeysResource = <A>(cb: (key: DustSecretKey) => A) => A;
export const SecretKeysResource = {
  create: (secretKey: DustSecretKey): SecretKeysResource => {
    let sk: DustSecretKey | null = secretKey;
    return (cb) => {
      if (sk === null || sk === undefined) {
        throw new Error('Secret key has been consumed');
      }
      const result = cb(sk);
      sk = null;
      return result;
    };
  },
};

const LedgerEventSchema = Schema.declare(
  (input: unknown): input is LedgerEvent => input instanceof LedgerEvent,
).annotations({
  identifier: 'ledger.Event',
});

const LedgerEventFromUInt8Array: Schema.Schema<LedgerEvent, Uint8Array> = Schema.asSchema(
  Schema.transformOrFail(Uint8ArraySchema, LedgerEventSchema, {
    encode: (e) => {
      return Effect.try({
        try: () => e.serialize(),
        catch: (err) => {
          return new ParseResult.Unexpected(err, 'Could not serialize Ledger Event');
        },
      });
    },
    decode: (bytes) =>
      Effect.try({
        try: () => LedgerEvent.deserialize(bytes),
        catch: (err) => {
          return new ParseResult.Unexpected(err, 'Could not deserialize Ledger Event');
        },
      }),
  }),
);

const HexedEvent: Schema.Schema<LedgerEvent, string> = pipe(
  Schema.Uint8ArrayFromHex,
  Schema.compose(LedgerEventFromUInt8Array),
);

export const SyncEventsUpdateSchema = Schema.Struct({
  id: Schema.Number,
  raw: HexedEvent,
  maxId: Schema.Number,
});

export type WalletSyncSubscription = Schema.Schema.Type<typeof SyncEventsUpdateSchema>;

export type WalletSyncUpdate = {
  update: WalletSyncSubscription;
  secretKeys: SecretKeysResource;
};
export const WalletSyncUpdate = {
  create: (update: WalletSyncSubscription, secretKey: DustSecretKey): WalletSyncUpdate => {
    return {
      update,
      secretKeys: SecretKeysResource.create(secretKey),
    };
  },
};
export const makeDefaultSyncService = (
  config: DefaultSyncConfiguration,
): SyncService<DustCoreWallet, DustSecretKey, WalletSyncUpdate> => {
  const indexerSyncService = makeIndexerSyncService(config);
  return {
    updates: (
      state: DustCoreWallet,
      secretKey: DustSecretKey,
    ): Stream.Stream<WalletSyncUpdate, WalletError.WalletError, Scope.Scope> => {
      return pipe(
        indexerSyncService.subscribeWallet(state),
        Stream.map((data) => WalletSyncUpdate.create(data, secretKey)),
        Stream.provideSomeLayer(indexerSyncService.connectionLayer()),
      );
    },
    blockData: (): Effect.Effect<BlockData, WalletError.WalletError> => {
      return Effect.gen(function* () {
        const query = yield* BlockHash;
        const result = yield* query({ offset: null });
        return result.block;
      }).pipe(
        Effect.provide(indexerSyncService.queryClient()),
        Effect.scoped,
        Effect.catchAll((err) =>
          Effect.fail(WalletError.WalletError.other(`Encountered unexpected error: ${err.message}`)),
        ),
        Effect.flatMap((blockData) => {
          if (!blockData) {
            return Effect.fail(WalletError.WalletError.other('Unable to fetch block data'));
          }
          // TODO: convert to schema
          return LedgerOps.ledgerTry(() => ({
            hash: blockData.hash,
            height: blockData.height,
            ledgerParameters: LedgerParameters.deserialize(Buffer.from(blockData.ledgerParameters, 'hex')),
            timestamp: new Date(blockData.timestamp),
          }));
        }),
      );
    },
  };
};

export type IndexerSyncService = {
  connectionLayer: () => Layer.Layer<SubscriptionClient, WalletError.WalletError, Scope.Scope>;
  subscribeWallet: (
    state: DustCoreWallet,
  ) => Stream.Stream<WalletSyncSubscription, WalletError.WalletError, Scope.Scope | SubscriptionClient>;
  queryClient: () => Layer.Layer<QueryClient, WalletError.WalletError, Scope.Scope>;
};

export const makeIndexerSyncService = (config: DefaultSyncConfiguration): IndexerSyncService => {
  return {
    queryClient(): Layer.Layer<QueryClient, WalletError.WalletError, Scope.Scope> {
      return pipe(
        HttpQueryClient.layer({ url: config.indexerClientConnection.indexerHttpUrl }),
        Layer.mapError((error) => WalletError.WalletError.other(error)),
      );
    },
    connectionLayer(): Layer.Layer<SubscriptionClient, WalletError.WalletError, Scope.Scope> {
      const { indexerClientConnection } = config;

      return ConnectionHelper.createWebSocketUrl(
        indexerClientConnection.indexerHttpUrl,
        indexerClientConnection.indexerWsUrl,
      ).pipe(
        Either.flatMap((url) => WsURL.make(url)),
        Either.match({
          onLeft: (error) => Layer.fail(error),
          onRight: (url: WsURL.WsURL) => WsSubscriptionClient.layer({ url }),
        }),
        Layer.mapError(
          (e: URLError) =>
            new WalletError.SyncWalletError({ message: 'Failed to to obtain correct indexer URLs', cause: e }),
        ),
      );
    },
    subscribeWallet(
      state: DustCoreWallet,
    ): Stream.Stream<WalletSyncSubscription, WalletError.WalletError, Scope.Scope | SubscriptionClient> {
      const { appliedIndex } = state.progress;

      return pipe(
        DustLedgerEvents.run({
          id: Number(appliedIndex),
        }),
        Stream.mapEffect((subscription) =>
          pipe(
            Schema.decodeUnknownEither(SyncEventsUpdateSchema)(subscription.dustLedgerEvents),
            Either.mapLeft((err) => new WalletError.SyncWalletError(err)),
            EitherOps.toEffect,
          ),
        ),
        Stream.mapError((error) => new WalletError.SyncWalletError(error)),
      );
    },
  };
};

export const makeDefaultSyncCapability = (): SyncCapability<DustCoreWallet, WalletSyncUpdate> => {
  return {
    applyUpdate(state: DustCoreWallet, wrappedUpdate: WalletSyncUpdate): DustCoreWallet {
      const { update, secretKeys } = wrappedUpdate;
      const nextIndex = BigInt(update.id);
      const highestRelevantWalletIndex = BigInt(update.maxId);

      // in case the nextIndex is less than or equal to the current appliedIndex
      // just update highestRelevantWalletIndex
      if (nextIndex <= state.progress.appliedIndex) {
        return state.updateProgress({ highestRelevantWalletIndex, isConnected: true });
      }

      const events = [update.raw].filter((event) => event !== null);
      return secretKeys((keys) =>
        state
          .applyEvents(keys, events, new Date())
          .updateProgress({ appliedIndex: nextIndex, highestRelevantWalletIndex, isConnected: true }),
      );
    },
  };
};

export const makeSimulatorSyncService = (
  config: SimulatorSyncConfiguration,
): SyncService<DustCoreWallet, DustSecretKey, SimulatorSyncUpdate> => {
  return {
    updates: (_state: DustCoreWallet, secretKey: DustSecretKey) =>
      config.simulator.state$.pipe(Stream.map((state) => ({ update: state, secretKey }))),
    blockData: (): Effect.Effect<BlockData> => {
      return Effect.gen(function* () {
        const state = yield* config.simulator.getLatestState();
        const timestamp = DateOps.secondsToDate(state.lastTxNumber);
        return {
          hash: yield* Simulator.blockHash(timestamp),
          height: Number(state.lastTxNumber),
          ledgerParameters: state.ledger.parameters,
          timestamp,
        };
      });
    },
  };
};

export const makeSimulatorSyncCapability = (): SyncCapability<DustCoreWallet, SimulatorSyncUpdate> => ({
  applyUpdate: (state: DustCoreWallet, update: SimulatorSyncUpdate) =>
    state
      .applyEvents(
        update.secretKey,
        update.update.lastTxResult?.events || [],
        DateOps.secondsToDate(update.update.lastTxNumber),
      )
      .updateProgress({ appliedIndex: update.update.lastTxNumber }),
});

================
File: packages/dust-wallet/src/V1Builder.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Scope, Types, Either } from 'effect';
import { Expect, ItemType } from '@midnight-ntwrk/wallet-sdk-utilities/types';
import { DustSecretKey, FinalizedTransaction } from '@midnight-ntwrk/ledger-v6';
import { WalletRuntimeError, VariantBuilder, Variant } from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
import { Proving, WalletError } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import {
  SyncService,
  SyncCapability,
  DefaultSyncConfiguration,
  makeDefaultSyncCapability,
  makeDefaultSyncService,
  WalletSyncUpdate,
} from './Sync.js';
import { RunningV1Variant, V1Tag } from './RunningV1Variant.js';
import { DustCoreWallet } from './DustCoreWallet.js';
import { KeysCapability, makeDefaultKeysCapability } from './Keys.js';
import {
  chooseCoin,
  CoinsAndBalancesCapability,
  CoinSelection,
  makeDefaultCoinsAndBalancesCapability,
} from './CoinsAndBalances.js';
import {
  DefaultTransactingConfiguration,
  DefaultTransactingContext,
  makeDefaultTransactingCapability,
  TransactingCapability,
} from './Transacting.js';
import { NetworkId } from './types/ledger.js';
import { DefaultSubmissionConfiguration, makeDefaultSubmissionService, SubmissionService } from './Submission.js';
import { DustToken } from './types/Dust.js';
import { makeDefaultV1SerializationCapability, SerializationCapability } from './Serialization.js';
import { TotalCostParameters } from './types/transaction.js';

export type BaseV1Configuration = {
  networkId: NetworkId;
  costParameters: TotalCostParameters;
};

export type DefaultV1Configuration = BaseV1Configuration;

const V1BuilderSymbol: {
  readonly typeId: unique symbol;
} = {
  typeId: Symbol('@midnight-ntwrk/dustWallet#V1Builder') as (typeof V1BuilderSymbol)['typeId'],
} as const;

export type DefaultV1Variant = V1Variant<string, WalletSyncUpdate, FinalizedTransaction, DustSecretKey>;

export type V1Variant<TSerialized, TSyncUpdate, TTransaction, TAuxData> = Variant.Variant<
  typeof V1Tag,
  DustCoreWallet,
  DustCoreWallet, // null,
  RunningV1Variant<TSerialized, TSyncUpdate, TTransaction, TAuxData>
> & {
  deserializeState: (serialized: TSerialized) => Either.Either<DustCoreWallet, WalletError.WalletError>;
  coinsAndBalances: CoinsAndBalancesCapability<DustCoreWallet>;
  keys: KeysCapability<DustCoreWallet>;
  serialization: SerializationCapability<DustCoreWallet, null, TSerialized>;
};

export type DefaultV1Builder = V1Builder<
  DefaultV1Configuration,
  RunningV1Variant.Context<string, WalletSyncUpdate, FinalizedTransaction, DustSecretKey>,
  string,
  WalletSyncUpdate,
  FinalizedTransaction
>;

export class V1Builder<
  TConfig extends BaseV1Configuration = BaseV1Configuration,
  TContext extends Partial<RunningV1Variant.AnyContext> = object,
  TSerialized = never,
  TSyncUpdate = never,
  TTransaction = never,
  TStartAux extends object = object,
> implements VariantBuilder.VariantBuilder<V1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux>, TConfig> {
  #buildState: V1Builder.PartialBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>;

  constructor(
    buildState: V1Builder.PartialBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux> = {},
  ) {
    this.#buildState = buildState;
  }

  withDefaults(): DefaultV1Builder {
    return this.withDefaultTransactionType()
      .withSyncDefaults()
      .withSerializationDefaults()
      .withTransactingDefaults()
      .withCoinsAndBalancesDefaults()
      .withKeysDefaults()
      .withSubmissionDefaults()
      .withProvingDefaults()
      .withCoinSelectionDefaults() as DefaultV1Builder;
  }

  withTransactionType<Transaction>(): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, Transaction, TStartAux> {
    return new V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, Transaction, TStartAux>({
      ...this.#buildState,
      provingService: undefined,
      transactingCapability: undefined,
      submissionService: undefined,
    });
  }

  withDefaultTransactionType(): V1Builder<
    TConfig,
    TContext,
    TSerialized,
    TSyncUpdate,
    FinalizedTransaction,
    TStartAux
  > {
    return this.withTransactionType<FinalizedTransaction>();
  }

  withSyncDefaults(): V1Builder<
    TConfig & DefaultSyncConfiguration,
    TContext,
    TSerialized,
    WalletSyncUpdate,
    TTransaction,
    DustSecretKey
  > {
    return this.withSync(makeDefaultSyncService, makeDefaultSyncCapability);
  }

  withSync<
    TSyncConfig,
    TSyncContext extends Partial<RunningV1Variant.AnyContext>,
    TSyncUpdate,
    TStartAux extends object,
  >(
    syncService: (
      configuration: TSyncConfig,
      getContext: () => TSyncContext,
    ) => SyncService<DustCoreWallet, TStartAux, TSyncUpdate>,
    syncCapability: (
      configuration: TSyncConfig,
      getContext: () => TSyncContext,
    ) => SyncCapability<DustCoreWallet, TSyncUpdate>,
  ): V1Builder<TConfig & TSyncConfig, TContext & TSyncContext, TSerialized, TSyncUpdate, TTransaction, TStartAux> {
    return new V1Builder<
      TConfig & TSyncConfig,
      TContext & TSyncContext,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >({
      ...this.#buildState,
      syncService,
      syncCapability,
    });
  }

  withSerializationDefaults(): V1Builder<TConfig, TContext, string, TSyncUpdate, TTransaction, TStartAux> {
    return this.withSerialization(makeDefaultV1SerializationCapability);
  }

  withSerialization<
    TSerializationConfig,
    TSerializationContext extends Partial<RunningV1Variant.AnyContext>,
    TSerialized,
  >(
    serializationCapability: (
      configuration: TSerializationConfig,
      getContext: () => TSerializationContext,
    ) => SerializationCapability<DustCoreWallet, null, TSerialized>,
  ): V1Builder<
    TConfig & TSerializationConfig,
    TContext & TSerializationContext,
    TSerialized,
    TSyncUpdate,
    TTransaction,
    TStartAux
  > {
    return new V1Builder<
      TConfig & TSerializationConfig,
      TContext & TSerializationContext,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >({
      ...this.#buildState,
      serializationCapability,
    });
  }

  withTransactingDefaults(
    this: V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, FinalizedTransaction, TStartAux>,
  ): V1Builder<
    TConfig & DefaultTransactingConfiguration,
    TContext & DefaultTransactingContext,
    TSerialized,
    TSyncUpdate,
    FinalizedTransaction,
    TStartAux
  > {
    return this.withTransacting(makeDefaultTransactingCapability);
  }

  withTransacting<TTransactingConfig, TTransactingContext extends Partial<RunningV1Variant.AnyContext>>(
    transactingCapability: (
      config: TTransactingConfig,
      getContext: () => TTransactingContext,
    ) => TransactingCapability<DustSecretKey, DustCoreWallet, TTransaction>,
  ): V1Builder<
    TConfig & TTransactingConfig,
    TContext & TTransactingContext,
    TSerialized,
    TSyncUpdate,
    TTransaction,
    TStartAux
  > {
    return new V1Builder<
      TConfig & TTransactingConfig,
      TContext & TTransactingContext,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >({
      ...this.#buildState,
      transactingCapability,
    });
  }

  withCoinSelection<TCoinSelectionConfig, TCoinSelectionContext extends Partial<RunningV1Variant.AnyContext>>(
    coinSelection: (config: TCoinSelectionConfig, getContext: () => TCoinSelectionContext) => CoinSelection<DustToken>,
  ): V1Builder<
    TConfig & TCoinSelectionConfig,
    TContext & TCoinSelectionContext,
    TSerialized,
    TSyncUpdate,
    TTransaction,
    TStartAux
  > {
    return new V1Builder<
      TConfig & TCoinSelectionConfig,
      TContext & TCoinSelectionContext,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >({
      ...this.#buildState,
      coinSelection,
    });
  }

  withCoinSelectionDefaults(): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux> {
    return this.withCoinSelection(() => chooseCoin);
  }

  withProving<TProvingConfig, TProvingContext extends Partial<RunningV1Variant.AnyContext>>(
    provingService: (config: TProvingConfig, getContext: () => TProvingContext) => Proving.ProvingService<TTransaction>,
  ): V1Builder<
    TConfig & TProvingConfig,
    TContext & TProvingContext,
    TSerialized,
    TSyncUpdate,
    TTransaction,
    TStartAux
  > {
    return new V1Builder<
      TConfig & TProvingConfig,
      TContext & TProvingContext,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >({
      ...this.#buildState,
      provingService,
    });
  }

  withProvingDefaults(
    this: V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, FinalizedTransaction, TStartAux>,
  ): V1Builder<
    TConfig & Proving.DefaultProvingConfiguration,
    TContext,
    TSerialized,
    TSyncUpdate,
    FinalizedTransaction,
    TStartAux
  > {
    return this.withProving(Proving.makeDefaultProvingService);
  }

  withCoinsAndBalancesDefaults(): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux> {
    return this.withCoinsAndBalances(makeDefaultCoinsAndBalancesCapability);
  }

  withCoinsAndBalances<TBalancesConfig, TBalancesContext extends Partial<RunningV1Variant.AnyContext>>(
    coinsAndBalancesCapability: (
      configuration: TBalancesConfig,
      getContext: () => TBalancesContext,
    ) => CoinsAndBalancesCapability<DustCoreWallet>,
  ): V1Builder<
    TConfig & TBalancesConfig,
    TContext & TBalancesContext,
    TSerialized,
    TSyncUpdate,
    TTransaction,
    TStartAux
  > {
    return new V1Builder<
      TConfig & TBalancesConfig,
      TContext & TBalancesContext,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >({
      ...this.#buildState,
      coinsAndBalancesCapability,
    });
  }

  withKeysDefaults(): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux> {
    return this.withKeys(makeDefaultKeysCapability);
  }

  withKeys<TKeysConfig, TKeysContext extends Partial<RunningV1Variant.AnyContext>>(
    keysCapability: (configuration: TKeysConfig, getContext: () => TKeysContext) => KeysCapability<DustCoreWallet>,
  ): V1Builder<TConfig & TKeysConfig, TContext & TKeysContext, TSerialized, TSyncUpdate, TTransaction, TStartAux> {
    return new V1Builder<
      TConfig & TKeysConfig,
      TContext & TKeysContext,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >({
      ...this.#buildState,
      keysCapability,
    });
  }

  withSubmission<TSubmissionConfig, TSubmissionContext extends Partial<RunningV1Variant.AnyContext>>(
    submissionService: (
      config: TSubmissionConfig,
      getContext: () => TSubmissionContext,
    ) => SubmissionService<TTransaction>,
  ): V1Builder<
    TConfig & TSubmissionConfig,
    TContext & TSubmissionContext,
    TSerialized,
    TSyncUpdate,
    TTransaction,
    TStartAux
  > {
    return new V1Builder<
      TConfig & TSubmissionConfig,
      TContext & TSubmissionContext,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >({
      ...this.#buildState,
      submissionService,
    });
  }

  withSubmissionDefaults(
    this: V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, FinalizedTransaction, TStartAux>,
  ): V1Builder<
    TConfig & DefaultSubmissionConfiguration,
    TContext,
    TSerialized,
    TSyncUpdate,
    FinalizedTransaction,
    TStartAux
  > {
    return this.withSubmission(makeDefaultSubmissionService);
  }

  build(
    this: V1Builder<
      TConfig,
      RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction, TStartAux>,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >,
    configuration: TConfig,
  ): V1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux> {
    const v1Context = this.#buildContextFromBuildState(configuration);
    return {
      __polyTag__: V1Tag,
      coinsAndBalances: v1Context.coinsAndBalancesCapability,
      keys: v1Context.keysCapability,
      serialization: v1Context.serializationCapability,
      start(
        context: Variant.VariantContext<DustCoreWallet>,
      ): Effect.Effect<
        RunningV1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux>,
        WalletRuntimeError,
        Scope.Scope
      > {
        return Effect.gen(function* () {
          yield* Effect.addFinalizer(() => v1Context.submissionService.close());
          const scope = yield* Scope.Scope;
          return new RunningV1Variant(scope, context, v1Context);
        });
      },
      migrateState(prevState) {
        // TODO: re-implement
        return Effect.succeed(prevState);
      },
      deserializeState: (serialized: TSerialized): Either.Either<DustCoreWallet, WalletError.WalletError> => {
        return v1Context.serializationCapability.deserialize(null, serialized);
      },
    };
  }

  #buildContextFromBuildState(
    this: V1Builder<
      TConfig,
      RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction, TStartAux>,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >,
    configuration: TConfig,
  ): RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction, TStartAux> {
    if (!isBuildStateFull(this.#buildState)) {
      throw new Error('Not all components are configured in V1 Builder');
    }

    const {
      syncCapability,
      syncService,
      transactingCapability,
      serializationCapability,
      provingService,
      coinSelection,
      coinsAndBalancesCapability,
      keysCapability,
      submissionService,
    } = this.#buildState;

    const getContext = (): RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction, TStartAux> => context;

    const context = {
      serializationCapability: serializationCapability(configuration, getContext),
      syncCapability: syncCapability(configuration, getContext),
      syncService: syncService(configuration, getContext),
      transactingCapability: transactingCapability(configuration, getContext),
      coinsAndBalancesCapability: coinsAndBalancesCapability(configuration, getContext),
      keysCapability: keysCapability(configuration, getContext),
      provingService: provingService(configuration, getContext),
      coinSelection: coinSelection(configuration, getContext),
      submissionService: submissionService(configuration, getContext),
    };

    return context;
  }
}

/** @internal */
declare namespace V1Builder {
  type HasSync<TConfig, TContext, TSyncUpdate, TStartAux> = {
    readonly syncService: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => SyncService<DustCoreWallet, TStartAux, TSyncUpdate>;
    readonly syncCapability: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => SyncCapability<DustCoreWallet, TSyncUpdate>;
  };

  type HasTransacting<TConfig, TContext, TTransaction> = {
    readonly transactingCapability: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => TransactingCapability<DustSecretKey, DustCoreWallet, TTransaction>;
  };

  type HasSerialization<TConfig, TContext, TSerialized> = {
    readonly serializationCapability: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => SerializationCapability<DustCoreWallet, null, TSerialized>;
  };

  type HasCoinSelection<TConfig, TContext> = {
    readonly coinSelection: (configuration: TConfig, getContext: () => TContext) => CoinSelection<DustToken>;
  };

  type HasProving<TConfig, TContext, TTransaction> = {
    readonly provingService: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => Proving.ProvingService<TTransaction>;
  };

  type HasCoinsAndBalances<TConfig, TContext> = {
    readonly coinsAndBalancesCapability: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => CoinsAndBalancesCapability<DustCoreWallet>;
  };

  type HasKeys<TConfig, TContext> = {
    readonly keysCapability: (configuration: TConfig, getContext: () => TContext) => KeysCapability<DustCoreWallet>;
  };

  type HasSubmission<TConfig, TContext, TTransaction> = {
    readonly submissionService: (configuration: TConfig, getContext: () => TContext) => SubmissionService<TTransaction>;
  };

  /**
   * The internal build state of {@link V1Builder}.
   */
  type FullBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux> = Types.Simplify<
    HasSync<TConfig, TContext, TSyncUpdate, TStartAux> &
      HasSerialization<TConfig, TContext, TSerialized> &
      HasTransacting<TConfig, TContext, TTransaction> &
      HasCoinSelection<TConfig, TContext> &
      HasProving<TConfig, TContext, TTransaction> &
      HasSubmission<TConfig, TContext, TTransaction> &
      HasCoinsAndBalances<TConfig, TContext> &
      HasKeys<TConfig, TContext>
  >;
  type PartialBuildState<
    TConfig = object,
    TContext = object,
    TSerialized = never,
    TSyncUpdate = never,
    TTransaction = never,
    TStartAux = object,
  > = {
    [K in keyof FullBuildState<never, never, never, never, never, never>]?:
      | FullBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>[K]
      | undefined;
  };

  /**
   * Utility interface that manages the type variance of {@link V1Builder}.
   */
  interface Variance<R> {
    readonly [V1BuilderSymbol.typeId]: {
      readonly _R: Types.Covariant<R>;
    };
  }
}

const isBuildStateFull = <TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>(
  buildState: V1Builder.PartialBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>,
): buildState is V1Builder.FullBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux> => {
  const allBuildStateKeys = [
    'syncService',
    'syncCapability',
    'transactingCapability',
    'coinSelection',
    'serializationCapability',
    'provingService',
    'coinsAndBalancesCapability',
    'keysCapability',
    'submissionService',
  ] as const;
  /**
   * This type will fail compilation if any key is omitted, letting the `isFull` check work properly
   */
  type _1 = Expect<
    Types.Equals<
      keyof V1Builder.FullBuildState<never, never, never, never, never, never>,
      ItemType<typeof allBuildStateKeys>
    >
  >;
  return allBuildStateKeys.every((key) => typeof buildState[key] == 'function');
};

================
File: packages/dust-wallet/test/DustWallet.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { expect, vi } from 'vitest';
import { beforeEach, describe, it } from '@vitest/runner';
import { Effect, Scope, SubscriptionRef, Stream } from 'effect';
import {
  DustSecretKey,
  Intent,
  LedgerParameters,
  Transaction,
  UnshieldedOffer,
  UserAddress,
  ProofErasedTransaction,
  nativeToken,
} from '@midnight-ntwrk/ledger-v6';
import { DustAddress } from '@midnight-ntwrk/wallet-sdk-address-format';
import { DateOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import { Proving, ProvingRecipe } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import { createUnshieldedKeystore, UnshieldedKeystore } from './UnshieldedKeyStore.js';
import { getDustSeed } from './utils.js';
import { UtxoWithMeta, V1Builder, Transacting, DustCoreWallet, V1Variant, RunningV1Variant } from '../src/index.js';
import { Simulator, SimulatorState } from '../src/Simulator.js';
import { makeSimulatorSyncCapability, makeSimulatorSyncService, SimulatorSyncUpdate } from '../src/Sync.js';
import * as Submission from '../src/Submission.js';

vi.setConfig({ testTimeout: 1 * 1000 });

const NIGHT_TOKEN_TYPE = nativeToken().raw;
const SEED = '0000000000000000000000000000000000000000000000000000000000000001';
const SEED_BOB = '0000000000000000000000000000000000000000000000000000000000000002';
const NETWORK = 'undeployed';

const getNightTokens = (state: SimulatorState, walletAddress: UserAddress) => {
  const utxos = state.ledger.utxo.filter(walletAddress);
  return [...utxos].filter((utxo) => utxo.type === NIGHT_TOKEN_TYPE);
};

const getNightTokensWithMeta = (state: SimulatorState, walletAddress: UserAddress): Array<UtxoWithMeta> => {
  const utxos = state.ledger.utxo.filter(walletAddress);
  const result: Array<UtxoWithMeta> = [];
  for (const utxo of utxos) {
    if (utxo.type === NIGHT_TOKEN_TYPE) {
      const meta = state.ledger.utxo.lookupMeta(utxo);
      if (meta) {
        result.push({ ...utxo, ctime: meta.ctime });
      }
    }
  }
  return result;
};

const toTxTime = (secs: number | bigint): Date => new Date(Number(secs) * 1000);

const getCurrentTime = (simulatorState: SimulatorState) => DateOps.addSeconds(toTxTime(simulatorState.lastTxNumber), 1);

const waitForTx = (stateRef: SubscriptionRef.SubscriptionRef<DustCoreWallet>, txTime: number) => {
  const stream = stateRef.changes.pipe(Stream.find((val) => val.progress.appliedIndex === BigInt(txTime)));
  return Stream.runLast(stream);
};

type WalletVariant = V1Variant<string, SimulatorSyncUpdate, ProofErasedTransaction, DustSecretKey>;
type RunningWallet = RunningV1Variant<string, SimulatorSyncUpdate, ProofErasedTransaction, DustSecretKey>;

describe('DustWallet', () => {
  const costParameters = {
    additionalFeeOverhead: 300_000_000_000_000n,
    feeBlocksMargin: 5,
  };
  const dustParameters = LedgerParameters.initialParameters().dust;
  let walletVariant: WalletVariant;
  let wallet: RunningWallet;
  let stateRef: SubscriptionRef.SubscriptionRef<DustCoreWallet>;
  let simulator: Simulator;
  let keyStore: UnshieldedKeystore;

  const registerNightTokens = (wallet: RunningWallet, nightTokens: Array<UtxoWithMeta>, nightVerifyingKey: string) => {
    return Effect.gen(function* () {
      const lastState = yield* SubscriptionRef.get(stateRef);
      const simulatorState = yield* simulator.getLatestState();
      const currentTime = getCurrentTime(simulatorState);
      const ttl = DateOps.addSeconds(currentTime, 1);

      const registerForDustTransaction = yield* wallet.createDustGenerationTransaction(
        currentTime,
        ttl,
        nightTokens,
        nightVerifyingKey,
        DustAddress.encodePublicKey(NETWORK, lastState.publicKey.publicKey),
      );

      const intent = registerForDustTransaction.intents!.get(1);
      const intentSignatureData = intent!.signatureData(1);
      const signature = keyStore.signData(intentSignatureData);
      const recipe = (yield* wallet.addDustGenerationSignature(
        registerForDustTransaction,
        signature,
      )) as ProvingRecipe.TransactionToProve;
      expect(recipe.type).toEqual(ProvingRecipe.TRANSACTION_TO_PROVE);

      const signedTransaction = {
        type: ProvingRecipe.NOTHING_TO_PROVE as typeof ProvingRecipe.NOTHING_TO_PROVE,
        transaction: recipe.transaction.eraseProofs(),
      };
      const transaction = yield* wallet.finalizeTransaction(signedTransaction);
      const result = yield* wallet.submitTransaction(transaction);
      const latestSimulatorState = yield* simulator.getLatestState();
      expect(result.blockHeight).toBe(latestSimulatorState.lastTxNumber);
      expect(latestSimulatorState.lastTxResult?.type).toBe('success');
      return result;
    });
  };

  const deregisterNightTokens = (
    wallet: RunningWallet,
    nightTokens: Array<UtxoWithMeta>,
    nightVerifyingKey: string,
    dustSecretKey: DustSecretKey,
  ) => {
    return Effect.gen(function* () {
      const simulatorState = yield* simulator.getLatestState();
      const currentTime = getCurrentTime(simulatorState);
      const ttl = DateOps.addSeconds(currentTime, 1);

      const registerForDustTransaction = yield* wallet.createDustGenerationTransaction(
        currentTime,
        ttl,
        nightTokens,
        nightVerifyingKey,
        undefined,
      );

      const feeRecipe = (yield* wallet.addFeePayment(
        dustSecretKey,
        registerForDustTransaction,
        ttl,
        currentTime,
      )) as ProvingRecipe.TransactionToProve;

      const intent = feeRecipe.transaction.intents!.get(1);
      const intentSignatureData = intent!.signatureData(1);
      const signature = keyStore.signData(intentSignatureData);
      const recipeWithSignature = (yield* wallet.addDustGenerationSignature(
        feeRecipe.transaction,
        signature,
      )) as ProvingRecipe.TransactionToProve;
      expect(recipeWithSignature.type).toEqual(ProvingRecipe.TRANSACTION_TO_PROVE);

      const signedTransaction = {
        type: ProvingRecipe.NOTHING_TO_PROVE as typeof ProvingRecipe.NOTHING_TO_PROVE,
        transaction: recipeWithSignature.transaction.eraseProofs(),
      };
      const transaction = yield* wallet.finalizeTransaction(signedTransaction);
      const result = yield* wallet.submitTransaction(transaction);
      const latestSimulatorState = yield* simulator.getLatestState();
      expect(result.blockHeight).toBe(latestSimulatorState.lastTxNumber);
      expect(latestSimulatorState.lastTxResult?.type).toBe('success');
      return result;
    });
  };

  beforeEach(async () =>
    Effect.gen(function* () {
      const dustSeed = getDustSeed(SEED);
      keyStore = createUnshieldedKeystore(dustSeed);
      const dustSecretKey = DustSecretKey.fromSeed(keyStore.getSecretKey());
      const scope = yield* Scope.make();

      simulator = yield* Simulator.init(NETWORK).pipe(Effect.provideService(Scope.Scope, scope));

      walletVariant = new V1Builder()
        .withTransactionType<ProofErasedTransaction>()
        .withProving(Proving.makeSimulatorProvingService)
        .withCoinSelectionDefaults()
        .withTransacting(Transacting.makeSimulatorTransactingCapability)
        .withSync(makeSimulatorSyncService, makeSimulatorSyncCapability)
        .withCoinsAndBalancesDefaults()
        .withKeysDefaults()
        .withSubmission(Submission.makeSimulatorSubmissionService())
        .withSerializationDefaults()
        .build({
          simulator,
          networkId: NETWORK,
          costParameters,
        });

      const initialState = DustCoreWallet.initEmpty(dustParameters, dustSecretKey, NETWORK);
      stateRef = yield* SubscriptionRef.make(initialState);
      wallet = yield* walletVariant.start({ stateRef }).pipe(Effect.provideService(Scope.Scope, scope));
      yield* wallet.startSyncInBackground(dustSecretKey);
    }).pipe(Effect.scoped, Effect.runPromise),
  );

  it('should build', async () => {
    return Effect.gen(function* () {
      const lastState = yield* SubscriptionRef.get(stateRef);
      expect(lastState).toBeTruthy();
    }).pipe(Effect.runPromise);
  });

  it('should get the night tokens', async () => {
    return Effect.gen(function* () {
      const nightVerifyingKey = keyStore.getPublicKey();
      const walletAddress = keyStore.getAddress();
      const awardTokens = 150_000n;

      const rewardNight = yield* simulator.rewardNight(walletAddress, awardTokens, nightVerifyingKey);
      const simulatorState = yield* simulator.getLatestState();
      expect(rewardNight.blockNumber).toBe(1n);
      expect(simulatorState.lastTxNumber).toBe(1n);
      expect(simulatorState.lastTxResult!.type).toBe('success');

      const nightTokens = getNightTokens(yield* simulator.getLatestState(), walletAddress);
      yield* waitForTx(stateRef, 1);

      expect(nightTokens.length).toBe(1);
      expect(nightTokens[0].value).toBe(awardTokens);
    }).pipe(Effect.runPromise);
  });

  it('should register the night tokens', async () => {
    return Effect.gen(function* () {
      const nightVerifyingKey = keyStore.getPublicKey();
      const walletAddress = keyStore.getAddress();
      const awardTokens = 150_000_000_000n;

      // reward & claim Night tokens
      const rewardNight = yield* simulator.rewardNight(walletAddress, awardTokens, nightVerifyingKey);
      expect(rewardNight.blockNumber).toBe(1n);
      yield* waitForTx(stateRef, 1);

      let latestState = yield* SubscriptionRef.get(stateRef);
      const walletBalance = walletVariant.coinsAndBalances.getWalletBalance(latestState, toTxTime(1));
      expect(walletBalance).toEqual(0n);

      const simulatorState = yield* simulator.getLatestState();
      const nightTokens = getNightTokensWithMeta(simulatorState, walletAddress);
      expect(nightTokens.length).toBe(1);

      // register Night tokens
      yield* registerNightTokens(wallet, nightTokens, nightVerifyingKey);
      yield* waitForTx(stateRef, 2);

      latestState = yield* SubscriptionRef.get(stateRef);
      const newWalletBalance = walletVariant.coinsAndBalances.getWalletBalance(latestState, toTxTime(3));
      expect(newWalletBalance).toBe(1_240_050_000_000_000n);
    }).pipe(Effect.runPromise);
  });

  it('should get the right Dust balances', async () => {
    return Effect.gen(function* () {
      const nightVerifyingKey = keyStore.getPublicKey();
      const walletAddress = keyStore.getAddress();
      const awardTokens = 150_000_000_000n;

      // reward & claim Night tokens
      const rewardNight = yield* simulator.rewardNight(walletAddress, awardTokens, nightVerifyingKey);
      expect(rewardNight.blockNumber).toBe(1n);
      yield* waitForTx(stateRef, 1);

      const simulatorState = yield* simulator.getLatestState();
      const nightTokens = getNightTokensWithMeta(simulatorState, walletAddress);
      expect(nightTokens.length).toBe(1);

      // register Night tokens
      yield* registerNightTokens(wallet, nightTokens, nightVerifyingKey);
      yield* waitForTx(stateRef, 2);

      const latestState = yield* SubscriptionRef.get(stateRef);

      const availableCoins = walletVariant.coinsAndBalances.getAvailableCoins(latestState);
      expect(availableCoins.length).toBe(1);
      expect(DateOps.dateToSeconds(availableCoins.at(0)!.ctime)).toBe(2n);

      const pendingCoins = walletVariant.coinsAndBalances.getPendingCoins(latestState);
      expect(pendingCoins.length).toBe(0);

      const generationInfo = walletVariant.coinsAndBalances.getGenerationInfo(latestState, availableCoins.at(0)!);
      expect(generationInfo?.value).toBe(awardTokens);
    }).pipe(Effect.runPromise);
  });

  it('should allow spending Dust tokens', async () => {
    return Effect.gen(function* () {
      const nightVerifyingKey = keyStore.getPublicKey();
      const dustSecretKey = DustSecretKey.fromSeed(keyStore.getSecretKey());
      const walletAddress = keyStore.getAddress();
      const awardTokens = 150_000_000_000n;

      // reward & claim Night tokens
      const rewardNight = yield* simulator.rewardNight(walletAddress, awardTokens, nightVerifyingKey);
      expect(rewardNight.blockNumber).toBe(1n);
      yield* waitForTx(stateRef, 1);

      let simulatorState = yield* simulator.getLatestState();
      const nightTokensWithMeta = getNightTokensWithMeta(simulatorState, walletAddress);
      expect(nightTokensWithMeta.length).toBe(1);

      // register Night tokens
      yield* registerNightTokens(wallet, nightTokensWithMeta, nightVerifyingKey);
      yield* waitForTx(stateRef, 2);

      // get more night tokens with a different amount
      const newNightTokenAmount = 160_000_000_000n;
      const rewardNight2 = yield* simulator.rewardNight(walletAddress, newNightTokenAmount, nightVerifyingKey);
      expect(rewardNight2.blockNumber).toBe(3n);
      simulatorState = yield* simulator.getLatestState();
      expect(simulatorState.lastTxResult!.type).toBe('success');
      yield* waitForTx(stateRef, 3);

      const walletState = yield* SubscriptionRef.get(stateRef);
      const availableCoins = walletVariant.coinsAndBalances.getAvailableCoins(walletState);
      expect(availableCoins.length).toBe(2);

      // send one token to Bob
      const nightTokens = getNightTokens(simulatorState, walletAddress);
      const sendToken = nightTokens.find((val) => val.value === awardTokens);
      expect(sendToken).toBeDefined();

      const bobKeyStore = createUnshieldedKeystore(getDustSeed(SEED_BOB));
      const bobAddress = bobKeyStore.getAddress();

      const inputs = [
        {
          ...sendToken!,
          owner: nightVerifyingKey,
        },
      ];
      const outputs = [
        {
          type: NIGHT_TOKEN_TYPE,
          owner: bobAddress,
          value: sendToken!.value,
        },
      ];
      const currentTime = getCurrentTime(simulatorState);
      const ttl = DateOps.addSeconds(currentTime, 1);
      const intent = Intent.new(ttl);
      intent.guaranteedUnshieldedOffer = UnshieldedOffer.new(inputs, outputs, []);
      const transferTransaction = Transaction.fromParts(NETWORK, undefined, undefined, intent);

      // cover fees with dust
      const transactionWithFee = (yield* wallet.addFeePayment(
        dustSecretKey,
        transferTransaction,
        ttl,
        currentTime,
      )) as ProvingRecipe.TransactionToProve;
      const transaction = yield* wallet.finalizeTransaction({
        type: ProvingRecipe.NOTHING_TO_PROVE as typeof ProvingRecipe.NOTHING_TO_PROVE,
        transaction: transactionWithFee.transaction.eraseProofs(),
      });

      yield* wallet.submitTransaction(transaction);
      yield* waitForTx(stateRef, 4);

      simulatorState = yield* simulator.getLatestState();
      expect(simulatorState.lastTxResult?.type).toBe('success');

      const latestState = yield* SubscriptionRef.get(stateRef);
      const newAvailableCoins = walletVariant.coinsAndBalances.getAvailableCoins(latestState);
      const generationInfo = walletVariant.coinsAndBalances.getGenerationInfo(
        latestState,
        newAvailableCoins.find((c) => c.seq === 0)!,
      );
      expect(newAvailableCoins.length).toBe(2);
      expect(newAvailableCoins.some((coin) => DateOps.dateToSeconds(coin.ctime) === 4n)).toBe(true);
      expect(generationInfo?.dtime).toStrictEqual(DateOps.secondsToDate(4n));

      const pendingCoins = walletVariant.coinsAndBalances.getPendingCoins(latestState);
      expect(pendingCoins.length).toBe(0);
    }).pipe(Effect.runPromise);
  });

  it('spend the only Dust token', async () => {
    return Effect.gen(function* () {
      const nightVerifyingKey = keyStore.getPublicKey();
      const dustSecretKey = DustSecretKey.fromSeed(keyStore.getSecretKey());
      const walletAddress = keyStore.getAddress();
      const awardTokens = 150_000_000_000_000n;

      // reward & claim Night tokens
      const rewardNight = yield* simulator.rewardNight(walletAddress, awardTokens, nightVerifyingKey);
      expect(rewardNight.blockNumber).toBe(1n);
      yield* waitForTx(stateRef, 1);

      let simulatorState = yield* simulator.getLatestState();
      const nightTokensWithMeta = getNightTokensWithMeta(simulatorState, walletAddress);
      expect(nightTokensWithMeta.length).toBe(1);

      // register Night tokens
      yield* registerNightTokens(wallet, nightTokensWithMeta, nightVerifyingKey);
      yield* waitForTx(stateRef, 2);

      let walletState = yield* SubscriptionRef.get(stateRef);
      const availableCoins = walletVariant.coinsAndBalances.getAvailableCoins(walletState);
      expect(availableCoins.length).toBe(1);

      // add more time to generate dust
      yield* simulator.fastForward(10n);

      // send one token to Bob
      simulatorState = yield* simulator.getLatestState();
      const nightTokens = getNightTokens(simulatorState, walletAddress);
      const sendToken = nightTokens.find((val) => val.value === awardTokens);
      expect(sendToken).toBeDefined();

      const bobKeyStore = createUnshieldedKeystore(getDustSeed(SEED_BOB));
      const bobAddress = bobKeyStore.getAddress();

      const inputs = [
        {
          ...sendToken!,
          owner: nightVerifyingKey,
        },
      ];
      const outputs = [
        {
          type: NIGHT_TOKEN_TYPE,
          owner: bobAddress,
          value: sendToken!.value,
        },
      ];
      const currentTime = getCurrentTime(simulatorState);
      const ttl = DateOps.addSeconds(currentTime, 1);
      const intent = Intent.new(ttl);
      intent.guaranteedUnshieldedOffer = UnshieldedOffer.new(inputs, outputs, []);
      const transferTransaction = Transaction.fromParts(NETWORK, undefined, undefined, intent);

      walletState = yield* SubscriptionRef.get(stateRef);

      // capture fees
      const totalFee = yield* wallet.calculateFee(transferTransaction);
      const walletBalance = walletVariant.coinsAndBalances.getWalletBalance(
        walletState,
        getCurrentTime(simulatorState),
      );
      expect(totalFee).toBeGreaterThan(0n);

      // cover fees with dust
      const transactionWithFee = (yield* wallet.addFeePayment(
        dustSecretKey,
        transferTransaction,
        ttl,
        currentTime,
      )) as ProvingRecipe.TransactionToProve;
      const transaction = yield* wallet.finalizeTransaction({
        type: ProvingRecipe.NOTHING_TO_PROVE as typeof ProvingRecipe.NOTHING_TO_PROVE,
        transaction: transactionWithFee.transaction.eraseProofs(),
      });

      // validate fee imbalance
      expect(Transacting.TransactingCapabilityImplementation.feeImbalance(transaction, totalFee)).toBe(0n);

      yield* wallet.submitTransaction(transaction);
      yield* waitForTx(stateRef, 11);

      walletState = yield* SubscriptionRef.get(stateRef);
      simulatorState = yield* simulator.getLatestState();
      expect(simulatorState.lastTxResult?.type).toBe('success');

      const lastTxNumber = Number(simulatorState.lastTxNumber);
      const newAvailableCoins = walletVariant.coinsAndBalances.getAvailableCoinsWithFullInfo(
        walletState,
        toTxTime(lastTxNumber),
      );
      expect(newAvailableCoins.length).toBe(1);
      expect(newAvailableCoins[0].dtime).toStrictEqual(DateOps.secondsToDate(lastTxNumber));

      // validate wallet balance changed to balance_now = balance_before - tx_fee
      expect(walletVariant.coinsAndBalances.getWalletBalance(walletState, toTxTime(lastTxNumber))).toBe(
        walletBalance - totalFee,
      );

      // validate it decays properly
      expect(walletVariant.coinsAndBalances.getWalletBalance(walletState, toTxTime(lastTxNumber + 1))).toBe(
        walletBalance - totalFee - newAvailableCoins[0].rate,
      );

      // validate at the maxCapReachedAt the balance will be 0
      expect(walletVariant.coinsAndBalances.getWalletBalance(walletState, newAvailableCoins[0].maxCapReachedAt)).toBe(
        0n,
      );

      // check there are no pending tokens left
      const pendingCoins = walletVariant.coinsAndBalances.getPendingCoins(walletState);
      expect(pendingCoins.length).toBe(0);
    }).pipe(Effect.runPromise);
  });

  it('deregister from Dust generation', async () => {
    return Effect.gen(function* () {
      const nightVerifyingKey = keyStore.getPublicKey();
      const dustSecretKey = DustSecretKey.fromSeed(keyStore.getSecretKey());
      const walletAddress = keyStore.getAddress();
      const awardTokens = 150_000_000_000_000n;

      // reward & claim Night tokens
      const rewardNight = yield* simulator.rewardNight(walletAddress, awardTokens, nightVerifyingKey);
      expect(rewardNight.blockNumber).toBe(1n);
      yield* waitForTx(stateRef, 1);

      let simulatorState = yield* simulator.getLatestState();
      const nightTokensWithMeta = getNightTokensWithMeta(simulatorState, walletAddress);
      expect(nightTokensWithMeta.length).toBe(1);

      // register Night tokens
      yield* registerNightTokens(wallet, nightTokensWithMeta, nightVerifyingKey);
      yield* waitForTx(stateRef, 2);

      let walletState = yield* SubscriptionRef.get(stateRef);
      const availableCoins = walletVariant.coinsAndBalances.getAvailableCoins(walletState);
      expect(availableCoins.length).toBe(1);

      // add more time to generate dust
      yield* simulator.fastForward(10n);
      simulatorState = yield* simulator.getLatestState();

      // address_delegation should be not empty
      expect(simulatorState.ledger.dust.toString().includes('address_delegation: {}')).toBeFalsy();

      // deregister Night tokens from dust generation
      // NOTE: to only unregister the address, set the night tokens param to []
      yield* deregisterNightTokens(
        wallet,
        getNightTokensWithMeta(simulatorState, walletAddress),
        nightVerifyingKey,
        dustSecretKey,
      );
      yield* waitForTx(stateRef, 11);

      walletState = yield* SubscriptionRef.get(stateRef);
      simulatorState = yield* simulator.getLatestState();

      const newAvailableCoins = walletVariant.coinsAndBalances.getAvailableCoinsWithFullInfo(
        walletState,
        toTxTime(simulatorState.lastTxNumber),
      );
      expect(newAvailableCoins.length).toBe(1);
      expect(newAvailableCoins[0].dtime).toStrictEqual(DateOps.secondsToDate(simulatorState.lastTxNumber));

      // address_delegation should be empty
      expect(simulatorState.ledger.dust.toString()).toMatch(/address_delegation: {},/);
    }).pipe(Effect.runPromise);
  });
});

================
File: packages/e2e-tests/src/tests/balanceConstant.remote.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { TestContainersFixture, useTestContainersFixture } from './test-fixture.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import * as utils from './utils.js';
import { logger } from './logger.js';
import { exit } from 'node:process';
import * as allure from 'allure-js-commons';
import { WalletFacade } from '@midnight-ntwrk/wallet-sdk-facade';

/**
 * Tests checking balance is constant
 *
 * @group devnet
 * @group testnet
 */

describe('Balance constant', () => {
  if (process.env['SEED_STABLE'] === undefined) {
    logger.info('SEED_STABLE not set');
    exit(1);
  }
  const getFixture = useTestContainersFixture();
  const seed = process.env['SEED_STABLE'];
  const shieldedTokenRaw = ledger.shieldedToken().raw;
  const unshieldedTokenRaw = ledger.unshieldedToken().raw;
  const nativeTokenHash = '02000000000000000000000000000000000000000000000000000000000000000001';
  const nativeTokenHash2 = '02000000000000000000000000000000000000000000000000000000000000000002';
  const expectedShieldedBalance = 100_000_000n;
  const expectedTokenOneBalance = 25n;
  const expectedTokenTwoBalance = 50n;
  const expectedUnshieldedBalance = 100_000_000n;
  const expectedDustBalance = expectedShieldedBalance;
  const filename = `stable-${seed.substring(seed.length - 7)}-${TestContainersFixture.network}.state`;
  const syncTimeout = TestContainersFixture.network === 'testnet' ? 3_000_000 : 1_800_000;
  const shieldedSecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(seed));
  const dustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(seed));

  let walletFacade: WalletFacade;

  beforeEach(async () => {
    const fixture = getFixture();

    walletFacade = utils.buildWalletFacade(seed, fixture);
    await walletFacade.start(shieldedSecretKey, dustSecretKey);
  }, syncTimeout);

  afterEach(async () => {
    await utils.saveState(walletFacade, filename);
    await utils.closeWallet(walletFacade);
  });

  test(
    'Balance is constant when syncing from 0 @healthcheck',
    async () => {
      allure.tag('healthcheck');
      allure.tms('PM-13614', 'PM-13614');
      allure.epic('Headless wallet');
      allure.feature('Balance');
      allure.story('Balance constant when syncing from 0');

      const syncedState = await utils.waitForSyncFacade(walletFacade);
      // logger.info(walletStateTrimmed(syncedState));
      expect(syncedState.shielded.balances[shieldedTokenRaw] ?? 0n).toBe(expectedShieldedBalance);
      expect(syncedState.shielded.balances[nativeTokenHash] ?? 0n).toBe(expectedTokenOneBalance);
      expect(syncedState.shielded.balances[nativeTokenHash2] ?? 0n).toBe(expectedTokenTwoBalance);
      expect(syncedState.unshielded.balances[unshieldedTokenRaw] ?? 0n).toBe(expectedUnshieldedBalance);
      expect(syncedState.dust.walletBalance(new Date())).toBe(expectedDustBalance);
      expect(syncedState.shielded.availableCoins.length).toBeGreaterThanOrEqual(3);
      expect(syncedState.shielded.pendingCoins.length).toBe(0);
      expect(syncedState.shielded.totalCoins).toBeGreaterThanOrEqual(3);
      expect(syncedState.shielded.transactionHistory.length).toBeGreaterThanOrEqual(2);
    },
    syncTimeout,
  );

  test(
    'Balance is constant when syncing from a restored state @healthcheck',
    async () => {
      allure.tag('healthcheck');
      allure.tms('PM-13615', 'PM-13615');
      allure.epic('Headless wallet');
      allure.feature('Wallet state');
      allure.story('Balance constant');

      const syncedState = await utils.waitForSyncFacade(walletFacade);
      expect(syncedState.shielded.balances[shieldedTokenRaw] ?? 0n).toBe(expectedDustBalance);
      expect(syncedState.shielded.balances[nativeTokenHash] ?? 0n).toBe(expectedTokenOneBalance);
      expect(syncedState.shielded.balances[nativeTokenHash2] ?? 0n).toBe(expectedTokenTwoBalance);
      expect(syncedState.unshielded.balances[unshieldedTokenRaw] ?? 0n).toBe(expectedUnshieldedBalance);
      expect(syncedState.dust.walletBalance(new Date())).toBe(expectedDustBalance);
      expect(syncedState.shielded.availableCoins.length).toBeGreaterThanOrEqual(3);
      expect(syncedState.shielded.pendingCoins.length).toBe(0);
      expect(syncedState.shielded.totalCoins).toBeGreaterThanOrEqual(3);
      expect(syncedState.shielded.transactionHistory.length).toBeGreaterThanOrEqual(2);
    },
    syncTimeout,
  );
});

================
File: packages/e2e-tests/src/tests/balancing.undeployed.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { TestContainersFixture, useTestContainersFixture } from './test-fixture.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import * as utils from './utils.js';
import { logger } from './logger.js';
import { randomBytes } from 'node:crypto';
import * as allure from 'allure-js-commons';
import { CombinedTokenTransfer, WalletFacade } from '@midnight-ntwrk/wallet-sdk-facade';

/**
 * Tests checking transaction balancing
 *
 * @group undeployed
 */

describe('Transaction balancing examples', () => {
  const getFixture = useTestContainersFixture();
  const senderSeed = randomBytes(32).toString('hex');
  const fundedSeed = '0000000000000000000000000000000000000000000000000000000000000001';
  const fundedShieldedSecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(fundedSeed));
  const senderShieldedSecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(senderSeed));
  const fundedDustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(fundedSeed));
  const senderDustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(senderSeed));
  const timeout = 600_000;

  let fundedFacade: WalletFacade;
  let senderFacade: WalletFacade;
  let receiver1: WalletFacade;
  let receiver2: WalletFacade;
  let receiver3: WalletFacade;
  let fixture: TestContainersFixture;
  const shieldedTokenRaw = ledger.shieldedToken().raw;
  const nativeTokenRaw1 = '0000000000000000000000000000000000000000000000000000000000000001';
  const nativeTokenRaw2 = '0000000000000000000000000000000000000000000000000000000000000002';

  const output100 = 100_000_000n;
  const output50 = 50_000_000n;
  const output30 = 30_000_000n;

  beforeEach(async () => {
    await allure.step('Distribute coins to sender', async function () {
      fixture = getFixture();
      fundedFacade = utils.buildWalletFacade(fundedSeed, fixture);
      await fundedFacade.start(fundedShieldedSecretKey, fundedDustSecretKey);

      const initialState = await utils.waitForSyncFacade(fundedFacade);
      const sendTx = async (address: string): Promise<void> => {
        const initialBalance = initialState.shielded.balances[shieldedTokenRaw] ?? 0n;
        const initialBalanceNative = initialState.shielded.balances[nativeTokenRaw1] ?? 0n;
        const initialBalanceNative2 = initialState.shielded.balances[nativeTokenRaw2] ?? 0n;
        const initialDustBalance = initialState.dust.walletBalance(new Date());
        logger.info(`Funded Wallet: ${initialDustBalance} tDUST`);
        logger.info(`Funded Wallet: ${initialBalance} shielded tokens`);
        logger.info(`Funded Wallet: ${initialBalanceNative} native tokens 1`);
        logger.info(`Funded Wallet: ${initialBalanceNative2} native tokens 2`);
        logger.info(`Funded Wallet available coins: ${initialState.shielded.availableCoins.length}`);
        logger.info(
          `Sending ${output100 / 1_000_000n} shielded tokens ${shieldedTokenRaw}, ${output50 / 1_000_000n} ${nativeTokenRaw1} and ${
            output30 / 1_000_000n
          }, ${nativeTokenRaw2} to address: ${address}`,
        );

        const outputsToCreate: CombinedTokenTransfer[] = [
          {
            type: 'shielded',
            outputs: [
              {
                type: shieldedTokenRaw,
                amount: output100,
                receiverAddress: address,
              },
              {
                type: nativeTokenRaw1,
                amount: output50,
                receiverAddress: address,
              },
              {
                type: nativeTokenRaw2,
                amount: output30,
                receiverAddress: address,
              },
            ],
          },
        ];

        const txToProve = await fundedFacade.transferTransaction(
          fundedShieldedSecretKey,
          fundedDustSecretKey,
          outputsToCreate,
          new Date(Date.now() + 60 * 60 * 1000),
        );
        const provenTx = await fundedFacade.finalizeTransaction(txToProve);
        const id = await fundedFacade.submitTransaction(provenTx);
        logger.info('Transaction id: ' + id);

        await utils.waitForFacadePendingClear(fundedFacade);
        // await utils.waitForTxInHistory(String(id), fundedFacade.shielded);

        const finalState = await utils.waitForSyncFacade(fundedFacade);
        // logger.info(walletStateTrimmed(finalState));

        expect(finalState.shielded.balances[shieldedTokenRaw] ?? 0n).toBe(initialBalance - output100);
        expect(finalState.shielded.balances[nativeTokenRaw1] ?? 0n).toBe(initialBalanceNative - output50);
        expect(finalState.shielded.balances[nativeTokenRaw2] ?? 0n).toBe(initialBalanceNative2 - output30);
        expect(finalState.shielded.pendingCoins.length).toBe(0);
        // expect(finalState.shielded.transactionHistory.length).toBe(initialState.shielded.transactionHistory.length + 2);
        await utils.waitForFacadePendingClear(senderFacade);
      };
      senderFacade = utils.buildWalletFacade(senderSeed, fixture);
      await senderFacade.start(senderShieldedSecretKey, senderDustSecretKey);
      const state = await utils.waitForSyncFacade(senderFacade);
      const walletAddress = utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, state.shielded.address);
      await sendTx(walletAddress);
    });
  }, timeout);

  afterEach(async () => {
    await fundedFacade.stop();
    await senderFacade.stop();
  }, timeout);

  test(
    'tDUST transfer up to 2nd lowest native coin',
    async () => {
      allure.tms('PM-13746', 'PM-13746');
      allure.epic('Headless wallet');
      allure.feature('Transaction balancing');
      allure.story('tDUST transfer which uses the second lowest coin');

      const output35 = 35_000_000n;
      const receiver1Seed = randomBytes(32).toString('hex');
      const receiver1SecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(receiver1Seed));
      const receiver1DustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(receiver1Seed));

      receiver1 = utils.buildWalletFacade(receiver1Seed, fixture);
      await receiver1.start(receiver1SecretKey, receiver1DustSecretKey);

      const initialState = await utils.waitForSyncFacade(senderFacade);
      const initialDustBalance = initialState.dust.walletBalance(new Date(Date.now() + 60 * 60 * 1000));
      logger.info(initialState.shielded.balances);
      logger.info(`Wallet 1: ${initialDustBalance} tDUST`);
      logger.info(`Wallet 1 available coins: ${initialState.shielded.availableCoins.length}`);
      logger.info(initialState.shielded.availableCoins);

      const initialState2 = await utils.waitForSyncFacade(receiver1);
      const initialDustBalance2 = initialState2.dust.walletBalance(new Date());
      logger.info(`Wallet 2: ${initialDustBalance2} tDUST`);
      logger.info(`Wallet 2 available coins: ${initialState2.shielded.availableCoins.length}`);

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: nativeTokenRaw1,
              amount: output35,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState2.shielded.address),
            },
          ],
        },
      ];
      const txToProve = await senderFacade.transferTransaction(
        senderShieldedSecretKey,
        receiver1DustSecretKey,
        outputsToCreate,
        new Date(Date.now() + 60 * 60 * 1000),
      );
      const provenTx = await senderFacade.finalizeTransaction(txToProve);
      const txId = await senderFacade.submitTransaction(provenTx);
      logger.info('Transaction id: ' + txId);

      const pendingState = await utils.waitForPending(senderFacade.shielded);
      // logger.info(utils.walletStateTrimmed(pendingState));
      logger.info(`Wallet 1 available coins: ${pendingState.availableCoins.length}`);
      expect(pendingState.availableCoins.length).toBeLessThan(initialState.shielded.availableCoins.length);
      expect(pendingState.pendingCoins.length).toBeLessThanOrEqual(2);
      expect(pendingState.totalCoins).toBe(initialState.shielded.totalCoins);
      // expect(pendingState.nullifiers.length).toBe(initialState.nullifiers.length);
      expect(pendingState.transactionHistory.length).toBe(initialState.shielded.transactionHistory.length);

      // await utils.waitForTxInHistory(String(txId), senderFacade.shielded);
      const finalState = await utils.waitForSyncFacade(senderFacade);
      // logger.info(walletStateTrimmed(finalState));
      logger.info(`Wallet 1 available coins: ${finalState.shielded.availableCoins.length}`);
      logger.info(`Wallet 1: ${finalState.shielded.balances[shieldedTokenRaw]} shielded tokens`);
      logger.info(finalState.shielded.availableCoins);
      expect(finalState.shielded.balances[shieldedTokenRaw] ?? 0n).toBe(144840380n);
      expect(finalState.shielded.availableCoins.length).toBeLessThanOrEqual(
        initialState.shielded.availableCoins.length - 1,
      ); // Lowest available coin used up in transfer
      expect(finalState.shielded.pendingCoins.length).toBe(0);
      expect(finalState.shielded.totalCoins.length).toBe(initialState.shielded.totalCoins.length - 1);
      // expect(finalState.nullifiers.length).toBe(initialState.nullifiers.length - 1);
      expect(finalState.shielded.transactionHistory.length).toBeGreaterThanOrEqual(
        initialState.shielded.transactionHistory.length + 1,
      );

      // await utils.waitForTxInHistory(String(txId), receiver1.shielded);
      const finalState2 = await utils.waitForSyncShielded(receiver1.shielded);
      // logger.info(utils.walletStateTrimmed(finalState2));
      logger.info(`Wallet 2 available coins: ${finalState2.availableCoins.length}`);
      logger.info(`Wallet 2: ${finalState2.balances[shieldedTokenRaw]} shielded tokens`);
      logger.info(finalState2.availableCoins);
      expect(finalState2.balances[shieldedTokenRaw] ?? 0n).toBe(output35);
      // validateWalletTxHistory(finalState2, initialState2);

      await utils.closeWallet(receiver1);
    },
    timeout,
  );

  test(
    'tDUST transfer with lowest native coin',
    async () => {
      allure.tms('PM-13747', 'PM-13747');
      allure.epic('Headless wallet');
      allure.feature('Transaction balancing');
      allure.story('Native token transfer which uses the lowest coin');

      const output = 1n;
      const receiver1Seed = randomBytes(32).toString('hex');
      const receiver1SecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(receiver1Seed));
      const receiver1DustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(receiver1Seed));

      receiver1 = utils.buildWalletFacade(receiver1Seed, fixture);
      await receiver1.start(receiver1SecretKey, receiver1DustSecretKey);

      const initialState = await utils.waitForSyncFacade(senderFacade);
      const initialBalance = initialState.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(initialState.shielded.balances);
      logger.info(`Wallet 1: ${initialBalance}`);
      logger.info(`Wallet 1 available coins: ${initialState.shielded.availableCoins.length}`);
      logger.info(initialState.shielded.availableCoins);

      const initialState2 = await utils.waitForSyncFacade(receiver1);
      const initialBalance2 = initialState2.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(`Wallet 2: ${initialBalance2} shielded tokens`);
      logger.info(`Wallet 2 available coins: ${initialState2.shielded.availableCoins.length}`);

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: nativeTokenRaw1,
              amount: output,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState2.shielded.address),
            },
          ],
        },
      ];
      const txToProve = await senderFacade.transferTransaction(
        senderShieldedSecretKey,
        senderDustSecretKey,
        outputsToCreate,
        new Date(),
      );
      const provenTx = await senderFacade.finalizeTransaction(txToProve);
      const txId = await senderFacade.submitTransaction(provenTx);
      logger.info('Transaction id: ' + txId);

      const pendingState = await utils.waitForPending(senderFacade.shielded);
      // logger.info(utils.walletStateTrimmed(pendingState));
      logger.info(`Wallet 1 available coins: ${pendingState.availableCoins.length}`);
      expect(pendingState.balances[shieldedTokenRaw] ?? 0n).toBeLessThan(initialBalance);
      expect(pendingState.availableCoins.length).toBeLessThan(initialState.shielded.availableCoins.length);
      expect(pendingState.pendingCoins.length).toBeLessThanOrEqual(2);
      expect(pendingState.totalCoins.length).toBe(initialState.shielded.totalCoins.length);
      // expect(pendingState.nullifiers.length).toBe(initialState.nullifiers.length);
      expect(pendingState.transactionHistory.length).toBe(initialState.shielded.transactionHistory.length);

      // await utils.waitForTxInHistory(String(txId), senderFacade.shielded);
      const finalState = await utils.waitForSyncFacade(senderFacade);
      // logger.info(walletStateTrimmed(finalState));
      logger.info(`Wallet 1 available coins: ${finalState.shielded.availableCoins.length}`);
      logger.info(`Wallet 1: ${finalState.shielded.balances[nativeTokenRaw2]} NT2`);
      logger.info(finalState.shielded.availableCoins);
      expect(finalState.shielded.balances[shieldedTokenRaw] ?? 0n).toBeLessThan(initialBalance - output);
      expect(finalState.shielded.availableCoins.length).toBeLessThanOrEqual(
        initialState.shielded.availableCoins.length,
      );
      expect(finalState.shielded.pendingCoins.length).toBe(0);
      expect(finalState.shielded.totalCoins.length).toBeLessThanOrEqual(initialState.shielded.totalCoins.length);
      // expect(finalState.nullifiers.length).toBeLessThanOrEqual(initialState.nullifiers.length);
      expect(finalState.shielded.transactionHistory.length).toBeGreaterThanOrEqual(
        initialState.shielded.transactionHistory.length + 1,
      );

      // await utils.waitForTxInHistory(String(txId), receiver1.shielded);
      const finalState2 = await utils.waitForSyncShielded(receiver1.shielded);
      // logger.info(utils.walletStateTrimmed(finalState2));
      logger.info(`Wallet 2 available coins: ${finalState2.availableCoins.length}`);
      logger.info(`Wallet 2: ${finalState2.balances[shieldedTokenRaw]} shielded tokens`);
      logger.info(`Wallet 2: ${finalState2.balances[nativeTokenRaw2]} NT2`);
      logger.info(finalState2.availableCoins);
      expect(finalState2.balances[shieldedTokenRaw] ?? 0n).toBe(initialBalance2);
      expect(finalState2.balances[nativeTokenRaw2] ?? 0n).toBe(output);
      // validateWalletTxHistory(finalState2, initialState2);

      await utils.closeWallet(receiver1);
    },
    timeout,
  );

  test(
    'Token transfer involving multiple token types and recipients in one transaction',
    async () => {
      allure.tms('PM-13748', 'PM-13748');
      allure.epic('Headless wallet');
      allure.feature('Transaction balancing');
      allure.story('Multiple token types and recipients in one tx');

      const NativeTokenOutput = 1n;
      const output2 = 10_000_000n;
      const output3 = 3_000_000n;

      receiver1 = utils.buildWalletFacade(randomBytes(32).toString('hex'), fixture);
      receiver2 = utils.buildWalletFacade(randomBytes(32).toString('hex'), fixture);
      receiver3 = utils.buildWalletFacade(randomBytes(32).toString('hex'), fixture);

      const initialState = await utils.waitForSyncFacade(senderFacade);
      const initialBalance = initialState.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(initialState.shielded.balances);
      logger.info(`Wallet 1: ${initialBalance}`);
      logger.info(`Wallet 1 available coins: ${initialState.shielded.availableCoins.length}`);
      logger.info(initialState.shielded.availableCoins);

      const initialState2 = await utils.waitForSyncFacade(receiver1);
      const initialBalance2 = initialState2.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(`Wallet 2: ${initialBalance2} shielded tokens`);
      logger.info(`Wallet 2 available coins: ${initialState2.shielded.availableCoins.length}`);

      const initialState3 = await utils.waitForSyncFacade(receiver2);
      const initialBalance3 = initialState3.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(`Wallet 3: ${initialBalance3} shielded tokens`);
      logger.info(`Wallet 3 available coins: ${initialState3.shielded.availableCoins.length}`);

      const initialState4 = await utils.waitForSyncFacade(receiver3);
      const initialBalance4 = initialState4.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(`Wallet 4: ${initialBalance4} shielded tokens`);
      logger.info(`Wallet 4 available coins: ${initialState4.shielded.availableCoins.length}`);

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: nativeTokenRaw2,
              amount: NativeTokenOutput,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState2.shielded.address),
            },
            {
              type: shieldedTokenRaw,
              amount: output2,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState3.shielded.address),
            },
            {
              type: shieldedTokenRaw,
              amount: output3,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState4.shielded.address),
            },
          ],
        },
      ];
      const txToProve = await senderFacade.transferTransaction(
        senderShieldedSecretKey,
        senderDustSecretKey,
        outputsToCreate,
        new Date(),
      );
      const provenTx = await senderFacade.finalizeTransaction(txToProve);
      const txId = await senderFacade.submitTransaction(provenTx);
      logger.info('Transaction id: ' + txId);

      const pendingState = await utils.waitForPending(senderFacade.shielded);
      // logger.info(utils.walletStateTrimmed(pendingState));
      logger.info(`Wallet 1 available coins: ${pendingState.availableCoins.length}`);
      expect(pendingState.balances[shieldedTokenRaw] ?? 0n).toBeLessThan(initialBalance);
      expect(pendingState.availableCoins.length).toBeLessThan(initialState.shielded.availableCoins.length);
      expect(pendingState.pendingCoins.length).toBeLessThanOrEqual(2);
      expect(pendingState.totalCoins.length).toBe(initialState.shielded.totalCoins.length);
      // expect(pendingState.nullifiers.length).toBe(initialState.nullifiers.length);
      expect(pendingState.transactionHistory.length).toBe(initialState.shielded.transactionHistory.length);

      // await utils.waitForTxInHistory(String(txId), senderFacade.shielded);
      const finalState = await utils.waitForSyncFacade(senderFacade);
      // logger.info(walletStateTrimmed(finalState));
      logger.info(`Wallet 1 available coins: ${finalState.shielded.availableCoins.length}`);
      logger.info(`Wallet 1: ${finalState.shielded.balances[shieldedTokenRaw]} shielded tokens`);
      logger.info(`Wallet 1: ${finalState.shielded.balances[nativeTokenRaw2]} NT2`);
      logger.info(finalState.shielded.availableCoins);
      expect(finalState.shielded.balances[shieldedTokenRaw] ?? 0n).toBeLessThan(initialBalance - output2 - output3);
      expect(finalState.shielded.availableCoins.length).toBeLessThanOrEqual(
        initialState.shielded.availableCoins.length,
      );
      expect(finalState.shielded.pendingCoins.length).toBe(0);
      expect(finalState.shielded.totalCoins.length).toBeLessThanOrEqual(initialState.shielded.totalCoins.length);
      // expect(finalState.nullifiers.length).toBeLessThanOrEqual(initialState.nullifiers.length);
      expect(finalState.shielded.transactionHistory.length).toBeGreaterThanOrEqual(
        initialState.shielded.transactionHistory.length + 1,
      );

      // await utils.waitForTxInHistory(String(txId), receiver1.shielded);
      const finalState2 = await utils.waitForSyncFacade(receiver1);
      // logger.info(walletStateTrimmed(finalState2));
      logger.info(`Wallet 2 available coins: ${finalState2.shielded.availableCoins.length}`);
      logger.info(`Wallet 2: ${finalState2.shielded.balances[shieldedTokenRaw]} shielded tokens`);
      logger.info(`Wallet 2: ${finalState2.shielded.balances[nativeTokenRaw2]} NT2`);
      logger.info(finalState2.shielded.availableCoins);
      expect(finalState2.shielded.balances[shieldedTokenRaw] ?? 0n).toBe(0n);
      expect(finalState2.shielded.balances[nativeTokenRaw2] ?? 0n).toBe(NativeTokenOutput);
      // validateWalletTxHistory(finalState2, initialState2);

      // await utils.waitForTxInHistory(String(txId), receiver2.shielded);
      const finalState3 = await utils.waitForSyncFacade(receiver2);
      // logger.info(walletStateTrimmed(finalState3));
      logger.info(`Wallet 3 available coins: ${finalState3.shielded.availableCoins.length}`);
      logger.info(`Wallet 3: ${finalState3.shielded.balances[shieldedTokenRaw]} shielded tokens`);
      logger.info(`Wallet 3: ${finalState3.shielded.balances[nativeTokenRaw2]} NT2`);
      logger.info(finalState3.shielded.availableCoins);
      expect(finalState3.shielded.balances[shieldedTokenRaw] ?? 0n).toBe(output2);
      // validateWalletTxHistory(finalState3, initialState3);

      // await utils.waitForTxInHistory(String(txId), receiver3.shielded);
      const finalState4 = await utils.waitForSyncFacade(receiver3);
      // logger.info(walletStateTrimmed(finalState4));
      logger.info(`Wallet 4 available coins: ${finalState4.shielded.availableCoins.length}`);
      logger.info(`Wallet 4: ${finalState4.shielded.balances[shieldedTokenRaw]} shielded tokens`);
      logger.info(`Wallet 4: ${finalState4.shielded.balances[nativeTokenRaw2]} NT2`);
      logger.info(finalState4.shielded.availableCoins);
      expect(finalState4.shielded.balances[shieldedTokenRaw] ?? 0n).toBe(output3);
      // validateWalletTxHistory(finalState4, initialState4);

      await utils.closeWallet(receiver1);
      await utils.closeWallet(receiver2);
      await utils.closeWallet(receiver3);
    },
    timeout,
  );

  // Refactor this test when tokenisation is added to wallet sdk
  test.skip(
    'Insufficient balance error when trying to transfer all available tdust',
    async () => {
      allure.tms('PM-15080', 'PM-15080');
      allure.epic('Headless wallet');
      allure.feature('Transaction balancing');
      allure.story('Error when trying to transfer all available tdust');

      receiver1 = utils.buildWalletFacade(randomBytes(32).toString('hex'), fixture);

      const initialState = await utils.waitForSyncFacade(senderFacade);
      const initialBalance = initialState.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(initialState.shielded.balances);
      logger.info(`Wallet 1: ${initialBalance} shielded tokens`);
      logger.info(`Wallet 1 available coins: ${initialState.shielded.availableCoins.length}`);
      logger.info(initialState.shielded.availableCoins);

      const initialState2 = await utils.waitForSyncFacade(receiver1);
      const initialBalance2 = initialState2.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(`Wallet 2: ${initialBalance2} shielded tokens`);
      logger.info(`Wallet 2 available coins: ${initialState2.shielded.availableCoins.length}`);

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: initialBalance,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState2.shielded.address),
            },
          ],
        },
      ];
      try {
        const txToProve = await senderFacade.transferTransaction(
          senderShieldedSecretKey,
          senderDustSecretKey,
          outputsToCreate,
          new Date(),
        );
        const provenTx = await senderFacade.finalizeTransaction(txToProve);
        await senderFacade.submitTransaction(provenTx);
      } catch (e: unknown) {
        if (e instanceof Error) {
          expect(e.message).toContain(
            'Insufficient Funds: could not balance 02000000000000000000000000000000000000000000000000000000000000000000',
          );
        } else {
          logger.info(e);
        }
      }
      await utils.closeWallet(receiver1);
    },
    timeout,
  );

  // Refactor this test when tokenisation is added to wallet sdk
  test.skip(
    'Able to transfer all available tDust incl fees',
    async () => {
      allure.tms('PM-15023', 'PM-15023');
      allure.epic('Headless wallet');
      allure.feature('Transaction balancing');
      allure.story('tDUST transfer that uses all available tokens');

      const output1 = 1_000_000n;
      const walletFees = 159620n;

      receiver1 = utils.buildWalletFacade(randomBytes(32).toString('hex'), fixture);

      const initialState = await utils.waitForSyncFacade(senderFacade);
      const initialBalance = initialState.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(initialState.shielded.balances);
      logger.info(`Wallet 1: ${initialBalance} shielded tokens`);
      logger.info(`Wallet 1 available coins: ${initialState.shielded.availableCoins.length}`);
      logger.info(initialState.shielded.availableCoins);

      const initialReceiverState = await utils.waitForSyncFacade(receiver1);
      const initialReceiverBalance = initialReceiverState.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(`Wallet 2: ${initialReceiverBalance} shielded tokens`);
      logger.info(`Wallet 2 available coins: ${initialReceiverState.shielded.availableCoins.length}`);

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: output1,
              receiverAddress: utils.getShieldedAddress(
                NetworkId.NetworkId.Undeployed,
                initialReceiverState.shielded.address,
              ),
            },
          ],
        },
      ];
      const txToProve = await senderFacade.transferTransaction(
        senderShieldedSecretKey,
        senderDustSecretKey,
        outputsToCreate,
        new Date(),
      );
      const provenTx = await senderFacade.finalizeTransaction(txToProve);
      const txId = await senderFacade.submitTransaction(provenTx);
      logger.info('sending tDUST to wallet 2');
      logger.info('Transaction id: ' + txId);

      await utils.waitForPending(senderFacade.shielded);
      // await utils.waitForTxInHistory(String(txId), senderFacade.shielded);
      const senderState = await utils.waitForSyncFacade(senderFacade);
      const newSenderWalletBalance = senderState.shielded.balances[shieldedTokenRaw] ?? 0n;
      const totalFees = initialBalance - newSenderWalletBalance - output1;
      // logger.info(walletStateTrimmed(senderState));
      logger.info(`Wallet 1: ${newSenderWalletBalance} tDUST`);
      expect(totalFees).toBeGreaterThanOrEqual(59730n);

      // await utils.waitForTxInHistory(String(txId), receiver1.shielded);
      const receiverWalletState = await utils.waitForSyncFacade(receiver1);
      // logger.info(walletStateTrimmed(receiverWalletState));
      logger.info(`Wallet 2: ${receiverWalletState.shielded.balances[shieldedTokenRaw] ?? 0n} tDUST`);

      const outputsToCreate2: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: walletFees,
              receiverAddress: utils.getShieldedAddress(
                NetworkId.NetworkId.Undeployed,
                initialReceiverState.shielded.address,
              ),
            },
          ],
        },
      ];
      const txToProve2 = await senderFacade.transferTransaction(
        senderShieldedSecretKey,
        senderDustSecretKey,
        outputsToCreate2,
        new Date(),
      );
      const provenTx2 = await senderFacade.finalizeTransaction(txToProve2);
      const txId2 = await senderFacade.submitTransaction(provenTx2);
      logger.info('Sending transaction fee to wallet 2');
      logger.info('Transaction id: ' + txId2);

      await utils.waitForSyncFacade(senderFacade);
      // await utils.waitForTxInHistory(String(txId2), receiver1.shielded);

      const ReceiverWalletState2 = await utils.waitForSyncFacade(receiver1);
      const ReceiverWalletBalance2 = ReceiverWalletState2.shielded.balances[shieldedTokenRaw] ?? 0n;
      // logger.info(walletStateTrimmed(ReceiverWalletState2));
      logger.info(`Wallet 2 available coins: ${ReceiverWalletState2.shielded.availableCoins.length}`);
      logger.info(`Wallet 2: ${ReceiverWalletBalance2} tDUST`);
      expect(ReceiverWalletBalance2).toBe(output1 + walletFees);

      const outputsToCreate3: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: output1,
              receiverAddress: utils.getShieldedAddress(
                NetworkId.NetworkId.Undeployed,
                initialReceiverState.shielded.address,
              ),
            },
          ],
        },
      ];
      const txToProve3 = await receiver1.transferTransaction(
        senderShieldedSecretKey,
        senderDustSecretKey,
        outputsToCreate3,
        new Date(),
      );
      const provenTx3 = await receiver1.finalizeTransaction(txToProve3);
      const txId3 = await receiver1.submitTransaction(provenTx3);
      logger.info('Sending maximum available tDust not incl fees');
      logger.info('Transaction id: ' + txId3);

      // const pendingState = await utils.waitForSyncFacade(receiver1);
      // logger.info(walletStateTrimmed(pendingState));
      // await utils.waitForTxInHistory(String(txId3), receiver1.shielded);

      const receiverWalletState3 = await utils.waitForSyncFacade(receiver1);
      const ReceiverWalletBalance3 = receiverWalletState3.shielded.balances[shieldedTokenRaw] ?? 0n;
      // logger.info(walletStateTrimmed(receiverWalletState3));
      logger.info(`Wallet 2 available coins: ${receiverWalletState3.shielded.availableCoins.length}`);
      logger.info(`Wallet 2: ${ReceiverWalletBalance3} tDUST`);
      expect(ReceiverWalletBalance3).toBe(0n);

      await utils.closeWallet(receiver1);

      receiver1 = utils.buildWalletFacade(randomBytes(32).toString('hex'), fixture);

      const finalReceiverWalletState = await utils.waitForSyncFacade(receiver1);
      const finalWalletBalancer = finalReceiverWalletState.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(`Wallet 2: ${finalWalletBalancer} tDUST`);
      logger.info(`Wallet 2 available coins: ${finalReceiverWalletState.shielded.availableCoins.length}`);
      expect(finalWalletBalancer).toBe(0n);
      await utils.closeWallet(receiver1);
    },
    timeout,
  );

  test(
    'Should error when trying to make transaction with wallet containing no Dust',
    async () => {
      // allure.tms('PM-13746', 'PM-13746');
      // allure.epic('Headless wallet');
      // allure.feature('Transaction balancing');
      // allure.story('tDUST transfer which uses the second lowest coin');

      const output35 = 35_000_000n;
      const receiver1Seed = randomBytes(32).toString('hex');
      const receiver1SecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(receiver1Seed));
      const receiver1DustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(receiver1Seed));

      receiver1 = utils.buildWalletFacade(receiver1Seed, fixture);
      await receiver1.start(receiver1SecretKey, receiver1DustSecretKey);
      const initialState = await utils.waitForSyncFacade(senderFacade);
      logger.info(initialState.shielded.balances);
      logger.info(`Wallet 1 available coins: ${initialState.shielded.availableCoins.length}`);

      const initialState2 = await utils.waitForSyncFacade(receiver1);
      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: nativeTokenRaw1,
              amount: output35,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState2.shielded.address),
            },
          ],
        },
      ];
      await expect(
        senderFacade.transferTransaction(
          senderShieldedSecretKey,
          senderDustSecretKey,
          outputsToCreate,
          new Date(Date.now() + 60 * 60 * 1000),
        ),
      ).rejects.toThrow('No dust tokens found in the wallet state');
      await receiver1.stop();
    },
    timeout,
  );
});

================
File: packages/e2e-tests/src/tests/dust.undeployed.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { describe, test, expect } from 'vitest';
import * as rx from 'rxjs';
import { TestContainersFixture, useTestContainersFixture } from './test-fixture.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import * as utils from './utils.js';
import { logger } from './logger.js';
import * as allure from 'allure-js-commons';
import { CombinedTokenTransfer, WalletFacade } from '@midnight-ntwrk/wallet-sdk-facade';
import { createKeystore } from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';
import { UnshieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';

/**
 *
 * @group undeployed
 */

describe('Dust tests', () => {
  const getFixture = useTestContainersFixture();
  const seed = 'b7d32a5094ec502af45aa913b196530e155f17ef05bbf5d75e743c17c3824a82';
  const seedFunded = '0000000000000000000000000000000000000000000000000000000000000001';
  const fundedSecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(seedFunded));
  const fundedDustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(seedFunded));
  const unshieldedFundedKeyStore = createKeystore(utils.getUnshieldedSeed(seedFunded), NetworkId.NetworkId.Undeployed);
  const receiverWalletSecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(seed));
  const receiverWalletDustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(seed));
  const receiverKeystore = createKeystore(utils.getUnshieldedSeed(seed), NetworkId.NetworkId.Undeployed);
  const unshieldedTokenRaw = ledger.unshieldedToken().raw;
  const timeout = 240_000;
  const outputValue = 10000n * 10n ** 6n;

  let fixture: TestContainersFixture;
  let walletFunded: WalletFacade;
  let receiverWallet: WalletFacade;

  beforeEach(async () => {
    await allure.step('Start two wallets', async function () {
      fixture = getFixture();
      walletFunded = utils.buildWalletFacade(seedFunded, fixture);
      receiverWallet = utils.buildWalletFacade(seed, fixture);
      await walletFunded.start(fundedSecretKey, fundedDustSecretKey);
      await receiverWallet.start(receiverWalletSecretKey, receiverWalletDustSecretKey);
      logger.info('Two wallets started');
    });
  });

  afterEach(async () => {
    await utils.closeWallet(walletFunded);
    await utils.closeWallet(receiverWallet);
  }, 20_000);

  const sendAndRegisterNightUtxos = async () => {
    const initialState = await utils.waitForSyncFacade(walletFunded);
    const receiverInitialState = await utils.waitForSyncFacade(receiverWallet);
    const initialUnshieldedBalance = initialState.unshielded.balances[unshieldedTokenRaw];
    logger.info(`Wallet 1: ${initialUnshieldedBalance} unshielded tokens`);
    logger.info(`Wallet 1 total unshielded coins: ${initialState.unshielded.totalCoins.length}`);

    const outputsToCreate: CombinedTokenTransfer[] = [
      {
        type: 'unshielded',
        outputs: [
          {
            amount: outputValue,
            receiverAddress: UnshieldedAddress.codec
              .encode(fixture.getNetworkId(), receiverInitialState.unshielded.address)
              .asString(),
            type: ledger.unshieldedToken().raw,
          },
        ],
      },
    ];

    const ttl = new Date(Date.now() + 30 * 60 * 1000);
    const txToProve = await walletFunded.transferTransaction(
      fundedSecretKey,
      fundedDustSecretKey,
      outputsToCreate,
      ttl,
    );
    const signedTx = await walletFunded.signTransaction(txToProve.transaction, (payload) =>
      unshieldedFundedKeyStore.signData(payload),
    );
    const provenTx = await walletFunded.finalizeTransaction({ ...txToProve, transaction: signedTx });
    const txId = await walletFunded.submitTransaction(provenTx);
    logger.info('Transaction id: ' + txId);

    logger.info('Waiting for finalized balance...');
    await utils.waitForFacadePendingClear(walletFunded);
    await utils.waitForFacadePendingClear(receiverWallet);
    const receiverState2 = await utils.waitForSyncFacade(receiverWallet);
    const finalUnshieldedBalance = receiverState2.unshielded.balances[unshieldedTokenRaw];
    logger.info(`Wallet 2: ${finalUnshieldedBalance} unshielded tokens`);
    expect(finalUnshieldedBalance).toBe(outputValue);

    const nightUtxos = receiverState2.unshielded.availableCoins.filter(
      (coin) => coin.meta.registeredForDustGeneration === false,
    );
    expect(nightUtxos.length).toBeGreaterThan(0);
    logger.info(`utxo length: ${nightUtxos.length}`);

    const dustRegistrationRecipe = await receiverWallet.registerNightUtxosForDustGeneration(
      nightUtxos,
      receiverKeystore.getPublicKey(),
      (payload) => receiverKeystore.signData(payload),
    );

    const finalizedDustTx = await receiverWallet.finalizeTransaction(dustRegistrationRecipe);
    const dustRegistrationTxid = await receiverWallet.submitTransaction(finalizedDustTx);
    logger.info(`Dust registration tx id: ${dustRegistrationTxid}`);
  };

  test(
    'Able to register Night tokens for Dust generation after receiving unshielded tokens @healthcheck',
    async () => {
      await sendAndRegisterNightUtxos();
      const initialWalletState = await utils.waitForSyncFacade(receiverWallet);
      const receiverDustBalance = await rx.firstValueFrom(
        receiverWallet.state().pipe(
          rx.tap((s) => {
            const dustBalance = s.dust.walletBalance(new Date());
            logger.info(`Dust balance: ${dustBalance}`);
          }),
          rx.filter((s) => s.dust.walletBalance(new Date()) > 1000n),
          rx.map((s) => s.dust.walletBalance(new Date())),
        ),
      );

      expect(receiverDustBalance).toBeGreaterThan(0n);
      await rx.firstValueFrom(
        receiverWallet.state().pipe(
          rx.tap((s) => {
            const registeredTokens = s.unshielded.availableCoins.filter(
              (coin) => coin.meta.registeredForDustGeneration === true,
            );
            logger.info(`registered tokens: ${registeredTokens.length}`);
          }),
          rx.filter(
            (s) =>
              s.unshielded.availableCoins.filter((coin) => coin.meta.registeredForDustGeneration === true).length > 0,
          ),
        ),
      );
      const registerdNightUtxos = initialWalletState.unshielded.availableCoins.filter(
        (coin) => coin.meta.registeredForDustGeneration === true,
      );
      expect(registerdNightUtxos.length).toBeGreaterThan(0);
    },
    timeout,
  );

  test(
    'Able to deregister night tokens for dust decay',
    async () => {
      // allure.tag('smoke');
      // allure.tag('heanthcheck');
      // allure.tms('PM-8916', 'PM-8916');
      // allure.epic('Headless wallet');
      // allure.feature('Transactions');
      // allure.story('Valid transfer transaction');

      await sendAndRegisterNightUtxos();

      // Wait for registered tokens
      const initialWalletState = await rx.firstValueFrom(
        receiverWallet.state().pipe(
          rx.tap((s) => {
            const registeredTokens = s.unshielded.availableCoins.filter(
              (coin) => coin.meta.registeredForDustGeneration === true,
            );
            logger.info(`registered tokens: ${registeredTokens.length}`);
          }),
          rx.filter(
            (s) =>
              s.unshielded.availableCoins.filter((coin) => coin.meta.registeredForDustGeneration === true).length > 0,
          ),
        ),
      );
      const initialDustBalance = initialWalletState.dust.walletBalance(new Date());
      logger.info(`Initial Dust Balance: ${initialDustBalance}`);

      const registerdNightUtxos = initialWalletState.unshielded.availableCoins.filter(
        (coin) => coin.meta.registeredForDustGeneration === true,
      );
      expect(registerdNightUtxos.length).toBeGreaterThan(0);

      const deregisterTokens = 2;
      const dustDeregistrationRecipe = await receiverWallet.deregisterFromDustGeneration(
        registerdNightUtxos.slice(0, deregisterTokens),
        receiverKeystore.getPublicKey(),
        (payload) => receiverKeystore.signData(payload),
      );

      const balancedTransactionRecipe = await receiverWallet.balanceTransaction(
        receiverWalletSecretKey,
        receiverWalletDustSecretKey,
        dustDeregistrationRecipe.transaction,
        new Date(Date.now() + 30 * 60 * 1000),
      );

      if (balancedTransactionRecipe.type !== 'TransactionToProve') {
        throw new Error('Expected a transaction to prove');
      }

      const finalizedDustTx = await receiverWallet.finalizeTransaction(balancedTransactionRecipe);
      const dustDeregistrationTxid = await receiverWallet.submitTransaction(finalizedDustTx);
      logger.info(`Dust de-registration tx id: ${dustDeregistrationTxid}`);

      const finalDustBalance = await rx.firstValueFrom(
        receiverWallet.state().pipe(
          rx.tap((s) => {
            const dustBalance = s.dust.walletBalance(new Date());
            logger.info(`Dust balance: ${dustBalance}`);
          }),
          rx.filter((s) => s.dust.walletBalance(new Date()) == 0n),
          rx.map((s) => s.dust.walletBalance(new Date())),
        ),
      );

      expect(finalDustBalance).toBe(0n);
    },
    timeout,
  );

  test(
    'Able to spend generated Dust',
    async () => {
      await sendAndRegisterNightUtxos();
      // Wait for dust balance to be generated
      const initialWalletState = await rx.firstValueFrom(
        receiverWallet.state().pipe(
          rx.tap((s) => {
            const registeredTokens = s.unshielded.availableCoins.filter(
              (coin) => coin.meta.registeredForDustGeneration === true,
            );
            logger.info(`registered tokens: ${registeredTokens.length}`);
            const dustBalance = s.dust.walletBalance(new Date());
            logger.info(`Dust balance: ${dustBalance}`);
          }),
          rx.filter(
            (s) =>
              s.unshielded.availableCoins.filter((coin) => coin.meta.registeredForDustGeneration === true).length > 0,
          ),
          rx.filter((s) => s.dust.walletBalance(new Date()) > 1000n),
        ),
      );

      const initialUnshieldedBalance = initialWalletState.unshielded.balances[unshieldedTokenRaw];
      logger.info(`Wallet 1: ${initialUnshieldedBalance} unshielded tokens`);

      const initialFundedState = await utils.waitForSyncFacade(walletFunded);
      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'unshielded',
          outputs: [
            {
              amount: outputValue,
              receiverAddress: UnshieldedAddress.codec
                .encode(fixture.getNetworkId(), initialFundedState.unshielded.address)
                .asString(),
              type: ledger.unshieldedToken().raw,
            },
          ],
        },
      ];
      const ttl = new Date(Date.now() + 30 * 60 * 1000);
      const txToProve = await receiverWallet.transferTransaction(
        receiverWalletSecretKey,
        receiverWalletDustSecretKey,
        outputsToCreate,
        ttl,
      );
      const signedTx = await receiverWallet.signTransaction(txToProve.transaction, (payload) =>
        receiverKeystore.signData(payload),
      );
      const provenTx = await receiverWallet.finalizeTransaction({ ...txToProve, transaction: signedTx });
      const txId = await receiverWallet.submitTransaction(provenTx);
      expect(txId).toBeDefined();
      logger.info('Transaction id: ' + txId);
    },
    timeout,
  );
});

================
File: packages/e2e-tests/src/tests/emptyWallet.universal.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
import { describe, test, expect } from 'vitest';
import { firstValueFrom } from 'rxjs';
import { ShieldedWallet, ShieldedWalletClass } from '@midnight-ntwrk/wallet-sdk-shielded';
import * as KeyManagement from '@cardano-sdk/key-management';
import { TestContainersFixture, useTestContainersFixture } from './test-fixture.js';
import * as utils from './utils.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import * as allure from 'allure-js-commons';
import {
  createKeystore,
  InMemoryTransactionHistoryStorage,
  PublicKey,
  UnshieldedKeystore,
  UnshieldedWallet,
} from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';
import { WalletFacade } from '@midnight-ntwrk/wallet-sdk-facade';
import { DustWallet, DustWalletClass } from '@midnight-ntwrk/wallet-sdk-dust-wallet';
import { logger } from './logger.js';
import { UnshieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';

/**
 * Tests using an empty wallet
 *
 * @group undeployed
 * @group devnet
 * @group testnet
 */
describe('Fresh wallet with empty state', () => {
  const getFixture = useTestContainersFixture();
  const walletSeed = '0000000000000000000000000000000000000000000000000000000000000009';
  const walletSecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(walletSeed));
  const dustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(walletSeed));
  let walletKeystore: UnshieldedKeystore;
  const timeout = (process.env['NETWORK'] as utils.MidnightNetwork) === 'devnet' ? 240_000 : 120_000;

  let Wallet: ShieldedWalletClass;
  let Dust: DustWalletClass;
  let shieldedWallet: ShieldedWallet;
  let wallet: WalletFacade;
  let networkId: NetworkId.NetworkId;
  let fixture: TestContainersFixture;

  beforeEach(async () => {
    await allure.step('Start a fresh wallet', async function () {
      fixture = getFixture();
      networkId = fixture.getNetworkId();
      expect(fixture).toBeDefined();
      walletKeystore = createKeystore(utils.getUnshieldedSeed(walletSeed), fixture.getNetworkId());

      Dust = DustWallet(fixture.getDustWalletConfig());
      Wallet = ShieldedWallet(fixture.getWalletConfig());
      shieldedWallet = Wallet.startWithSecretKeys(walletSecretKey);
      wallet = utils.buildWalletFacade(walletSeed, fixture);
      await wallet.start(walletSecretKey, dustSecretKey);
    });
  });

  afterEach(async () => {
    await utils.closeWallet(wallet);
  });

  test('Valid Midnight wallet can be built from a BIP32 compatible mnemonic seed phrase', () => {
    allure.tag('smoke');
    allure.tms('PM-8914', 'PM-8914');
    allure.epic('Headless wallet');
    allure.feature('Build wallet');
    allure.story('Midnight wallet can be built from a BIP32 mnemonic seed phrase seed phrase');
    const mnemonics = [
      'result',
      'off',
      'neither',
      'clap',
      'shallow',
      'betray',
      'sphere',
      'festival',
      'beauty',
      'million',
      'network',
      'bring',
      'field',
      'message',
      'rose',
      'resist',
      'volume',
      'road',
      'other',
      'join',
      'label',
      'scorpion',
      'claw',
      'economy',
    ];

    const entropy = Buffer.from(KeyManagement.util.mnemonicWordsToEntropy(mnemonics), 'hex');
    try {
      Wallet.startWithShieldedSeed(entropy);
      // If we reach here, no error was thrown
      expect(true).toBe(true);
    } catch (error) {
      // If we reach here, an error was thrown when it shouldn't have
      expect(error).toBeUndefined();
    }

    try {
      UnshieldedWallet({
        networkId: fixture.getNetworkId(),
        indexerClientConnection: {
          indexerHttpUrl: fixture.getIndexerUri(),
          indexerWsUrl: fixture.getIndexerWsUri(),
        },
        txHistoryStorage: new InMemoryTransactionHistoryStorage(),
      }).startWithPublicKey(PublicKey.fromKeyStore(walletKeystore));
    } catch (error) {
      expect(error).toBeUndefined();
    }
  });

  test('Unable to start wallet with invalid seed', () => {
    const shortSeed = Buffer.from('12345', 'hex');
    expect(() => Wallet.startWithShieldedSeed(shortSeed)).toThrowError('Expected 32-byte seed');
    const invalidSeed = Buffer.from('"000000000000000000000000000000000000000000000000000000000000009', 'hex');
    expect(() => Wallet.startWithShieldedSeed(invalidSeed)).toThrowError('Expected 32-byte seed');
  });

  test(
    'Shielded wallet state can be serialized and then restored',
    async () => {
      allure.tms('PM-9084', 'PM-9084');
      allure.epic('Headless wallet');
      allure.feature('Wallet state');
      allure.story('Wallet state properties - serialize');
      // await shieldedWallet.waitForSyncedState();
      const serialized = await shieldedWallet.serializeState();
      const stateObject = JSON.parse(serialized);
      expect(stateObject.txHistory).toHaveLength(0);
      expect(Number(stateObject.offset)).toBeGreaterThanOrEqual(0);
      expect(stateObject.state).toBeTruthy();

      const restoredWallet = Wallet.restore(serialized);
      const newState = await firstValueFrom(restoredWallet.state);
      expect(newState.address.coinPublicKeyString()).toMatch(/^[0-9a-f]{64}$/);
      // compareStates(newState, state);
      // expect(state.syncProgress?.lag?.applyGap).toBeLessThanOrEqual(newState.syncProgress?.lag?.applyGap ?? 0);
      // expect(state.syncProgress?.lag?.sourceGap).toBeLessThanOrEqual(newState.syncProgress?.lag?.sourceGap ?? 0);
      await restoredWallet.stop();
    },
    timeout,
  );

  test(
    'Unshielded wallet state can be serialized and then restored',
    async () => {
      allure.tms('PM-9084', 'PM-9084');
      allure.epic('Headless wallet');
      allure.feature('Wallet state');
      allure.story('Wallet state properties - serialize');
      const walletState = await firstValueFrom(wallet.unshielded.state);
      const walletAddress = UnshieldedAddress.codec.encode(fixture.getNetworkId(), walletState.address).asString();
      const serialized = await wallet.unshielded.serializeState();
      const stateObject = JSON.parse(serialized);
      expect(stateObject.utxos).toHaveLength(0);
      expect(stateObject.pendingUtxos).toHaveLength(0);

      const restoredWallet = UnshieldedWallet({
        networkId: fixture.getNetworkId(),
        indexerClientConnection: {
          indexerHttpUrl: fixture.getIndexerUri(),
          indexerWsUrl: fixture.getIndexerWsUri(),
        },
        txHistoryStorage: new InMemoryTransactionHistoryStorage(),
      }).restore(serialized);
      const newState = await firstValueFrom(restoredWallet.state);
      expect(UnshieldedAddress.codec.encode(fixture.getNetworkId(), newState.address).asString()).toBe(walletAddress);
      await restoredWallet.stop();
    },
    timeout,
  );

  test(
    'Dust wallet state can be serialized and then restored',
    async () => {
      allure.tms('PM-9084', 'PM-9084');
      allure.epic('Headless wallet');
      allure.feature('Wallet state');
      allure.story('Wallet state properties - serialize');
      const state = await utils.waitForSyncFacade(wallet);
      const publicKey = state.dust.dustPublicKey;
      const address = state.dust.dustAddress;
      const serialized = await wallet.dust.serializeState();
      const stateObject = await JSON.parse(serialized);
      expect(stateObject.publicKey.publicKey).toContain(publicKey);
      expect(stateObject.state).toBeTruthy();
      expect(stateObject.networkId).toBe(networkId);

      const restoredWallet = Dust.restore(serialized);
      await restoredWallet.start(dustSecretKey);
      const restoredState = await firstValueFrom(restoredWallet.state);
      expect(publicKey).toBe(restoredState.dustPublicKey);
      expect(address).toBe(restoredState.dustAddress);
    },
    timeout,
  );

  test('Shielded wallet state returns coinPublicKey hex string', async () => {
    allure.tms('PM-8920', 'PM-8920');
    allure.epic('Headless wallet');
    allure.feature('Wallet state');
    allure.story('Wallet state properties - fresh');
    const state = await firstValueFrom(wallet.shielded.state);
    expect(state.address.coinPublicKeyString()).toMatch(/^[0-9a-f]{64}$/);
  });

  test('Shielded wallet state returns encryptionPublicKey hex string', async () => {
    allure.tms('PM-8921', 'PM-8921');
    allure.epic('Headless wallet');
    allure.feature('Wallet state');
    allure.story('Wallet state properties - fresh');
    const state = await firstValueFrom(wallet.shielded.state);
    expect(state.address.encryptionPublicKeyString()).toMatch(/^[0-9a-f]{64}$/);
  });

  test(
    'Shielded midnight wallet returns empty object of balances',
    async () => {
      allure.tms('PM-8923', 'PM-8923');
      allure.epic('Headless wallet');
      allure.feature('Wallet state');
      allure.story('Wallet state properties - fresh');
      const state = await firstValueFrom(wallet.shielded.state);
      expect(state.balances).toMatchObject({});
    },
    timeout,
  );

  test(
    'Shielded midnight wallet returns no coins',
    async () => {
      allure.tms('PM-8924', 'PM-8924');
      allure.epic('Headless wallet');
      allure.feature('Wallet state');
      allure.story('Wallet state properties - fresh');
      const state = await firstValueFrom(wallet.shielded.state);
      expect(state.totalCoins).toHaveLength(0);
    },
    timeout,
  );

  test(
    'Shielded midnight wallet returns no available coins',
    async () => {
      allure.tms('PM-8925', 'PM-8925');
      allure.epic('Headless wallet');
      allure.feature('Wallet state');
      allure.story('Wallet state properties - fresh');
      const state = await firstValueFrom(wallet.shielded.state);
      expect(state.availableCoins).toHaveLength(0);
    },
    timeout,
  );

  test(
    'Shielded midnight wallet returns no pending coins',
    async () => {
      allure.tms('PM-8926', 'PM-8926');
      allure.epic('Headless wallet');
      allure.feature('Wallet state');
      allure.story('Wallet state properties - fresh');
      const state = await firstValueFrom(wallet.shielded.state);
      expect(state.pendingCoins).toHaveLength(0);
    },
    timeout,
  );

  test(
    'Shielded midnight wallet returns no tx history',
    async () => {
      allure.tms('PM-8927', 'PM-8927');
      allure.epic('Headless wallet');
      allure.feature('Wallet state');
      allure.story('Wallet state properties - fresh');
      const state = await firstValueFrom(wallet.shielded.state);
      expect(state.transactionHistory).toHaveLength(0);
    },
    timeout,
  );

  test(
    'Shielded midnight wallet returns coin public key',
    async () => {
      allure.tms('PM-15112', 'PM-15112');
      allure.epic('Headless wallet');
      allure.feature('Wallet state - Bech32m');
      allure.story('Wallet returns Bech32m coin public key');
      const state = await firstValueFrom(wallet.shielded.state);
      expect(state.address.coinPublicKeyString()).toMatch(/^[0-9a-f]{64}$/);
    },
    timeout,
  );

  test(
    'Shielded midnight wallet returns encryption public key',
    async () => {
      allure.tms('PM-15106', 'PM-15106');
      allure.epic('Headless wallet');
      allure.feature('Wallet state - Bech32m');
      allure.story('Wallet returns Bech32m encryption public key');
      const state = await firstValueFrom(wallet.shielded.state);
      expect(state.address.encryptionPublicKeyString()).toMatch(/^[0-9a-f]{64}$/);
    },
    timeout,
  );

  test(
    'Unshielded midnight wallet returns valid bech32 public coin address',
    async () => {
      allure.tms('PM-15106', 'PM-15106');
      allure.epic('Headless wallet');
      allure.feature('Wallet state - Bech32m');
      allure.story('Wallet returns Bech32m encryption public key');
      const walletState = await firstValueFrom(wallet.unshielded.state);
      expect(walletState.address).toBeTruthy();
      utils.validateNetworkInAddress(
        UnshieldedAddress.codec.encode(fixture.getNetworkId(), walletState.address).asString(),
      ); // probably not needed anymore
    },
    timeout,
  );

  test(
    'Unshielded midnight wallet returns returns no available coins',
    async () => {
      allure.tms('PM-15106', 'PM-15106');
      allure.epic('Headless wallet');
      allure.feature('Wallet state - Bech32m');
      allure.story('Wallet returns Bech32m encryption public key');
      const walletState = await firstValueFrom(wallet.unshielded.state);
      expect(walletState.availableCoins).toHaveLength(0);
    },
    timeout,
  );

  test(
    'Unshielded midnight wallet returns returns no balances',
    async () => {
      allure.tms('PM-15106', 'PM-15106');
      allure.epic('Headless wallet');
      allure.feature('Wallet state - Bech32m');
      allure.story('Wallet returns Bech32m encryption public key');
      const walletState = await firstValueFrom(wallet.unshielded.state);
      expect(walletState.balances).toHaveLength(0);
    },
    timeout,
  );

  test(
    'Unshielded midnight wallet returns returns no pending coins',
    async () => {
      allure.tms('PM-15106', 'PM-15106');
      allure.epic('Headless wallet');
      allure.feature('Wallet state - Bech32m');
      allure.story('Wallet returns Bech32m encryption public key');
      const walletState = await firstValueFrom(wallet.unshielded.state);
      expect(walletState.pendingCoins).toHaveLength(0);
    },
    timeout,
  );

  test(
    'Unshielded midnight wallet returns returns no total coins',
    async () => {
      allure.tms('PM-15106', 'PM-15106');
      allure.epic('Headless wallet');
      allure.feature('Wallet state - Bech32m');
      allure.story('Wallet returns Bech32m encryption public key');
      const walletState = await firstValueFrom(wallet.unshielded.state);
      expect(walletState.totalCoins).toHaveLength(0);
    },
    timeout,
  );

  test(
    'Dust wallet returns empty balance',
    async () => {
      const walletState = await firstValueFrom(wallet.dust.state);
      expect(walletState.walletBalance(new Date())).toBe(0n);
    },
    timeout,
  );

  test(
    'Dust wallet returns valid public key',
    async () => {
      const walletState = await firstValueFrom(wallet.dust.state);
      const publicKey = walletState.dustPublicKey;
      expect(publicKey).toBeTruthy();
      expect(publicKey).toBeTypeOf('bigint');
    },
    timeout,
  );

  test(
    'Dust wallet returns valid address',
    async () => {
      // allure.tms('PM-15106', 'PM-15106');
      // allure.epic('Headless wallet');
      // allure.feature('Wallet state - Bech32m');
      // allure.story('Wallet returns Bech32m encryption public key');
      const walletState = await firstValueFrom(wallet.dust.state);
      const dustAddress = walletState.dustAddress;
      logger.info(`Dust Address: ${dustAddress}`);
      expect(dustAddress).toBeTruthy();
      utils.validateNetworkInAddress(String(dustAddress));
    },
    timeout,
  );

  test(
    'Dust wallet returns no available coins',
    async () => {
      const walletState = await firstValueFrom(wallet.dust.state);
      expect(walletState.availableCoins).toHaveLength(0);
    },
    timeout,
  );

  test(
    'Dust wallet returns no total coins',
    async () => {
      const walletState = await firstValueFrom(wallet.dust.state);
      expect(walletState.totalCoins).toHaveLength(0);
    },
    timeout,
  );

  test(
    'Dust wallet returns no pending coins',
    async () => {
      const walletState = await firstValueFrom(wallet.dust.state);
      expect(walletState.pendingCoins).toHaveLength(0);
    },
    timeout,
  );
});

================
File: packages/e2e-tests/src/tests/fundedWallet.undeployed.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { useTestContainersFixture } from './test-fixture.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import * as utils from './utils.js';
import * as allure from 'allure-js-commons';
import { WalletFacade } from '@midnight-ntwrk/wallet-sdk-facade';
import { logger } from './logger.js';

/**
 * Tests using a funded wallet
 *
 * @group undeployed
 */

describe('Funded wallet', () => {
  const getFixture = useTestContainersFixture();
  const seedFunded = '0000000000000000000000000000000000000000000000000000000000000001';
  const fundedSecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(seedFunded));
  const fundedDustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(seedFunded));
  const rawNativeTokenType = (ledger.nativeToken() as { tag: string; raw: string }).raw;
  const unshieldedTokenRaw = ledger.unshieldedToken().raw;
  const timeout = 120_000;

  let wallet: WalletFacade;

  beforeEach(async () => {
    await allure.step('Start a funded wallet', async function () {
      const fixture = getFixture();
      wallet = utils.buildWalletFacade(seedFunded, fixture);
      await wallet.start(fundedSecretKey, fundedDustSecretKey);
    });
  });

  afterEach(async () => {
    await utils.closeWallet(wallet);
  });

  test(
    'Wallet balance for native token is 25B tDUST and there are two other token types',
    async () => {
      allure.tms('PM-8928', 'PM-8928');
      allure.epic('Headless wallet');
      allure.feature('Wallet state');
      allure.story('Wallet state properties - funded');
      logger.info('Waiting for sync...');
      const state = await utils.waitForSyncFacade(wallet);
      expect(Object.keys(state.shielded.balances)).toHaveLength(3);
      expect(state?.shielded.balances[rawNativeTokenType]).toBe(2_500_000_000_000_000n);
      expect(state?.shielded.balances['0000000000000000000000000000000000000000000000000000000000000001']).toBe(
        500000000000000n,
      );
      expect(state?.shielded.balances['0000000000000000000000000000000000000000000000000000000000000002']).toBe(
        500000000000000n,
      );
      expect(state?.unshielded.balances).toHaveLength(1);
      expect(state?.unshielded.balances[unshieldedTokenRaw]).toBe(2_500_000_000_000_000n);
      expect(
        state?.unshielded.balances['0000000000000000000000000000000000000000000000000000000000000002'],
      ).toBeUndefined();
      expect(state?.dust.totalCoins).toHaveLength(5);
      expect(state?.dust.walletBalance(new Date())).toBe(12500000000000000000000000n);
    },
    timeout,
  );

  test(
    'funded wallet facade returns total coins',
    async () => {
      allure.tms('PM-8929', 'PM-8929');
      allure.epic('Headless wallet');
      allure.feature('Wallet state');
      allure.story('Wallet state properties - funded');
      const state = await utils.waitForSyncFacade(wallet);
      const shieldedCoins = state.shielded.totalCoins;
      expect(shieldedCoins).toHaveLength(7);
      expect(utils.isArrayUnique(shieldedCoins.map((c) => c.coin.nonce))).toBeTruthy();
      expect(shieldedCoins.every((c) => typeof c.coin.type === 'string')).toBeTruthy();
      expect(shieldedCoins.every((c) => typeof c.coin.value === 'bigint')).toBeTruthy();
      expect(shieldedCoins.every((c) => typeof c.commitment === 'string')).toBeTruthy();
      expect(utils.isArrayUnique(shieldedCoins.map((c) => c.commitment))).toBeTruthy();
      expect(utils.isArrayUnique(shieldedCoins.map((c) => c.nullifier))).toBeTruthy();
      shieldedCoins
        .filter((c) => (c.coin.type = '02000000000000000000000000000000000000000000000000000000000000000000'))
        .forEach((coin) => {
          expect(coin.coin.nonce).toBeDefined();
          expect(coin.coin.type).toHaveLength(68);
          expect(coin.coin.value).toBe(500000000000000n);
        });

      const unshieldedCoins = state.unshielded.totalCoins;
      expect(unshieldedCoins).toHaveLength(5);
      expect(utils.isArrayUnique(unshieldedCoins.map((c) => c.utxo.intentHash))).toBeTruthy();
      unshieldedCoins.forEach((c) => {
        expect(c.utxo.value).toBe(500000000000000n);
        expect(c.utxo.outputNo).toBe(0);
        expect(typeof c.utxo.owner).toBe('string');
        expect(typeof c.utxo.type).toBe('string');
        expect(c.meta.registeredForDustGeneration).toBe(true);
      });

      const dustCoins = state.dust.totalCoins;
      expect(dustCoins).toHaveLength(5);
      expect(utils.isArrayUnique(dustCoins.map((c) => c.nonce))).toBeTruthy();
      expect(utils.isArrayUnique(dustCoins.map((c) => c.backingNight))).toBeTruthy();
      dustCoins.forEach((c) => {
        expect(c.initialValue).toBe(0n);
        expect(c.seq).toBe(0);
        expect(typeof c.owner).toBe('bigint');
        expect(typeof c.nonce).toBe('bigint');
        expect(typeof c.ctime).toBe('object');
      });
    },
    timeout,
  );
  test(
    'funded wallet facade eturns available coins',
    async () => {
      allure.tms('PM-8930', 'PM-8930');
      allure.epic('Headless wallet');
      allure.feature('Wallet state');
      allure.story('Wallet state properties - funded');
      const state = await utils.waitForSyncFacade(wallet);
      const shieldedCoins = state.shielded.availableCoins;
      expect(shieldedCoins).toHaveLength(7);
      expect(utils.isArrayUnique(shieldedCoins.map((c) => c.coin.nonce))).toBeTruthy();
      expect(shieldedCoins.every((c) => typeof c.coin.type === 'string')).toBeTruthy();
      expect(shieldedCoins.every((c) => typeof c.coin.value === 'bigint')).toBeTruthy();
      expect(shieldedCoins.every((c) => typeof c.commitment === 'string')).toBeTruthy();
      expect(utils.isArrayUnique(shieldedCoins.map((c) => c.commitment))).toBeTruthy();
      expect(utils.isArrayUnique(shieldedCoins.map((c) => c.nullifier))).toBeTruthy();
      shieldedCoins
        .filter((c) => (c.coin.type = '02000000000000000000000000000000000000000000000000000000000000000000'))
        .forEach((coin) => {
          expect(coin.coin.nonce).toBeDefined();
          expect(coin.coin.type).toHaveLength(68);
          expect(coin.coin.value).toBe(500000000000000n);
        });

      const unshieldedCoins = state.unshielded.availableCoins;
      expect(unshieldedCoins).toHaveLength(5);
      expect(utils.isArrayUnique(unshieldedCoins.map((c) => c.utxo.intentHash))).toBeTruthy();
      unshieldedCoins.forEach((c) => {
        expect(c.utxo.value).toBe(500000000000000n);
        expect(c.utxo.outputNo).toBe(0);
        expect(typeof c.utxo.owner).toBe('string');
        expect(typeof c.utxo.type).toBe('string');
        expect(c.meta.registeredForDustGeneration).toBe(true);
      });

      const dustCoins = state.dust.availableCoins;
      expect(dustCoins).toHaveLength(5);
      expect(utils.isArrayUnique(dustCoins.map((c) => c.nonce))).toBeTruthy();
      expect(utils.isArrayUnique(dustCoins.map((c) => c.backingNight))).toBeTruthy();
      dustCoins.forEach((c) => {
        expect(c.initialValue).toBe(0n);
        expect(c.seq).toBe(0);
        expect(typeof c.owner).toBe('bigint');
        expect(typeof c.nonce).toBe('bigint');
        expect(typeof c.ctime).toBe('object');
      });
    },
    timeout,
  );

  test(
    'Wallet has no pending coins',
    async () => {
      allure.tms('PM-8931', 'PM-8931');
      allure.epic('Headless wallet');
      allure.feature('Wallet state');
      allure.story('Wallet state properties - funded');
      const state = await utils.waitForSyncFacade(wallet);
      expect(state.shielded.pendingCoins).toHaveLength(0);
      expect(state.unshielded.pendingCoins).toHaveLength(0);
      expect(state.dust.pendingCoins).toHaveLength(0);
    },
    timeout,
  );

  // test(
  //   'Wallet has one tx in tx history',
  //   async () => {
  //     allure.tms('PM-8932', 'PM-8932');
  //     allure.epic('Headless wallet');
  //     allure.feature('Wallet state');
  //     allure.story('Wallet state properties - funded');
  //     const state = await waitForSyncFacade(wallet);
  //     const txHistory = state.shielded.transactionHistory;
  //     expect(txHistory).toHaveLength(0);
  //     const expectedIdentifiers = new Map(
  //       Object.entries({
  //         '02000000000000000000000000000000000000000000000000000000000000000000': 2n * -100000000000000000n,
  //         '02000000000000000000000000000000000000000000000000000000000000000001': 2n * -20000000000000000n,
  //         '02000000000000000000000000000000000000000000000000000000000000000002': 2n * -20000000000000000n,
  //       }),
  //     );
  //     // eslint-disable-next-line @typescript-eslint/no-unsafe-call
  //     txHistory.forEach((tx) => {
  //       // deltas are doubled as node team send genesis funds to 2 sets of seeds (legacy key derivation + new key derivation)
  //       expect(tx.guaranteedOffer?.deltas).toStrictEqual(expectedIdentifiers);
  //       expect(tx.identifiers()).not.toHaveLength(0);
  //     });
  //   },
  //   timeout,
  // );
});

================
File: packages/e2e-tests/src/tests/multipleWallets.undeployed.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { DustParameters, nativeToken } from '@midnight-ntwrk/ledger-v6';
import { firstValueFrom } from 'rxjs';
import { logger } from './logger.js';
import { TestContainersFixture, useTestContainersFixture } from './test-fixture.js';
import { getShieldedSeed, waitForSyncFacade } from './utils.js';
import * as allure from 'allure-js-commons';
import { ShieldedWallet, ShieldedWalletClass } from '@midnight-ntwrk/wallet-sdk-shielded';
import {
  createKeystore,
  InMemoryTransactionHistoryStorage,
  PublicKey,
  UnshieldedKeystore,
  UnshieldedWallet,
} from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';
import { WalletFacade } from '@midnight-ntwrk/wallet-sdk-facade';
import { DustWallet } from '../../../dust-wallet/dist/DustWallet.js';

/**
 * Syncing tests
 *
 * @group undeployed
 */

describe('Syncing', () => {
  const getFixture = useTestContainersFixture();
  const timeout = 240_000;
  const seeds = [
    getShieldedSeed('0000000000000000000000000000000000000000000000000000000000000001'),
    getShieldedSeed('b7d32a5094ec502af45aa913b196530e155f17ef05bbf5d75e743c17c3824a82'),
    getShieldedSeed('0000000000000000000000000000000000000000000000000000000000000001'),
    getShieldedSeed('0000000000000000000000000000000000000000000000000000000000000000'),
  ];

  let Wallet: ShieldedWalletClass;
  const shieldedWallets: Array<ShieldedWallet> = [];
  const unshieldedWallets: Array<UnshieldedWallet> = [];
  const dustWallets: Array<DustWallet> = [];
  const unshieldedKeystores: Array<UnshieldedKeystore> = [];
  const facades: Array<WalletFacade> = [];
  let fixture: TestContainersFixture;
  const rawNativeTokenType = (nativeToken() as { tag: string; raw: string }).raw;

  beforeEach(() => {
    allure.step('Start multiple wallets', function () {
      fixture = getFixture();
      Wallet = ShieldedWallet(fixture.getWalletConfig());
      const Dust = DustWallet(fixture.getDustWalletConfig());
      const dustParameters = new DustParameters(5_000_000_000n, 8_267n, 3n * 60n * 60n);

      function buildWallets(seeds: Uint8Array<ArrayBufferLike>[]) {
        for (let i = 0; i < seeds.length; i++) {
          unshieldedKeystores[i] = createKeystore(seeds[i], fixture.getNetworkId());
          shieldedWallets[i] = Wallet.startWithShieldedSeed(seeds[i]);
          dustWallets[i] = Dust.startWithSeed(seeds[i], dustParameters);
        }

        for (let i = 0; i < seeds.length; i++) {
          unshieldedWallets[i] = UnshieldedWallet({
            networkId: fixture.getNetworkId(),
            indexerClientConnection: {
              indexerHttpUrl: fixture.getIndexerUri(),
              indexerWsUrl: fixture.getIndexerWsUri(),
            },
            txHistoryStorage: new InMemoryTransactionHistoryStorage(),
          }).startWithPublicKey(PublicKey.fromKeyStore(unshieldedKeystores[i]));
        }

        for (let i = 0; i < seeds.length; i++) {
          facades[i] = new WalletFacade(shieldedWallets[i], unshieldedWallets[i], dustWallets[i]);
        }
      }

      buildWallets(seeds);
    });
  }, timeout);

  afterEach(async () => {
    for (const facade of facades) {
      await facade.stop();
    }
  });

  test(
    'Syncing is working for multiple wallets concurrently',
    async () => {
      allure.tms('PM-10974', 'PM-10974');
      allure.epic('Headless wallet');
      allure.feature('Syncing');
      allure.story('Syncing wallets concurrently');

      const promises = facades.map((facade) => {
        return waitForSyncFacade(facade);
      });

      await Promise.all(promises);

      for (const facade of facades) {
        const index = facades.indexOf(facade);
        const syncedState = await firstValueFrom(facade.state());
        logger.info(`Wallet ${index}: ${syncedState.shielded.balances[rawNativeTokenType ?? 0n]}`);
        expect(syncedState.shielded.state.progress.isStrictlyComplete()).toBeTruthy();
        expect(syncedState.unshielded.progress.isStrictlyComplete()).toBeTruthy();
      }
    },
    timeout,
  );
});

================
File: packages/e2e-tests/src/tests/nativeTokenTransfer.remote.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { firstValueFrom } from 'rxjs';
import { TestContainersFixture, useTestContainersFixture } from './test-fixture.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import * as utils from './utils.js';
import { logger } from './logger.js';
import { exit } from 'node:process';
import * as allure from 'allure-js-commons';
import { CombinedTokenTransfer, WalletFacade } from '@midnight-ntwrk/wallet-sdk-facade';
import { createKeystore, UnshieldedKeystore } from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';

/**
 * Tests performing a token transfer
 *
 * @group devnet
 * @group testnet
 */

describe('Token transfer', () => {
  if (process.env['NT_SEED'] === undefined || process.env['NT_SEED2'] === undefined) {
    logger.info('NT_SEED or NT_SEED2 env vars not set');
    exit(1);
  }
  const getFixture = useTestContainersFixture();
  const receivingSeed = process.env['NT_SEED2'];
  const fundedSeed = process.env['NT_SEED'];
  const initialReceiverSecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(receivingSeed));
  const initialFundedSecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(fundedSeed));
  const receiverDustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(receivingSeed));
  const fundedDustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(fundedSeed));
  const outputValue = 1n;
  const expectedTokenHash = '02000000000000000000000000000000000000000000000000000000000000000001';
  const shieldedTokenRaw = '02000000000000000000000000000000000000000000000000000000000000000001';
  const unshieldedTokenRaw = '02000000000000000000000000000000000000000000000000000000000000000001';
  const nativeToken1Raw = '0000000000000000000000000000000000000000000000000000000000000001';
  const nativeToken2Raw = '0000000000000000000000000000000000000000000000000000000000000002';

  let sender: WalletFacade;
  let receiver: WalletFacade;
  let wallet: WalletFacade;
  let wallet2: WalletFacade;
  let senderSecretKey: ledger.ZswapSecretKeys;
  let senderDustSecretKey: ledger.DustSecretKey;
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  let senderKeyStore: UnshieldedKeystore;
  let fixture: TestContainersFixture;
  let networkId: NetworkId.NetworkId;
  const syncTimeout = (1 * 60 + 30) * 60 * 1000; // 1 hour + 30 minutes in milliseconds
  const timeout = 600_000;

  const filenameWallet = `${fundedSeed.substring(0, 7)}-${TestContainersFixture.network}.state`;
  const filenameWallet2 = `${receivingSeed.substring(0, 7)}-${TestContainersFixture.network}.state`;

  beforeAll(async () => {
    fixture = getFixture();
    networkId = fixture.getNetworkId();

    wallet = utils.buildWalletFacade(fundedSeed, fixture);
    wallet2 = utils.buildWalletFacade(receivingSeed, fixture);

    await wallet.start(initialFundedSecretKey, fundedDustSecretKey);
    await wallet2.start(initialReceiverSecretKey, receiverDustSecretKey);

    const initialState = await utils.waitForSyncFacade(wallet);
    const initialNativeBalance = initialState.shielded.balances[expectedTokenHash] ?? 0n;
    logger.info(`initial balance: ${initialNativeBalance}`);

    if (initialNativeBalance === 0n) {
      logger.info('wallet 1 has 0 native token. Wallet 2 will be sender');
      sender = wallet2;
      senderSecretKey = initialReceiverSecretKey;
      senderDustSecretKey = receiverDustSecretKey;
      receiver = wallet;
      senderKeyStore = createKeystore(utils.getUnshieldedSeed(receivingSeed), networkId);
    } else {
      logger.info('native token in wallet 1. Wallet 1 will be sender');
      sender = wallet;
      senderSecretKey = initialFundedSecretKey;
      senderDustSecretKey = fundedDustSecretKey;
      receiver = wallet2;
      senderKeyStore = createKeystore(utils.getUnshieldedSeed(fundedSeed), networkId);
    }
  }, syncTimeout);

  afterAll(async () => {
    await utils.saveState(sender, filenameWallet);
    await utils.saveState(receiver, filenameWallet2);
    await utils.closeWallet(sender);
    await utils.closeWallet(receiver);
  }, timeout);

  test(
    'Is working for valid native token transfer @smoke @healthcheck',
    async () => {
      allure.tag('smoke');
      allure.tag('healthcheck');
      allure.tms('PM-8933', 'PM-8933');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Valid transfer transaction using bech32m address');
      await Promise.all([utils.waitForSyncFacade(sender), utils.waitForSyncFacade(receiver)]);
      const initialState = await firstValueFrom(sender.state());
      const initialShieldedBalance = initialState.shielded.balances[shieldedTokenRaw];
      const initialUnshieldedBalance = initialState.unshielded.balances[unshieldedTokenRaw];
      const initialDustBalance = initialState.dust.walletBalance(new Date());
      logger.info(`Wallet 1: ${initialShieldedBalance} shielded tokens`);
      logger.info(`Wallet 1: ${initialUnshieldedBalance} shielded tokens`);
      logger.info(`Wallet 1 available dust: ${initialDustBalance}`);
      logger.info(`Wallet 1 available shielded coins: ${initialState.shielded.availableCoins.length}`);
      logger.info(`Wallet 1 available unshielded coins: ${initialState.unshielded.availableCoins.length}`);

      const initialReceiverState = await firstValueFrom(receiver.state());
      const initialReceiverShieldedBalance1 = initialReceiverState.shielded.balances[nativeToken1Raw];
      const initialReceiverShieldedBalance2 = initialReceiverState.shielded.balances[nativeToken2Raw];
      const initialReceiverUnshieldedBalance = initialReceiverState.unshielded.balances[unshieldedTokenRaw];
      const initialReceiverDustBalance = initialReceiverState.dust.walletBalance(new Date());
      logger.info(`Wallet 2: ${initialReceiverShieldedBalance1} native token 1`);
      logger.info(`Wallet 2: ${initialReceiverShieldedBalance2} native token 2`);
      logger.info(`Wallet 2: ${initialReceiverUnshieldedBalance} shielded tokens`);

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: nativeToken1Raw,
              amount: outputValue,
              receiverAddress: utils.getShieldedAddress(
                NetworkId.NetworkId.Undeployed,
                initialReceiverState.shielded.address,
              ),
            },
            {
              type: nativeToken2Raw,
              amount: outputValue,
              receiverAddress: utils.getShieldedAddress(
                NetworkId.NetworkId.Undeployed,
                initialReceiverState.shielded.address,
              ),
            },
          ],
        },
      ];

      const txToProve = await sender.transferTransaction(
        senderSecretKey,
        senderDustSecretKey,
        outputsToCreate,
        new Date(Date.now() + 30 * 60 * 1000),
      );
      // const signedTx = await sender.signTransaction(
      //   txToProve.transaction,
      //   async (payload) => await Promise.resolve(senderKeyStore.signData(payload)),
      // );
      const provenTx = await sender.finalizeTransaction(txToProve);
      const txId = await sender.submitTransaction(provenTx);
      logger.info('txProcessing');
      logger.info('Transaction id: ' + txId);

      const pendingState = await utils.waitForFacadePending(sender);
      // logger.info(utils.walletStateTrimmed(pendingState));
      expect(pendingState.shielded.balances[nativeToken1Raw] ?? 0n).toBeLessThanOrEqual(
        initialShieldedBalance - outputValue,
      );
      expect(pendingState.shielded.balances[nativeToken2Raw] ?? 0n).toBeLessThanOrEqual(
        initialShieldedBalance - outputValue,
      );
      expect(pendingState.shielded.availableCoins.length).toBeLessThanOrEqual(
        initialState.shielded.availableCoins.length,
      );
      expect(pendingState.shielded.pendingCoins.length).toBeGreaterThanOrEqual(1);
      expect(pendingState.unshielded.pendingCoins.length).toBe(0);
      expect(pendingState.dust.pendingCoins.length).toBeGreaterThanOrEqual(1);
      // expect(pendingState.totalCoins.length).toBe(initialState.shielded.totalCoins.length);
      // expect(pendingState.nullifiers.length).toBe(initialState.nullifiers.length);
      // expect(pendingState.transactionHistory.length).toBe(initialState.transactionHistory.length);

      logger.info('waiting for tx in history');
      // await waitForTxInHistory(txId, sender);
      await utils.waitForFacadePendingClear(sender);
      const finalState = await utils.waitForSyncFacade(sender);
      // logger.info(walletStateTrimmed(finalState));
      const senderFinalShieldedBalance1 = finalState.shielded.balances[nativeToken1Raw];
      const senderFinalShieldedBalance2 = finalState.shielded.balances[nativeToken2Raw];
      const senderFinalUnshieldedBalance = finalState.unshielded.balances[unshieldedTokenRaw];
      const senderFinalDustBalance = finalState.dust.walletBalance(new Date(3 * 1000));
      logger.info(`Wallet 1 final available dust: ${senderFinalDustBalance}`);
      logger.info(`Wallet 1 final available shielded coins: ${senderFinalShieldedBalance1}`);
      logger.info(`Wallet 2 final available shielded coins: ${senderFinalShieldedBalance2}`);
      logger.info(`Wallet 1 final available unshielded coins: ${senderFinalUnshieldedBalance}`);
      expect(senderFinalShieldedBalance1).toBe(initialReceiverShieldedBalance1 - outputValue);
      expect(senderFinalShieldedBalance2).toBe(initialReceiverShieldedBalance2 - outputValue);
      expect(senderFinalUnshieldedBalance).toBe(initialUnshieldedBalance);
      expect(senderFinalDustBalance).toBeLessThan(initialDustBalance);
      expect(finalState.shielded.availableCoins.length).toBeLessThanOrEqual(
        initialState.shielded.availableCoins.length,
      );
      expect(finalState.dust.pendingCoins.length).toBe(0);
      expect(finalState.shielded.pendingCoins.length).toBe(0);
      expect(finalState.shielded.totalCoins.length).toBeLessThanOrEqual(initialState.shielded.totalCoins.length);
      expect(finalState.unshielded.availableCoins.length).toBeLessThanOrEqual(
        initialState.unshielded.availableCoins.length,
      );
      expect(finalState.unshielded.pendingCoins.length).toBe(0);
      expect(finalState.unshielded.totalCoins.length).toBeLessThanOrEqual(initialState.shielded.totalCoins.length);
      // expect(finalState.nullifiers.length).toBeLessThanOrEqual(initialState.nullifiers.length);
      // expect(finalState.transactionHistory.length).toBeGreaterThanOrEqual(initialState.transactionHistory.length + 1);

      // await waitForTxInHistory(txId, receiver);
      const finalState2 = await utils.waitForSyncFacade(receiver);
      // logger.info(walletStateTrimmed(finalState2));
      const receiverFinalShieldedBalance1 = finalState.shielded.balances[nativeToken1Raw];
      const receiverFinalShieldedBalance2 = finalState.shielded.balances[nativeToken2Raw];
      const receiverFinalUnshieldedBalance = finalState.unshielded.balances[unshieldedTokenRaw];
      const receiverFinalDustBalance = finalState.dust.walletBalance(new Date(3 * 1000));
      logger.info(`Wallet 2 final available shielded coins: ${receiverFinalShieldedBalance1}`);
      logger.info(`Wallet 2 final available shielded coins: ${receiverFinalShieldedBalance2}`);
      logger.info(`Wallet 2 final available unshielded coins: ${receiverFinalUnshieldedBalance}`);
      expect(receiverFinalShieldedBalance1).toBe(initialReceiverShieldedBalance1 + outputValue);
      expect(receiverFinalShieldedBalance2).toBe(initialReceiverShieldedBalance2 + outputValue);
      expect(receiverFinalUnshieldedBalance).toBe(0n);
      expect(finalState2.shielded.pendingCoins.length).toBe(0);
      expect(finalState2.shielded.totalCoins.length).toBeGreaterThanOrEqual(
        initialReceiverState.shielded.totalCoins.length + 1,
      );
      expect(receiverFinalDustBalance).toBe(initialReceiverDustBalance);
      // expect(finalState2.nullifiers.length).toBeGreaterThanOrEqual(initialState2.nullifiers.length + 1);
      // expect(finalState2.transactionHistory.length).toBeGreaterThanOrEqual(initialState2.transactionHistory.length + 1);
    },
    syncTimeout,
  );

  test(
    'can perform a self-transaction',
    async () => {
      allure.tag('smoke');
      allure.tms('PM-9680', 'PM-9680');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Valid transfer self-transaction');

      const initialState = await utils.waitForSyncFacade(sender);
      const initialBalance = initialState.shielded.balances[shieldedTokenRaw];
      logger.info(initialState.shielded.availableCoins);
      logger.info(`Wallet 1: ${initialBalance}`);
      logger.info(`Wallet 1 available coins: ${initialState.shielded.availableCoins.length}`);

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: outputValue,
              receiverAddress: utils.getShieldedAddress(networkId, initialState.shielded.address),
            },
          ],
        },
      ];
      const txToProve = await sender.transferTransaction(
        senderSecretKey,
        senderDustSecretKey,
        outputsToCreate,
        new Date(),
      );
      const provenTx = await sender.finalizeTransaction(txToProve);
      const txId = await sender.submitTransaction(provenTx);
      const fees = provenTx.fees(ledger.LedgerParameters.initialParameters());
      logger.info('Transaction id: ' + txId);

      const pendingState = await utils.waitForPending(sender.shielded);
      // logger.info(utils.walletStateTrimmed(pendingState));
      logger.info(`Wallet 1 available coins: ${pendingState.availableCoins.length}`);
      expect(pendingState.balances[shieldedTokenRaw] ?? 0n).toBeLessThan(initialBalance - outputValue);
      expect(pendingState.availableCoins.length).toBeLessThan(initialState.shielded.availableCoins.length);
      expect(pendingState.pendingCoins.length).toBeLessThanOrEqual(1);
      expect(pendingState.totalCoins.length).toBe(initialState.shielded.totalCoins.length);
      // expect(pendingState.nullifiers.length).toBe(initialState.nullifiers.length);
      // expect(pendingState.transactionHistory.length).toBe(initialState.transactionHistory.length);

      // await utils.waitForTxInHistory(String(txId), sender.shielded);
      const finalState = await utils.waitForSyncFacade(sender);
      // logger.info(walletStateTrimmed(finalState));
      logger.info(`Wallet 1 available coins: ${finalState.shielded.availableCoins.length}`);
      logger.info(`Wallet 1: ${finalState.shielded.balances[shieldedTokenRaw]}`);
      // actually deducted fees are greater - PM-7721
      expect(finalState.shielded.balances[shieldedTokenRaw] ?? 0n).toBeLessThanOrEqual(initialBalance - fees);
      expect(finalState.shielded.availableCoins.length).toBeGreaterThanOrEqual(
        initialState.shielded.availableCoins.length,
      );
      expect(finalState.shielded.pendingCoins.length).toBe(0);
      expect(finalState.shielded.totalCoins.length).toBeGreaterThanOrEqual(initialState.shielded.totalCoins.length);
      // expect(finalState.nullifiers.length).toBeGreaterThanOrEqual(initialState.nullifiers.length);
      // expect(finalState.transactionHistory.length).toBeGreaterThanOrEqual(initialState.transactionHistory.length + 1);
    },
    syncTimeout,
  );

  // test.skip(
  //   'coins become available when native token tx fails on node @smoke',
  //   async () => {
  //     allure.tag('smoke');
  //     allure.tms('PM-8936', 'PM-8936');
  //     allure.epic('Headless wallet');
  //     allure.feature('Transactions');
  //     allure.story('Invalid native token transaction');
  //     const initialState = await firstValueFrom(sender.state());
  //     const syncedState = await utils.waitForSyncShielded(sender.shielded);
  //     const initialDustBalance = syncedState?.balances[rawNativeTokenType] ?? 0n;
  //     Object.entries(initialState.shielded.balances).forEach(([key, _]) => {
  //       if (key !== rawNativeTokenType) tokenTypeHash = key;
  //     });
  //     if (tokenTypeHash === undefined) {
  //       throw new Error('No native tokens found');
  //     }
  //     const initialBalance = syncedState?.balances[tokenTypeHash] ?? 0n;
  //     logger.info(`Wallet 1 balance is: ${initialDustBalance} tDUST`);
  //     logger.info(`Wallet 1 balance is: ${initialBalance} ${tokenTypeHash}`);

  //     const syncedState2 = await utils.waitForSyncShielded(receiver.shielded);
  //     const initialDustBalance2 = syncedState2?.balances[rawNativeTokenType] ?? 0n;
  //     const initialBalance2 = syncedState2?.balances[tokenTypeHash] ?? 0n;
  //     logger.info(`Wallet 1 balance is: ${initialDustBalance2} tDUST`);
  //     logger.info(`Wallet 1 balance is: ${initialBalance2} ${tokenTypeHash}`);

  //     const coin = createShieldedCoinInfo(tokenTypeHash, outputValue);
  //     const output = ledger.ZswapOutput.new(
  //       coin,
  //       Segments.guaranteed,
  //       initialState.shielded.coinPublicKey.toHexString(),
  //       initialState.shielded.encryptionPublicKey.toHexString(),
  //     );
  //     const offer = ledger.ZswapOffer.fromOutput(output, rawNativeTokenType, outputValue);
  //     const unprovenTx = ledger.Transaction.fromParts(networkId, offer).eraseProofs();
  //     const provenTx = await sender.finalizeTransaction({
  //       type: 'TransactionToProve',
  //       transaction: unprovenTx,
  //     });

  //     await expect(
  //       Promise.all([sender.submitTransaction(provenTx), sender.submitTransaction(provenTx)]),
  //     ).rejects.toThrow();

  //     const finalState = await utils.waitForFinalizedBalance(sender.shielded);
  //     expect(finalState).toMatchObject(syncedState);
  //     expect(finalState.balances[rawNativeTokenType]).toBe(initialDustBalance);
  //     expect(finalState.balances[tokenTypeHash]).toBe(initialBalance);
  //     expect(finalState.availableCoins.length).toBe(syncedState.availableCoins.length);
  //     expect(finalState.pendingCoins.length).toBe(0);
  //     expect(finalState.totalCoins.length).toBe(syncedState.totalCoins.length);
  //     // expect(finalState.transactionHistory.length).toBe(syncedState.transactionHistory.length);
  //   },
  //   timeout,
  // );

  // test(
  //   'coins become available when native token tx does not get proved',
  //   async () => {
  //     allure.tms('PM-8934', 'PM-8934');
  //     allure.epic('Headless wallet');
  //     allure.feature('Transactions');
  //     allure.story('Transaction not proved');
  //     const syncedState = await waitForSyncShielded(sender.shielded);
  //     const initialDustBalance = syncedState?.balances[rawNativeTokenType] ?? 0n;
  //     Object.entries(syncedState.balances).forEach(([key, _]) => {
  //       if (key !== rawNativeTokenType) tokenTypeHash = key;
  //     });
  //     if (tokenTypeHash === undefined) {
  //       throw new Error('No native tokens found');
  //     }
  //     const initialBalance = syncedState?.balances[tokenTypeHash] ?? 0n;
  //     logger.info(`Wallet 1 balance is: ${initialDustBalance} tDUST`);
  //     logger.info(`Wallet 1 balance is: ${initialBalance} ${tokenTypeHash}`);

  //     logger.info('Stopping proof server container..');
  //     await fixture.getProofServerContainer().stop({ timeout: 10_000 });

  //     const initialState2 = await firstValueFrom(receiver.state());

  //     const outputsToCreate: CombinedTokenTransfer[] = [
  //       {
  //         type: 'shielded',
  //         outputs: [
  //           {
  //             type: tokenTypeHash,
  //             amount: outputValue,
  //             receiverAddress: getShieldedAddress(networkId, initialState2.shielded.address),
  //           },
  //         ],
  //       },
  //     ];
  //     const txToProve = await sender.transferTransaction(
  //       senderSecretKey,
  //       senderDustSecretKey,
  //       outputsToCreate,
  //       new Date(),
  //     );
  //     await expect(sender.finalizeTransaction(txToProve)).rejects.toThrow();

  //     const finalState = await waitForFinalizedBalance(sender.shielded);
  //     expect(finalState).toMatchObject(syncedState);
  //     expect(finalState.balances[rawNativeTokenType]).toBe(initialDustBalance);
  //     expect(finalState.balances[tokenTypeHash]).toBe(initialBalance);
  //     expect(finalState.availableCoins.length).toBe(syncedState.availableCoins.length);
  //     expect(finalState.pendingCoins.length).toBe(0);
  //     expect(finalState.totalCoins.length).toBe(syncedState.totalCoins.length);
  //     // expect(finalState.transactionHistory.length).toBe(syncedState.transactionHistory.length);
  //   },
  //   timeout,
  // );
});

================
File: packages/e2e-tests/src/tests/smoke.undeployed.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { describe, test, expect } from 'vitest';
import { firstValueFrom } from 'rxjs';
import { TestContainersFixture, useTestContainersFixture } from './test-fixture.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import * as utils from './utils.js';
import { logger } from './logger.js';
import * as allure from 'allure-js-commons';
import { ShieldedWallet, ShieldedWalletClass } from '@midnight-ntwrk/wallet-sdk-shielded';
import { CombinedTokenTransfer, WalletFacade } from '@midnight-ntwrk/wallet-sdk-facade';
import {
  createKeystore,
  PublicKey,
  UnshieldedWallet,
  InMemoryTransactionHistoryStorage,
} from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';
import { DustWallet, DustWalletClass } from '@midnight-ntwrk/wallet-sdk-dust-wallet';
import { UnshieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';

/**
 * Smoke tests
 *
 * @group undeployed
 */

describe('Smoke tests', () => {
  const getFixture = useTestContainersFixture();
  const seed = 'b7d32a5094ec502af45aa913b196530e155f17ef05bbf5d75e743c17c3824a82';
  const seedFunded = '0000000000000000000000000000000000000000000000000000000000000001';
  const fundedSecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(seedFunded));
  const receiverWalletSecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(seed));
  const fundedDustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(seedFunded));
  const receiverWalletDustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(seed));
  const shieldedTokenRaw = ledger.shieldedToken().raw;
  const unshieldedTokenRaw = ledger.unshieldedToken().raw;
  const timeout = 240_000;
  const outputValue = 1_000n;

  let fixture: TestContainersFixture;
  let Wallet: ShieldedWalletClass;
  let walletFunded: WalletFacade;
  let receiverWallet: WalletFacade;
  let Dust: DustWalletClass;

  beforeEach(async () => {
    await allure.step('Start two wallets', async function () {
      fixture = getFixture();
      Dust = DustWallet(fixture.getDustWalletConfig());
      Wallet = ShieldedWallet(fixture.getWalletConfig());
      walletFunded = utils.buildWalletFacade(seedFunded, fixture);
      receiverWallet = utils.buildWalletFacade(seed, fixture);
      await walletFunded.start(fundedSecretKey, fundedDustSecretKey);
      await receiverWallet.start(receiverWalletSecretKey, receiverWalletDustSecretKey);
      logger.info('Two wallets started');
    });
  });

  afterEach(async () => {
    await utils.closeWallet(walletFunded);
    await utils.closeWallet(receiverWallet);
  }, 20_000);

  test(
    'Valid transfer of shielded and unshielded token @healthcheck',
    async () => {
      allure.tag('smoke');
      allure.tag('heanthcheck');
      allure.tms('PM-8916', 'PM-8916');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Valid transfer transaction');
      logger.info(`shielded token type: ${shieldedTokenRaw}`);
      logger.info(`unshielded token type: ${unshieldedTokenRaw}`);

      const balance = 2500000000000000n;
      const unshieldedFundedKeyStore = createKeystore(
        utils.getUnshieldedSeed(seedFunded),
        NetworkId.NetworkId.Undeployed,
      );
      await Promise.all([utils.waitForSyncFacade(walletFunded), utils.waitForSyncFacade(receiverWallet)]);
      const initialState = await utils.waitForSyncFacade(walletFunded);
      const initialShieldedBalance = initialState.shielded.balances[shieldedTokenRaw];
      const initialUnshieldedBalance = initialState.unshielded.balances[unshieldedTokenRaw];
      logger.info(`Wallet 1: ${initialShieldedBalance} shielded tokens`);
      logger.info(`Wallet 1: ${initialUnshieldedBalance} unshielded tokens`);
      logger.info(`Wallet 1 total shielded coins: ${initialState.shielded.totalCoins.length}`);
      logger.info(`Wallet 1 total unshielded coins: ${initialState.unshielded.totalCoins.length}`);
      logger.info(`Wallet 1 available shielded coins: ${initialState.shielded.availableCoins.length}`);
      logger.info(`Wallet 1 available unshielded coins: ${initialState.unshielded.availableCoins.length}`);
      expect(initialState.shielded.balances[shieldedTokenRaw]).toBe(balance);
      expect(initialState.unshielded.balances[unshieldedTokenRaw]).toBe(balance);
      expect(Object.keys(initialState.shielded.balances)).toHaveLength(3);
      // expect(initialState.unshielded.balances.size).toBe(3);

      const initialState2 = await firstValueFrom(receiverWallet.state());
      const initialBalance2 = initialState2.shielded.balances[shieldedTokenRaw];
      expect(initialBalance2).toBe(undefined);
      expect(Object.keys(initialState2.shielded.balances)).toHaveLength(0);
      expect(Object.keys(initialState.unshielded.balances)).toHaveLength(1);
      logger.info(`Wallet 2: ${initialBalance2}`);
      logger.info(`Wallet 2 available coins: ${initialState2.shielded.availableCoins.length}`);

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: outputValue,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState2.shielded.address),
            },
          ],
        },
        {
          type: 'unshielded',
          outputs: [
            {
              type: unshieldedTokenRaw,
              amount: outputValue,
              receiverAddress: UnshieldedAddress.codec
                .encode(NetworkId.NetworkId.Undeployed, initialState2.unshielded.address)
                .asString(),
            },
          ],
        },
      ];
      const txToProve = await walletFunded.transferTransaction(
        fundedSecretKey,
        fundedDustSecretKey,
        outputsToCreate,
        new Date(Date.now() + 30 * 60 * 1000),
      );
      const signedTx = await walletFunded.signTransaction(txToProve.transaction, (payload) =>
        unshieldedFundedKeyStore.signData(payload),
      );
      const provenTx = await walletFunded.finalizeTransaction({ ...txToProve, transaction: signedTx });
      const txId = await walletFunded.submitTransaction(provenTx);
      logger.info('Transaction id: ' + txId);

      const pendingState = await utils.waitForFacadePending(walletFunded);
      expect(pendingState.shielded.balances[shieldedTokenRaw] ?? 0n).toBeLessThanOrEqual(balance - outputValue);
      expect(pendingState.unshielded.balances[unshieldedTokenRaw] ?? 0n).toBeLessThanOrEqual(balance - outputValue);
      expect(pendingState.shielded.totalCoins.length).toBe(7);
      expect(pendingState.unshielded.totalCoins.length).toBe(5);
      expect(pendingState.shielded.availableCoins.length).toBe(6);
      expect(pendingState.unshielded.availableCoins.length).toBe(4);
      expect(pendingState.shielded.pendingCoins.length).toBe(1);
      expect(pendingState.unshielded.pendingCoins.length).toBe(1);

      logger.info('Waiting for finalized balance...');
      await utils.waitForFacadePendingClear(walletFunded);
      const finalState = await utils.waitForSyncFacade(walletFunded);
      logger.info(`Wallet 1 available coins: ${finalState.shielded.availableCoins.length}`);
      expect(finalState.shielded.balances[shieldedTokenRaw]).toBe(balance - outputValue);
      expect(finalState.unshielded.balances[unshieldedTokenRaw] ?? 0n).toBeLessThanOrEqual(balance - outputValue);
      expect(finalState.shielded.totalCoins.length).toBe(7);
      expect(finalState.unshielded.totalCoins.length).toBe(5);
      expect(finalState.unshielded.availableCoins.length).toBe(5);
      expect(finalState.shielded.pendingCoins.length).toBe(0);
      expect(finalState.unshielded.pendingCoins.length).toBe(0);

      await utils.waitForFinalizedBalance(receiverWallet.shielded);
      const finalState2 = await utils.waitForSyncFacade(receiverWallet);
      const finalShieldedBalance = finalState2.shielded.balances[shieldedTokenRaw];
      const finalUnshieldedBalance = finalState2.unshielded.balances[unshieldedTokenRaw];
      logger.info(finalState2);
      logger.info(`Wallet 2 available coins: ${finalState2.shielded.availableCoins.length}`);
      logger.info(`Wallet 2: ${finalShieldedBalance} shielded tokens`);
      logger.info(`Wallet 2: ${finalUnshieldedBalance} unshielded tokens`);
      expect(finalShieldedBalance).toBe(outputValue);
      expect(finalUnshieldedBalance).toBe(outputValue);
      expect(finalState2.shielded.availableCoins.length).toBe(1);
      expect(finalState2.unshielded.availableCoins.length).toBe(1);
      expect(finalState2.shielded.pendingCoins.length).toBe(0);
      expect(finalState2.unshielded.pendingCoins.length).toBe(0);
    },
    timeout,
  );

  test(
    'Shielded wallet state can be serialized and then restored',
    async () => {
      allure.tag('smoke');
      allure.tms('PM-9084', 'PM-9084');
      allure.epic('Headless wallet');
      allure.feature('Wallet state');
      allure.story('Wallet state properties - serialize');
      const initialState = await utils.waitForSyncFacade(walletFunded);
      const initialStateTxHistory = utils.getTransactionHistoryIds(initialState.shielded);
      const serialized = await walletFunded.shielded.serializeState();
      const stateObject = JSON.parse(serialized);
      expect(stateObject.txHistory).toHaveLength(1);
      expect(Number(stateObject.offset)).toBeGreaterThan(0);
      expect(typeof stateObject.state).toBe('string');
      expect(stateObject.state).toBeTruthy();
      await walletFunded.stop();

      logger.info('Restoring wallet from serialized state...');
      const restoredWallet = Wallet.restore(serialized);
      try {
        const restoredState = await restoredWallet.waitForSyncedState();
        const restoredStateTxHistory = utils.getTransactionHistoryIds(restoredState);
        expect(restoredStateTxHistory).toEqual(initialStateTxHistory);
      } finally {
        await restoredWallet.stop();
      }
    },
    timeout,
  );

  test(
    'Unshielded wallet can be serialized and restored with in memory tx history storage',
    async () => {
      allure.tag('smoke');
      allure.tag('healthcheck');
      allure.tms('PM-11088', 'PM-11088');
      allure.epic('Headless wallet');
      allure.feature('Wallet building');
      allure.story('Building with discardTxHistory undefined');

      fixture = getFixture();
      const txHistoryStorage = new InMemoryTransactionHistoryStorage();
      const unshieldedKeyStore = createKeystore(utils.getUnshieldedSeed(seedFunded), fixture.getNetworkId());
      const initialWallet = UnshieldedWallet({
        networkId: fixture.getNetworkId(),
        indexerClientConnection: {
          indexerHttpUrl: fixture.getIndexerUri(),
          indexerWsUrl: fixture.getIndexerWsUri(),
        },
        txHistoryStorage,
      }).startWithPublicKey(PublicKey.fromKeyStore(unshieldedKeyStore));
      logger.info(`Waiting to sync...`);
      // const syncedState = await utils.waitForSyncUnshielded(initialWallet);
      // TODO add assertion for Tx history
      const serializedState = await initialWallet.serializeState();
      const serializedTxHistory = txHistoryStorage.serialize();
      await initialWallet.stop();

      const restoredTxHistory = InMemoryTransactionHistoryStorage.fromSerialized(serializedTxHistory);
      const restoredWallet = UnshieldedWallet({
        networkId: fixture.getNetworkId(),
        indexerClientConnection: {
          indexerHttpUrl: fixture.getIndexerUri(),
          indexerWsUrl: fixture.getIndexerWsUri(),
        },
        txHistoryStorage: restoredTxHistory,
      }).restore(serializedState);

      const restoredState = await utils.waitForSyncUnshielded(restoredWallet);
      expect(restoredState).toBeTruthy();
      // TODO add assertion for Tx history
    },
    timeout,
  );

  test(
    'Dust wallet can be serialized and restored with in memory tx history storage',
    async () => {
      allure.tag('smoke');
      allure.tag('healthcheck');
      allure.tms('PM-11088', 'PM-11088');
      allure.epic('Headless wallet');
      allure.feature('Wallet building');
      allure.story('Building with discardTxHistory undefined');

      const initialState = await utils.waitForSyncFacade(walletFunded);
      const publicKey = initialState.dust.dustPublicKey;
      const address = initialState.dust.dustAddress;
      const dustBalance = initialState.dust.walletBalance(new Date());
      const serialized = await walletFunded.dust.serializeState();
      logger.info(`serializeState: ${serialized}`);
      const stateObject = JSON.parse(serialized);
      expect(stateObject.publicKey.publicKey).toContain(publicKey);
      expect(stateObject.state).toBeTruthy();
      expect(stateObject.networkId).toBe(NetworkId.NetworkId.Undeployed);

      logger.info('Restoring wallet from serialized state...');
      const restoredWallet = Dust.restore(serialized);
      await restoredWallet.start(fundedDustSecretKey);
      const restoredState = await restoredWallet.waitForSyncedState();
      logger.info(restoredState);
      expect(restoredState.dustPublicKey).toBe(publicKey);
      expect(restoredState.dustAddress).toBe(address);
      expect(restoredState.walletBalance(new Date())).toBe(dustBalance);
      await restoredWallet.stop();
    },
    timeout,
  );
});

// describe('Wallet building', () => {
//   const getFixture = useTestContainersFixture();
//   const seedFunded = '0000000000000000000000000000000000000000000000000000000000000001';
//   const rawNativeTokenType = (nativeToken() as { tag: string; raw: string }).raw;
//   const timeout = 60_000;

//   let walletFunded: ShieldedWallet;
//   let fixture: TestContainersFixture;

//   afterEach(async () => {
//     await walletFunded.stop();
//   });

//   test(
//     'Unshielded wallet is working if txHistoryStorage is not defined @healthcheck',
//     async () => {
//       allure.tag('smoke');
//       allure.tag('healthcheck');
//       allure.tms('PM-11088', 'PM-11088');
//       allure.epic('Headless wallet');
//       allure.feature('Wallet building');
//       allure.story('Building with discardTxHistory undefined');

//       fixture = getFixture();
//       const unshieldedKeyStore = createKeystore(getUnshieldedSeed(seedFunded), fixture.getNetworkId());
//       const unshieldedWallet = await WalletBuilder.build({
//         publicKey: PublicKey.fromKeyStore(unshieldedKeyStore),
//         networkId: fixture.getNetworkId(),
//         indexerUrl: fixture.getIndexerUri(),
//       });
//       logger.info(`Waiting to receive tokens...`);
//       const syncedState = await waitForSyncUnshielded(unshieldedWallet);
//       // logger.info(`Wallet 1 balance: ${syncedState.balances[rawNativeTokenType]}`);
//       // expect(syncedState.transactionHistory).toHaveLength(1);
//     },
//     timeout,
//   );

//   test(
//     'Is working if discardTxHistory is set to false @healthcheck',
//     async () => {
//       allure.tag('smoke');
//       allure.tag('healthcheck');
//       allure.tms('PM-11090', 'PM-11090');
//       allure.epic('Headless wallet');
//       allure.feature('Wallet building');
//       allure.story('Building with discardTxHistory set to false');

//       await allure.step('Start a wallet', async function () {
//         fixture = getFixture();

//         walletFunded = await WalletBuilder.build(
//           fixture.getIndexerUri(),
//           fixture.getIndexerWsUri(),
//           fixture.getProverUri(),
//           fixture.getNodeUri(),
//           seedFunded,
//           NetworkId.Undeployed,
//           'info',
//           false,
//         );

//         walletFunded.start();
//       });

//       logger.info(`Waiting to receive tokens...`);
//       const syncedState = await waitForSync(walletFunded);
//       logger.info(`Wallet 1 balance: ${syncedState.balances[nativeToken()]}`);
//       expect(syncedState.transactionHistory).toHaveLength(1);
//     },
//     timeout,
//   );

//   test(
//     'Is working if discardTxHistory is set to true @healthcheck',
//     async () => {
//       allure.tag('smoke');
//       allure.tag('healthcheck');
//       allure.tms('PM-11091', 'PM-11091');
//       allure.epic('Headless wallet');
//       allure.feature('Wallet building');
//       allure.story('Building with discardTxHistory set to true');

//       await allure.step('Start a wallet', async function () {
//         fixture = getFixture();

//         walletFunded = await WalletBuilder.build(
//           fixture.getIndexerUri(),
//           fixture.getIndexerWsUri(),
//           fixture.getProverUri(),
//           fixture.getNodeUri(),
//           seedFunded,
//           NetworkId.Undeployed,
//           'info',
//           true,
//         );

//         walletFunded.start();
//       });

//       logger.info(`Waiting to receive tokens...`);
//       const syncedState = await waitForSync(walletFunded);
//       logger.info(`Wallet 1 balance: ${syncedState.balances[nativeToken()]}`);
//       expect(syncedState.transactionHistory).toHaveLength(0);
//     },
//     timeout,
//   );
// });

================
File: packages/e2e-tests/src/tests/tokenTransfer.remote.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { firstValueFrom } from 'rxjs';
import { TestContainersFixture, useTestContainersFixture } from './test-fixture.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import * as utils from './utils.js';
import { exit } from 'node:process';
import { logger } from './logger.js';
import * as allure from 'allure-js-commons';
import { CombinedTokenTransfer, WalletFacade } from '@midnight-ntwrk/wallet-sdk-facade';
import { createKeystore, UnshieldedKeystore } from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';
import { UnshieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';

/**
 * Tests performing a token transfer
 *
 * @group devnet
 * @group testnet
 */

describe('Token transfer', () => {
  if (process.env['SEED2'] === undefined || process.env['SEED'] === undefined) {
    logger.info('SEED or SEED2 env vars not set');
    exit(1);
  }
  const getFixture = useTestContainersFixture();
  const seed = process.env['SEED2'];
  const seedFunded = process.env['SEED'];
  const initialReceiverShieldedSecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(seed));
  const initialFundedShieldedSecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(seedFunded));
  const initialReceiverDustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(seed));
  const initialFundedDustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(seedFunded));
  const shieldedTokenRaw = ledger.shieldedToken().raw;
  const unshieldedTokenRaw = ledger.unshieldedToken().raw;
  const syncTimeout = (1 * 60 + 30) * 60 * 1000; // 1 hour + 30 minutes in milliseconds
  const timeout = 600_000;
  const outputValue = 10_000n;

  let sender: WalletFacade;
  let receiver: WalletFacade;
  let wallet: WalletFacade;
  let wallet2: WalletFacade;
  let senderSeed: string;
  let receiverSeed: string;
  let senderShieldedSecretKey: ledger.ZswapSecretKeys;
  let senderDustKey: ledger.DustSecretKey;
  let receiverShieldedSecretKey: ledger.ZswapSecretKeys;
  let receiverDustKey: ledger.DustSecretKey;
  let senderKeyStore: UnshieldedKeystore;
  let fixture: TestContainersFixture;
  let networkId: NetworkId.NetworkId;

  beforeAll(async () => {
    fixture = getFixture();
    networkId = fixture.getNetworkId();

    wallet = utils.buildWalletFacade(seedFunded, fixture);
    wallet2 = utils.buildWalletFacade(seed, fixture);
    await wallet.start(initialFundedShieldedSecretKey, initialFundedDustSecretKey);
    await wallet2.start(initialReceiverShieldedSecretKey, initialReceiverDustSecretKey);
    logger.info('Two wallets started');
    logger.info(`shielded token type: ${shieldedTokenRaw}`);
    logger.info(`unshielded token type: ${unshieldedTokenRaw}`);

    const date = new Date();
    const hour = date.getHours();

    if (hour % 2 !== 0) {
      logger.info('Using SEED2 as receiver');
      sender = wallet;
      senderShieldedSecretKey = initialFundedShieldedSecretKey;
      senderDustKey = initialFundedDustSecretKey;
      receiverShieldedSecretKey = initialReceiverShieldedSecretKey;
      receiverDustKey = initialReceiverDustSecretKey;
      receiver = wallet2;
      senderKeyStore = createKeystore(utils.getUnshieldedSeed(seedFunded), networkId);
      senderSeed = seedFunded;
      receiverSeed = seed;
    } else {
      logger.info('Using SEED2 as sender');
      sender = wallet2;
      senderShieldedSecretKey = initialReceiverShieldedSecretKey;
      senderDustKey = initialReceiverDustSecretKey;
      receiverShieldedSecretKey = initialFundedShieldedSecretKey;
      receiverDustKey = initialFundedDustSecretKey;
      receiver = wallet;
      senderKeyStore = createKeystore(utils.getUnshieldedSeed(seed), networkId);
      senderSeed = seed;
      receiverSeed = seedFunded;
    }
  }, syncTimeout);

  afterAll(async () => {
    const filenameWallet = `${senderSeed.substring(0, 7)}-${TestContainersFixture.network}.state`;
    const filenameWallet2 = `${receiverSeed.substring(0, 7)}-${TestContainersFixture.network}.state`;

    await utils.saveState(sender, filenameWallet);
    await utils.saveState(receiver, filenameWallet2);
    await utils.closeWallet(sender);
    await utils.closeWallet(receiver);
  }, timeout);

  test(
    'Is working for valid transfer @healthcheck',
    async () => {
      allure.tag('smoke');
      allure.tag('healthcheck');
      allure.tms('PM-8933', 'PM-8933');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Valid transfer transaction using bech32m address');
      await Promise.all([utils.waitForSyncFacade(sender), utils.waitForSyncFacade(receiver)]);
      const initialState = await firstValueFrom(sender.state());
      const initialShieldedBalance = initialState.shielded.balances[shieldedTokenRaw];
      const initialUnshieldedBalance = initialState.unshielded.balances[unshieldedTokenRaw];
      const initialDustBalance = initialState.dust.walletBalance(new Date());

      logger.info(`Wallet 1: ${initialShieldedBalance} shielded tokens`);
      logger.info(`Wallet 1: ${initialUnshieldedBalance} shielded tokens`);
      logger.info(`Wallet 1 available dust: ${initialDustBalance}`);
      logger.info(`Wallet 1 available shielded coins: ${initialState.shielded.availableCoins.length}`);
      logger.info(`Wallet 1 available unshielded coins: ${initialState.unshielded.availableCoins.length}`);

      const initialReceiverState = await firstValueFrom(receiver.state());
      const initialReceiverShieldedBalance = initialReceiverState.shielded.balances[shieldedTokenRaw];
      const initialReceiverUnshieldedBalance = initialReceiverState.unshielded.balances[unshieldedTokenRaw];
      const initialReceiverDustBalance = initialReceiverState.dust.walletBalance(new Date());
      logger.info(`Wallet 2: ${initialReceiverShieldedBalance} shielded tokens`);
      logger.info(`Wallet 2: ${initialReceiverUnshieldedBalance} shielded tokens`);

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: outputValue,
              receiverAddress: utils.getShieldedAddress(
                NetworkId.NetworkId.Undeployed,
                initialReceiverState.shielded.address,
              ),
            },
          ],
        },
        {
          type: 'unshielded',
          outputs: [
            {
              type: unshieldedTokenRaw,
              amount: outputValue,
              receiverAddress: UnshieldedAddress.codec
                .encode(networkId, initialReceiverState.unshielded.address)
                .asString(),
            },
          ],
        },
      ];

      const txToProve = await sender.transferTransaction(
        senderShieldedSecretKey,
        senderDustKey,
        outputsToCreate,
        new Date(Date.now() + 30 * 60 * 1000),
      );
      const signedTx = await sender.signTransaction(txToProve.transaction, (payload) =>
        senderKeyStore.signData(payload),
      );
      const provenTx = await sender.finalizeTransaction({ ...txToProve, transaction: signedTx });
      const txId = await sender.submitTransaction(provenTx);
      logger.info('txProcessing');
      logger.info('Transaction id: ' + txId);

      const pendingState = await utils.waitForFacadePending(sender);
      // logger.info(utils.walletStateTrimmed(pendingState));
      expect(pendingState.shielded.balances[shieldedTokenRaw] ?? 0n).toBeLessThanOrEqual(
        initialShieldedBalance - outputValue,
      );
      expect(pendingState.unshielded.balances[unshieldedTokenRaw]).toBeLessThanOrEqual(
        (initialUnshieldedBalance ?? 0n) - outputValue,
      );
      expect(pendingState.shielded.availableCoins.length).toBeLessThanOrEqual(
        initialState.shielded.availableCoins.length,
      );
      expect(pendingState.shielded.pendingCoins.length).toBeGreaterThanOrEqual(1);
      expect(pendingState.unshielded.pendingCoins.length).toBeGreaterThanOrEqual(1);
      expect(pendingState.dust.pendingCoins.length).toBeGreaterThanOrEqual(1);
      // expect(pendingState.totalCoins.length).toBe(initialState.shielded.totalCoins.length);
      // expect(pendingState.nullifiers.length).toBe(initialState.nullifiers.length);
      // expect(pendingState.transactionHistory.length).toBe(initialState.transactionHistory.length);

      logger.info('waiting for tx in history');
      // await waitForTxInHistory(txId, sender);
      await utils.waitForFacadePendingClear(sender);
      const finalState = await utils.waitForSyncFacade(sender);
      // logger.info(walletStateTrimmed(finalState));
      const senderFinalShieldedBalance = finalState.shielded.balances[shieldedTokenRaw];
      const senderFinalUnshieldedBalance = finalState.unshielded.balances[unshieldedTokenRaw];
      const senderFinalDustBalance = finalState.dust.walletBalance(new Date(3 * 1000));
      logger.info(`Wallet 1 final available dust: ${senderFinalDustBalance}`);
      logger.info(`Wallet 1 final available shielded coins: ${senderFinalShieldedBalance}`);
      logger.info(`Wallet 1 final available unshielded coins: ${senderFinalUnshieldedBalance}`);
      expect(senderFinalShieldedBalance).toBe(initialShieldedBalance - outputValue);
      expect(senderFinalUnshieldedBalance).toBe(initialUnshieldedBalance ?? 0n - outputValue);
      expect(senderFinalDustBalance).toBeLessThan(initialDustBalance);
      expect(finalState.shielded.availableCoins.length).toBeLessThanOrEqual(
        initialState.shielded.availableCoins.length,
      );
      expect(finalState.dust.pendingCoins.length).toBe(0);
      expect(finalState.shielded.pendingCoins.length).toBe(0);
      expect(finalState.shielded.totalCoins.length).toBeLessThanOrEqual(initialState.shielded.totalCoins.length);
      expect(finalState.unshielded.availableCoins.length).toBeLessThanOrEqual(
        initialState.unshielded.availableCoins.length,
      );
      expect(finalState.unshielded.pendingCoins.length).toBe(0);
      expect(finalState.unshielded.totalCoins.length).toBeLessThanOrEqual(initialState.shielded.totalCoins.length);
      // expect(finalState.nullifiers.length).toBeLessThanOrEqual(initialState.nullifiers.length);
      // expect(finalState.transactionHistory.length).toBeGreaterThanOrEqual(initialState.transactionHistory.length + 1);

      // await waitForTxInHistory(txId, receiver);
      const finalState2 = await utils.waitForSyncFacade(receiver);
      // logger.info(walletStateTrimmed(finalState2));
      const receiverFinalShieldedBalance = finalState.shielded.balances[shieldedTokenRaw];
      const receiverFinalUnshieldedBalance = finalState.unshielded.balances[unshieldedTokenRaw];
      const receiverFinalDustBalance = finalState.dust.walletBalance(new Date(3 * 1000));
      logger.info(`Wallet 2 final available shielded coins: ${receiverFinalShieldedBalance}`);
      logger.info(`Wallet 2 final available unshielded coins: ${receiverFinalUnshieldedBalance}`);
      expect(receiverFinalShieldedBalance).toBe(initialReceiverShieldedBalance + outputValue);
      expect(receiverFinalUnshieldedBalance).toBe(initialReceiverUnshieldedBalance ?? 0n + outputValue);
      expect(finalState2.shielded.pendingCoins.length).toBe(0);
      expect(finalState2.shielded.totalCoins.length).toBeGreaterThanOrEqual(
        initialReceiverState.shielded.totalCoins.length + 1,
      );
      expect(receiverFinalDustBalance).toBe(initialReceiverDustBalance);
      // expect(finalState2.nullifiers.length).toBeGreaterThanOrEqual(initialState2.nullifiers.length + 1);
      // expect(finalState2.transactionHistory.length).toBeGreaterThanOrEqual(initialState2.transactionHistory.length + 1);
    },
    syncTimeout,
  );

  test(
    'can perform a self-transaction',
    async () => {
      allure.tag('smoke');
      allure.tms('PM-9680', 'PM-9680');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Valid transfer self-transaction');

      const initialState = await utils.waitForSyncFacade(sender);
      const initialBalance = initialState.shielded.balances[shieldedTokenRaw];
      logger.info(initialState.shielded.availableCoins);
      logger.info(`Wallet 1: ${initialBalance}`);
      logger.info(`Wallet 1 available coins: ${initialState.shielded.availableCoins.length}`);

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: outputValue,
              receiverAddress: utils.getShieldedAddress(networkId, initialState.shielded.address),
            },
          ],
        },
      ];
      const txToProve = await sender.transferTransaction(
        senderShieldedSecretKey,
        senderDustKey,
        outputsToCreate,
        new Date(),
      );
      const provenTx = await sender.finalizeTransaction(txToProve);
      const txId = await sender.submitTransaction(provenTx);
      const fees = provenTx.fees(ledger.LedgerParameters.initialParameters());
      logger.info('Transaction id: ' + txId);

      const pendingState = await utils.waitForPending(sender.shielded);
      // logger.info(utils.walletStateTrimmed(pendingState));
      logger.info(`Wallet 1 available coins: ${pendingState.availableCoins.length}`);
      expect(pendingState.balances[shieldedTokenRaw] ?? 0n).toBeLessThan(initialBalance - outputValue);
      expect(pendingState.availableCoins.length).toBeLessThan(initialState.shielded.availableCoins.length);
      expect(pendingState.pendingCoins.length).toBeLessThanOrEqual(1);
      expect(pendingState.totalCoins.length).toBe(initialState.shielded.totalCoins.length);
      // expect(pendingState.nullifiers.length).toBe(initialState.nullifiers.length);
      // expect(pendingState.transactionHistory.length).toBe(initialState.transactionHistory.length);

      // await utils.waitForTxInHistory(String(txId), sender.shielded);
      const finalState = await utils.waitForSyncFacade(sender);
      // logger.info(walletStateTrimmed(finalState));
      logger.info(`Wallet 1 available coins: ${finalState.shielded.availableCoins.length}`);
      logger.info(`Wallet 1: ${finalState.shielded.balances[shieldedTokenRaw]}`);
      // actually deducted fees are greater - PM-7721
      expect(finalState.shielded.balances[shieldedTokenRaw] ?? 0n).toBeLessThanOrEqual(initialBalance - fees);
      expect(finalState.shielded.availableCoins.length).toBeGreaterThanOrEqual(
        initialState.shielded.availableCoins.length,
      );
      expect(finalState.shielded.pendingCoins.length).toBe(0);
      expect(finalState.shielded.totalCoins.length).toBeGreaterThanOrEqual(initialState.shielded.totalCoins.length);
      // expect(finalState.nullifiers.length).toBeGreaterThanOrEqual(initialState.nullifiers.length);
      // expect(finalState.transactionHistory.length).toBeGreaterThanOrEqual(initialState.transactionHistory.length + 1);
    },
    timeout,
  );

  test('Able to swap shielded tokens', async () => {
    const shieldedToken1 = '0000000000000000000000000000000000000000000000000000000000000001';
    const shieldedToken2 = '0000000000000000000000000000000000000000000000000000000000000002';
    const ttl = new Date(Date.now() + 30 * 60 * 1000);

    const initialStateWallet1 = await utils.waitForSyncFacade(sender);
    const initialStateWallet2 = await utils.waitForSyncFacade(receiver);

    // Does walllet have shielded tokens to swap
    const wallet1BalanceToken1 = initialStateWallet1.shielded.balances[shieldedToken1] ?? 0n;
    const wallet1BalanceToken2 = initialStateWallet1.shielded.balances[shieldedToken2] ?? 0n;
    const wallet2BalanceToken1 = initialStateWallet2.shielded.balances[shieldedToken1] ?? 0n;
    const wallet2BalanceToken2 = initialStateWallet2.shielded.balances[shieldedToken2] ?? 0n;

    if (wallet1BalanceToken1 < 1000000n || wallet2BalanceToken2 < 1000000n) {
      logger.info('One of the wallets does not have enough shielded tokens to swap');
      return;
    }

    const swapTx = await sender.initSwap(
      senderShieldedSecretKey,
      { shielded: { [shieldedToken1]: 1000000n } },
      [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedToken2,
              amount: 1000000n,
              receiverAddress: utils.getShieldedAddress(networkId, initialStateWallet1.shielded.address),
            },
          ],
        },
      ],
      ttl,
    );
    const provenTx = await sender.finalizeTransaction({ type: 'TransactionToProve', transaction: swapTx });
    const wallet1TxId = await sender.submitTransaction(provenTx);
    logger.info('Transaction id: ' + wallet1TxId);

    const wallet2BalancedTx = await receiver.balanceTransaction(
      receiverShieldedSecretKey,
      receiverDustKey,
      provenTx,
      ttl,
    );
    const finalizedSwapTx = await receiver.finalizeTransaction(wallet2BalancedTx);
    const wallet2TxId = await receiver.submitTransaction(finalizedSwapTx);
    logger.info('Transaction id 2: ' + wallet2TxId);

    const finalStateWallet1 = await utils.waitForFinalizedBalance(sender.shielded);
    const finalStateWallet2 = await utils.waitForFinalizedBalance(receiver.shielded);
    expect(finalStateWallet1.balances[shieldedToken1] ?? 0n).toBe(wallet1BalanceToken1 - 1000000n);
    expect(finalStateWallet1.balances[shieldedToken2] ?? 0n).toBe(wallet1BalanceToken2 + 1000000n);
    expect(finalStateWallet2.balances[shieldedToken2] ?? 0n).toBe(wallet2BalanceToken2 - 1000000n);
    expect(finalStateWallet2.balances[shieldedToken1] ?? 0n).toBe(wallet2BalanceToken1 + 1000000n);
  });

  // TO-DO: check why pending is not used
  test.skip(
    'coin becomes available when tx fails on node',
    async () => {
      allure.tms('PM-8919', 'PM-8919');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Invalid transaction');
      const initialState = await firstValueFrom(sender.state());
      const syncedState = await utils.waitForSyncFacade(sender);
      const initialBalance = syncedState?.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);
      const balance = 25000000000000000n;

      const initialState2 = await firstValueFrom(receiver.state());
      const initialBalance2 = initialState2.shielded.balances[shieldedTokenRaw];
      if (initialBalance2 === undefined || initialBalance2 === 0n) {
        logger.info(`Waiting to receive tokens...`);
      }

      // const outputsToCreate = [
      //   {
      //     type: rawNativeTokenType,
      //     amount: outputValue,
      //     receiverAddress: initialState2.address,
      //   },
      // ];
      const coin = ledger.createShieldedCoinInfo(shieldedTokenRaw, balance);
      const output = ledger.ZswapOutput.new(
        coin,
        0,
        initialState.shielded.coinPublicKey.toHexString(),
        initialState.shielded.encryptionPublicKey.toHexString(),
      );
      const offer = ledger.ZswapOffer.fromOutput(output, shieldedTokenRaw, outputValue);
      const unprovenTx = ledger.Transaction.fromParts(networkId, offer);
      const provenTx = await sender.finalizeTransaction({
        type: 'TransactionToProve',
        transaction: unprovenTx,
      });
      // const txToProve = await walletFunded.transferTransaction(outputsToCreate);
      // const provenTx = await walletFunded.proveTransaction(txToProve);
      await expect(
        Promise.all([sender.submitTransaction(provenTx), sender.submitTransaction(provenTx)]),
      ).rejects.toThrow();
      // const txToProve = await walletFunded.transferTransaction(outputsToCreate);
      // const provenTx = await walletFunded.proveTransaction(txToProve);
      // const id = await walletFunded.submitTransaction(provenTx);
      // logger.info('Transaction id: ' + id);

      // const pendingState = await waitForPending(walletFunded);
      // logger.info(pendingState);
      // expect(pendingState.balances[rawNativeTokenType]).toBe(20000000000000000n);
      // expect(pendingState.availableCoins.length).toBe(4);
      // expect(pendingState.pendingCoins.length).toBe(1);
      // expect(pendingState.coins.length).toBe(5);
      // expect(pendingState.transactionHistory.length).toBe(2);

      const finalState = await utils.waitForFinalizedBalance(sender.shielded);
      // const finalState = await waitForTxHistory(walletFunded, 2);
      expect(finalState.balances[shieldedTokenRaw]).toBe(balance);
      expect(finalState.availableCoins.length).toBe(5);
      expect(finalState.pendingCoins.length).toBe(0);
      expect(finalState.totalCoins.length).toBe(5);
      // expect(finalState.transactionHistory.length).toBe(1);

      // const finalState2 = await waitForFinalizedBalance(wallet2);
      // logger.info(finalState2);
      // expect(finalState2.balances[rawNativeTokenType]).toBe(outputValue);
      // expect(finalState2.availableCoins.length).toBe(1);
      // expect(finalState2.pendingCoins.length).toBe(0);
      // expect(finalState2.coins.length).toBe(1);
      // expect(finalState2.transactionHistory.length).toBe(1);
    },
    timeout,
  );

  // TO-DO: check why pending is not used
  test.skip(
    'coin becomes available when tx does not get proved',
    async () => {
      allure.tms('PM-8917', 'PM-8917');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Transaction not proved');
      const syncedState = await utils.waitForSyncFacade(sender);
      const initialBalance = syncedState?.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);

      logger.info('Stopping proof server container..');
      await fixture.getProofServerContainer().stop({ timeout: 10_000 });

      const initialState2 = await firstValueFrom(receiver.state());

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: outputValue,
              receiverAddress: utils.getShieldedAddress(networkId, initialState2.shielded.address),
            },
          ],
        },
      ];

      const txToProve = await sender.transferTransaction(
        senderShieldedSecretKey,
        senderDustKey,
        outputsToCreate,
        new Date(),
      );
      await expect(sender.finalizeTransaction(txToProve)).rejects.toThrow();

      // const pendingState = await waitForPending(walletFunded);
      // logger.info(pendingState);
      // expect(pendingState.balances[rawNativeTokenType]).toBe(20000000000000000n);
      // expect(pendingState.availableCoins.length).toBe(4);
      // expect(pendingState.pendingCoins.length).toBe(1);
      // expect(pendingState.coins.length).toBe(5);
      // expect(pendingState.transactionHistory.length).toBe(1);

      const finalState = await utils.waitForFinalizedBalance(sender.shielded);
      expect(finalState).toMatchObject(syncedState);
      // expect(finalState.balances[rawNativeTokenType]).toBe(initialBalance);
      // expect(finalState.availableCoins.length).toBe(5);
      // expect(finalState.pendingCoins.length).toBe(0);
      // expect(finalState.coins.length).toBe(5);
      // expect(finalState.transactionHistory.length).toBe(1);
    },
    timeout,
  );

  test(
    'error message when attempting to send to an invalid address',
    async () => {
      allure.tms('PM-9678', 'PM-9678');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Invalid address error message');
      const syncedState = await utils.waitForSyncFacade(sender);
      const initialBalance = syncedState?.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);
      const invalidAddress = 'invalidAddress';

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: outputValue,
              receiverAddress: invalidAddress,
            },
          ],
        },
      ];
      await expect(
        sender.transferTransaction(senderShieldedSecretKey, senderDustKey, outputsToCreate, new Date()),
      ).rejects.toThrow(`Address parsing error: invalidAddress`);
    },
    timeout,
  );

  test(
    'error message when attempting to send an invalid amount',
    async () => {
      allure.tms('PM-9679', 'PM-9679');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Invalid amount error message');
      const syncedState = await utils.waitForSyncFacade(sender);
      const initialBalance = syncedState?.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);
      // the max amount that we support: Rust u64 max. The entire Midnight supply
      // is 24 billion tDUST, 1 tDUST = 10^6 specks, which is lesser
      // Check below amount is still erroring with invalid transaction after rewrite
      // const invalidAmount = 18446744073709551616n;
      const aboveBalance = initialBalance + 1000n;
      const initialState2 = await firstValueFrom(receiver.state());

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: aboveBalance,
              receiverAddress: utils.getShieldedAddress(networkId, initialState2.shielded.address),
            },
          ],
        },
      ];
      try {
        const txToProve = await sender.transferTransaction(
          senderShieldedSecretKey,
          senderDustKey,
          outputsToCreate,
          new Date(),
        );
        const provenTx = await sender.finalizeTransaction(txToProve);
        await sender.submitTransaction(provenTx);
      } catch (e: unknown) {
        if (e instanceof Error) {
          expect(e.message).toContain('Insufficient funds');
        } else {
          logger.info(e);
        }
      }
    },
    timeout,
  );

  test(
    'error message when attempting to send a negative amount',
    async () => {
      allure.tms('PM-9679', 'PM-9679');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Invalid amount error message');
      const syncedState = await utils.waitForSyncFacade(sender);
      const initialBalance = syncedState?.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);

      const initialState2 = await firstValueFrom(receiver.state());

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: -5n,
              receiverAddress: utils.getShieldedAddress(networkId, initialState2.shielded.address),
            },
          ],
        },
      ];
      await expect(
        sender.transferTransaction(senderShieldedSecretKey, senderDustKey, outputsToCreate, new Date()),
      ).rejects.toThrow('The amount needs to be positive');
    },
    timeout,
  );

  test(
    'error message when attempting to send a zero amount',
    async () => {
      allure.tms('PM-9679', 'PM-9679');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Invalid amount error message');
      const syncedState = await utils.waitForSyncFacade(sender);
      const initialBalance = syncedState?.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);
      const initialState2 = await firstValueFrom(receiver.state());

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: 0n,
              receiverAddress: utils.getShieldedAddress(networkId, initialState2.shielded.address),
            },
          ],
        },
      ];

      await expect(
        sender.transferTransaction(senderShieldedSecretKey, senderDustKey, outputsToCreate, new Date()),
      ).rejects.toThrow('The amount needs to be positive');
    },
    timeout,
  );

  test(
    'error message when attempting to send an empty array of outputs',
    async () => {
      allure.tms('PM-9679', 'PM-9679');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Invalid amount error message');
      const syncedState = await utils.waitForSyncFacade(sender);
      const initialBalance = syncedState?.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);

      await expect(sender.transferTransaction(senderShieldedSecretKey, senderDustKey, [], new Date())).rejects.toThrow(
        'At least one shielded or unshielded output is required.',
      );
    },
    timeout,
  );

  test('error message when sending token to bech32m address from different networkId', async () => {
    allure.tms('PM-14147', 'PM-14147');
    allure.epic('Headless wallet');
    allure.feature('Wallet state - Bech32m');
    allure.story('Tx to addresss from different networkId');
    const bech32mAddress =
      'mn_shield-addr_undeployed1kav2zmw5u5qtvfpcx0xnkdrsrsmnqpxd8c6rt6nrqs34yy0ttahsxqpmpljwuf6rjg0pzseww9l8xlpjwjf2sxackw69numxqs9ag2hphgx2cfjgtqvqyaeqtx97rpvy0sp2gmc60zreapu488v043';

    const syncedState = await utils.waitForSyncFacade(sender);
    const initialBalance = syncedState?.shielded.balances[shieldedTokenRaw] ?? 0n;
    logger.info(`Wallet 1 balance is: ${initialBalance}`);

    const outputsToCreate: CombinedTokenTransfer[] = [
      {
        type: 'shielded',
        outputs: [
          {
            type: shieldedTokenRaw,
            amount: 1n,
            receiverAddress: bech32mAddress,
          },
        ],
      },
    ];

    await expect(
      sender.transferTransaction(senderShieldedSecretKey, senderDustKey, outputsToCreate, new Date()),
    ).rejects.toThrow(
      'Address parsing error: mn_shield-addr_undeployed1kav2zmw5u5qtvfpcx0xnkdrsrsmnqpxd8c6rt6nrqs34yy0ttahsxqpmpljwuf6rjg0pzseww9l8xlpjwjf2sxackw69numxqs9ag2hphgx2cfjgtqvqyaeqtx97rpvy0sp2gmc60zreapu488v043',
    );
  });

  test('error message when sending token to bech32m address from different chain', async () => {
    allure.tms('PM-14148', 'PM-14148');
    allure.epic('Headless wallet');
    allure.feature('Wallet state - Bech32m');
    allure.story('Tx to addresss from different chain');
    const bech32mAddress = 'bc1p5d7rjq7g6rdk2yhzks9smlaqtedr4dekq08ge8ztwac72sfr9rusxg3297';

    const syncedState = await utils.waitForSyncFacade(sender);
    const initialBalance = syncedState?.shielded.balances[shieldedTokenRaw] ?? 0n;
    logger.info(`Wallet 1 balance is: ${initialBalance}`);

    const outputsToCreate: CombinedTokenTransfer[] = [
      {
        type: 'shielded',
        outputs: [
          {
            type: shieldedTokenRaw,
            amount: 1n,
            receiverAddress: bech32mAddress,
          },
        ],
      },
    ];

    await expect(
      sender.transferTransaction(senderShieldedSecretKey, senderDustKey, outputsToCreate, new Date()),
    ).rejects.toThrow('Address parsing error: bc1p5d7rjq7g6rdk2yhzks9smlaqtedr4dekq08ge8ztwac72sfr9rusxg3297');
  });
});

================
File: packages/e2e-tests/src/tests/tokenTransfer.undeployed.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { filter, firstValueFrom } from 'rxjs';
import { TestContainersFixture, useTestContainersFixture } from './test-fixture.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import * as utils from './utils.js';
import { logger } from './logger.js';
import * as allure from 'allure-js-commons';
import { CombinedTokenTransfer, WalletFacade } from '@midnight-ntwrk/wallet-sdk-facade';
import { createKeystore } from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';
import { randomBytes } from 'node:crypto';
import { UnshieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';

/**
 * Tests performing a token transfer
 *
 * @group undeployed
 */

describe('Token transfer', () => {
  const getFixture = useTestContainersFixture();
  const seed = 'b7d32a5094ec502af45aa913b196530e155f17ef05bbf5d75e743c17c3824a82';
  const fundedSeed = '0000000000000000000000000000000000000000000000000000000000000001';
  const seedShieldedSecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(seed));
  const fundedShieldedSecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(fundedSeed));
  const seedDustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(seed));
  const fundedDustSecretKey = ledger.DustSecretKey.fromSeed(utils.getDustSeed(fundedSeed));
  const unshieldedFundedKeyStore = createKeystore(utils.getUnshieldedSeed(fundedSeed), NetworkId.NetworkId.Undeployed);
  const dustTokenHash = (ledger.nativeToken() as { tag: string; raw: string }).raw;
  const shieldedTokenRaw = ledger.shieldedToken().raw;
  const unshieldedTokenRaw = ledger.unshieldedToken().raw;
  const timeout = 800_000;
  const outputValue = 3_000_000n;

  let fixture: TestContainersFixture;
  let fundedFacade: WalletFacade;
  let walletFacade: WalletFacade;
  const outputValueNativeToken = 1n;
  let tokenTypeHash: string | undefined;

  beforeEach(async () => {
    fixture = getFixture();

    fundedFacade = utils.buildWalletFacade(fundedSeed, fixture);
    walletFacade = utils.buildWalletFacade(seed, fixture);

    await fundedFacade.start(fundedShieldedSecretKey, fundedDustSecretKey);
    await walletFacade.start(seedShieldedSecretKey, seedDustSecretKey);
  });

  afterEach(async () => {
    await utils.closeWallet(fundedFacade);
    await utils.closeWallet(walletFacade);
  });

  test(
    'can perform a self-transaction',
    async () => {
      allure.tag('smoke');
      allure.tag('healthcheck');
      allure.tms('PM-9680', 'PM-9680');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Valid transfer self-transaction');

      const initialState = await utils.waitForSyncFacade(fundedFacade);
      const initialBalance = initialState.shielded.balances[shieldedTokenRaw];
      const initialDustBalance = initialState.dust.walletBalance(new Date());
      logger.info(`Wallet 1: ${initialBalance}`);
      logger.info(`Wallet 1: ${initialDustBalance} tDUST`);
      logger.info(`Wallet 1 available coins: ${initialState.shielded.availableCoins.length}`);

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded' as const,
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: outputValue,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState.shielded.address),
            },
          ],
        },
      ];
      const txToProve = await fundedFacade.transferTransaction(
        fundedShieldedSecretKey,
        fundedDustSecretKey,
        outputsToCreate,
        new Date(Date.now() + 60 * 60 * 1000),
      );
      logger.info('Sending transaction...');
      const provenTx = await fundedFacade.finalizeTransaction(txToProve);
      const txId = await fundedFacade.submitTransaction(provenTx);
      const txFees = await fundedFacade.calculateTransactionFee(provenTx);
      // for (const [key, value] of provenTx.imbalances(0, fees)) {
      //   console.log(key, value);
      // }
      // for (const [key, value] of provenTx.imbalances(1, fees)) {
      //   console.log(key, value);
      // }
      logger.info('Transaction id: ' + txId);
      // logger.info('Wait for pending...');
      // const pendingState = await utils.waitForFacadePending(fundedFacade);
      // logger.info(`Wallet 1 available coins: ${pendingState.shielded.availableCoins.length}`);
      // expect(pendingState.shielded.balances[shieldedTokenRaw]).toBeLessThan(initialBalance);
      // expect(pendingState.shielded.availableCoins.length).toBe(6);
      // expect(pendingState.shielded.pendingCoins.length).toBe(2);
      // expect(pendingState.shielded.totalCoins.length).toBeLessThanOrEqual(8);
      // expect(pendingState.nullifiers.length).toBe(7);
      // expect(pendingState.transactionHistory.length).toBe(1);

      await utils.waitForFacadePendingClear(fundedFacade);
      const finalState = await utils.waitForSyncFacade(fundedFacade);
      // logger.info(walletStateTrimmed(finalState));
      logger.info(`Wallet 1 available coins: ${finalState.shielded.availableCoins.length}`);
      // actually deducted fees are greater - PM-7721
      expect(finalState.shielded.balances[shieldedTokenRaw]).toBe(initialBalance);
      expect(finalState.shielded.availableCoins.length).toBe(8);
      expect(finalState.shielded.pendingCoins.length).toBe(0);
      expect(finalState.shielded.totalCoins.length).toBe(8);
      // Transaction fees are calculated by adding fee payment with margin plus total fee charge so
      // total fees deducted should be higher than estimated fees
      expect(finalState.dust.walletBalance(new Date(3 * 1000))).toBeLessThan(initialDustBalance - txFees);
      // expect(finalState.nullifiers.length).toBe(8);
      // expect(finalState.transactionHistory.length).toBe(2);
    },
    timeout,
  );

  test(
    'can perform a transaction to two different wallet addresses',
    async () => {
      allure.tag('smoke');
      allure.tag('healthcheck');
      allure.tms('PM-9680', 'PM-9680');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Valid transfer self-transaction');

      const receiverSeed1 = randomBytes(32).toString('hex');
      const receiverSeed2 = randomBytes(32).toString('hex');
      const receiverShieldedSecretKey1 = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(receiverSeed1));
      const receiverShieldedSecretKey2 = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(receiverSeed2));
      const receiverDustSecretKey1 = ledger.DustSecretKey.fromSeed(utils.getDustSeed(receiverSeed1));
      const receiverDustSecretKey2 = ledger.DustSecretKey.fromSeed(utils.getDustSeed(receiverSeed2));

      const initialState = await utils.waitForSyncFacade(fundedFacade);
      const initialBalance = initialState.shielded.balances[shieldedTokenRaw];
      const initialDustBalance = initialState.dust.walletBalance(new Date());
      logger.info(`Wallet 1: ${initialBalance}`);
      logger.info(`Wallet 1: ${initialDustBalance} tDUST`);
      logger.info(`Wallet 1 available coins: ${initialState.shielded.availableCoins.length}`);

      const receiver1 = utils.buildWalletFacade(receiverSeed1, fixture);
      const receiver2 = utils.buildWalletFacade(receiverSeed2, fixture);
      await receiver1.start(receiverShieldedSecretKey1, receiverDustSecretKey1);
      await receiver2.start(receiverShieldedSecretKey2, receiverDustSecretKey2);
      const initialReceiver1State = await utils.waitForSyncFacade(receiver1);
      const initialReceiver2State = await utils.waitForSyncFacade(receiver2);
      logger.info('Receiver wallets');

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: outputValue,
              receiverAddress: utils.getShieldedAddress(
                NetworkId.NetworkId.Undeployed,
                initialReceiver1State.shielded.address,
              ),
            },
          ],
        },
        {
          type: 'unshielded',
          outputs: [
            {
              type: unshieldedTokenRaw,
              amount: outputValue,
              receiverAddress: UnshieldedAddress.codec
                .encode(fixture.getNetworkId(), initialReceiver1State.unshielded.address)
                .asString(),
            },
          ],
        },
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: outputValue,
              receiverAddress: utils.getShieldedAddress(
                NetworkId.NetworkId.Undeployed,
                initialReceiver2State.shielded.address,
              ),
            },
          ],
        },
        {
          type: 'unshielded',
          outputs: [
            {
              type: unshieldedTokenRaw,
              amount: outputValue,
              receiverAddress: UnshieldedAddress.codec
                .encode(fixture.getNetworkId(), initialReceiver2State.unshielded.address)
                .asString(),
            },
          ],
        },
      ];
      const txToProve = await fundedFacade.transferTransaction(
        fundedShieldedSecretKey,
        fundedDustSecretKey,
        outputsToCreate,
        new Date(Date.now() + 60 * 60 * 1000),
      );
      logger.info('Sending transaction...');
      const signedTx = await fundedFacade.signTransaction(txToProve.transaction, (payload) =>
        unshieldedFundedKeyStore.signData(payload),
      );
      const finalizedTx = await fundedFacade.finalizeTransaction({ ...txToProve, transaction: signedTx });
      const txId = await fundedFacade.submitTransaction(finalizedTx);
      const txFees = await fundedFacade.calculateTransactionFee(finalizedTx);
      logger.info('Transaction id: ' + txId);
      logger.info('Wait for pending...');
      const pendingState = await utils.waitForFacadePending(fundedFacade);
      logger.info(`Wallet 1 available coins: ${pendingState.shielded.availableCoins.length}`);
      expect(pendingState.shielded.balances[shieldedTokenRaw]).toBeLessThan(initialBalance);
      expect(pendingState.shielded.availableCoins.length).toBe(7); // Test intemittently failing for different available coins
      // expect(pendingState.shielded.pendingCoins.length).toBe(2);
      expect(pendingState.shielded.totalCoins.length).toBeLessThanOrEqual(8);
      expect(pendingState.unshielded.availableCoins.length).toBe(4);
      expect(pendingState.unshielded.pendingCoins.length).toBe(1);
      expect(pendingState.unshielded.totalCoins.length).toBeLessThanOrEqual(8);

      await utils.waitForFacadePendingClear(fundedFacade);
      const finalState = await utils.waitForSyncFacade(fundedFacade);
      const finalReceiver1State = await utils.waitForSyncFacade(receiver1);
      const finalReceiver2State = await utils.waitForSyncFacade(receiver2);
      // logger.info(walletStateTrimmed(finalState));
      logger.info(`Wallet 1 available coins: ${finalState.shielded.availableCoins.length}`);
      logger.info(`Dust fees paid: ${initialDustBalance - finalState.dust.walletBalance(new Date(3 * 1000))}`);
      // actually deducted fees are greater - PM-7721
      expect(finalState.shielded.balances[shieldedTokenRaw]).toBe(initialBalance - outputValue * 2n);
      expect(finalState.unshielded.balances[unshieldedTokenRaw]).toBe(initialBalance - outputValue * 2n);
      expect(finalState.shielded.availableCoins.length).toBe(7);
      expect(finalState.shielded.pendingCoins.length).toBe(0);
      expect(finalState.shielded.totalCoins.length).toBe(7);
      expect(finalState.dust.walletBalance(new Date(3 * 1000))).toBeLessThan(initialDustBalance - txFees);
      expect(finalReceiver1State.shielded.balances[shieldedTokenRaw]).toBe(outputValue);
      expect(finalReceiver1State.unshielded.balances[shieldedTokenRaw]).toBe(outputValue);
      expect(finalReceiver2State.shielded.balances[shieldedTokenRaw]).toBe(outputValue);
      expect(finalReceiver2State.unshielded.balances[shieldedTokenRaw]).toBe(outputValue);
      await receiver1.stop();
      await receiver2.stop();
    },
    timeout,
  );

  test(
    'coin becomes available when tx fails on node',
    async () => {
      allure.tms('PM-8919', 'PM-8919');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Invalid transaction');
      const initialState = await firstValueFrom(fundedFacade.state());
      const syncedState = await utils.waitForSyncFacade(fundedFacade);
      const initialBalance = syncedState?.shielded.balances[dustTokenHash] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);
      const balance = 2500000000000000n;

      const initialState2 = await firstValueFrom(walletFacade.state());
      const initialBalance2 = initialState2.shielded.balances[dustTokenHash];
      if (initialBalance2 === undefined || initialBalance2 === 0n) {
        logger.info(`Waiting to receive tokens...`);
      }

      const coin = ledger.createShieldedCoinInfo(dustTokenHash, outputValue);
      const output = ledger.ZswapOutput.new(
        coin,
        0,
        initialState.shielded.coinPublicKey.toHexString(),
        initialState.shielded.encryptionPublicKey.toHexString(),
      );
      const offer = ledger.ZswapOffer.fromOutput(output, dustTokenHash, outputValue);
      const unprovenTx = ledger.Transaction.fromParts(NetworkId.NetworkId.Undeployed, offer);
      const provenTx = await fundedFacade.finalizeTransaction({
        type: 'TransactionToProve',
        transaction: unprovenTx,
      });
      await expect(
        Promise.all([fundedFacade.submitTransaction(provenTx), fundedFacade.submitTransaction(provenTx)]),
      ).rejects.toThrow();

      const finalState = await utils.waitForFinalizedBalance(fundedFacade.shielded);
      expect(finalState.balances[dustTokenHash]).toBe(balance);
      expect(finalState.availableCoins.length).toBe(7);
      expect(finalState.pendingCoins.length).toBe(0);
      expect(finalState.totalCoins.length).toBe(7);
    },
    timeout,
  );

  // TO-DO: Dust stays pending and only returns after some time. Wait for ledger to implement api to return back pending.
  test.skip(
    'coin becomes available when tx does not get proved',
    async () => {
      allure.tms('PM-8917', 'PM-8917');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Transaction not proved');
      const syncedState = await utils.waitForSyncFacade(fundedFacade);
      const initialBalance = syncedState?.shielded.balances[dustTokenHash] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);
      const balance = 2500000000000000n;

      logger.info('Stopping proof server container..');
      await fixture.getProofServerContainer().stop({ timeout: 10_000 });

      const initialState2 = await firstValueFrom(walletFacade.state());

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: dustTokenHash,
              amount: outputValue,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState2.shielded.address),
            },
          ],
        },
      ];
      const txToProve = await fundedFacade.transferTransaction(
        fundedShieldedSecretKey,
        fundedDustSecretKey,
        outputsToCreate,
        new Date(Date.now() + 60 * 60 * 1000),
      );
      await expect(fundedFacade.finalizeTransaction(txToProve)).rejects.toThrow();

      // const pendingState = await waitForPending(fundedFacade);
      // logger.info(pendingState);
      // expect(pendingState.balances[dustTokenHash]).toBe(20000000000000000n);
      // expect(pendingState.availableCoins.length).toBe(4);
      // expect(pendingState.pendingCoins.length).toBe(1);
      // expect(pendingState.coins.length).toBe(5);
      // expect(pendingState.transactionHistory.length).toBe(1);

      const finalState = await utils.waitForFacadePendingClear(fundedFacade);
      expect(finalState.shielded.balances[dustTokenHash]).toBe(balance);
      expect(finalState.shielded.availableCoins.length).toBe(7);
      expect(finalState.shielded.pendingCoins.length).toBe(0);
      expect(finalState.shielded.totalCoins.length).toBe(7);
      // expect(finalState.transactionHistory.length).toBe(1);
    },
    timeout,
  );

  // TO-DO: Same as above
  test.skip(
    'coin becomes available when tx does not get submitted',
    async () => {
      allure.tms('PM-8918', 'PM-8918');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Transaction not submitted');
      const syncedState = await utils.waitForSyncFacade(fundedFacade);
      const initialBalance = syncedState?.shielded.balances[dustTokenHash] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);
      const balance = 2500000000000000n;

      logger.info('Stopping node container..');
      await fixture.getNodeContainer().stop({ removeVolumes: false });

      const initialState2 = await firstValueFrom(walletFacade.state());

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: outputValue,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState2.shielded.address),
            },
          ],
        },
      ];
      const txToProve = await fundedFacade.transferTransaction(
        fundedShieldedSecretKey,
        fundedDustSecretKey,
        outputsToCreate,
        new Date(Date.now() + 60 * 60 * 1000),
      );
      const provenTx = await fundedFacade.finalizeTransaction(txToProve);
      await expect(fundedFacade.submitTransaction(provenTx)).rejects.toThrow();

      // const pendingState = await waitForPending(fundedFacade);
      // logger.info(pendingState);
      // expect(pendingState.balances[dustTokenHash]).toBe(20000000000000000n);
      // expect(pendingState.availableCoins.length).toBe(4);
      // expect(pendingState.pendingCoins.length).toBe(1);
      // expect(pendingState.coins.length).toBe(5);
      // expect(pendingState.transactionHistory.length).toBe(1);

      const finalState = await utils.waitForFinalizedBalance(fundedFacade.shielded);
      expect(finalState.balances[dustTokenHash]).toBe(balance);
      expect(finalState.availableCoins.length).toBe(5);
      expect(finalState.pendingCoins.length).toBe(0);
      expect(finalState.totalCoins.length).toBe(5);
      // expect(finalState.transactionHistory.length).toBe(1);
    },
    timeout,
  );

  test(
    'error message when attempting to send to an invalid address',
    async () => {
      allure.tms('PM-9678', 'PM-9678');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Invalid address error message');
      const syncedState = await utils.waitForSyncFacade(fundedFacade);
      const initialBalance = syncedState?.shielded.balances[dustTokenHash] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);
      const invalidAddress = 'invalidAddress';

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: outputValue,
              receiverAddress: invalidAddress,
            },
          ],
        },
      ];
      await expect(
        fundedFacade.transferTransaction(fundedShieldedSecretKey, fundedDustSecretKey, outputsToCreate, new Date()),
      ).rejects.toThrow(`Address parsing error: invalidAddress`);
    },
    timeout,
  );

  test(
    'error message when attempting to send an amount greater than available balance',
    async () => {
      allure.tms('PM-9679', 'PM-9679');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Invalid amount error message');
      const syncedState = await utils.waitForSyncFacade(fundedFacade);
      const initialBalance = syncedState?.shielded.balances[dustTokenHash] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);
      const aboveBalanceAmount = initialBalance + 1n;
      logger.info(`Attempting to send amount: ${aboveBalanceAmount}`);
      const initialState2 = await firstValueFrom(walletFacade.state());

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: aboveBalanceAmount,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState2.shielded.address),
            },
          ],
        },
      ];
      await expect(
        fundedFacade.transferTransaction(
          fundedShieldedSecretKey,
          fundedDustSecretKey,
          outputsToCreate,
          new Date(Date.now() + 60 * 60 * 1000),
        ),
      ).rejects.toThrow(`Insufficient funds`);
    },
    timeout,
  );

  // Bug logged: PM20174
  test.skip(
    'error message when attempting to send an amount at max available network supply',
    async () => {
      allure.tms('PM-9679', 'PM-9679');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Invalid amount error message');
      const syncedState = await utils.waitForSyncFacade(fundedFacade);
      const initialBalance = syncedState?.shielded.balances[dustTokenHash] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);
      // the max amount that we support: Rust u128 max.
      const maxAmount = 340_282_366_920_938_463_463_374_607_431_768_211_455n;
      const initialState2 = await firstValueFrom(walletFacade.state());

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: maxAmount,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState2.shielded.address),
            },
          ],
        },
      ];
      const txToProve = await fundedFacade.transferTransaction(
        fundedShieldedSecretKey,
        fundedDustSecretKey,
        outputsToCreate,
        new Date(Date.now() + 60 * 60 * 1000),
      );
      const provenTx = await fundedFacade.finalizeTransaction(txToProve);
      await expect(fundedFacade.submitTransaction(provenTx)).rejects.toThrow(
        `Insufficient Funds: could not balance 02000000000000000000000000000000000000000000000000000000000000000000`,
      );
    },
    timeout,
  );

  test(
    'error message when attempting to send an invalid amount',
    async () => {
      allure.tms('PM-9679', 'PM-9679');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Invalid amount error message');
      const syncedState = await utils.waitForSyncFacade(fundedFacade);
      const initialBalance = syncedState?.shielded.balances[dustTokenHash] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);
      // the max amount that we support: Rust u128 max. The entire Midnight supply
      // is 24 billion tDUST, 1 tDUST = 10^6 specks, which is lesser
      const invalidAmount = 340_282_366_920_938_463_463_374_607_431_768_211_456n;
      const initialState2 = await firstValueFrom(walletFacade.state());

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: dustTokenHash,
              amount: invalidAmount,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState2.shielded.address),
            },
          ],
        },
      ];
      await expect(
        fundedFacade.transferTransaction(
          fundedShieldedSecretKey,
          fundedDustSecretKey,
          outputsToCreate,
          new Date(Date.now() + 60 * 60 * 1000),
        ),
      ).rejects.toThrow(`Error: Couldn't deserialize u128 from a BigInt outside u128::MIN..u128::MAX bounds`);
    },
    timeout,
  );

  test(
    'error message when attempting to send a negative amount',
    async () => {
      allure.tms('PM-9679', 'PM-9679');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Invalid amount error message');
      const syncedState = await utils.waitForSyncFacade(fundedFacade);
      const initialBalance = syncedState?.shielded.balances[dustTokenHash] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);

      const initialState2 = await firstValueFrom(walletFacade.state());

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: dustTokenHash,
              amount: -5n,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState2.shielded.address),
            },
          ],
        },
      ];
      await expect(
        fundedFacade.transferTransaction(
          fundedShieldedSecretKey,
          fundedDustSecretKey,
          outputsToCreate,
          new Date(Date.now() + 60 * 60 * 1000),
        ),
      ).rejects.toThrow('The amount needs to be positive');
    },
    timeout,
  );

  test(
    'error message when attempting shielded transfer to send a zero amount',
    async () => {
      const syncedState = await utils.waitForSyncFacade(fundedFacade);
      const initialBalance = syncedState?.shielded.balances[dustTokenHash] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: 0n,
              receiverAddress: utils.getShieldedAddress(
                NetworkId.NetworkId.Undeployed,
                await walletFacade.shielded.getAddress(),
              ),
            },
          ],
        },
      ];

      await expect(
        fundedFacade.transferTransaction(
          fundedShieldedSecretKey,
          fundedDustSecretKey,
          outputsToCreate,
          new Date(Date.now() + 60 * 60 * 1000),
        ),
      ).rejects.toThrow('The amount needs to be positive');
    },
    timeout,
  );

  test(
    'error message when attempting shielded initSwap with non-positive outputs',
    async () => {
      const initialState2 = await firstValueFrom(walletFacade.state());

      const desiredInputs = {
        shielded: {},
      };

      const desiredOutputs = [
        {
          type: 'shielded' as const,
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: 0n,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState2.shielded.address),
            },
          ],
        },
      ];

      await expect(
        fundedFacade.initSwap(
          fundedShieldedSecretKey,
          desiredInputs,
          desiredOutputs,
          new Date(Date.now() + 60 * 60 * 1000),
        ),
      ).rejects.toThrow('The amount needs to be positive');
    },
    timeout,
  );

  test(
    'error message when attempting shielded initSwap with non-positive inputs',
    async () => {
      const initialState2 = await firstValueFrom(walletFacade.state());

      const desiredInputs = {
        shielded: {
          [shieldedTokenRaw]: 0n,
        },
      };

      const desiredOutputs = [
        {
          type: 'shielded' as const,
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: outputValue,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState2.shielded.address),
            },
          ],
        },
      ];

      await expect(
        fundedFacade.initSwap(
          fundedShieldedSecretKey,
          desiredInputs,
          desiredOutputs,
          new Date(Date.now() + 60 * 60 * 1000),
        ),
      ).rejects.toThrow('The input amounts need to be positive');
    },
    timeout,
  );

  test(
    'error message when attempting to send an empty array of outputs',
    async () => {
      allure.tms('PM-9679', 'PM-9679');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Invalid amount error message');
      const syncedState = await utils.waitForSyncFacade(fundedFacade);
      const initialBalance = syncedState?.shielded.balances[dustTokenHash] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);

      await expect(
        fundedFacade.transferTransaction(fundedShieldedSecretKey, fundedDustSecretKey, [], new Date()),
      ).rejects.toThrow('At least one shielded or unshielded output is required.');
    },
    timeout,
  );

  test(
    'Is working for shielded token transfer @smoke @healthcheck',
    async () => {
      allure.tag('smoke');
      allure.tag('healthcheck');
      allure.tms('PM-8933', 'PM-8933');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Valid native token transfer transaction');

      logger.info('Funding wallet 1 with native tokens...');
      await Promise.all([utils.waitForSyncFacade(fundedFacade), utils.waitForSyncFacade(walletFacade)]);
      const initialState = await firstValueFrom(fundedFacade.state());
      const initialDustBalance = initialState.dust.walletBalance(new Date()) ?? 0n;
      const initialShieldedTokenBalance = initialState.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(initialState.shielded.balances);
      // Object.entries(initialState.shielded.balances).forEach(([key, _]) => {
      //   if (key !== shieldedTokenRaw) tokenTypeHash = key;
      // });
      // if (shieldedTokenRaw === undefined) {
      //   throw new Error('No native tokens found');
      // }
      logger.info(`Wallet 1: ${initialDustBalance} tDUST`);
      logger.info(`Wallet 1: ${initialShieldedTokenBalance} shielded token`);
      // logger.info(`Wallet 1: ${initialBalanceNative} ${tokenTypeHash}`);
      logger.info(`Wallet 1 available coins: ${initialState.shielded.availableCoins.length}`);
      // logger.info(initialState.shielded.availableCoins);

      const initialState2 = await firstValueFrom(walletFacade.state());
      const initialWallet2ShieldedTokenBalance = initialState2.shielded.balances[shieldedTokenRaw] ?? 0n;
      logger.info(`Wallet 2: ${initialWallet2ShieldedTokenBalance} shielded token`);
      // logger.info(`Wallet 2: ${initialBalanceNative2} ${tokenTypeHash}`);
      logger.info(`Wallet 2 available coins: ${initialState2.shielded.availableCoins.length}`);

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: outputValueNativeToken,
              receiverAddress: utils.getShieldedAddress(
                NetworkId.NetworkId.Undeployed,
                await walletFacade.shielded.getAddress(),
              ),
            },
          ],
        },
      ];
      const txToProve = await fundedFacade.transferTransaction(
        fundedShieldedSecretKey,
        fundedDustSecretKey,
        outputsToCreate,
        new Date(Date.now() + 60 * 60 * 1000),
      );
      logger.info('Sending transaction...');
      const provenTx = await fundedFacade.finalizeTransaction(txToProve);
      const txId = await fundedFacade.submitTransaction(provenTx);
      logger.info('Transaction id: ' + txId);

      const pendingState = await utils.waitForFacadePending(fundedFacade);
      // logger.info(utils.walletStateTrimmed(pendingState.shielded));
      logger.info(`Wallet 1 available coins: ${pendingState.shielded.availableCoins.length}`);
      logger.info(pendingState);
      logger.info(pendingState.shielded.balances);
      logger.info(`Wallet 1: ${pendingState.dust.walletBalance(new Date())} tDUST`);
      logger.info(`Wallet 1: ${pendingState.shielded.balances[shieldedTokenRaw]} shielded token`);
      expect(pendingState.dust.walletBalance(new Date()) ?? 0n).toBeLessThan(initialDustBalance);
      expect(pendingState.shielded.balances[shieldedTokenRaw] ?? 0n).toBeLessThanOrEqual(
        initialShieldedTokenBalance - outputValueNativeToken,
      );
      expect(pendingState.shielded.availableCoins.length).toBeLessThan(initialState.shielded.availableCoins.length);
      expect(pendingState.shielded.pendingCoins.length).toBeLessThanOrEqual(2);
      expect(pendingState.shielded.totalCoins.length).toBe(initialState.shielded.totalCoins.length);
      // expect(pendingState.nullifiers.length).toBe(initialState.nullifiers.length);
      // expect(pendingState.transactionHistory.length).toBe(initialState.transactionHistory.length);

      await utils.waitForFacadePendingClear(fundedFacade);
      // await waitForTxInHistory(String(txId), fundedFacade.shielded);
      const finalState = await utils.waitForSyncFacade(fundedFacade);
      // logger.info(walletStateTrimmed(finalState));
      logger.info(`Wallet 1 available coins: ${finalState.shielded.availableCoins.length}`);
      // expect(finalState.dust.walletBalance(new Date()) ?? 0n).toBeLessThan(initialDustBalance);
      expect(finalState.shielded.balances[shieldedTokenRaw] ?? 0n).toBe(
        initialShieldedTokenBalance - outputValueNativeToken,
      );
      expect(finalState.shielded.availableCoins.length).toBeLessThanOrEqual(
        initialState.shielded.availableCoins.length,
      );
      // expect(finalState.shielded.pendingCoins.length).toBe(0);
      expect(finalState.shielded.totalCoins.length).toBeLessThanOrEqual(initialState.shielded.totalCoins.length);
      // expect(finalState.nullifiers.length).toBeLessThanOrEqual(initialState.nullifiers.length);
      // expect(finalState.transactionHistory.length).toBeGreaterThanOrEqual(initialState.transactionHistory.length + 1);
      logger.info(`Wallet 1: ${finalState.dust.walletBalance(new Date(3 * 1000))} tDUST`);
      logger.info(`Wallet 1: ${finalState.shielded.balances[shieldedTokenRaw]} ${shieldedTokenRaw}`);
      logger.info(`Dust fees paid: ${initialDustBalance - finalState.dust.walletBalance(new Date(3 * 1000))}`);

      // await waitForTxInHistory(String(txId), walletFacade.shielded);
      await firstValueFrom(
        walletFacade.state().pipe(filter((s) => s.shielded.availableCoins.some((c) => c.coin.value === 1n))),
      );
      const finalState2 = await utils.waitForSyncFacade(walletFacade);
      // logger.info(walletStateTrimmed(finalState2));
      logger.info(`Wallet 2 available coins: ${finalState2.shielded.availableCoins.length}`);
      logger.info(`Wallet 2: ${finalState2.dust.walletBalance(new Date())} tDUST`);
      logger.info(`Wallet 2: ${finalState2.shielded.balances[shieldedTokenRaw]} ${shieldedTokenRaw}`);
      logger.info(finalState2.shielded.balances);
      // expect(finalState2.shielded.balances[dustTokenHash] ?? 0n).toBe(initialBalance2);
      expect(finalState2.shielded.balances[shieldedTokenRaw] ?? 0n).toBe(
        initialWallet2ShieldedTokenBalance + outputValueNativeToken,
      );
      expect(finalState2.shielded.availableCoins.length).toBe(initialState2.shielded.availableCoins.length + 1);
      expect(finalState2.shielded.pendingCoins.length).toBe(0);
      expect(finalState2.shielded.totalCoins.length).toBeGreaterThanOrEqual(
        initialState2.shielded.totalCoins.length + 1,
      );
      // expect(finalState2.nullifiers.length).toBeGreaterThanOrEqual(initialState2.nullifiers.length + 1);
      // expect(finalState2.transactionHistory.length).toBeGreaterThanOrEqual(initialState2.transactionHistory.length + 1);
    },
    timeout,
  );
  test(
    'Is working for unshielded token transfer @smoke @healthcheck',
    async () => {
      // allure.tag('smoke');
      // allure.tag('healthcheck');
      // allure.tms('PM-8933', 'PM-8933');
      // allure.epic('Headless wallet');
      // allure.feature('Transactions');
      // allure.story('Valid native token transfer transaction by using bech32 wallets addresses');

      const unshieldedFundedKeyStore = createKeystore(
        utils.getUnshieldedSeed(fundedSeed),
        NetworkId.NetworkId.Undeployed,
      );
      logger.info('Funding wallet 1 with native tokens...');
      await Promise.all([utils.waitForSyncFacade(fundedFacade), utils.waitForSyncFacade(walletFacade)]);
      const initialState = await firstValueFrom(fundedFacade.state());
      const initialDustBalance = initialState.dust.walletBalance(new Date()) ?? 0n;
      const initialBalance = initialState.unshielded.balances[unshieldedTokenRaw] ?? 0n;
      logger.info(initialState.unshielded.balances);
      logger.info(`Wallet 1: ${initialDustBalance} tDUST`);
      logger.info(`Wallet 1: ${initialBalance} unshielded token`);
      logger.info(`Wallet 1 available coins: ${initialState.unshielded.availableCoins.length}`);
      logger.info(initialState.unshielded.availableCoins);

      const initialState2 = await firstValueFrom(walletFacade.state());
      const initialBalance2 = initialState2.unshielded.balances[unshieldedTokenRaw] ?? 0n;
      logger.info(`Wallet 1: ${initialBalance2} unshielded token`);
      logger.info(`Wallet 2 available coins: ${initialState2.unshielded.availableCoins.length}`);

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'unshielded',
          outputs: [
            {
              type: unshieldedTokenRaw,
              amount: outputValueNativeToken,
              receiverAddress: UnshieldedAddress.codec
                .encode(fixture.getNetworkId(), initialState2.unshielded.address)
                .asString(),
            },
          ],
        },
      ];
      const txToProve = await fundedFacade.transferTransaction(
        fundedShieldedSecretKey,
        fundedDustSecretKey,
        outputsToCreate,
        new Date(Date.now() + 30 * 60 * 1000),
      );
      const signedTx = await fundedFacade.signTransaction(txToProve.transaction, (payload) =>
        unshieldedFundedKeyStore.signData(payload),
      );
      const finalizedTx = await fundedFacade.finalizeTransaction({ ...txToProve, transaction: signedTx });
      const txId = await fundedFacade.submitTransaction(finalizedTx);
      logger.info('Transaction id: ' + txId);

      const pendingState = await utils.waitForFacadePending(fundedFacade);
      // logger.info(walletStateTrimmed(pendingState));
      logger.info(`Wallet 1 available coins: ${pendingState.unshielded.availableCoins.length}`);
      expect(pendingState.dust.walletBalance(new Date()) ?? 0n).toBeLessThan(initialDustBalance);
      expect(pendingState.unshielded.balances[unshieldedTokenRaw] ?? 0n).toBeLessThanOrEqual(
        initialBalance - outputValue,
      );
      expect(pendingState.unshielded.availableCoins.length).toBeLessThan(initialState.unshielded.availableCoins.length);
      expect(pendingState.unshielded.pendingCoins.length).toBeLessThanOrEqual(2);
      expect(pendingState.unshielded.totalCoins.length).toBe(initialState.unshielded.totalCoins.length);
      // expect(pendingState.nullifiers.length).toBe(initialState.nullifiers.length);
      // expect(pendingState.transactionHistory.length).toBe(initialState.transactionHistory.length);

      await utils.waitForFacadePendingClear(fundedFacade);
      // await waitForTxInHistory(String(txId), fundedFacade.unshielded);
      const finalState = await utils.waitForSyncFacade(fundedFacade);
      // logger.info(walletStateTrimmed(finalState));
      logger.info(`Wallet 1 available coins: ${finalState.unshielded.availableCoins.length}`);
      expect(finalState.dust.walletBalance(new Date()) ?? 0n).toBeLessThan(initialDustBalance);
      expect(finalState.unshielded.balances[unshieldedTokenRaw] ?? 0n).toBe(initialBalance - outputValueNativeToken);
      expect(finalState.unshielded.availableCoins.length).toBeLessThanOrEqual(
        initialState.unshielded.availableCoins.length,
      );
      expect(finalState.unshielded.pendingCoins.length).toBe(0);
      expect(finalState.unshielded.totalCoins.length).toBeLessThanOrEqual(initialState.unshielded.totalCoins.length);
      // expect(finalState.nullifiers.length).toBeLessThanOrEqual(initialState.nullifiers.length);
      // expect(finalState.transactionHistory.length).toBeGreaterThanOrEqual(initialState.transactionHistory.length + 1);
      logger.info(`Wallet 1: ${finalState.dust.walletBalance(new Date(3 * 1000))} tDUST`);
      logger.info(`Wallet 1: ${finalState.unshielded.balances[unshieldedTokenRaw]} unshielded tokens`);
      logger.info(`Dust fees paid: ${initialDustBalance - finalState.dust.walletBalance(new Date(3 * 1000))}`);

      await utils.waitForFacadePendingClear(walletFacade);
      // await waitForTxInHistory(String(txId), walletFacade.unshielded);
      const finalState2 = await utils.waitForSyncFacade(walletFacade);
      // logger.info(walletStateTrimmed(finalState2));
      logger.info(`Wallet 2 available coins: ${finalState2.unshielded.availableCoins.length}`);
      logger.info(`Wallet 2: ${finalState2.unshielded.balances[unshieldedTokenRaw]} unshielded tokens`);
      expect(finalState2.unshielded.balances[unshieldedTokenRaw] ?? 0n).toBe(initialBalance2 + outputValueNativeToken);
      expect(finalState2.unshielded.availableCoins.length).toBe(initialState2.unshielded.availableCoins.length + 1);
      expect(finalState2.unshielded.pendingCoins.length).toBe(0);
      expect(finalState2.unshielded.totalCoins.length).toBeGreaterThanOrEqual(
        initialState2.unshielded.totalCoins.length + 1,
      );
      // expect(finalState2.nullifiers.length).toBeGreaterThanOrEqual(initialState2.nullifiers.length + 1);
      // expect(finalState2.transactionHistory.length).toBeGreaterThanOrEqual(initialState2.transactionHistory.length + 1);
    },
    timeout,
  );

  // TODO: fix test
  test.skip(
    'coins become available when native token tx fails on node',
    async () => {
      allure.tms('PM-8936', 'PM-8936');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Invalid native token transaction');
      const initialState = await firstValueFrom(fundedFacade.state());
      const syncedState = await utils.waitForSyncFacade(fundedFacade);
      const initialDustBalance = syncedState?.shielded.balances[dustTokenHash] ?? 0n;
      Object.entries(initialState.shielded.balances).forEach(([key, _]) => {
        if (key !== dustTokenHash) tokenTypeHash = key;
      });
      if (tokenTypeHash === undefined) {
        throw new Error('No native tokens found');
      }
      const initialBalance = syncedState?.shielded.balances[tokenTypeHash] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialDustBalance} tDUST`);
      logger.info(`Wallet 1 balance is: ${initialBalance} ${tokenTypeHash}`);

      const syncedState2 = await utils.waitForSyncFacade(walletFacade);
      const initialDustBalance2 = syncedState2?.shielded.balances[dustTokenHash] ?? 0n;
      const initialBalance2 = syncedState2?.shielded.balances[tokenTypeHash] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialDustBalance2} tDUST`);
      logger.info(`Wallet 1 balance is: ${initialBalance2} ${tokenTypeHash}`);

      const coin = ledger.createShieldedCoinInfo(tokenTypeHash, outputValueNativeToken);
      const output = ledger.ZswapOutput.new(
        coin,
        0,
        initialState.shielded.coinPublicKey.toHexString(),
        initialState.shielded.encryptionPublicKey.toHexString(),
      );
      const offer = ledger.ZswapOffer.fromOutput(output, tokenTypeHash, outputValueNativeToken);
      const unprovenTx = ledger.Transaction.fromParts(NetworkId.NetworkId.Undeployed, offer);
      const provenTx = await fundedFacade.finalizeTransaction({
        type: 'TransactionToProve',
        transaction: unprovenTx,
      });

      await expect(
        Promise.all([fundedFacade.submitTransaction(provenTx), fundedFacade.submitTransaction(provenTx)]),
      ).rejects.toThrow();

      const finalState = await utils.waitForFinalizedBalance(fundedFacade.shielded);
      expect(finalState).toMatchObject(syncedState);
      expect(finalState.balances[dustTokenHash]).toBe(initialDustBalance);
      expect(finalState.balances[tokenTypeHash]).toBe(initialBalance);
      expect(finalState.availableCoins.length).toBe(syncedState.shielded.availableCoins.length);
      expect(finalState.pendingCoins.length).toBe(0);
      expect(finalState.totalCoins.length).toBe(syncedState.shielded.totalCoins.length);
      // expect(finalState.nullifiers.length).toBe(syncedState.nullifiers.length);
      // expect(finalState.transactionHistory.length).toBe(syncedState.transactionHistory.length);
    },
    timeout,
  );
  // TODO: fix test
  test.skip(
    'coins become available when native token tx does not get proved',
    async () => {
      allure.tms('PM-8934', 'PM-8934');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Transaction not proved');
      const syncedState = await utils.waitForSyncFacade(fundedFacade);
      const initialDustBalance = syncedState?.shielded.balances[dustTokenHash] ?? 0n;
      Object.entries(syncedState.shielded.balances).forEach(([key, _]) => {
        if (key !== dustTokenHash) tokenTypeHash = key;
      });
      if (tokenTypeHash === undefined) {
        throw new Error('No native tokens found');
      }
      const initialBalance = syncedState?.shielded.balances[tokenTypeHash] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialDustBalance} tDUST`);
      logger.info(`Wallet 1 balance is: ${initialBalance} ${tokenTypeHash}`);

      logger.info('Stopping proof server container..');
      await fixture.getProofServerContainer().stop({ timeout: 10_000 });

      const initialState2 = await firstValueFrom(walletFacade.state());

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: tokenTypeHash,
              amount: outputValueNativeToken,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState2.shielded.address),
            },
          ],
        },
      ];
      const txToProve = await fundedFacade.transferTransaction(
        fundedShieldedSecretKey,
        fundedDustSecretKey,
        outputsToCreate,
        new Date(),
      );
      await expect(fundedFacade.finalizeTransaction(txToProve)).rejects.toThrow();

      const finalState = await utils.waitForFinalizedBalance(fundedFacade.shielded);
      expect(finalState).toMatchObject(syncedState);
      expect(finalState.balances[dustTokenHash]).toBe(initialDustBalance);
      expect(finalState.balances[tokenTypeHash]).toBe(initialBalance);
      expect(finalState.availableCoins.length).toBe(syncedState.shielded.availableCoins.length);
      expect(finalState.pendingCoins.length).toBe(0);
      expect(finalState.totalCoins.length).toBe(syncedState.shielded.totalCoins.length);
      // expect(finalState.nullifiers.length).toBe(syncedState.nullifiers.length);
      // expect(finalState.transactionHistory.length).toBe(syncedState.transactionHistory.length);
    },
    timeout,
  );

  test(
    'error message when attempting to make transfer using incorrect shielded secret key',
    async () => {
      // allure.tms('PM-9679', 'PM-9679');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Invalid amount error message');
      const incorrectSecretKey = ledger.ZswapSecretKeys.fromSeed(utils.getShieldedSeed(seed));
      const syncedState = await utils.waitForSyncFacade(fundedFacade);
      const initialBalance = syncedState?.shielded.balances[dustTokenHash] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);

      const initialState2 = await firstValueFrom(walletFacade.state());

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: dustTokenHash,
              amount: outputValue,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState2.shielded.address),
            },
          ],
        },
      ];
      const txToProve = await fundedFacade.transferTransaction(
        incorrectSecretKey,
        fundedDustSecretKey,
        outputsToCreate,
        new Date(Date.now() + 60 * 60 * 1000),
      );
      await expect(fundedFacade.finalizeTransaction(txToProve)).rejects.toThrow('Failed to prove transaction');
    },
    timeout,
  );

  test(
    'error message when attempting to make transfer using incorrect dust secret key',
    async () => {
      // allure.tms('PM-9679', 'PM-9679');
      allure.epic('Headless wallet');
      allure.feature('Transactions');
      allure.story('Invalid amount error message');
      const incorrectDustKey = seedDustSecretKey;
      const syncedState = await utils.waitForSyncFacade(fundedFacade);
      const initialBalance = syncedState?.shielded.balances[dustTokenHash] ?? 0n;
      logger.info(`Wallet 1 balance is: ${initialBalance}`);

      const initialState2 = await firstValueFrom(walletFacade.state());

      const outputsToCreate: CombinedTokenTransfer[] = [
        {
          type: 'shielded',
          outputs: [
            {
              type: shieldedTokenRaw,
              amount: outputValue,
              receiverAddress: utils.getShieldedAddress(NetworkId.NetworkId.Undeployed, initialState2.shielded.address),
            },
          ],
        },
      ];
      await expect(
        fundedFacade.transferTransaction(
          fundedShieldedSecretKey,
          incorrectDustKey,
          outputsToCreate,
          new Date(Date.now() + 60 * 60 * 1000),
        ),
      ).rejects.toThrow("Error from ledger: attempted to spend Dust UTXO that's not in the wallet state:");
    },
    timeout,
  );
});

================
File: packages/e2e-tests/src/tests/utils.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
import { filter, firstValueFrom, tap, throttleTime } from 'rxjs';
import { WalletState, type Wallet } from '@midnight-ntwrk/wallet-api';
import { logger } from './logger.js';
import { TestContainersFixture } from './test-fixture.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { existsSync } from 'node:fs';
import { exit } from 'node:process';
import * as fsAsync from 'node:fs/promises';
import * as fs from 'node:fs';
import { ShieldedWallet, ShieldedWalletClass, ShieldedWalletState } from '@midnight-ntwrk/wallet-sdk-shielded';
import { ShieldedAddress, UnshieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';
import { HDWallet, Roles } from '@midnight-ntwrk/wallet-sdk-hd';
import { WalletFacade } from '@midnight-ntwrk/wallet-sdk-facade';
import {
  createKeystore,
  InMemoryTransactionHistoryStorage,
  PublicKey,
  UnshieldedWallet,
} from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';
import { DefaultV1Configuration, DustWallet } from '@midnight-ntwrk/wallet-sdk-dust-wallet';

// place this somewhere better?
export const Segments = {
  guaranteed: 0,
  fallible: 1,
};

export const waitForSyncProgress = async (wallet: WalletFacade) =>
  await firstValueFrom(
    wallet.state().pipe(
      throttleTime(5000),
      tap((state) => {
        const applyGap = state.unshielded.progress.highestTransactionId - state.unshielded.progress.appliedId;
        logger.info(`Wallet facade behind by ${applyGap}`);
      }),
      filter((state) =>
        // Let's allow progress only if syncProgress is defined
        state.unshielded.progress.isStrictlyComplete(),
      ),
    ),
  );

export const isAnotherChain = async (wallet: ShieldedWallet, offset: number) => {
  const state = await wallet.waitForSyncedState();
  // allow for situations when there's no new index in the network between runs
  const applyGap = state.state?.progress.highestRelevantIndex - state.state?.progress.appliedIndex;
  return applyGap <= offset - 1;
};

export const streamToString = async (stream: fs.ReadStream): Promise<string> => {
  const chunks: string[] = [];
  return await new Promise((resolve, reject) => {
    stream.on('data', (chunk) => chunks.push(chunk as string));
    stream.on('error', (err) => reject(err));
    stream.on('end', () => resolve(chunks.join('')));
  });
};

const restoreShieldedWallet = async (
  path: string,
  Wallet: ShieldedWalletClass,
  readIfExists: (path: string) => Promise<string | undefined>,
) => {
  try {
    const serialized = await readIfExists(path);
    if (serialized) {
      const wallet = Wallet.restore(serialized);
      logger.info(`Restored shielded wallet from ${path}`);
      return wallet;
    }
    logger.warn('Unable to restore shielded wallet.');
  } catch (err: unknown) {
    logger.error(`Failed to restore shielded wallet: ${err instanceof Error ? err.message : String(err)}`);
  }
  return undefined;
};

const restoreUnshieldedWallet = async (
  path: string,
  seed: string,
  fixture: TestContainersFixture,
  readIfExists: (path: string) => Promise<string | undefined>,
) => {
  try {
    const serialized = await readIfExists(path);
    if (serialized) {
      logger.info(`Unshielded serialize: ${serialized}`);
      const keyStore = createKeystore(getUnshieldedSeed(seed), fixture.getNetworkId());
      const wallet = UnshieldedWallet({
        networkId: fixture.getNetworkId(),
        indexerClientConnection: {
          indexerHttpUrl: fixture.getIndexerUri(),
          indexerWsUrl: fixture.getIndexerWsUri(),
        },
        txHistoryStorage: new InMemoryTransactionHistoryStorage(),
      }).startWithPublicKey(PublicKey.fromKeyStore(keyStore));
      logger.info(`Restored unshielded wallet from ${path}`);
      return wallet;
    }
    logger.warn('Unable to restore unshielded wallet.');
  } catch (err: unknown) {
    logger.error(`Failed to restore unshielded wallet: ${err instanceof Error ? err.message : String(err)}`);
  }
  return undefined;
};

const restoreDustWallet = async (
  path: string,
  walletConfig: DefaultV1Configuration,
  readIfExists: (path: string) => Promise<string | undefined>,
) => {
  try {
    const serialized = await readIfExists(path);
    if (serialized) {
      logger.info(`Dust serialize: ${serialized}`);
      const DustInstance = DustWallet({
        ...walletConfig,
        costParameters: walletConfig?.costParameters ?? {
          additionalFeeOverhead: 300_000_000_000_000n,
          feeBlocksMargin: 5,
        },
      });
      const wallet = DustInstance.restore(serialized);
      logger.info(`Restored dust wallet from ${path}`);
      return wallet;
    }
    logger.warn('Unable to restore dust wallet.');
  } catch (err: unknown) {
    logger.error(`Failed to restore dust wallet: ${err instanceof Error ? err.message : String(err)}`);
  }
  return undefined;
};

export const provideWallet = async (
  filename: string,
  seed: string,
  fixture: TestContainersFixture,
): Promise<WalletFacade> => {
  const walletConfig = fixture.getWalletConfig();
  const dustWalletConfig = fixture.getDustWalletConfig();
  const Wallet = ShieldedWallet(walletConfig);
  const directoryPath = process.env['SYNC_CACHE'];
  if (!directoryPath) {
    logger.warn('SYNC_CACHE env var not set');
    exit(1);
  }

  const readIfExists = async (p: string): Promise<string | undefined> => {
    try {
      if (!existsSync(p)) return undefined;
      return await fsAsync.readFile(p, 'utf-8');
    } catch (err: unknown) {
      logger.error(`Failed to read ${p}: ${err instanceof Error ? err.message : String(err)}`);
      return undefined;
    }
  };

  const [restoredShielded, restoredUnshielded, restoredDust] = await Promise.all([
    restoreShieldedWallet(`${directoryPath}/shielded-${filename}`, Wallet, readIfExists),
    restoreUnshieldedWallet(`${directoryPath}/unshielded-${filename}`, seed, fixture, readIfExists),
    restoreDustWallet(`${directoryPath}/dust-${filename}`, dustWalletConfig, readIfExists),
  ]);

  if (!restoredShielded || !restoredUnshielded || !restoredDust) {
    logger.info('Building wallet facade from scratch');
    return buildWalletFacade(seed, fixture);
  } else {
    const restoredWallet = new WalletFacade(restoredShielded, restoredUnshielded, restoredDust);
    // check if wallet is syncing correctly
    await waitForSyncProgress(restoredWallet);
    const restoredWalletState = await firstValueFrom(restoredWallet.state());
    const applyGap =
      restoredWalletState.unshielded.progress.highestTransactionId - restoredWalletState.unshielded.progress.appliedId;
    logger.info(`Apply gap: ${applyGap}`);
    if ((applyGap ?? 0) < 0) {
      logger.warn('Unable to sync restored wallet. Building wallet facade from scratch');
      return buildWalletFacade(seed, fixture);
    } else {
      logger.info('Successfully restored wallet facade.');
      return restoredWallet;
    }
  }
};

export const saveState = async (wallet: WalletFacade, filename: string) => {
  const directoryPath = process.env['SYNC_CACHE'];
  if (!directoryPath) {
    logger.warn('SYNC_CACHE env var not set');
    exit(1);
  }

  logger.info(`Saving state in ${directoryPath}/${filename}`);

  try {
    await fsAsync.mkdir(directoryPath, { recursive: true });

    // Serialize all three states
    const [shieldedSerializedState, unshieldedSerializedState, dustSerializedState] = await Promise.all([
      wallet.shielded.serializeState(),
      wallet.unshielded.serializeState(),
      wallet.dust.serializeState(),
    ]);

    const files = [
      { suffix: 'shielded-', data: shieldedSerializedState },
      { suffix: 'unshielded-', data: unshieldedSerializedState },
      { suffix: 'dust-', data: dustSerializedState },
    ];

    const results = await Promise.allSettled(
      files.map((f) => fsAsync.writeFile(`${directoryPath}/${f.suffix}${filename}`, f.data, 'utf-8')),
    );

    for (const [i, res] of results.entries()) {
      const pathWritten = `${directoryPath}/${files[i].suffix}${filename}`;
      if (res.status === 'fulfilled') {
        logger.info(`State written to file ${pathWritten}`);
      } else {
        logger.error(
          `Failed to write ${pathWritten}: ${res.reason instanceof Error ? res.reason.message : String(res.reason)}`,
        );
      }
    }
  } catch (e) {
    if (typeof e === 'string') {
      logger.warn(e);
    } else if (e instanceof Error) {
      logger.warn(e.message);
    } else {
      logger.warn('Unknown error while saving state');
    }
  }
};

export const buildWalletFacade = (walletSeed: string, fixture: TestContainersFixture) => {
  const unshieldedKeyStore = createKeystore(getUnshieldedSeed(walletSeed), fixture.getNetworkId());
  const Wallet = ShieldedWallet(fixture.getWalletConfig());

  const shieldedWallet = Wallet.startWithShieldedSeed(getShieldedSeed(walletSeed));

  const unshieldedWallet = UnshieldedWallet({
    networkId: fixture.getNetworkId(),
    indexerClientConnection: {
      indexerHttpUrl: fixture.getIndexerUri(),
      indexerWsUrl: fixture.getIndexerWsUri(),
    },
    txHistoryStorage: new InMemoryTransactionHistoryStorage(),
  }).startWithPublicKey(PublicKey.fromKeyStore(unshieldedKeyStore));

  const dustSeed = getDustSeed(walletSeed);
  const Dust = DustWallet(fixture.getDustWalletConfig());
  const dustParameters = new ledger.DustParameters(5_000_000_000n, 8267n, 3n * 60n * 60n);
  const dustWallet = Dust.startWithSeed(dustSeed, dustParameters);

  return new WalletFacade(shieldedWallet, unshieldedWallet, dustWallet);
};

export const closeWallet = async (wallet: WalletFacade) => {
  try {
    await wallet.stop();
  } catch (e: unknown) {
    if (typeof e === 'string') {
      logger.warn(e);
    } else if (e instanceof Error) {
      logger.warn(e.message);
    }
  }
};

export const waitForSyncUnshielded = (wallet: UnshieldedWallet) =>
  firstValueFrom(
    wallet.state.pipe(
      throttleTime(5_000),
      tap((state) => {
        const applyGap = state.state.progress.highestTransactionId - state.state.progress.appliedId;
        // const txs = state.transactionHistory.length;
        logger.info(`Wallet behind by ${applyGap} indices`);
      }),
      filter((state) => state.state.progress.isStrictlyComplete()),
    ),
  );

export const waitForSyncShielded = (wallet: ShieldedWallet) =>
  firstValueFrom(
    wallet.state.pipe(
      throttleTime(5_000),
      tap((state) => {
        const applyGap = state.state?.progress.highestRelevantIndex - state.state?.progress.appliedIndex;
        const sourceGap = state.state?.progress.highestIndex - state.state?.progress.highestRelevantIndex;
        // const txs = state.transactionHistory.length;
        logger.info(
          `Wallet behind by ${applyGap} indices, source behind by ${sourceGap}, synced = ${state.state?.progress.isStrictlyComplete()}`,
        );
      }),
      filter(
        (state) =>
          state.state?.progress !== undefined &&
          state.state?.progress.highestRelevantIndex - state.state?.progress.appliedIndex === 0n &&
          state.state?.progress.highestIndex - state.state?.progress.highestRelevantIndex <= 50n &&
          state.state?.progress.isStrictlyComplete() === true,
      ),
    ),
  );

export const waitForSyncOld = (wallet: Wallet) =>
  firstValueFrom(
    wallet.state().pipe(
      throttleTime(5_000),
      tap((state) => {
        const applyGap = state.syncProgress?.lag.applyGap ?? 0n;
        const sourceGap = state.syncProgress?.lag.sourceGap ?? 0n;
        const txs = state.transactionHistory.length;
        logger.info(`Wallet behind by ${applyGap} indices, source behind by ${sourceGap}, transactions=${txs}`);
      }),
      filter(
        (state) =>
          state.syncProgress !== undefined &&
          state?.syncProgress?.lag?.applyGap === 0n &&
          state?.syncProgress?.lag?.sourceGap <= 100n,
      ),
    ),
  );

export const waitForSyncFacade = async (facade: WalletFacade) =>
  await firstValueFrom(
    facade.state().pipe(
      throttleTime(5_000),
      tap((state) => {
        const applyGap = state.unshielded.progress.highestTransactionId - state.unshielded.progress.appliedId;
        logger.info(`Wallet facade behind by ${applyGap}`);
      }),
      filter(
        (state) =>
          state.dust.state.progress.isStrictlyComplete() &&
          state.shielded.state.progress.isStrictlyComplete() &&
          state.unshielded.progress.isStrictlyComplete(),
      ),
    ),
  );

export const waitForFacadePending = (wallet: WalletFacade) =>
  firstValueFrom(
    wallet.state().pipe(
      tap((state) => {
        const shieldedPending = state.shielded.pendingCoins.length;
        logger.info(`Shielded wallet pending coins: ${shieldedPending}, waiting for pending coins...`);
        const unshieldedPending = state.shielded.pendingCoins.length;
        logger.info(`Unshielded wallet pending coins: ${unshieldedPending}, waiting for pending coins...`);
      }),
      filter(
        (state) =>
          // Let's allow progress only if pendingCoins are present
          state.shielded.pendingCoins.length > 0 || state.unshielded.pendingCoins.length > 0,
      ),
    ),
  );

export const waitForFacadePendingClear = (wallet: WalletFacade) =>
  firstValueFrom(
    wallet.state().pipe(
      tap((state) => {
        const shieldedPending = state.shielded.pendingCoins.length;
        logger.info(`Shielded wallet pending coins: ${shieldedPending}, waiting for pending coins to clear...`);
        const unshieldedPending = state.unshielded.pendingCoins.length;
        logger.info(`Unshielded wallet pending coins: ${unshieldedPending}, waiting for pending coins to clear...`);
        const dustPending = state.dust.pendingCoins.length;
        logger.info(`Dust wallet pending coins: ${dustPending}, waiting for pending coins to clear...`);
      }),
      filter(
        (state) =>
          // Allow progress only if there are no pending coins
          state.shielded.pendingCoins.length == 0 &&
          state.unshielded.pendingCoins.length == 0 &&
          state.dust.pendingCoins.length == 0,
      ),
    ),
  );

export const waitForPending = (wallet: ShieldedWallet) =>
  firstValueFrom(
    wallet.state.pipe(
      tap((state) => {
        const pending = state.pendingCoins.length;
        logger.info(`Wallet pending coins: ${pending}, waiting for pending coins...`);
      }),
      filter((state) => {
        // Let's allow progress only if pendingCoins are present
        const pending = state.pendingCoins.length;
        return pending > 0;
      }),
    ),
  );

export const waitForBalanceUpdate = (wallet: UnshieldedWallet) =>
  firstValueFrom(
    wallet.state.pipe(
      tap((state) => {
        const balanceSize = Object.values(state.balances).length;
        logger.info(`Balance size: ${balanceSize}, waiting for balance to update...`);
      }),
      filter((state) => {
        return Object.values(state.balances).length > 0;
      }),
    ),
  );

export const waitForDustBalance = (wallet: WalletFacade, expectedDustBalance: bigint) =>
  firstValueFrom(
    wallet.state().pipe(
      tap((state) => {
        const dustBalance = state.dust.walletBalance(new Date(Date.now() + 60 * 60 * 1000));
        logger.info(`Dust balance: ${dustBalance}`);
      }),
      filter((state) => {
        return state.dust.walletBalance(new Date(Date.now() + 60 * 60 * 1000)) >= expectedDustBalance;
      }),
    ),
  );

export const waitForFinalizedBalanceUnshielded = (wallet: UnshieldedWallet) =>
  firstValueFrom(
    wallet.state.pipe(
      tap((state) => {
        const pending = state.pendingCoins.length;
        logger.info(`Wallet pending coins: ${pending}, waiting for pending coins cleared...`);
      }),
      filter((state) => {
        // Let's allow progress only if pendingCoins are cleared
        const pending = state.pendingCoins.length;
        return pending === 0;
      }),
    ),
  );

export const waitForFinalizedBalance = (wallet: ShieldedWallet) =>
  firstValueFrom(
    wallet.state.pipe(
      tap((state) => {
        const pending = state.pendingCoins.length;
        logger.info(`Wallet pending coins: ${pending}, waiting for pending coins cleared...`);
      }),
      filter((state) => {
        // Let's allow progress only if pendingCoins are cleared
        const pending = state.pendingCoins.length;
        return pending === 0;
      }),
    ),
  );

// export const waitForTxInHistory = async (txId: string, wallet: ShieldedWallet) =>
//   firstValueFrom(
//     wallet.state.pipe(
//       tap({
//         next: (state) => {
//           logger.info(`Current transactionHistory: ${state.transactionHistory}`);
//           state.transactionHistory.forEach((tx, idx) => {
//             logger.info(`Tx[${idx}] identifiers: ${JSON.stringify(tx.identifiers())}`);
//           });
//           const txFound = state.transactionHistory.some((tx) => tx.identifiers().includes(txId));
//           logger.info(`Transaction ${txId} found: ${txFound}`);
//         },
//       }),
//       filter((state) => state.transactionHistory.some((tx) => tx.identifiers().includes(txId))),
//     ),
//   );

// export const walletStateTrimmed = (state: ShieldedWalletState) => {
//   const { totalCoins, availableCoins, ...rest } = state; // eslint-disable-line @typescript-eslint/no-unused-vars
//   return rest;
// };

// export function normalizeWalletState(state: ShieldedWalletState) {
//   const normalized = state.transactionHistory.map((txHistoryEntry: Transaction) => {
//     const { identifiers, ...otherProps } = txHistoryEntry; // eslint-disable-line @typescript-eslint/no-unused-vars
//     return otherProps;
//   });
//   const { transactionHistory, syncProgress, ...otherProps } = state; // eslint-disable-line @typescript-eslint/no-unused-vars
//   return { ...otherProps, normalized };
// }

export const getTransactionHistoryIds = (state: ShieldedWalletState) => {
  return state.transactionHistory.map((tx) => tx.identifiers());
};

// export function compareStates(state1: ShieldedWalletState, state2: ShieldedWalletState) {
//   const normalized1 = normalizeWalletState(state1);
//   const normalized2 = normalizeWalletState(state2);
//   expect(normalized1).toStrictEqual(normalized2);
// }

// Validate wallet transaction history after wallet has received token
export function validateWalletTxHistory(finalWalletState: WalletState, initialWalletState: WalletState) {
  expect(finalWalletState.availableCoins.length).toBe(initialWalletState.availableCoins.length + 1);
  expect(finalWalletState.pendingCoins.length).toBe(0);
  expect(finalWalletState.coins.length).toBeGreaterThanOrEqual(initialWalletState.coins.length + 1);
  expect(finalWalletState.nullifiers.length).toBeGreaterThanOrEqual(initialWalletState.nullifiers.length + 1);
  expect(finalWalletState.transactionHistory.length).toBeGreaterThanOrEqual(
    initialWalletState.transactionHistory.length + 1,
  );
}

export function validateNetworkInAddress(address: string) {
  switch (TestContainersFixture.network) {
    case 'testnet':
      expect(address).toContain('test');
      break;
    case 'devnet':
      expect(address).toContain('dev');
      break;
    case 'undeployed':
      expect(address).toContain('undeployed');
      break;
  }
}

export function getShieldedAddress(networkId: NetworkId.NetworkId, walletAddress: ShieldedAddress): string {
  return ShieldedAddress.codec.encode(networkId, walletAddress).asString();
}

export function getUnshieldedAddress(networkId: NetworkId.NetworkId, walletAddress: UnshieldedAddress): string {
  return UnshieldedAddress.codec.encode(networkId, walletAddress).asString();
}

export const getShieldedSeed = (seed: string): Uint8Array => {
  const seedBuffer = Buffer.from(seed, 'hex');
  const hdWalletResult = HDWallet.fromSeed(seedBuffer);

  const { hdWallet } = hdWalletResult as {
    type: 'seedOk';
    hdWallet: HDWallet;
  };

  const derivationResult = hdWallet.selectAccount(0).selectRole(Roles.Zswap).deriveKeyAt(0);

  if (derivationResult.type === 'keyOutOfBounds') {
    throw new Error('Key derivation out of bounds');
  }

  return Buffer.from(derivationResult.key);
};

export const getUnshieldedSeed = (seed: string): Uint8Array<ArrayBufferLike> => {
  const seedBuffer = Buffer.from(seed, 'hex');
  const hdWalletResult = HDWallet.fromSeed(seedBuffer);

  const { hdWallet } = hdWalletResult as {
    type: 'seedOk';
    hdWallet: HDWallet;
  };

  const derivationResult = hdWallet.selectAccount(0).selectRole(Roles.NightExternal).deriveKeyAt(0);

  if (derivationResult.type === 'keyOutOfBounds') {
    throw new Error('Key derivation out of bounds');
  }

  return derivationResult.key;
};

export const getDustSeed = (seed: string): Uint8Array<ArrayBufferLike> => {
  const seedBuffer = Buffer.from(seed, 'hex');
  const hdWalletResult = HDWallet.fromSeed(seedBuffer);

  const { hdWallet } = hdWalletResult as {
    type: 'seedOk';
    hdWallet: HDWallet;
  };

  const derivationResult = hdWallet.selectAccount(0).selectRole(Roles.Dust).deriveKeyAt(0);

  if (derivationResult.type === 'keyOutOfBounds') {
    throw new Error('Key derivation out of bounds');
  }

  return derivationResult.key;
};

export const isArrayUnique = (arr: any[]) => Array.isArray(arr) && new Set(arr).size === arr.length; // eslint-disable-line @typescript-eslint/no-explicit-any

export type MidnightNetwork = 'undeployed' | 'node-dev-01' | 'qanet' | 'devnet' | 'testnet' | 'preview' | 'preprod';

================
File: packages/e2e-tests/README.md
================
# Midnight Wallet E2E Tests in TypeScript

This directory contains e2e wallet tests written using Vitest that run against a local docker compose environment or a
hosted deployment of choice.

## Setup

### 1. Nix

First install [Nix](https://nixos.org). Then [direnv](https://direnv.net) is optional but strongly recommended. This
project provides a [flake](flake.nix) with a dev shell definition.

### 2. Internal private registry and credentials

Configure Yarn and Nix by following the
[Authentication setup document](https://input-output.atlassian.net/wiki/spaces/MN/pages/3696001685/Authentication+setup).

### 3. Install npm dependencies

```shell
nix develop .#typescript --command yarn
```

from the root of the project

## Running e2e tests

### Environment Setup

Tests require environment variables to be configured. The repository includes a `.env.example` file that serves as a
template showing all available configuration options. To configure your environment:

1. Copy `.env.example` to `.env`:

   ```shell
   cp .env.example .env
   ```

2. Edit `.env` and fill in the required values for your environment (see `.env.example` for descriptions of each
   variable).

The `.env` file is automatically loaded by the test setup when running any tests (including e2e tests). Environment
variables from the `.env` file will override any existing environment variables when executing tests.

Then to run all tests (all following commands in the root of the project):

```shell
nix develop .#typescript --command yarn test-e2e
```

To run a subset of tests with a tag:

```shell
nix develop .#typescript --command yarn test-e2e -- -t @healthcheck
```

To run tests from a specific file:

```shell
nix develop .#typescript --command yarn test-e2e -- packages/e2e-tests/src/tests/emptyWallet.test.ts
```

================
File: packages/e2e-tests/vitest.config.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/// <reference types="vitest" />
import AllureReporter from 'allure-vitest/reporter';
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    setupFiles: ['allure-vitest/setup', '../../setup-env.ts'],
    pool: 'threads',
    environment: 'node',
    testTimeout: 90_000,
    globals: true,
    exclude: ['node_modules', 'dist'],
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage',
    },
    reporters: [
      'default',
      ['junit', { outputFile: './reports/test-report.xml' }],
      ['json', { outputFile: './reports/test-report.json' }],
      ['html', { outputFile: './reports/html/index.html' }],
      ['allure-vitest/reporter', { resultsDir: './reports/allure-results' }],
    ],
    projects: [
      {
        extends: true,
        test: {
          name: 'undeployed',
          include: ['**/**/tests/*.undeployed.test.ts', '**/**/tests/*.universal.test.ts'],
        },
      },
      {
        extends: true,
        test: {
          name: 'remote',
          include: ['**/**/tests/*.remote.test.ts'],
        },
      },
    ],
  },
  resolve: {
    extensions: ['.ts', '.js'],
    alias: {
      // '@': path.resolve(__dirname, './src'),
      // '@infrastructure': path.resolve(__dirname, '../src/infrastructure'),
      // '@e2e': path.resolve(__dirname, '../src/e2e')
    },
  },
});

================
File: packages/facade/test/utils.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { HDWallet, Roles } from '@midnight-ntwrk/wallet-sdk-hd';
import { WalletFacade } from '../src/index.js';
import * as rx from 'rxjs';

export const getShieldedSeed = (seed: string): Uint8Array => {
  const seedBuffer = Buffer.from(seed, 'hex');
  const hdWalletResult = HDWallet.fromSeed(seedBuffer);

  const { hdWallet } = hdWalletResult as {
    type: 'seedOk';
    hdWallet: HDWallet;
  };

  const derivationResult = hdWallet.selectAccount(0).selectRole(Roles.Zswap).deriveKeyAt(0);

  if (derivationResult.type === 'keyOutOfBounds') {
    throw new Error('Key derivation out of bounds');
  }

  return Buffer.from(derivationResult.key);
};

export const getUnshieldedSeed = (seed: string): Uint8Array<ArrayBufferLike> => {
  const seedBuffer = Buffer.from(seed, 'hex');
  const hdWalletResult = HDWallet.fromSeed(seedBuffer);

  const { hdWallet } = hdWalletResult as {
    type: 'seedOk';
    hdWallet: HDWallet;
  };

  const derivationResult = hdWallet.selectAccount(0).selectRole(Roles.NightExternal).deriveKeyAt(0);

  if (derivationResult.type === 'keyOutOfBounds') {
    throw new Error('Key derivation out of bounds');
  }

  return derivationResult.key;
};

export const getDustSeed = (seed: string): Uint8Array<ArrayBufferLike> => {
  const seedBuffer = Buffer.from(seed, 'hex');
  const hdWalletResult = HDWallet.fromSeed(seedBuffer);

  const { hdWallet } = hdWalletResult as {
    type: 'seedOk';
    hdWallet: HDWallet;
  };

  const derivationResult = hdWallet.selectAccount(0).selectRole(Roles.Dust).deriveKeyAt(0);

  if (derivationResult.type === 'keyOutOfBounds') {
    throw new Error('Key derivation out of bounds');
  }

  return derivationResult.key;
};

export const tokenValue = (value: bigint): bigint => value * 10n ** 6n;

export const waitForFullySynced = async (facade: WalletFacade): Promise<void> => {
  await rx.firstValueFrom(facade.state().pipe(rx.filter((s) => s.isSynced)));
};

export const sleep = (secs: number): Promise<void> => {
  return new Promise((resolve) => setTimeout(resolve, secs * 1000));
};

// we need to wait for at least one block for Dust to be generated
export const waitForDustGenerated = (seconds: number = 10): Promise<void> => sleep(seconds);

================
File: packages/facade/vitest.config.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/// <reference types="vitest" />
/// <reference types="vitest/globals" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    setupFiles: ['../../setup-env.ts'],
    environment: 'node',
    globals: true,
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage',
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }],
    ],
  },
});

================
File: packages/hd/CHANGELOG.md
================
# @midnight-ntwrk/wallet-sdk-hd

## 3.0.0-beta.7

### Patch Changes

- fb55d52: Introduce more convenient API for Bech32m address encoding/decoding Remove network id from Dust wallet
  initialization methods (so they are read from the configuration) Introduce FacadeState and add a getter to check for
  sync status of whole facade wallet Introduce CompositeDerivation for HD wallet, so that it is possible to derive keys
  for multiple roles at once

## 3.0.0-beta.6

### Patch Changes

- 2a0d132: chore: force re-release after workspace failure

## 3.0.0-beta.5

### Patch Changes

- ae22baf: chore: initialize baseline release after introducing Changesets

================
File: packages/hd/README.md
================
# Midnight SDK HD Wallet

This package provides support for Hierarchical Deterministic (HD) Wallet.

To allow deterministic derivation of keys for different features, Midnight follows algorithms and structure being a mix
of [BIP-32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki),
[BIP-44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) and
[CIP-1852](https://github.com/cardano-foundation/CIPs/blob/master/CIP-1852/README.md). Specifically, derivation follows
BIP-32, and following path for a key pair is used:

```
m / purpose' / coin_type' / account' / role / index
```

Where:

- `purpose` is integer `44` (`0x8000002c`) - despite extensions, Night part of the hierarchy follows BIP-44
- `coin_type` is integer `2400` (`0x80000960`)
- `account` follows BIP-44 recommendations
- `role` follows table below
- `index` follows BIP-44 recommendations

| Role name            | Value | Description                                             |
| -------------------- | ----- | ------------------------------------------------------- |
| Night External chain | 0     | Night is Midnight's main token of value, Follows BIP-44 |
| Night Internal chain | 1     | as above                                                |
| Dust                 | 2     | Dust is needed to pay fees on Midnight                  |
| Zswap                | 3     | Zswap is a sub-protocol for shielded native tokens      |
| Metadata             | 4     | Keys for signing metadata                               |

## How to derive the keys?

Below you can find an example on how to derive keys from a random seed:

```typescript
import { generateRandomSeed, HDWallet, Roles } from '@midnight-ntwrk/wallet-sdk-hd';

const seed = generateRandomSeed();
const generatedWallet = HDWallet.fromSeed(seed);

if (generatedWallet.type == 'seedOk') {
  const zswapKey = generatedWallet.hdWallet.selectAccount(0).selectRole(Roles.Zswap).deriveKeyAt(0);
  if (zswapKey.type === 'keyDerived') {
    console.log('success', zswapKey.key);
  } else {
    console.error('Error deriving key');
  }
} else {
  console.error('Error generating HDWallet');
}
```

================
File: packages/indexer-client/src/effect/Query.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Context, Effectable, Option, identity } from 'effect';
import { ClientError, ServerError } from '@midnight-ntwrk/wallet-sdk-utilities/networking';
import type { TypedDocumentNode } from '@graphql-typed-document-node/core';
import { QueryClient } from './QueryClient.js';

/**
 * Describes an invocable GraphQL query.
 */
export interface Query<R, V, F extends Query.QueryFn<R, V> = Query.QueryFn<R, V>> extends Effect.Effect<F> {
  readonly tag: Context.Tag<Query<R, V>, F>;
  readonly run: F;
}

export declare namespace Query {
  /**
   * A GraphQL query (that may be parameterized with variables), that returns a typed document.
   *
   * @typeParam R The type returned by the GraphQL query.
   * @typeParam V A type that describes the variables present in the GraphQL query.
   *
   * @remarks
   * `Document` is a simple type alias for `TypedDocumentNode`.
   */
  export type Document<R, V> = TypedDocumentNode<R, V>;

  /**
   * The variables of a {@link Document}.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  export type Variables<T> = T extends Document<any, infer V> ? V : never;

  /**
   * The expected result of executing a {@link Document}.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  export type Result<T> = T extends Document<infer R, any> ? R : never;

  /**
   * Describes a function that executes a GraphQL query over some given variables.
   *
   * @param variables The variables to be used in the GraphQL query.
   * @returns An `Effect` that will yield the result of the GraphQL query.
   */
  export type QueryFn<R, V> = (variables: V) => Effect.Effect<R, ClientError | ServerError, QueryClient>;
}

/**
 * Constructs a new invocable GraphQL query.
 *
 * @param name The name of the tag to be associated with this query.
 * @param document A parsed GraphQL query document that represents the query.
 * @returns A {@link Query}.
 */
export const make: <Name extends string, T extends Query.Document<R, V>, R = Query.Result<T>, V = Query.Variables<T>>(
  name: Name,
  document: T,
) => Query<R, V> = <Name extends string, T extends Query.Document<R, V>, R = Query.Result<T>, V = Query.Variables<T>>(
  name: Name,
  document: T,
) => new QueryImpl<R, V, T>(`${name}Query`, document);

class QueryImpl<
  R,
  V,
  T extends Query.Document<R, V> = Query.Document<R, V>,
  F extends Query.QueryFn<R, V> = Query.QueryFn<R, V>,
>
  extends Effectable.Class<F>
  implements Query<R, V, F>
{
  readonly name: string;
  protected readonly document: T;

  constructor(name: string, document: T) {
    super();
    this.document = document;
    this.name = name;
    this.tag = Context.GenericTag(name);
    this.run = ((variables: V) => Effect.flatMap(this, (f) => f(variables))) as F;
  }

  readonly tag: Context.Tag<Query<R, V>, F>;
  readonly run: F;

  commit() {
    const self = this; // eslint-disable-line @typescript-eslint/no-this-alias
    return Effect.gen(function* () {
      return Option.match(yield* Effect.serviceOption(self.tag), {
        onSome: identity,
        onNone: () => self.defaultFn.bind(self) as F,
      });
    });
  }

  private defaultFn(variables: V): Effect.Effect<R, ClientError | ServerError, QueryClient> {
    return QueryClient.pipe(Effect.flatMap((client) => client.query(this.document, variables)));
  }
}

================
File: packages/indexer-client/src/effect/Subscription.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Stream, Context, Effectable, Option, identity } from 'effect';
import { ClientError, ServerError } from '@midnight-ntwrk/wallet-sdk-utilities/networking';
import { SubscriptionClient } from './SubscriptionClient.js';
import type { Query } from './Query.js';

/**
 * Describes a subscription of elements from an invocable GraphQL query.
 */
export interface Subscription<
  R,
  V,
  F extends Subscription.SubscriptionFn<R, V> = Subscription.SubscriptionFn<R, V>,
> extends Effect.Effect<F> {
  readonly tag: Context.Tag<Subscription<R, V>, F>;
  readonly run: F;
}

export declare namespace Subscription {
  /**
   * Describes a function that streams a GraphQL subscription for some given variables.
   *
   * @param variables The variables to be used in the GraphQL query.
   * @returns A `Stream` that will yield the elements of the GraphQL subscription.
   */
  export type SubscriptionFn<R, V> = (variables: V) => Stream.Stream<R, ClientError | ServerError, SubscriptionClient>;
}

export const make: <Name extends string, T extends Query.Document<R, V>, R = Query.Result<T>, V = Query.Variables<T>>(
  name: Name,
  document: T,
) => Subscription<R, V> = <
  Name extends string,
  T extends Query.Document<R, V>,
  R = Query.Result<T>,
  V = Query.Variables<T>,
>(
  name: Name,
  document: T,
) => new SubscriptionImpl<R, V, T>(`${name}Subscription`, document);

class SubscriptionImpl<
  R,
  V,
  T extends Query.Document<R, V> = Query.Document<R, V>,
  F extends Subscription.SubscriptionFn<R, V> = Subscription.SubscriptionFn<R, V>,
>
  extends Effectable.Class<F>
  implements Subscription<R, V, F>
{
  readonly name: string;
  protected readonly document: T;

  constructor(name: string, document: T) {
    super();
    this.document = document;
    this.name = name;
    this.tag = Context.GenericTag(name);
    this.run = ((variables: V) => Stream.flatMap(this, (f) => f(variables))) as F;
  }

  readonly tag: Context.Tag<Subscription<R, V>, F>;
  readonly run: F;

  commit() {
    const self = this; // eslint-disable-line @typescript-eslint/no-this-alias
    return Effect.gen(function* () {
      return Option.match(yield* Effect.serviceOption(self.tag), {
        onSome: identity,
        onNone: () => self.defaultFn.bind(self) as F,
      });
    });
  }

  private defaultFn(variables: V): Stream.Stream<R, ClientError | ServerError, SubscriptionClient> {
    return SubscriptionClient.pipe(Stream.flatMap((client) => client.subscribe(this.document, variables)));
  }
}

================
File: packages/indexer-client/src/graphql/generated/index.ts
================
export * from "./fragment-masking.js";
export * from "./gql.js";

================
File: packages/indexer-client/src/graphql/queries/BlockHash.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Query } from '../../effect/index.js';
import { gql } from '../generated/index.js';

export const BlockHash = Query.make(
  'BlockHash',
  gql(`
    query BlockHash($offset: BlockOffset) {
      block(offset: $offset) {
        height
        hash
        ledgerParameters
        timestamp
      }
    }
  `),
);

================
File: packages/indexer-client/src/graphql/subscriptions/UnshieldedTransactions.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Subscription } from '../../effect/index.js';
import { gql } from '../generated/index.js';

export const UnshieldedTransactions = Subscription.make(
  'UnshieldedTransactions',
  gql(`
    subscription UnshieldedTransactions($address: UnshieldedAddress!, $transactionId: Int) {
      unshieldedTransactions(address: $address, transactionId: $transactionId) {
        ... on UnshieldedTransaction {
          type: __typename
          transaction {
            type: __typename
            id
            hash
            protocolVersion
            block {
              timestamp
            }
            ... on RegularTransaction {
              identifiers
              fees {
                paidFees
                estimatedFees
              }
              transactionResult {
                status
                segments {
                  id
                  success
                }
              }
            }
          }
          createdUtxos {
            owner
            tokenType
            value
            outputIndex
            intentHash
            ctime
            registeredForDustGeneration
          }
          spentUtxos {
            owner
            tokenType
            value
            outputIndex
            intentHash
            ctime
            registeredForDustGeneration
          }
        }
        ... on UnshieldedTransactionsProgress {
          type: __typename
          highestTransactionId
        }
      }
    }
  `),
);

================
File: packages/indexer-client/vitest.config.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/// <reference types="vitest" />
/// <reference types="vitest/globals" />
import { defineConfig } from 'vitest/config';
import { fileURLToPath, URL } from 'node:url';

export default defineConfig({
  test: {
    setupFiles: ['../../setup-env.ts'],
    environment: 'node',
    globals: true,
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage',
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }],
    ],
  },
  resolve: {
    alias: {
      '@midnight-ntwrk/wallet-sdk-indexer-client/effect': fileURLToPath(
        new URL('../indexer-client/src/effect.ts', import.meta.url),
      ),
    },
  },
});

================
File: packages/node-client/CHANGELOG.md
================
# @midnight-ntwrk/wallet-sdk-node-client

## 1.0.0-beta.10

### Patch Changes

- 3f14055: chore: bump ledger to version 6.1.0-alpha.6

## 1.0.0-beta.9

### Patch Changes

- 1db4280: chore: bump ledger to version 6.1.0-beta.5

## 1.0.0-beta.8

### Patch Changes

- 2a0d132: chore: force re-release after workspace failure

## 1.0.0-beta.7

### Patch Changes

- ae22baf: chore: initialize baseline release after introducing Changesets

================
File: packages/runtime/src/abstractions/WalletLike.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/* eslint-disable @typescript-eslint/no-explicit-any */
import { Scope } from 'effect';
import { Observable } from 'rxjs';
import { Runtime } from '../Runtime.js';
import { AnyVersionedVariantArray, StateOf, VariantRecord } from './Variant.js';
import { HList, Poly } from '@midnight-ntwrk/wallet-sdk-utilities';
import { ProtocolState } from '@midnight-ntwrk/wallet-sdk-abstractions';

/**
 * Defines the static portion of base wallet class definition
 */
export interface BaseWalletClass<TVariants extends AnyVersionedVariantArray, TConfiguration = object> {
  readonly configuration: Readonly<TConfiguration>;
  new (runtime: Runtime<TVariants>, scope: Scope.CloseableScope): WalletLike<TVariants>;
  allVariants(): TVariants;
  allVariantsRecord(): VariantRecord<TVariants>;
  startEmpty<T extends WalletClassLike<TVariants, any>>(walletClass: T): WalletOf<T>;
  startFirst<T extends WalletClassLike<TVariants, any>>(
    walletClass: T,
    state: StateOf<HList.Head<TVariants>>,
  ): WalletOf<T>;
  start<T extends WalletClassLike<TVariants, any>, Tag extends string | symbol>(
    walletClass: T,
    tag: Tag,
    state: StateOf<HList.Find<TVariants, { variant: Poly.WithTag<Tag> }>>,
  ): WalletOf<T>;
}

/**
 * Defines the static portion of wallet-like definition
 */
export interface WalletClassLike<
  TVariants extends AnyVersionedVariantArray,
  TWallet extends WalletLike<TVariants>,
> extends BaseWalletClass<TVariants> {
  new (runtime: Runtime<TVariants>, scope: Scope.CloseableScope): TWallet;
}

export type AnyWalletClass<Variants extends AnyVersionedVariantArray> = WalletClassLike<Variants, WalletLike<Variants>>;
export type WalletOf<T> = T extends WalletClassLike<any, infer TWallet> ? TWallet : never;

/**
 * Defines a base wallet-like implementation.
 *
 * @typeParam TVariants Underlying variants
 */
export interface WalletLike<TVariants extends AnyVersionedVariantArray> {
  readonly runtime: Runtime<TVariants>;
  readonly runtimeScope: Scope.CloseableScope;

  /**
   * A stream of state changes over any amount of time that have been processed by the wallet.
   */
  readonly rawState: Observable<ProtocolState.ProtocolState<StateOf<HList.Each<TVariants>>>>;

  /**
   * Stops the wallet
   */
  stop(): Promise<void>;
}

================
File: packages/runtime/src/testing/variants.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { StateChange, Variant, VariantBuilder, VersionChangeType, WalletRuntimeError } from '../abstractions/index.js';
import { Effect, Option, PubSub, Scope, Stream } from 'effect';

export type RangeConfig = {
  min: number;
  max: number;
};

export const Numeric = 'NumericRange' as const;
export class NumericRange implements Variant.Variant<
  typeof Numeric,
  number,
  null,
  Variant.RunningVariant<typeof Numeric, number>
> {
  __polyTag__: typeof Numeric = Numeric;
  #state: number = 0;

  protected configuration: RangeConfig;
  protected yieldCount: number;
  protected throwError: boolean;

  constructor(configuration: RangeConfig, yieldCount: number, throwError: boolean) {
    this.throwError = throwError;
    this.yieldCount = yieldCount;
    this.configuration = configuration;
  }

  get currentState(): number {
    return this.#state;
  }

  start(context: Variant.VariantContext<number>): Effect.Effect<Variant.RunningVariant<typeof Numeric, number>> {
    const max = this.configuration.max ?? 10;

    return context.stateRef.get.pipe(
      Effect.flatMap((state) => {
        return Effect.sync(() => {
          this.#state = state;
        });
      }),
      Effect.map(() => ({
        __polyTag__: Numeric,
        state: Stream.fromAsyncIterable<StateChange.StateChange<number>, WalletRuntimeError>(
          // eslint-disable-next-line @typescript-eslint/require-await
          (async function* (self: NumericRange) {
            for (let value = self.#state; value <= max; value++) {
              self.#state = value;
              yield StateChange.State({ state: value });

              if (--self.yieldCount === 0) {
                if (self.throwError) {
                  throw new Error('NumericRange: forced break');
                }

                yield StateChange.VersionChange({ change: VersionChangeType.Next() });
              }
            }
          })(this),
          (e) => new WalletRuntimeError({ message: 'NumericRange error', cause: e }),
        ),
      })),
    );
  }

  migrateState(): Effect.Effect<number> {
    return Effect.succeed(0);
  }
}

export class NumericRangeBuilder implements VariantBuilder.VariantBuilder<NumericRange, RangeConfig> {
  private readonly yieldCount: number;
  private readonly throwError: boolean;

  constructor(yieldCount: number = 10, throwError: boolean = false) {
    this.throwError = throwError;
    this.yieldCount = yieldCount;
  }

  build(configuration: RangeConfig): NumericRange {
    return new NumericRange(configuration, this.yieldCount, this.throwError);
  }
}

export type RangeMultiplierConfig = RangeConfig & { multiplier: number };
export const NumericMultiplier = 'NumericMultiplier';
export class NumericRangeMultiplier implements Variant.Variant<
  typeof NumericMultiplier,
  number,
  number,
  Variant.RunningVariant<typeof NumericMultiplier, number>
> {
  __polyTag__: typeof NumericMultiplier = NumericMultiplier;
  #state: number = 0;

  protected configuration: RangeMultiplierConfig;

  constructor(configuration: RangeMultiplierConfig) {
    this.configuration = configuration;
  }

  get currentState(): number {
    return this.#state;
  }

  start(
    context: Variant.VariantContext<number>,
  ): Effect.Effect<Variant.RunningVariant<typeof NumericMultiplier, number>> {
    return context.stateRef.get.pipe(
      Effect.flatMap((state) => {
        return Effect.sync(() => {
          this.#state = state;
        });
      }),
      Effect.map(() => {
        const max = this.configuration.max ?? 10;

        return {
          __polyTag__: NumericMultiplier,
          state: Stream.fromIterable(
            (function* (self: NumericRangeMultiplier) {
              for (let value = self.#state; value <= max; value++) {
                self.#state = value;
                yield StateChange.State({ state: value * self.configuration.multiplier });
              }
              return Option.none();
            })(this),
          ),
        };
      }),
    );
  }

  migrateState(state: number): Effect.Effect<number> {
    return Effect.succeed(state + 1);
  }
}

export class NumericRangeMultiplierBuilder implements VariantBuilder.VariantBuilder<
  NumericRangeMultiplier,
  RangeMultiplierConfig
> {
  build(configuration: RangeMultiplierConfig): NumericRangeMultiplier {
    return new NumericRangeMultiplier(configuration);
  }
}

export type InterceptingRunningVariant<TTag extends string | symbol, TState> = Variant.RunningVariant<TTag, TState> & {
  emitProtocolVersionChange: (change: VersionChangeType.VersionChangeType) => Effect.Effect<void>;
};
export class InterceptingVariant<TTag extends string | symbol, TState> implements Variant.Variant<
  TTag,
  TState,
  TState,
  InterceptingRunningVariant<TTag, TState>
> {
  __polyTag__: TTag;
  constructor(tag: TTag) {
    this.__polyTag__ = tag;
  }

  migrateState(previousState: TState): Effect.Effect<TState> {
    return Effect.succeed(previousState);
  }
  start(
    context: Variant.VariantContext<TState>,
  ): Effect.Effect<InterceptingRunningVariant<TTag, TState>, WalletRuntimeError, Scope.Scope> {
    const tag = this.__polyTag__;
    return Effect.gen(this, function* () {
      const pubsub = yield* PubSub.bounded<StateChange.StateChange<TState>>({
        capacity: 1,
        replay: 1,
      });
      const state = yield* context.stateRef.get;
      yield* PubSub.publish(pubsub, StateChange.State({ state }));
      return {
        __polyTag__: tag,
        state: Stream.fromPubSub(pubsub, {
          shutdown: true,
        }),
        emitProtocolVersionChange: (change: VersionChangeType.VersionChangeType) => {
          return PubSub.publish(pubsub, StateChange.VersionChange({ change }));
        },
      };
    });
  }
}

/**
 * Builder of an intercepting variant
 * It allows removing the possibility of race conditions by requiring an explicit gesture to migrate to a next/specific protocol version
 */
export class InterceptingVariantBuilder<TTag extends string | symbol, TState> implements VariantBuilder.VariantBuilder<
  InterceptingVariant<TTag, TState>,
  object
> {
  tag: TTag;
  constructor(tag: TTag) {
    this.tag = tag;
  }
  build(): InterceptingVariant<TTag, TState> {
    return new InterceptingVariant(this.tag);
  }
}

================
File: packages/runtime/CHANGELOG.md
================
# @midnight-ntwrk/wallet-sdk-runtime

## 1.0.0-beta.8

### Patch Changes

- Updated dependencies [a06ccf3]
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.9

## 1.0.0-beta.7

### Patch Changes

- Updated dependencies [976628a]
- Updated dependencies [1db4280]
- Updated dependencies [646c8df]
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.8

## 1.0.0-beta.6

### Patch Changes

- 2a0d132: chore: force re-release after workspace failure
- Updated dependencies [2a0d132]
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.6

## 1.0.0-beta.5

### Patch Changes

- ae22baf: chore: initialize baseline release after introducing Changesets
- Updated dependencies [ae22baf]
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.5

================
File: packages/shielded-wallet/src/v1/test/sync.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Layer, Stream } from 'effect';
import { buildTestEnvironmentVariables, getComposeDirectory } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import { DockerComposeEnvironment, type StartedDockerComposeEnvironment } from 'testcontainers';
import { randomUUID } from 'node:crypto';
import { afterAll, beforeAll, describe, expect, it } from 'vitest';
import { HttpQueryClient, WsSubscriptionClient } from '@midnight-ntwrk/wallet-sdk-indexer-client/effect';
import { Connect, Disconnect, ShieldedTransactions } from '@midnight-ntwrk/wallet-sdk-indexer-client';

const KNOWN_VIEWING_KEY = 'mn_shield-esk_undeployed1qqpsq87f9ac09e95wjm2rp8vp0yd0z4pns7p2w7c9qus0vm20fj4dl93nu709t';

const timeout_minutes = (mins: number) => 1_000 * 60 * mins;

const environmentId = randomUUID();

const environmentVars = buildTestEnvironmentVariables(['APP_INFRA_SECRET'], {
  additionalVars: {
    TESTCONTAINERS_UID: environmentId,
  },
});

const environment = new DockerComposeEnvironment(getComposeDirectory(), 'docker-compose-dynamic.yml').withEnvironment(
  environmentVars,
);

// TODO: This is replicating the tests from indexer client, it should be rewritten to use the wallet sync service instead
describe.skip('Wallet subscription', () => {
  describe('with available Indexer Server', () => {
    let startedEnvironment: StartedDockerComposeEnvironment | undefined = undefined;
    const getIndexerPort = () =>
      startedEnvironment?.getContainer(`indexer_${environmentId}`).getMappedPort(8088) ?? 8088;

    beforeAll(async () => {
      startedEnvironment = await environment.up();
    }, timeout_minutes(3));

    afterAll(async () => {
      await startedEnvironment?.down();
    }, timeout_minutes(1));

    it(
      'should stream GraphQL subscription',
      async () => {
        const makeScopedSession = Effect.acquireRelease(Connect.run({ viewingKey: KNOWN_VIEWING_KEY }), (session) =>
          Disconnect.run({ sessionId: session.connect }).pipe(Effect.catchAll((_) => Effect.void)),
        );

        await Effect.gen(function* () {
          const session = yield* makeScopedSession;
          const events = yield* ShieldedTransactions.run({
            sessionId: session.connect,
            index: null,
          }).pipe(
            Stream.take(5),
            Stream.tap((data) => Effect.log(data.shieldedTransactions.__typename)),
            Stream.runCollect, // collect the elements into a single chunk.
          );

          expect(events).toHaveLength(5);
        }).pipe(
          Effect.provide(
            Layer.mergeAll(
              HttpQueryClient.layer({ url: `http://127.0.0.1:${getIndexerPort()}/api/v3/graphql` }),
              WsSubscriptionClient.layer({ url: `ws://127.0.0.1:${getIndexerPort()}/api/v3/graphql/ws` }),
            ),
          ),
          Effect.scoped,
          Effect.runPromise,
        );
      },
      timeout_minutes(1),
    );
  });
});

================
File: packages/shielded-wallet/src/v1/RunningV1Variant.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Effect, pipe, Record, Scope, Stream, SubscriptionRef, Schedule, Duration, Sink, Console } from 'effect';
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import {
  WalletRuntimeError,
  Variant,
  StateChange,
  VersionChangeType,
} from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
import { EitherOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import { ProvingService } from './Proving.js';
import { ProvingRecipe } from './ProvingRecipe.js';
import { SerializationCapability } from './Serialization.js';
import { EventsSyncUpdate, SyncCapability, SyncService } from './Sync.js';
import { TransactingCapability, TokenTransfer } from './Transacting.js';
import { OtherWalletError, WalletError } from './WalletError.js';
import { CoinsAndBalancesCapability } from './CoinsAndBalances.js';
import { KeysCapability } from './Keys.js';
import { SubmissionService, SubmitTransactionMethod } from './Submission.js';
import { CoinSelection } from '@midnight-ntwrk/wallet-sdk-capabilities';
import { CoreWallet } from './CoreWallet.js';
import { TransactionHistoryCapability } from './TransactionHistory.js';

const progress = (state: CoreWallet): StateChange.StateChange<CoreWallet>[] => {
  const appliedIndex = state.progress?.appliedIndex ?? 0n;
  const highestRelevantWalletIndex = state.progress?.highestRelevantWalletIndex ?? 0n;
  const highestIndex = state.progress?.highestIndex ?? 0n;
  const highestRelevantIndex = state.progress?.highestRelevantIndex ?? 0n;

  const sourceGap = highestIndex - highestRelevantIndex;
  const applyGap = highestRelevantWalletIndex - appliedIndex;

  return [StateChange.ProgressUpdate({ sourceGap, applyGap })];
};

const protocolVersionChange = (previous: CoreWallet, current: CoreWallet): StateChange.StateChange<CoreWallet>[] => {
  return previous.protocolVersion != current.protocolVersion
    ? [
        StateChange.VersionChange({
          change: VersionChangeType.Version({
            version: ProtocolVersion.ProtocolVersion(current.protocolVersion),
          }),
        }),
      ]
    : [];
};

export declare namespace RunningV1Variant {
  export type Context<TSerialized, TSyncUpdate, TTransaction, TStartAux> = {
    serializationCapability: SerializationCapability<CoreWallet, null, TSerialized>;
    syncService: SyncService<CoreWallet, TStartAux, TSyncUpdate>;
    syncCapability: SyncCapability<CoreWallet, TSyncUpdate>;
    transactingCapability: TransactingCapability<ledger.ZswapSecretKeys, CoreWallet, TTransaction>;
    provingService: ProvingService<TTransaction>;
    coinsAndBalancesCapability: CoinsAndBalancesCapability<CoreWallet>;
    keysCapability: KeysCapability<CoreWallet>;
    submissionService: SubmissionService<TTransaction>;
    coinSelection: CoinSelection<ledger.QualifiedShieldedCoinInfo>;
    transactionHistoryCapability: TransactionHistoryCapability<CoreWallet, TTransaction>;
  };
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  export type AnyContext = Context<any, any, any, any>;
}

export const V1Tag: unique symbol = Symbol('V1');

export type DefaultRunningV1 = RunningV1Variant<
  string,
  EventsSyncUpdate,
  ledger.FinalizedTransaction,
  ledger.ZswapSecretKeys
>;

export class RunningV1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux> implements Variant.RunningVariant<
  typeof V1Tag,
  CoreWallet
> {
  readonly __polyTag__: typeof V1Tag = V1Tag;
  readonly #scope: Scope.Scope;
  readonly #context: Variant.VariantContext<CoreWallet>;
  readonly #v1Context: RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction, TStartAux>;

  readonly state: Stream.Stream<StateChange.StateChange<CoreWallet>, WalletRuntimeError>;

  constructor(
    scope: Scope.Scope,
    context: Variant.VariantContext<CoreWallet>,
    v1Context: RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction, TStartAux>,
  ) {
    this.#scope = scope;
    this.#context = context;
    this.#v1Context = v1Context;
    this.state = Stream.fromEffect(context.stateRef.get).pipe(
      Stream.flatMap((initialState) =>
        context.stateRef.changes.pipe(
          Stream.mapAccum(initialState, (previous: CoreWallet, current: CoreWallet) => {
            return [current, [previous, current]] as const;
          }),
        ),
      ),
      Stream.mapConcat(
        ([previous, current]: readonly [CoreWallet, CoreWallet]): StateChange.StateChange<CoreWallet>[] => {
          // TODO: emit progress only upon actual change
          return [
            StateChange.State({ state: current }),
            ...progress(current),
            ...protocolVersionChange(previous, current),
          ];
        },
      ),
    );
  }

  startSyncInBackground(startAux: TStartAux): Effect.Effect<void> {
    return this.startSync(startAux).pipe(
      Stream.runScoped(Sink.drain),
      Effect.forkScoped,
      Effect.provideService(Scope.Scope, this.#scope),
    );
  }

  startSync(startAux: TStartAux): Stream.Stream<void, WalletError, Scope.Scope> {
    return pipe(
      SubscriptionRef.get(this.#context.stateRef),
      Stream.fromEffect,
      Stream.flatMap((state) => this.#v1Context.syncService.updates(state, startAux)),
      Stream.mapEffect((update) => {
        return SubscriptionRef.updateEffect(this.#context.stateRef, (state) =>
          Effect.try({
            try: () => this.#v1Context.syncCapability.applyUpdate(state, update),
            catch: (err) =>
              new OtherWalletError({
                message: 'Error while applying sync update',
                cause: err,
              }),
          }),
        );
      }),
      Stream.tapError((error) => Console.error(error)),
      Stream.retry(
        pipe(
          Schedule.exponential(Duration.seconds(1), 2),
          Schedule.map((delay) => {
            const maxDelay = Duration.minutes(2);
            const jitter = Duration.millis(Math.floor(Math.random() * 1000));
            const delayWithJitter = Duration.toMillis(delay) + Duration.toMillis(jitter);

            return Duration.millis(Math.min(delayWithJitter, Duration.toMillis(maxDelay)));
          }),
        ),
      ),
    );
  }

  balanceTransaction(
    secretKeys: ledger.ZswapSecretKeys,
    tx: ledger.Transaction<ledger.Signaturish, ledger.Proofish, ledger.Bindingish>,
  ): Effect.Effect<ProvingRecipe<TTransaction>, WalletError> {
    return SubscriptionRef.modifyEffect(this.#context.stateRef, (state) => {
      return pipe(
        this.#v1Context.transactingCapability.balanceTransaction(secretKeys, state, tx),
        EitherOps.toEffect,
        Effect.map(({ recipe, newState }) => [recipe, newState] as const),
      );
    });
  }

  transferTransaction(
    secretKeys: ledger.ZswapSecretKeys,
    outputs: ReadonlyArray<TokenTransfer>,
  ): Effect.Effect<ProvingRecipe<TTransaction>, WalletError> {
    return SubscriptionRef.modifyEffect(this.#context.stateRef, (state) => {
      return pipe(
        this.#v1Context.transactingCapability.makeTransfer(secretKeys, state, outputs),
        EitherOps.toEffect,
        Effect.map(({ recipe, newState }) => [recipe, newState] as const),
      );
    });
  }

  initSwap(
    secretKeys: ledger.ZswapSecretKeys,
    desiredInputs: Record<ledger.RawTokenType, bigint>,
    desiredOutputs: ReadonlyArray<TokenTransfer>,
  ): Effect.Effect<ProvingRecipe<TTransaction>, WalletError> {
    return SubscriptionRef.modifyEffect(this.#context.stateRef, (state) => {
      return pipe(
        this.#v1Context.transactingCapability.initSwap(secretKeys, state, desiredInputs, desiredOutputs),
        EitherOps.toEffect,
        Effect.map(({ recipe, newState }) => [recipe, newState] as const),
      );
    });
  }

  finalizeTransaction(recipe: ProvingRecipe<TTransaction>): Effect.Effect<TTransaction, WalletError> {
    return this.#v1Context.provingService
      .prove(recipe)
      .pipe(
        Effect.tapError(() =>
          SubscriptionRef.updateEffect(this.#context.stateRef, (state) =>
            EitherOps.toEffect(this.#v1Context.transactingCapability.revertRecipe(state, recipe)),
          ),
        ),
      );
  }

  submitTransaction: SubmitTransactionMethod<TTransaction> = ((
    transaction: TTransaction,
    waitForStatus: 'Submitted' | 'InBlock' | 'Finalized' = 'InBlock',
  ) => {
    return this.#v1Context.submissionService
      .submitTransaction(transaction, waitForStatus)
      .pipe(
        Effect.tapError(() =>
          SubscriptionRef.updateEffect(this.#context.stateRef, (state) =>
            EitherOps.toEffect(this.#v1Context.transactingCapability.revert(state, transaction)),
          ),
        ),
      );
  }) as SubmitTransactionMethod<TTransaction>;

  serializeState(state: CoreWallet): TSerialized {
    return this.#v1Context.serializationCapability.serialize(state);
  }
}

================
File: packages/shielded-wallet/src/v1/Transacting.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Array as Arr, Data, Either, Option, pipe, Record } from 'effect';
import { ArrayOps, EitherOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import {
  BALANCE_TRANSACTION_TO_PROVE,
  NOTHING_TO_PROVE,
  ProvingRecipe,
  TRANSACTION_TO_PROVE,
} from './ProvingRecipe.js';
import { CoreWallet } from './CoreWallet.js';
import { AddressError, InsufficientFundsError, OtherWalletError, WalletError } from './WalletError.js';
import {
  BalanceRecipe,
  CoinSelection,
  getBalanceRecipe,
  Imbalances,
  InsufficientFundsError as BalancingInsufficientFundsError,
} from '@midnight-ntwrk/wallet-sdk-capabilities';
import { MidnightBech32m, ShieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';
import { ShieldedCostModel, TransactionImbalances } from './TransactionImbalances.js';
import { TransactionTrait } from './Transaction.js';
import { CoinsAndBalancesCapability } from './CoinsAndBalances.js';
import { KeysCapability } from './Keys.js';

export interface TokenTransfer {
  readonly amount: bigint;
  readonly type: ledger.RawTokenType;
  readonly receiverAddress: string;
}

export interface TransactingCapability<TSecrets, TState, TTransaction> {
  balanceTransaction(
    secrets: TSecrets,
    state: TState,
    // That's definitely fine for now, question is whether it is worth bastracting over in general case
    tx: ledger.Transaction<ledger.Signaturish, ledger.Proofish, ledger.Bindingish>,
  ): Either.Either<{ recipe: ProvingRecipe<TTransaction>; newState: TState }, WalletError>;

  makeTransfer(
    secrets: TSecrets,
    state: TState,
    outputs: ReadonlyArray<TokenTransfer>,
  ): Either.Either<{ recipe: ProvingRecipe<TTransaction>; newState: TState }, WalletError>;

  initSwap(
    secrets: TSecrets,
    state: TState,
    desiredInputs: Record<ledger.RawTokenType, bigint>,
    desiredOutputs: ReadonlyArray<TokenTransfer>,
  ): Either.Either<{ recipe: ProvingRecipe<TTransaction>; newState: TState }, WalletError>;

  //These functions below do not exactly match here, but also seem to be somewhat good place to put
  //The reason is that they primarily make sense in a wallet flavour only able to issue transactions
  revert(state: TState, tx: TTransaction): Either.Either<TState, WalletError>;

  revertRecipe(state: TState, recipe: ProvingRecipe<TTransaction>): Either.Either<TState, WalletError>;
}

export type DefaultTransactingConfiguration = {
  networkId: NetworkId.NetworkId;
};

export type DefaultTransactingContext = {
  coinSelection: CoinSelection<ledger.QualifiedShieldedCoinInfo>;
  coinsAndBalancesCapability: CoinsAndBalancesCapability<CoreWallet>;
  keysCapability: KeysCapability<CoreWallet>;
};

export const makeDefaultTransactingCapability = (
  config: DefaultTransactingConfiguration,
  getContext: () => DefaultTransactingContext,
): TransactingCapability<ledger.ZswapSecretKeys, CoreWallet, ledger.FinalizedTransaction> => {
  return new TransactingCapabilityImplementation(
    config.networkId,
    () => getContext().coinSelection,
    () => getContext().coinsAndBalancesCapability,
    () => getContext().keysCapability,
    TransactionTrait.default,
  );
};

export const makeSimulatorTransactingCapability = (
  config: DefaultTransactingConfiguration,
  getContext: () => DefaultTransactingContext,
): TransactingCapability<ledger.ZswapSecretKeys, CoreWallet, ledger.ProofErasedTransaction> => {
  return new TransactingCapabilityImplementation(
    config.networkId,
    () => getContext().coinSelection,
    () => getContext().coinsAndBalancesCapability,
    () => getContext().keysCapability,
    TransactionTrait.proofErased,
  );
};

class NoSelfOutputsError extends Data.TaggedError('NoSelfOutputs')<object> {}

export class TransactingCapabilityImplementation<
  TTransaction extends ledger.Transaction<ledger.Signaturish, ledger.Proofish, ledger.Bindingish>,
> implements TransactingCapability<ledger.ZswapSecretKeys, CoreWallet, TTransaction> {
  public readonly networkId: NetworkId.NetworkId;
  public readonly getCoinSelection: () => CoinSelection<ledger.QualifiedShieldedCoinInfo>;
  public readonly txTrait: TransactionTrait<TTransaction>;
  readonly getCoins: () => CoinsAndBalancesCapability<CoreWallet>;
  readonly getKeys: () => KeysCapability<CoreWallet>;

  constructor(
    networkId: NetworkId.NetworkId,
    getCoinSelection: () => CoinSelection<ledger.QualifiedShieldedCoinInfo>,
    getCoins: () => CoinsAndBalancesCapability<CoreWallet>,
    getKeys: () => KeysCapability<CoreWallet>,
    txTrait: TransactionTrait<TTransaction>,
  ) {
    this.getCoins = getCoins;
    this.networkId = networkId;
    this.getCoinSelection = getCoinSelection;
    this.getKeys = getKeys;
    this.txTrait = txTrait;
  }

  balanceTransaction(
    secretKeys: ledger.ZswapSecretKeys,
    state: CoreWallet,
    tx: TTransaction,
  ): Either.Either<{ recipe: ProvingRecipe<TTransaction>; newState: CoreWallet }, WalletError> {
    return Either.gen(this, function* () {
      const coinSelection = this.getCoinSelection();
      const networkId = this.networkId;
      const initialImbalances = this.txTrait.getImbalances(tx);

      if (TransactionImbalances.areBalanced(initialImbalances)) {
        return {
          recipe: {
            type: NOTHING_TO_PROVE,
            transaction: tx,
          },
          newState: state,
        };
      }

      const { newState: afterFallible, offer: maybeFallible } = yield* this.balanceFallibleSection(
        secretKeys,
        state,
        initialImbalances,
        coinSelection,
      );
      const { newState: afterGuaranteed, offer: guaranteed } = yield* this.#balanceGuaranteedSection(
        secretKeys,
        afterFallible,
        initialImbalances,
        coinSelection,
        0,
        Imbalances.empty(),
      );

      return {
        newState: afterGuaranteed,
        recipe: {
          type: BALANCE_TRANSACTION_TO_PROVE,
          transactionToBalance: tx,
          transactionToProve: ledger.Transaction.fromParts(networkId, guaranteed, maybeFallible),
        },
      };
    });
  }

  makeTransfer(
    secretKeys: ledger.ZswapSecretKeys,
    state: CoreWallet,
    transfers: Arr.NonEmptyReadonlyArray<TokenTransfer>,
  ): Either.Either<{ recipe: ProvingRecipe<TTransaction>; newState: CoreWallet }, WalletError> {
    return Either.gen(this, function* () {
      const positiveTransfers = yield* pipe(
        transfers,
        Arr.filter((t) => t.amount > 0n),
        Arr.match({
          onEmpty: () =>
            Either.left(
              new OtherWalletError({
                message: 'The amount needs to be positive',
              }),
            ),
          onNonEmpty: (nonEmpty) => Either.right(nonEmpty),
        }),
      );

      const networkId = this.networkId;
      const { initialOffersAndCoins, selfCoins } = yield* this.#processDesiredOutputs(state, positiveTransfers);
      const offerToBalance = pipe(
        initialOffersAndCoins,
        Arr.map((o) => o.outputOffer),
        ArrayOps.fold((a, b) => a.merge(b)),
      );
      const unprovenTxToBalance = ledger.Transaction.fromParts(networkId, offerToBalance);
      const imbalances = TransactionTrait.unproven.getImbalances(unprovenTxToBalance);
      const { offer, newState } = yield* this.#balanceGuaranteedSection(
        secretKeys,
        state,
        imbalances,
        this.getCoinSelection(),
        selfCoins.length,
        Imbalances.empty(),
      );
      const finalState = CoreWallet.watchCoins(newState, secretKeys, selfCoins);
      const finalTx = unprovenTxToBalance.merge(ledger.Transaction.fromParts(networkId, offer));

      return {
        newState: finalState,
        recipe: {
          type: TRANSACTION_TO_PROVE,
          transaction: finalTx,
        },
      };
    });
  }

  initSwap(
    secretKeys: ledger.ZswapSecretKeys,
    state: CoreWallet,
    desiredInputs: Record<ledger.RawTokenType, bigint>,
    desiredOutputs: ReadonlyArray<TokenTransfer>,
  ): Either.Either<{ recipe: ProvingRecipe<TTransaction>; newState: CoreWallet }, WalletError> {
    return Either.gen(this, function* () {
      const outputsValid = desiredOutputs.every((output) => output.amount > 0n);
      if (!outputsValid) {
        return yield* Either.left(
          new OtherWalletError({
            message: 'The amount needs to be positive',
          }),
        );
      }

      const inputsValid = Object.entries(desiredInputs).every(([, amount]) => amount > 0n);
      if (!inputsValid) {
        return yield* Either.left(
          new OtherWalletError({
            message: 'The input amounts need to be positive',
          }),
        );
      }

      const outputsParseResult = yield* this.#processDesiredOutputsPossiblyEmpty(state, desiredOutputs);
      const inputsParseResult = Imbalances.fromEntries(Record.toEntries(desiredInputs));
      const networkId = this.networkId;

      const { offer, newState } = yield* this.#balanceGuaranteedSection(
        secretKeys,
        state,
        TransactionImbalances.empty(),
        this.getCoinSelection(),
        outputsParseResult.selfCoins.length,
        inputsParseResult,
      );
      const finalState = CoreWallet.watchCoins(newState, secretKeys, outputsParseResult.selfCoins);
      const balancingTx = ledger.Transaction.fromParts(networkId, offer);
      const finalTx = outputsParseResult.unprovenTxToBalance
        ? outputsParseResult.unprovenTxToBalance.merge(balancingTx)
        : balancingTx;

      return {
        newState: finalState,
        recipe: {
          type: TRANSACTION_TO_PROVE,
          transaction: finalTx,
        },
      };
    });
  }

  revert(state: CoreWallet, tx: TTransaction): Either.Either<CoreWallet, WalletError> {
    return Either.try({
      try: () => {
        return CoreWallet.revertTransaction(state, tx);
      },
      catch: (err) => {
        return new OtherWalletError({
          message: `Error while reverting transaction ${this.txTrait.id(tx)}`,
          cause: err,
        });
      },
    });
  }

  revertRecipe(state: CoreWallet, recipe: ProvingRecipe<TTransaction>): Either.Either<CoreWallet, WalletError> {
    const doRevert = (tx: ledger.UnprovenTransaction) => {
      return Either.try({
        try: () => {
          return CoreWallet.revertTransaction(state, tx);
        },
        catch: (err) => {
          return new OtherWalletError({
            message: `Error while reverting transaction ${TransactionTrait.unproven.id(tx)}`,
            cause: err,
          });
        },
      });
    };

    switch (recipe.type) {
      case TRANSACTION_TO_PROVE:
        return doRevert(recipe.transaction);
      case BALANCE_TRANSACTION_TO_PROVE:
        return doRevert(recipe.transactionToProve);
      case NOTHING_TO_PROVE:
        return Either.right(state);
    }
  }

  #prepareOffer(
    secretKeys: ledger.ZswapSecretKeys,
    state: CoreWallet,
    recipe: BalanceRecipe<ledger.QualifiedShieldedCoinInfo, ledger.ShieldedCoinInfo>,
    segment: 0 | 1,
  ): Option.Option<{ newState: CoreWallet; offer: ledger.ZswapOffer<ledger.PreProof> }> {
    const [inputOffers, stateAfterSpends] = CoreWallet.spendCoins(state, secretKeys, recipe.inputs, segment);
    const stateAfterWatches = CoreWallet.watchCoins(stateAfterSpends, secretKeys, recipe.outputs);
    const outputOffers = recipe.outputs.map((coin) => {
      const output = ledger.ZswapOutput.new(
        coin,
        segment,
        this.getKeys().getCoinPublicKey(state).toHexString(),
        this.getKeys().getEncryptionPublicKey(state).toHexString(),
      );
      return ledger.ZswapOffer.fromOutput(output, coin.type, coin.value);
    });

    return pipe(
      Arr.appendAll(inputOffers, outputOffers),
      Arr.match({
        onEmpty: () => Option.none<ledger.ZswapOffer<ledger.PreProof>>(),
        onNonEmpty: (nonEmpty) =>
          pipe(
            nonEmpty,
            ArrayOps.fold((a, b) => a.merge(b)),
            Option.some,
          ),
      }),
      Option.map((offer) => ({ offer, newState: stateAfterWatches })),
    );
  }

  balanceFallibleSection(
    secretKeys: ledger.ZswapSecretKeys,
    state: CoreWallet,
    imbalances: TransactionImbalances,
    coinSelection: CoinSelection<ledger.QualifiedShieldedCoinInfo>,
  ): Either.Either<
    {
      offer: ledger.ZswapOffer<ledger.PreProof> | undefined;
      newState: CoreWallet;
    },
    WalletError
  > {
    return Either.try({
      try: () => {
        const fallibleBalanceRecipe = getBalanceRecipe<ledger.QualifiedShieldedCoinInfo, ledger.ShieldedCoinInfo>({
          coins: this.getCoins()
            .getAvailableCoins(state)
            .map((c) => c.coin),
          initialImbalances: imbalances.fallible,
          transactionCostModel: ShieldedCostModel,
          feeTokenType: '',
          coinSelection,
          createOutput: (coin) => ledger.createShieldedCoinInfo(coin.type, coin.value),
          isCoinEqual: (a, b) => a.type === b.type && a.value === b.value,
        });
        return pipe(
          this.#prepareOffer(secretKeys, state, fallibleBalanceRecipe, 1),
          Option.match({
            onNone: () => ({
              newState: state,
              offer: undefined,
            }),
            onSome: (res) => res,
          }),
        );
      },
      catch: (err) => {
        if (err instanceof BalancingInsufficientFundsError) {
          return new InsufficientFundsError({
            message: 'Insufficient funds',
            tokenType: err.tokenType,
            amount: imbalances.fallible.get(err.tokenType) ?? 0n,
          });
        } else {
          return new OtherWalletError({
            message: 'Balancing fallible section failed',
            cause: err,
          });
        }
      },
    });
  }

  #balanceGuaranteedSection(
    secretKeys: ledger.ZswapSecretKeys,
    state: CoreWallet,
    imbalances: TransactionImbalances,
    coinSelection: CoinSelection<ledger.QualifiedShieldedCoinInfo>,
    knownSelfOutputs: number,
    targetImbalances: Imbalances,
  ): Either.Either<{ offer: ledger.ZswapOffer<ledger.PreProof>; newState: CoreWallet }, WalletError> {
    return Either.gen(this, function* () {
      const balanceRecipe = yield* Either.try({
        try: () =>
          getBalanceRecipe<ledger.QualifiedShieldedCoinInfo, ledger.ShieldedCoinInfo>({
            coins: this.getCoins()
              .getAvailableCoins(state)
              .map((c) => c.coin),
            initialImbalances: imbalances.guaranteed,
            transactionCostModel: ShieldedCostModel,
            feeTokenType: '',
            coinSelection,
            createOutput: (coin) => ledger.createShieldedCoinInfo(coin.type, coin.value),
            isCoinEqual: (a, b) => a.nonce === b.nonce,
            targetImbalances,
          }),
        catch: (err) => {
          if (err instanceof BalancingInsufficientFundsError) {
            return new InsufficientFundsError({
              message: 'Insufficient funds',
              tokenType: err.tokenType,
              amount: imbalances.guaranteed.get(err.tokenType) ?? 0n,
            });
          } else {
            return new OtherWalletError({
              message: 'Balancing guaranteed section failed',
              cause: err,
            });
          }
        },
      });

      if (balanceRecipe.outputs.length + knownSelfOutputs == 0) {
        return yield* Either.left(new NoSelfOutputsError({}));
      }

      return yield* pipe(
        this.#prepareOffer(secretKeys, state, balanceRecipe, 0),
        Either.fromOption(() => {
          return new OtherWalletError({
            message: 'Could not create a valid guaranteed offer',
          });
        }),
      );
    }).pipe(
      EitherOps.flatMapLeft((err: NoSelfOutputsError | WalletError) => {
        if (err instanceof NoSelfOutputsError) {
          return this.#balanceGuaranteedWithSelfOutput(secretKeys, state, imbalances, coinSelection, targetImbalances);
        } else {
          return Either.left(err);
        }
      }),
    );
  }

  #balanceGuaranteedWithSelfOutput(
    secretKeys: ledger.ZswapSecretKeys,
    state: CoreWallet,
    imbalances: TransactionImbalances,
    coinSelection: CoinSelection<ledger.QualifiedShieldedCoinInfo>,
    targetImbalances: Imbalances,
  ) {
    return Either.gen(this, function* () {
      const additionalOutputValue = 100_000n;
      const balanceRecipe = yield* Either.try({
        try: () => {
          return getBalanceRecipe<ledger.QualifiedShieldedCoinInfo, ledger.ShieldedCoinInfo>({
            coins: this.getCoins()
              .getAvailableCoins(state)
              .map((c) => c.coin),
            initialImbalances: Imbalances.merge(
              imbalances.guaranteed,
              Imbalances.fromEntry((ledger.shieldedToken() as { raw: string }).raw, -1n * additionalOutputValue),
            ),
            transactionCostModel: ShieldedCostModel,
            feeTokenType: '',
            coinSelection,
            targetImbalances,
            createOutput: (coin) => ledger.createShieldedCoinInfo(coin.type, coin.value),
            isCoinEqual: (a, b) => a.nonce === b.nonce,
          });
        },
        catch: (err) => {
          if (err instanceof BalancingInsufficientFundsError) {
            return new InsufficientFundsError({
              message: 'Insufficient funds',
              tokenType: err.tokenType,
              amount: imbalances.guaranteed.get(err.tokenType) ?? 0n,
            });
          } else {
            return new OtherWalletError({
              message: 'Balancing guaranteed section failed',
              cause: err,
            });
          }
        },
      });
      const additionalCoin = ledger.createShieldedCoinInfo(
        (ledger.shieldedToken() as { raw: string }).raw,
        additionalOutputValue,
      );
      const additionalOffer = pipe(
        additionalCoin,
        (coin) =>
          ledger.ZswapOutput.new(
            coin,
            0,
            this.getKeys().getCoinPublicKey(state).toHexString(),
            this.getKeys().getEncryptionPublicKey(state).toHexString(),
          ),
        (output) =>
          ledger.ZswapOffer.fromOutput(output, (ledger.shieldedToken() as { raw: string }).raw, additionalOutputValue),
      );

      return yield* pipe(
        this.#prepareOffer(secretKeys, state, balanceRecipe, 0),
        Option.map(({ newState, offer }) => {
          return {
            newState: CoreWallet.watchCoins(newState, secretKeys, [additionalCoin]),
            offer: offer.merge(additionalOffer),
          };
        }),
        Either.fromOption(() => {
          return new OtherWalletError({
            message: 'Balancing guaranteed section failed',
          });
        }),
      );
    });
  }

  #parseAddress(addr: string) {
    return Either.try({
      try: () => {
        const repr = MidnightBech32m.parse(addr);
        return ShieldedAddress.codec.decode(this.networkId, repr);
      },
      catch: (err) => {
        return new AddressError({
          message: `Address parsing error: ${addr}`,
          originalAddress: addr,
          cause: err,
        });
      },
    });
  }

  #processDesiredOutputs(state: CoreWallet, transfers: Arr.NonEmptyReadonlyArray<TokenTransfer>) {
    return Either.gen(this, function* () {
      const initialOffersAndCoins = yield* pipe(
        transfers,
        Arr.map((transfer) => {
          return pipe(
            this.#parseAddress(transfer.receiverAddress),
            Either.map((address) => {
              const coin = ledger.createShieldedCoinInfo(transfer.type, transfer.amount);
              const output = ledger.ZswapOutput.new(
                coin,
                0,
                address.coinPublicKey.toHexString(),
                address.encryptionPublicKey.toHexString(),
              );
              const outputOffer = ledger.ZswapOffer.fromOutput(output, transfer.type, transfer.amount);

              return {
                coin,
                outputOffer,
                isForSelf: address.coinPublicKey.equals(this.getKeys().getCoinPublicKey(state)),
              };
            }),
          );
        }),
        Either.all,
      );
      const selfCoins = Arr.flatMap(
        initialOffersAndCoins,
        ({ coin, isForSelf }): readonly ledger.ShieldedCoinInfo[] => {
          if (isForSelf) {
            return [coin];
          } else {
            return [];
          }
        },
      );

      return { initialOffersAndCoins, selfCoins };
    });
  }

  #processDesiredOutputsPossiblyEmpty(state: CoreWallet, desiredOutputs: ReadonlyArray<TokenTransfer>) {
    return pipe(
      desiredOutputs,
      Arr.match({
        onEmpty: () => {
          return Either.right({
            imbalances: TransactionImbalances.empty(),
            selfCoins: [],
            unprovenTxToBalance: null,
          });
        },
        onNonEmpty: (desiredOutputs) => {
          return pipe(
            this.#processDesiredOutputs(state, desiredOutputs),
            Either.map(({ initialOffersAndCoins, selfCoins }) => {
              const networkId = this.networkId;
              const offerToBalance = pipe(
                initialOffersAndCoins,
                Arr.map((o) => o.outputOffer),
                ArrayOps.fold((a, b) => a.merge(b)),
              );
              const unprovenTxToBalance = ledger.Transaction.fromParts(networkId, offerToBalance);
              const imbalances = TransactionTrait.unproven.getImbalances(unprovenTxToBalance);

              return {
                imbalances,
                selfCoins,
                unprovenTxToBalance,
              };
            }),
          );
        },
      }),
    );
  }
}

================
File: packages/shielded-wallet/src/v1/V1Builder.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Effect, Either, Scope, Types } from 'effect';
import { WalletSeed, NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Variant, VariantBuilder, WalletRuntimeError } from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
import { DefaultProvingConfiguration, makeDefaultProvingService, ProvingService } from './Proving.js';
import { RunningV1Variant, V1Tag } from './RunningV1Variant.js';
import { makeDefaultV1SerializationCapability, SerializationCapability } from './Serialization.js';
import {
  DefaultSyncContext,
  DefaultSyncConfiguration,
  SyncCapability,
  SyncService,
  WalletSyncUpdate,
  makeEventsSyncService,
  makeEventsSyncCapability,
} from './Sync.js';
import {
  DefaultTransactingConfiguration,
  DefaultTransactingContext,
  makeDefaultTransactingCapability,
  TransactingCapability,
} from './Transacting.js';
import { WalletError } from './WalletError.js';
import { CoinsAndBalancesCapability, makeDefaultCoinsAndBalancesCapability } from './CoinsAndBalances.js';
import { KeysCapability, makeDefaultKeysCapability } from './Keys.js';
import { DefaultSubmissionConfiguration, makeDefaultSubmissionService, SubmissionService } from './Submission.js';
import { CoinSelection, chooseCoin } from '@midnight-ntwrk/wallet-sdk-capabilities';
import { CoreWallet, PublicKeys } from './CoreWallet.js';
import { makeDefaultTransactionHistoryCapability, TransactionHistoryCapability } from './TransactionHistory.js';
import { Expect, Equal, ItemType } from '@midnight-ntwrk/wallet-sdk-utilities/types';

export type BaseV1Configuration = {
  networkId: NetworkId.NetworkId;
};

export type DefaultV1Configuration = BaseV1Configuration &
  DefaultSyncConfiguration &
  DefaultProvingConfiguration &
  DefaultTransactingConfiguration &
  DefaultSubmissionConfiguration;

const V1BuilderSymbol: {
  readonly typeId: unique symbol;
} = {
  typeId: Symbol('@midnight-ntwrk/wallet#V1Builder') as (typeof V1BuilderSymbol)['typeId'],
} as const;

export type V1Variant<TSerialized, TSyncUpdate, TTransaction, TAuxData> = Variant.Variant<
  typeof V1Tag,
  CoreWallet,
  null,
  RunningV1Variant<TSerialized, TSyncUpdate, TTransaction, TAuxData>
> & {
  deserializeState: (serialized: TSerialized) => Either.Either<CoreWallet, WalletError>;
  coinsAndBalances: CoinsAndBalancesCapability<CoreWallet>;
  keys: KeysCapability<CoreWallet>;
  serialization: SerializationCapability<CoreWallet, null, TSerialized>;
  transactionHistory: TransactionHistoryCapability<CoreWallet, TTransaction>;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type AnyV1Variant = V1Variant<any, any, any, any>;
export type DefaultV1Variant = V1Variant<string, WalletSyncUpdate, ledger.FinalizedTransaction, ledger.ZswapSecretKeys>;

export type TransactionOf<T extends AnyV1Variant> =
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  T extends V1Variant<any, any, infer TTransaction, any> ? TTransaction : never;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type AuxDataOf<T extends AnyV1Variant> = T extends V1Variant<any, any, any, infer TAuxData> ? TAuxData : never;
export type SerializedStateOf<T extends AnyV1Variant> =
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  T extends V1Variant<infer TSerialized, any, any, any> ? TSerialized : never;

export type DefaultV1Builder = V1Builder<
  DefaultV1Configuration,
  RunningV1Variant.Context<string, WalletSyncUpdate, ledger.FinalizedTransaction, ledger.ZswapSecretKeys>,
  string,
  WalletSyncUpdate,
  ledger.FinalizedTransaction,
  ledger.ZswapSecretKeys
>;

export class V1Builder<
  TConfig extends BaseV1Configuration = BaseV1Configuration,
  TContext extends Partial<RunningV1Variant.AnyContext> = object,
  TSerialized = never,
  TSyncUpdate = never,
  TTransaction = never,
  TStartAux extends object = object,
> implements VariantBuilder.VariantBuilder<V1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux>, TConfig> {
  readonly #buildState: V1Builder.PartialBuildState<
    TConfig,
    TContext,
    TSerialized,
    TSyncUpdate,
    TTransaction,
    TStartAux
  >;

  constructor(
    buildState: V1Builder.PartialBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux> = {},
  ) {
    this.#buildState = buildState;
  }

  withDefaults(): DefaultV1Builder {
    return this.withDefaultTransactionType()
      .withSyncDefaults()
      .withSerializationDefaults()
      .withTransactingDefaults()
      .withCoinsAndBalancesDefaults()
      .withTransactionHistoryDefaults()
      .withKeysDefaults()
      .withProvingDefaults()
      .withSubmissionDefaults()
      .withCoinSelectionDefaults() as DefaultV1Builder;
  }

  withTransactionType<Transaction>(): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, Transaction, TStartAux> {
    return new V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, Transaction, TStartAux>({
      ...this.#buildState,
      provingService: undefined,
      transactingCapability: undefined,
      submissionService: undefined,
      transactionHistoryCapability: undefined,
    });
  }

  withDefaultTransactionType(): V1Builder<
    TConfig,
    TContext,
    TSerialized,
    TSyncUpdate,
    ledger.FinalizedTransaction,
    TStartAux
  > {
    return this.withTransactionType<ledger.FinalizedTransaction>();
  }

  withSyncDefaults(): V1Builder<
    TConfig & DefaultSyncConfiguration,
    TContext & DefaultSyncContext,
    TSerialized,
    WalletSyncUpdate,
    TTransaction,
    ledger.ZswapSecretKeys
  > {
    return this.withSync(makeEventsSyncService, makeEventsSyncCapability);
  }

  withSync<
    TSyncConfig,
    TSyncContext extends Partial<RunningV1Variant.AnyContext>,
    TSyncUpdate,
    TStartAux extends object,
  >(
    syncService: (
      configuration: TSyncConfig,
      getContext: () => TSyncContext,
    ) => SyncService<CoreWallet, TStartAux, TSyncUpdate>,
    syncCapability: (
      configuration: TSyncConfig,
      getContext: () => TSyncContext,
    ) => SyncCapability<CoreWallet, TSyncUpdate>,
  ): V1Builder<TConfig & TSyncConfig, TContext & TSyncContext, TSerialized, TSyncUpdate, TTransaction, TStartAux> {
    return new V1Builder<
      TConfig & TSyncConfig,
      TContext & TSyncContext,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >({
      ...this.#buildState,
      syncService,
      syncCapability,
    });
  }

  withSerializationDefaults(): V1Builder<TConfig, TContext, string, TSyncUpdate, TTransaction, TStartAux> {
    return this.withSerialization(makeDefaultV1SerializationCapability);
  }

  withSerialization<
    TSerializationConfig,
    TSerializationContext extends Partial<RunningV1Variant.AnyContext>,
    TSerialized,
  >(
    serializationCapability: (
      configuration: TSerializationConfig,
      getContext: () => TSerializationContext,
    ) => SerializationCapability<CoreWallet, null, TSerialized>,
  ): V1Builder<
    TConfig & TSerializationConfig,
    TContext & TSerializationContext,
    TSerialized,
    TSyncUpdate,
    TTransaction,
    TStartAux
  > {
    return new V1Builder<
      TConfig & TSerializationConfig,
      TContext & TSerializationContext,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >({
      ...this.#buildState,
      serializationCapability,
    });
  }

  withTransactingDefaults(
    this: V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, ledger.FinalizedTransaction, TStartAux>,
  ): V1Builder<
    TConfig & DefaultTransactingConfiguration,
    TContext & DefaultTransactingContext,
    TSerialized,
    TSyncUpdate,
    ledger.FinalizedTransaction,
    TStartAux
  > {
    return this.withTransacting(makeDefaultTransactingCapability);
  }

  withTransacting<TTransactingConfig, TTransactingContext extends Partial<RunningV1Variant.AnyContext>>(
    transactingCapability: (
      config: TTransactingConfig,
      getContext: () => TTransactingContext,
    ) => TransactingCapability<ledger.ZswapSecretKeys, CoreWallet, TTransaction>,
  ): V1Builder<
    TConfig & TTransactingConfig,
    TContext & TTransactingContext,
    TSerialized,
    TSyncUpdate,
    TTransaction,
    TStartAux
  > {
    return new V1Builder<
      TConfig & TTransactingConfig,
      TContext & TTransactingContext,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >({
      ...this.#buildState,
      transactingCapability,
    });
  }

  withCoinSelection<TCoinSelectionConfig, TCoinSelectionContext extends Partial<RunningV1Variant.AnyContext>>(
    coinSelection: (
      config: TCoinSelectionConfig,
      getContext: () => TCoinSelectionContext,
    ) => CoinSelection<ledger.QualifiedShieldedCoinInfo>,
  ): V1Builder<
    TConfig & TCoinSelectionConfig,
    TContext & TCoinSelectionContext,
    TSerialized,
    TSyncUpdate,
    TTransaction,
    TStartAux
  > {
    return new V1Builder<
      TConfig & TCoinSelectionConfig,
      TContext & TCoinSelectionContext,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >({
      ...this.#buildState,
      coinSelection,
    });
  }

  withCoinSelectionDefaults(): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux> {
    return this.withCoinSelection(() => chooseCoin);
  }

  withProving<TProvingConfig, TProvingContext extends Partial<RunningV1Variant.AnyContext>>(
    provingService: (config: TProvingConfig, getContext: () => TProvingContext) => ProvingService<TTransaction>,
  ): V1Builder<
    TConfig & TProvingConfig,
    TContext & TProvingContext,
    TSerialized,
    TSyncUpdate,
    TTransaction,
    TStartAux
  > {
    return new V1Builder<
      TConfig & TProvingConfig,
      TContext & TProvingContext,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >({
      ...this.#buildState,
      provingService,
    });
  }

  withProvingDefaults(
    this: V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, ledger.FinalizedTransaction, TStartAux>,
  ): V1Builder<
    TConfig & DefaultProvingConfiguration,
    TContext,
    TSerialized,
    TSyncUpdate,
    ledger.FinalizedTransaction,
    TStartAux
  > {
    return this.withProving(makeDefaultProvingService);
  }

  withCoinsAndBalancesDefaults(): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux> {
    return this.withCoinsAndBalances(makeDefaultCoinsAndBalancesCapability);
  }

  withCoinsAndBalances<TBalancesConfig, TBalancesContext extends Partial<RunningV1Variant.AnyContext>>(
    coinsAndBalancesCapability: (
      configuration: TBalancesConfig,
      getContext: () => TBalancesContext,
    ) => CoinsAndBalancesCapability<CoreWallet>,
  ): V1Builder<
    TConfig & TBalancesConfig,
    TContext & TBalancesContext,
    TSerialized,
    TSyncUpdate,
    TTransaction,
    TStartAux
  > {
    return new V1Builder<
      TConfig & TBalancesConfig,
      TContext & TBalancesContext,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >({
      ...this.#buildState,
      coinsAndBalancesCapability,
    });
  }

  withTransactionHistoryDefaults(
    this: V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, ledger.FinalizedTransaction, TStartAux>,
  ): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, ledger.FinalizedTransaction, TStartAux> {
    return this.withTransactionHistory(makeDefaultTransactionHistoryCapability);
  }

  withTransactionHistory<
    TTransactionHistoryConfig,
    TTransactionHistoryContext extends Partial<RunningV1Variant.AnyContext>,
  >(
    transactionHistoryCapability: (
      configuration: TTransactionHistoryConfig,
      getContext: () => TTransactionHistoryContext,
    ) => TransactionHistoryCapability<CoreWallet, TTransaction>,
  ): V1Builder<
    TConfig & TTransactionHistoryConfig,
    TContext & TTransactionHistoryContext,
    TSerialized,
    TSyncUpdate,
    TTransaction,
    TStartAux
  > {
    return new V1Builder<
      TConfig & TTransactionHistoryConfig,
      TContext & TTransactionHistoryContext,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >({
      ...this.#buildState,
      transactionHistoryCapability,
    });
  }

  withKeysDefaults(): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux> {
    return this.withKeys(makeDefaultKeysCapability);
  }

  withKeys<TKeysConfig, TKeysContext extends Partial<RunningV1Variant.AnyContext>>(
    keysCapability: (configuration: TKeysConfig, getContext: () => TKeysContext) => KeysCapability<CoreWallet>,
  ): V1Builder<TConfig & TKeysConfig, TContext & TKeysContext, TSerialized, TSyncUpdate, TTransaction, TStartAux> {
    return new V1Builder<
      TConfig & TKeysConfig,
      TContext & TKeysContext,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >({
      ...this.#buildState,
      keysCapability,
    });
  }

  withSubmission<TSubmissionConfig, TSubmissionContext extends Partial<RunningV1Variant.AnyContext>>(
    submissionService: (
      config: TSubmissionConfig,
      getContext: () => TSubmissionContext,
    ) => SubmissionService<TTransaction>,
  ): V1Builder<
    TConfig & TSubmissionConfig,
    TContext & TSubmissionContext,
    TSerialized,
    TSyncUpdate,
    TTransaction,
    TStartAux
  > {
    return new V1Builder<
      TConfig & TSubmissionConfig,
      TContext & TSubmissionContext,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >({
      ...this.#buildState,
      submissionService,
    });
  }

  withSubmissionDefaults(
    this: V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, ledger.FinalizedTransaction, TStartAux>,
  ): V1Builder<
    TConfig & DefaultSubmissionConfiguration,
    TContext,
    TSerialized,
    TSyncUpdate,
    ledger.FinalizedTransaction,
    TStartAux
  > {
    return this.withSubmission(makeDefaultSubmissionService);
  }

  build(
    this: V1Builder<
      TConfig,
      RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction, TStartAux>,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >,
    configuration: TConfig,
  ): V1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux> {
    const v1Context = this.#buildContextFromBuildState(configuration);
    const { networkId } = configuration;

    return {
      __polyTag__: V1Tag,
      coinsAndBalances: v1Context.coinsAndBalancesCapability,
      keys: v1Context.keysCapability,
      serialization: v1Context.serializationCapability,
      transactionHistory: v1Context.transactionHistoryCapability,
      start(
        context: Variant.VariantContext<CoreWallet>,
      ): Effect.Effect<
        RunningV1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux>,
        WalletRuntimeError,
        Scope.Scope
      > {
        return Effect.gen(function* () {
          yield* Effect.addFinalizer(() => v1Context.submissionService.close());
          const scope = yield* Scope.Scope;
          return new RunningV1Variant(scope, context, v1Context);
        });
      },
      migrateState(_previousState) {
        const seed = WalletSeed.fromString('0000000000000000000000000000000000000000000000000000000000000001');

        return Effect.succeed(
          CoreWallet.empty(PublicKeys.fromSecretKeys(ledger.ZswapSecretKeys.fromSeed(seed)), networkId),
        );
      },

      deserializeState: (serialized: TSerialized): Either.Either<CoreWallet, WalletError> => {
        return v1Context.serializationCapability.deserialize(null, serialized);
      },
    };
  }

  #buildContextFromBuildState(
    this: V1Builder<
      TConfig,
      RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction, TStartAux>,
      TSerialized,
      TSyncUpdate,
      TTransaction,
      TStartAux
    >,
    configuration: TConfig,
  ): RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction, TStartAux> {
    if (!isBuildStateFull(this.#buildState)) {
      throw new Error('Not all components are configured in V1 Builder');
    }

    const {
      syncCapability,
      syncService,
      transactingCapability,
      serializationCapability,
      provingService,
      coinSelection,
      coinsAndBalancesCapability,
      keysCapability,
      submissionService,
      transactionHistoryCapability,
    } = this.#buildState;

    const getContext = (): RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction, TStartAux> => context;

    const context = {
      serializationCapability: serializationCapability(configuration, getContext),
      syncCapability: syncCapability(configuration, getContext),
      syncService: syncService(configuration, getContext),
      transactingCapability: transactingCapability(configuration, getContext),
      coinsAndBalancesCapability: coinsAndBalancesCapability(configuration, getContext),
      keysCapability: keysCapability(configuration, getContext),
      provingService: provingService(configuration, getContext),
      coinSelection: coinSelection(configuration, getContext),
      submissionService: submissionService(configuration, getContext),
      transactionHistoryCapability: transactionHistoryCapability(configuration, getContext),
    };

    return context;
  }
}

/** @internal */
declare namespace V1Builder {
  type HasSync<TConfig, TContext, TSyncUpdate, TStartAux> = {
    readonly syncService: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => SyncService<CoreWallet, TStartAux, TSyncUpdate>;
    readonly syncCapability: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => SyncCapability<CoreWallet, TSyncUpdate>;
  };

  type HasTransacting<TConfig, TContext, TTransaction> = {
    readonly transactingCapability: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => TransactingCapability<ledger.ZswapSecretKeys, CoreWallet, TTransaction>;
  };

  type HasCoinSelection<TConfig, TContext> = {
    readonly coinSelection: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => CoinSelection<ledger.QualifiedShieldedCoinInfo>;
  };

  type HasSerialization<TConfig, TContext, TSerialized> = {
    readonly serializationCapability: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => SerializationCapability<CoreWallet, null, TSerialized>;
  };

  type HasProving<TConfig, TContext, TTransaction> = {
    readonly provingService: (configuration: TConfig, getContext: () => TContext) => ProvingService<TTransaction>;
  };

  type HasCoinsAndBalances<TConfig, TContext> = {
    readonly coinsAndBalancesCapability: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => CoinsAndBalancesCapability<CoreWallet>;
  };

  type HasTransactionHistory<TConfig, TContext, TTransaction> = {
    readonly transactionHistoryCapability: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => TransactionHistoryCapability<CoreWallet, TTransaction>;
  };

  type HasKeys<TConfig, TContext> = {
    readonly keysCapability: (configuration: TConfig, getContext: () => TContext) => KeysCapability<CoreWallet>;
  };

  type HasSubmission<TConfig, TContext, TTransaction> = {
    readonly submissionService: (configuration: TConfig, getContext: () => TContext) => SubmissionService<TTransaction>;
  };

  /**
   * The internal build state of {@link V1Builder}.
   */
  type FullBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux> = Types.Simplify<
    HasSync<TConfig, TContext, TSyncUpdate, TStartAux> &
      HasSerialization<TConfig, TContext, TSerialized> &
      HasTransacting<TConfig, TContext, TTransaction> &
      HasCoinSelection<TConfig, TContext> &
      HasProving<TConfig, TContext, TTransaction> &
      HasSubmission<TConfig, TContext, TTransaction> &
      HasCoinsAndBalances<TConfig, TContext> &
      HasKeys<TConfig, TContext> &
      HasTransactionHistory<TConfig, TContext, TTransaction>
  >;
  type PartialBuildState<
    TConfig = object,
    TContext = object,
    TSerialized = never,
    TSyncUpdate = never,
    TTransaction = never,
    TStartAux = object,
  > = {
    [K in keyof FullBuildState<never, never, never, never, never, never>]?:
      | FullBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>[K]
      | undefined;
  };

  /**
   * Utility interface that manages the type variance of {@link V1Builder}.
   */
  interface Variance<R> {
    readonly [V1BuilderSymbol.typeId]: {
      readonly _R: Types.Covariant<R>;
    };
  }
}

const isBuildStateFull = <TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>(
  buildState: V1Builder.PartialBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux>,
): buildState is V1Builder.FullBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction, TStartAux> => {
  const allBuildStateKeys = [
    'syncService',
    'syncCapability',
    'transactingCapability',
    'coinSelection',
    'serializationCapability',
    'provingService',
    'coinsAndBalancesCapability',
    'keysCapability',
    'submissionService',
    'transactionHistoryCapability',
  ] as const;
  /**
   * This type will fail compilation if any key is omitted, letting the `isFull` check work properly
   */
  type _1 = Expect<
    Equal<keyof V1Builder.FullBuildState<never, never, never, never, never, never>, ItemType<typeof allBuildStateKeys>>
  >;
  return allBuildStateKeys.every((key) => typeof buildState[key] == 'function');
};

/** @internal */
declare namespace _V1BuilderMethods {
  type WithSyncDefaults = 'withSyncDefaults';
  type WithSyncMethod = 'withSync';
  type WithTransactingMethod = 'withTransacting';
  type WithTransactingDefaults = 'withTransactingDefaults';
  type WithSerializationMethod = 'withSerialization';
  type WithSerializationDefaults = 'withSerializationDefaults';
  type WithCoinsAndBalancesDefaults = 'withCoinsAndBalancesDefaults';
  type WithKeysDefaults = 'withKeysDefaults';
  type WithTransactionHistoryDefaults = 'withTransactionHistoryDefaults';
  type AllSyncMethods = WithSyncDefaults | WithSyncMethod;
  type AllTransactingMethods = WithTransactingMethod | WithTransactingDefaults;
  type AllSerializationMethods = WithSerializationMethod | WithSerializationDefaults;
  type AllProvingMethods = 'withProving' | 'withProvingDefaults';
  type AllSubmissionMethods = 'withSubmission' | 'withSubmissionDefaults';
  type AllCoinsAndBalancesMethods = 'withCoinsAndBalancesDefaults';
  type AllKeysMethods = 'withKeysDefaults';
  type AllTransactionHistoryMethods = 'withTransactionHistoryDefaults';
  type AllMethods =
    | AllSyncMethods
    | AllTransactingMethods
    | AllSerializationMethods
    | AllProvingMethods
    | AllSubmissionMethods
    | AllCoinsAndBalancesMethods
    | AllKeysMethods
    | AllTransactionHistoryMethods;
}

================
File: packages/shielded-wallet/src/ShieldedWallet.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ProtocolState, ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { BaseV1Configuration, DefaultV1Configuration, V1Builder, V1Tag, V1Variant, CoreWallet } from './v1/index.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Effect, Either, Scope } from 'effect';
import * as rx from 'rxjs';
import { ProvingRecipe } from './v1/ProvingRecipe.js';
import { SerializationCapability } from './v1/Serialization.js';
import { ProgressUpdate, TransactionHistoryCapability } from './v1/TransactionHistory.js';
import { AvailableCoin, CoinsAndBalancesCapability, PendingCoin } from './v1/CoinsAndBalances.js';
import { KeysCapability } from './v1/Keys.js';
import {
  ShieldedAddress,
  ShieldedCoinPublicKey,
  ShieldedEncryptionPublicKey,
} from '@midnight-ntwrk/wallet-sdk-address-format';
import { SubmissionEvent, SubmissionEventCases } from './v1/Submission.js';
import { TokenTransfer } from './v1/Transacting.js';
import { WalletSyncUpdate } from './v1/Sync.js';
import { Variant, VariantBuilder, WalletLike } from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
import { Runtime, WalletBuilder } from '@midnight-ntwrk/wallet-sdk-runtime';

export type ShieldedWalletCapabilities<TSerialized = string, TTransaction = ledger.FinalizedTransaction> = {
  serialization: SerializationCapability<CoreWallet, null, TSerialized>;
  coinsAndBalances: CoinsAndBalancesCapability<CoreWallet>;
  keys: KeysCapability<CoreWallet>;
  transactionHistory: TransactionHistoryCapability<CoreWallet, TTransaction>;
};

export class ShieldedWalletState<TSerialized = string, TTransaction = ledger.FinalizedTransaction> {
  static readonly mapState =
    <TSerialized = string, TTransaction = ledger.FinalizedTransaction>(
      capabilities: ShieldedWalletCapabilities<TSerialized, TTransaction>,
    ) =>
    (state: ProtocolState.ProtocolState<CoreWallet>): ShieldedWalletState<TSerialized, TTransaction> => {
      return new ShieldedWalletState(state, capabilities);
    };

  readonly protocolVersion: ProtocolVersion.ProtocolVersion;
  readonly state: CoreWallet;
  readonly capabilities: ShieldedWalletCapabilities<TSerialized, TTransaction>;

  get balances(): Record<ledger.RawTokenType, bigint> {
    return this.capabilities.coinsAndBalances.getAvailableBalances(this.state);
  }

  get totalCoins(): readonly (AvailableCoin | PendingCoin)[] {
    return this.capabilities.coinsAndBalances.getTotalCoins(this.state);
  }

  get availableCoins(): readonly AvailableCoin[] {
    return this.capabilities.coinsAndBalances.getAvailableCoins(this.state);
  }

  get pendingCoins(): readonly PendingCoin[] {
    return this.capabilities.coinsAndBalances.getPendingCoins(this.state);
  }

  get coinPublicKey(): ShieldedCoinPublicKey {
    return this.capabilities.keys.getCoinPublicKey(this.state);
  }

  get encryptionPublicKey(): ShieldedEncryptionPublicKey {
    return this.capabilities.keys.getEncryptionPublicKey(this.state);
  }

  get address(): ShieldedAddress {
    return this.capabilities.keys.getAddress(this.state);
  }

  get progress(): ProgressUpdate {
    return this.capabilities.transactionHistory.progress(this.state);
  }

  get transactionHistory(): readonly TTransaction[] {
    return this.capabilities.transactionHistory.transactionHistory(this.state);
  }

  constructor(
    state: ProtocolState.ProtocolState<CoreWallet>,
    capabilities: ShieldedWalletCapabilities<TSerialized, TTransaction>,
  ) {
    this.protocolVersion = state.version;
    this.state = state.state;
    this.capabilities = capabilities;
  }

  serialize(): TSerialized {
    return this.capabilities.serialization.serialize(this.state);
  }
}

export type SubmitTransactionMethod<TTransaction> = {
  (transaction: TTransaction, waitForStatus: 'Submitted'): Promise<SubmissionEventCases.Submitted>;
  (transaction: TTransaction, waitForStatus: 'InBlock'): Promise<SubmissionEventCases.InBlock>;
  (transaction: TTransaction, waitForStatus: 'Finalized'): Promise<SubmissionEventCases.Finalized>;
  (transaction: TTransaction): Promise<SubmissionEventCases.InBlock>;
  (transaction: TTransaction, waitForStatus?: 'Submitted' | 'InBlock' | 'Finalized'): Promise<SubmissionEvent>;
};

export type ShieldedWallet = CustomizedShieldedWallet<
  ledger.ZswapSecretKeys,
  ledger.FinalizedTransaction,
  WalletSyncUpdate,
  string
>;

export type ShieldedWalletClass = CustomizedShieldedWalletClass<
  ledger.ZswapSecretKeys,
  ledger.FinalizedTransaction,
  WalletSyncUpdate,
  string
>;

export interface CustomizedShieldedWallet<
  TStartAux = ledger.ZswapSecretKeys,
  TTransaction = ledger.FinalizedTransaction,
  TSyncUpdate = WalletSyncUpdate,
  TSerialized = string,
> extends WalletLike.WalletLike<
  [Variant.VersionedVariant<V1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux>>]
> {
  readonly state: rx.Observable<ShieldedWalletState<TSerialized, TTransaction>>;

  start(secretKeys: TStartAux): Promise<void>;

  // we can balance bound and unbound txs
  balanceTransaction(
    secretKeys: ledger.ZswapSecretKeys,
    tx: ledger.Transaction<ledger.Signaturish, ledger.Proofish, ledger.Bindingish>,
    newCoins: readonly ledger.ShieldedCoinInfo[],
  ): Promise<ProvingRecipe<TTransaction>>;

  transferTransaction(
    secretKeys: ledger.ZswapSecretKeys,
    outputs: readonly TokenTransfer[],
  ): Promise<ProvingRecipe<TTransaction>>;

  initSwap(
    secretKeys: ledger.ZswapSecretKeys,
    desiredInputs: Record<ledger.RawTokenType, bigint>,
    desiredOutputs: readonly TokenTransfer[],
  ): Promise<ProvingRecipe<TTransaction>>;

  finalizeTransaction(recipe: ProvingRecipe<TTransaction>): Promise<TTransaction>;

  readonly submitTransaction: SubmitTransactionMethod<TTransaction>;

  serializeState(): Promise<TSerialized>;

  waitForSyncedState(allowedGap?: bigint): Promise<ShieldedWalletState<TSerialized, TTransaction>>;

  getAddress(): Promise<ShieldedAddress>;
}

export interface CustomizedShieldedWalletClass<
  TStartAux = ledger.ZswapSecretKeys,
  TTransaction = ledger.FinalizedTransaction,
  TSyncUpdate = WalletSyncUpdate,
  TSerialized = string,
  TConfig extends BaseV1Configuration = DefaultV1Configuration,
> extends WalletLike.BaseWalletClass<
  [Variant.VersionedVariant<V1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux>>]
> {
  configuration: TConfig;
  startWithShieldedSeed(seed: Uint8Array): CustomizedShieldedWallet<TStartAux, TTransaction, TSyncUpdate, TSerialized>;
  startWithSecretKeys(
    secretKeys: ledger.ZswapSecretKeys,
  ): CustomizedShieldedWallet<TStartAux, TTransaction, TSyncUpdate, TSerialized>;
  restore(serializedState: TSerialized): CustomizedShieldedWallet<TStartAux, TTransaction, TSyncUpdate, TSerialized>;
}

export function ShieldedWallet(configuration: DefaultV1Configuration): ShieldedWalletClass {
  return CustomShieldedWallet(configuration, new V1Builder().withDefaults());
}

export function CustomShieldedWallet<
  TConfig extends BaseV1Configuration = DefaultV1Configuration,
  TStartAux = ledger.ZswapSecretKeys,
  TTransaction = ledger.FinalizedTransaction,
  TSyncUpdate = WalletSyncUpdate,
  TSerialized = string,
>(
  configuration: TConfig,
  builder: VariantBuilder.VariantBuilder<V1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux>, TConfig>,
): CustomizedShieldedWalletClass<TStartAux, TTransaction, TSyncUpdate, TSerialized, TConfig> {
  const buildArgs = [configuration] as WalletBuilder.BuildArguments<
    [
      VariantBuilder.VersionedVariantBuilder<
        VariantBuilder.VariantBuilder<V1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux>, TConfig>
      >,
    ]
  >;
  const BaseWallet = WalletBuilder.init()
    .withVariant(ProtocolVersion.MinSupportedVersion, builder)
    .build(...buildArgs) as WalletLike.BaseWalletClass<
    [Variant.VersionedVariant<V1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux>>],
    TConfig
  >;

  return class CustomShieldedWalletImplementation
    extends BaseWallet
    implements CustomizedShieldedWallet<TStartAux, TTransaction, TSyncUpdate, TSerialized>
  {
    static startWithSecretKeys(secretKeys: ledger.ZswapSecretKeys): CustomShieldedWalletImplementation {
      return CustomShieldedWalletImplementation.startFirst(
        CustomShieldedWalletImplementation,
        CoreWallet.initEmpty(secretKeys, CustomShieldedWalletImplementation.configuration.networkId),
      );
    }

    static startWithShieldedSeed(seed: Uint8Array): CustomShieldedWalletImplementation {
      const secretKeys: ledger.ZswapSecretKeys = ledger.ZswapSecretKeys.fromSeed(seed);
      return CustomShieldedWalletImplementation.startWithSecretKeys(secretKeys);
    }

    static restore(serializedState: TSerialized): CustomShieldedWalletImplementation {
      const deserialized: CoreWallet = CustomShieldedWalletImplementation.allVariantsRecord()
        [V1Tag].variant.deserializeState(serializedState)
        .pipe(Either.getOrThrow);
      return CustomShieldedWalletImplementation.startFirst(CustomShieldedWalletImplementation, deserialized);
    }

    readonly state: rx.Observable<ShieldedWalletState<TSerialized, TTransaction>>;

    constructor(
      runtime: Runtime.Runtime<
        [Variant.VersionedVariant<V1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux>>]
      >,
      scope: Scope.CloseableScope,
    ) {
      super(runtime, scope);
      this.state = this.rawState.pipe(
        rx.map(
          ShieldedWalletState.mapState<TSerialized, TTransaction>(
            CustomShieldedWalletImplementation.allVariantsRecord()[V1Tag].variant,
          ),
        ),
        rx.shareReplay({ refCount: true, bufferSize: 1 }),
      );
    }

    start(secretKeys: TStartAux): Promise<void> {
      return this.runtime.dispatch({ [V1Tag]: (v1) => v1.startSyncInBackground(secretKeys) }).pipe(Effect.runPromise);
    }

    balanceTransaction(
      secretKeys: ledger.ZswapSecretKeys,
      tx: ledger.Transaction<ledger.Signaturish, ledger.Proofish, ledger.Bindingish>,
    ): Promise<ProvingRecipe<TTransaction>> {
      return this.runtime
        .dispatch({
          [V1Tag]: (v1) => v1.balanceTransaction(secretKeys, tx),
        })
        .pipe(Effect.runPromise);
    }

    transferTransaction(
      secretKeys: ledger.ZswapSecretKeys,
      outputs: readonly TokenTransfer[],
    ): Promise<ProvingRecipe<TTransaction>> {
      return this.runtime
        .dispatch({
          [V1Tag]: (v1) => v1.transferTransaction(secretKeys, outputs),
        })
        .pipe(Effect.runPromise);
    }

    initSwap(
      secretKeys: ledger.ZswapSecretKeys,
      desiredInputs: Record<ledger.RawTokenType, bigint>,
      desiredOutputs: readonly TokenTransfer[],
    ): Promise<ProvingRecipe<TTransaction>> {
      return this.runtime
        .dispatch({ [V1Tag]: (v1) => v1.initSwap(secretKeys, desiredInputs, desiredOutputs) })
        .pipe(Effect.runPromise);
    }

    finalizeTransaction(recipe: ProvingRecipe<TTransaction>): Promise<TTransaction> {
      return this.runtime
        .dispatch({
          [V1Tag]: (v1) => v1.finalizeTransaction(recipe),
        })
        .pipe(Effect.runPromise);
    }

    submitTransaction: SubmitTransactionMethod<TTransaction> = ((
      tx: TTransaction,
      waitForStatus: 'Submitted' | 'InBlock' | 'Finalized' = 'InBlock',
    ) => {
      return this.runtime
        .dispatch({ [V1Tag]: (v1) => v1.submitTransaction(tx, waitForStatus) })
        .pipe(Effect.runPromise);
    }) as SubmitTransactionMethod<TTransaction>;

    waitForSyncedState(allowedGap: bigint = 0n): Promise<ShieldedWalletState<TSerialized, TTransaction>> {
      return rx.firstValueFrom(
        this.state.pipe(rx.filter((state) => state.state.progress.isCompleteWithin(allowedGap))),
      );
    }

    /**
     * Serializes the most recent state
     * It's preferable to use [[ShieldedWalletState.serialize]] instead, to know exactly, which state is serialized
     */
    serializeState(): Promise<TSerialized> {
      return rx.firstValueFrom(this.state).then((state) => state.serialize());
    }

    getAddress(): Promise<ShieldedAddress> {
      return rx.firstValueFrom(this.state).then((state) => state.address);
    }
  };
}

================
File: packages/shielded-wallet/vitest.config.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/// <reference types="vitest" />
/// <reference types="vitest/globals" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    setupFiles: ['../../setup-env.ts'],
    environment: 'node',
    globals: true,
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage',
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }],
    ],
  },
});

================
File: packages/unshielded-wallet/src/v1/Simulator.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Array as Arr, Effect, Encoding, pipe, Scope, Stream, SubscriptionRef, Clock } from 'effect';
import { ArrayOps, EitherOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import * as crypto from 'crypto';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';

export type SimulatorState = Readonly<{
  ledger: ledger.LedgerState;
  lastTxResult: ledger.TransactionResult;
  lastTxNumber: bigint;
}>;

const simpleHash = (input: string): Effect.Effect<string> => {
  return Encoding.decodeHex(input).pipe(
    EitherOps.toEffect,
    Effect.andThen((parsed) => Effect.promise(() => crypto.subtle.digest('SHA-256', parsed))),
    Effect.andThen((out) => Encoding.encodeHex(new Uint8Array(out))),
    Effect.orDie,
  );
};

const wellFormedStrictness = (
  params: {
    enforceBalancing?: boolean;
    verifyNativeProofs?: boolean;
    verifyContractProofs?: boolean;
    enforceLimits?: boolean;
    verifySignatures?: boolean;
  } = {},
): ledger.WellFormedStrictness => {
  const strictness = new ledger.WellFormedStrictness();

  // Note: Enforce balancing should be true by default outside genesis mints
  strictness.enforceBalancing = params?.enforceBalancing ?? false;
  strictness.verifyNativeProofs = params?.verifyNativeProofs ?? false;
  strictness.verifyContractProofs = params?.verifyContractProofs ?? false;
  strictness.enforceLimits = params?.enforceLimits ?? false;
  strictness.verifySignatures = params?.verifySignatures ?? false;

  return strictness;
};

export class Simulator {
  static nextBlockContext = (number: bigint): Effect.Effect<ledger.BlockContext> =>
    pipe(
      number.toString(16),
      (str) => (str.length % 2 == 0 ? str : str.padStart(str.length + 1, '0')),
      simpleHash,
      Effect.map((hash) => ({
        parentBlockHash: hash,
        secondsSinceEpoch: number,
        secondsSinceEpochErr: 1,
      })),
    );

  static init(
    genesisMints: Readonly<
      Arr.NonEmptyArray<{ amount: bigint; type: ledger.RawTokenType; recipient: ledger.ZswapSecretKeys }>
    >,
  ): Effect.Effect<Simulator, never, Scope.Scope> {
    const emptyState = ledger.LedgerState.blank(NetworkId.NetworkId.Undeployed);
    const noStrictness = wellFormedStrictness();

    const makeTransactions = (context: ledger.BlockContext) =>
      Effect.gen(function* () {
        const nowMillis = yield* Clock.currentTimeMillis;
        const verificationTime = new Date(nowMillis);

        const tx = pipe(
          genesisMints,
          Arr.map((transfer) => {
            const coin = ledger.createShieldedCoinInfo(transfer.type, transfer.amount);
            const output = ledger.ZswapOutput.new(
              coin,
              0,
              transfer.recipient.coinPublicKey,
              transfer.recipient.encryptionPublicKey,
            );
            return ledger.ZswapOffer.fromOutput<ledger.PreProof>(output, transfer.type, transfer.amount);
          }),
          ArrayOps.fold((acc, offer) => acc.merge(offer)),
          (offer) => ledger.Transaction.fromParts(NetworkId.NetworkId.Undeployed, offer).eraseProofs(),
          (tx) => tx.wellFormed(emptyState, noStrictness, verificationTime),
        );

        const [initialState, initialResult] = emptyState.apply(tx, new ledger.TransactionContext(emptyState, context));
        const postBlockUpdateState = initialState.postBlockUpdate(verificationTime);

        return {
          initialResult,
          initialState: postBlockUpdateState,
          tx,
        } as const;
      });

    return Effect.gen(function* () {
      const context = yield* Simulator.nextBlockContext(0n);
      const init = yield* makeTransactions(context);
      const initialState = {
        ledger: init.initialState,
        lastTxResult: init.initialResult,
        lastTxNumber: 0n,
      };
      const ref = yield* SubscriptionRef.make<SimulatorState>(initialState);
      const changesStream = yield* Stream.share(ref.changes, {
        capacity: 'unbounded',
        replay: Number.MAX_SAFE_INTEGER,
      });
      yield* pipe(changesStream, Stream.runDrain, Effect.forkScoped);
      return new Simulator(ref, changesStream);
    });
  }

  readonly #stateRef: SubscriptionRef.SubscriptionRef<SimulatorState>;

  readonly state$: Stream.Stream<SimulatorState>;

  constructor(stateRef: SubscriptionRef.SubscriptionRef<SimulatorState>, state$: Stream.Stream<SimulatorState>) {
    this.#stateRef = stateRef;
    this.state$ = state$;
  }

  submitRegularTx(tx: ledger.ProofErasedTransaction): Effect.Effect<{ blockNumber: bigint; blockHash: string }> {
    return pipe(
      this.#stateRef,
      SubscriptionRef.modifyEffect((simulatorState) =>
        Effect.gen(function* () {
          const nextNumber = simulatorState.lastTxNumber + 1n;
          const context = yield* Simulator.nextBlockContext(nextNumber);
          const nowMillis = yield* Clock.currentTimeMillis;
          const verificationTime = new Date(nowMillis);

          const noStrictness = wellFormedStrictness();
          const verifiedTx = tx.wellFormed(simulatorState.ledger, noStrictness, verificationTime);

          const [newState, result] = simulatorState.ledger.apply(
            verifiedTx,
            new ledger.TransactionContext(simulatorState.ledger, context),
          );

          const postBlockUpdatedState = newState.postBlockUpdate(verificationTime);

          const newSimulatorState = {
            ...simulatorState,
            ledger: postBlockUpdatedState,
            lastTxResult: result,
            lastTxNumber: nextNumber,
          };

          const output = {
            blockNumber: nextNumber,
            blockHash: context.parentBlockHash,
          };

          return [output, newSimulatorState];
        }),
      ),
    );
  }
}

================
File: packages/unshielded-wallet/src/v1/SyncProgress.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export interface SyncProgressData {
  readonly appliedId: bigint;
  readonly highestTransactionId: bigint;
  readonly isConnected: boolean;
}

export interface SyncProgressOps {
  isCompleteWithin(data: SyncProgressData, maxGap?: bigint): boolean;
}

export interface SyncProgress extends SyncProgressData {
  isStrictlyComplete(): boolean;
  isCompleteWithin(maxGap?: bigint): boolean;
}

export const SyncProgress: SyncProgressOps = {
  isCompleteWithin(data: SyncProgressData, maxGap: bigint = 50n): boolean {
    const applyLag = BigInt(Math.abs(Number(data.highestTransactionId - data.appliedId)));
    return data.isConnected && applyLag <= maxGap;
  },
};

export const createSyncProgress = (
  params: {
    appliedId?: bigint;
    highestTransactionId?: bigint;
    isConnected?: boolean;
  } = {},
): SyncProgress => {
  const { appliedId = 0n, highestTransactionId = 0n, isConnected = false } = params;

  const data: SyncProgressData = {
    appliedId,
    highestTransactionId,
    isConnected,
  };

  return {
    ...data,

    isStrictlyComplete(): boolean {
      return SyncProgress.isCompleteWithin(this, 0n);
    },

    isCompleteWithin(maxGap?: bigint): boolean {
      return SyncProgress.isCompleteWithin(this, maxGap);
    },
  };
};

================
File: packages/unshielded-wallet/vitest.config.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/// <reference types="vitest" />
/// <reference types="vitest/globals" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    setupFiles: ['../../setup-env.ts'],
    environment: 'node',
    globals: true,
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage',
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }],
    ],
  },
});

================
File: packages/utilities/package.json
================
{
  "name": "@midnight-ntwrk/wallet-sdk-utilities",
  "description": "Domain-agnostic utilities for the wallet SDK - common operations and types",
  "version": "1.0.0-beta.7",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "author": "Midnight Foundation",
  "license": "Apache-2.0",
  "publishConfig": {
    "registry": "https://npm.pkg.github.com/"
  },
  "files": [
    "dist/"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/midnight-ntwrk/artifacts.git"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    },
    "./networking": {
      "types": "./dist/networking/index.d.ts",
      "import": "./dist/networking/index.js"
    },
    "./types": {
      "types": "./dist/types.d.ts",
      "import": "./dist/types.js"
    },
    "./testing": {
      "types": "./dist/testing/index.d.ts",
      "import": "./dist/testing/index.js"
    }
  },
  "dependencies": {
    "effect": "^3.17.3",
    "portfinder": "^1.0.37",
    "rxjs": "^7.5",
    "testcontainers": "^11.8.1"
  },
  "scripts": {
    "typecheck": "tsc -b ./tsconfig.json --noEmit",
    "test": "vitest run",
    "lint": "eslint --max-warnings 0",
    "format": "prettier --write \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format:check": "prettier --check \"**/*.{ts,js,json,yaml,yml,md}\"",
    "dist": "tsc -b ./tsconfig.build.json",
    "dist:publish": "tsc -b ./tsconfig.publish.json",
    "clean": "rimraf --glob dist 'tsconfig.*.tsbuildinfo' && date +%s > .clean-timestamp",
    "publint": "publint --strict"
  },
  "devDependencies": {
    "eslint": "^9.37.0",
    "fast-check": "^4.2.0",
    "publint": "~0.3.14",
    "rimraf": "^6.0.1",
    "typescript": "^5.9.3",
    "vitest": "^3.2.4"
  }
}

================
File: packages/wallet-integration-tests/test/serializationAndRestoration.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ShieldedWallet, ShieldedWalletClass, ShieldedWalletState } from '@midnight-ntwrk/wallet-sdk-shielded';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { DefaultV1Configuration } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import { randomUUID } from 'node:crypto';
import os from 'node:os';
import { buildTestEnvironmentVariables, getComposeDirectory } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import { DockerComposeEnvironment, StartedDockerComposeEnvironment } from 'testcontainers';
import { afterAll, beforeAll, beforeEach, describe, expect, it, vi } from 'vitest';
import { getShieldedSeed } from './utils.js';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';

vi.setConfig({ testTimeout: 120_000, hookTimeout: 120_000 });

const environmentId = randomUUID();

const environmentVars = buildTestEnvironmentVariables(['APP_INFRA_SECRET'], {
  additionalVars: {
    TESTCONTAINERS_UID: environmentId,
    RAYON_NUM_THREADS: Math.min(os.availableParallelism(), 32).toString(10),
  },
});

const environment = new DockerComposeEnvironment(getComposeDirectory(), 'docker-compose-dynamic.yml').withEnvironment(
  environmentVars,
);

describe('Wallet serialization and restoration', () => {
  let startedEnvironment: StartedDockerComposeEnvironment;
  let configuration: DefaultV1Configuration;

  beforeAll(async () => {
    startedEnvironment = await environment.up();

    configuration = {
      indexerClientConnection: {
        indexerHttpUrl: `http://localhost:${startedEnvironment.getContainer(`indexer_${environmentId}`).getMappedPort(8088)}/api/v3/graphql`,
      },
      provingServerUrl: new URL(
        `http://localhost:${startedEnvironment.getContainer(`proof-server_${environmentId}`).getMappedPort(6300)}`,
      ),
      relayURL: new URL(
        `ws://127.0.0.1:${startedEnvironment.getContainer(`node_${environmentId}`).getMappedPort(9944)}`,
      ),
      networkId: NetworkId.NetworkId.Undeployed,
    };
  });

  afterAll(async () => {
    await startedEnvironment?.down({ timeout: 10_000 });
  });

  let Wallet: ShieldedWalletClass;
  beforeEach(() => {
    Wallet = ShieldedWallet(configuration);
  });

  it('allows to restore an non-empty wallet from the serialized state', async () => {
    const seed = getShieldedSeed('0000000000000000000000000000000000000000000000000000000000000002');
    const wallet = Wallet.startWithShieldedSeed(seed);
    await wallet.start(ledger.ZswapSecretKeys.fromSeed(seed));
    try {
      const syncedState: ShieldedWalletState = await wallet.waitForSyncedState();
      const originalBalances = syncedState.balances;

      const serializedState = await wallet.serializeState();
      const restored = Wallet.restore(serializedState);
      await restored.start(ledger.ZswapSecretKeys.fromSeed(seed));
      try {
        const state = await restored.waitForSyncedState();
        const restoredBalances = state.balances;

        expect(originalBalances).not.toEqual({});
        expect(restoredBalances).toEqual(originalBalances);
      } finally {
        await restored.stop();
      }
    } finally {
      await wallet.stop();
    }
  });

  it('allows to restore an empty wallet from the serialized state', async () => {
    const seed = getShieldedSeed('0000000000000000000000000000000000000000000000000000000000000009');
    const wallet = Wallet.startWithShieldedSeed(seed);
    await wallet.start(ledger.ZswapSecretKeys.fromSeed(seed));
    try {
      const syncedState: ShieldedWalletState = await wallet.waitForSyncedState();
      const originalBalances = syncedState.balances;

      const serializedState = await wallet.serializeState();
      const restored = Wallet.restore(serializedState);
      await restored.start(ledger.ZswapSecretKeys.fromSeed(seed));
      try {
        const state = await restored.waitForSyncedState();
        const restoredBalances = state.balances;

        expect(originalBalances).toEqual({});
        expect(restoredBalances).toEqual(originalBalances);
      } finally {
        await restored.stop();
      }
    } finally {
      await wallet.stop();
    }
  });
});

================
File: packages/wallet-integration-tests/test/transacting.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { NetworkId, ProtocolState, ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import {
  ShieldedAddress,
  ShieldedCoinPublicKey,
  ShieldedEncryptionPublicKey,
} from '@midnight-ntwrk/wallet-sdk-address-format';
import { WalletBuilder } from '@midnight-ntwrk/wallet-sdk-runtime';
import { Variant, WalletLike } from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
import {
  CoinsAndBalances,
  DefaultRunningV1,
  DefaultV1Configuration,
  DefaultV1Variant,
  Keys,
  V1Builder,
  CoreWallet,
  V1Tag,
  Transacting,
} from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Effect, pipe } from 'effect';
import * as fc from 'fast-check';
import { randomUUID } from 'node:crypto';
import os from 'node:os';
import prand from 'pure-rand';
import { buildTestEnvironmentVariables, getComposeDirectory } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import * as rx from 'rxjs';
import { DockerComposeEnvironment, StartedDockerComposeEnvironment } from 'testcontainers';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { outputsArbitrary, recipientArbitrary, swapParamsArbitrary } from '../src/arbitraries.js';
import { getShieldedSeed } from './utils.js';

type TokenTransfer = Transacting.TokenTransfer;

vi.setConfig({ testTimeout: 180_000, hookTimeout: 60_000 });

const random = new fc.Random(prand.xoroshiro128plus(Date.now() ^ (Math.random() * 0x100000000)));
const sampleValue = <T>(arbitrary: fc.Arbitrary<T>): T => {
  return arbitrary.generate(random, undefined).value;
};

const shieldedTokenType = (ledger.shieldedToken() as { tag: 'shielded'; raw: string }).raw;

/**
 * These tests need to be fairly high-level to examine interfaces and observable behaviors given already built wallet.
 * For that reason - they mostly examine happy-path or well-known failure handling scenarios
 * It's the job of unit tests in various setups to perform quick and exhaustive testing
 *
 * NOTE: Shielded wallet cannot transact on its own anymore, so these tests are skipped for now
 */
describe.skip('Wallet transacting', () => {
  let startedEnvironment: StartedDockerComposeEnvironment;
  let configuration: DefaultV1Configuration;

  beforeEach(async () => {
    const environmentId = randomUUID();

    const environmentVars = buildTestEnvironmentVariables(['APP_INFRA_SECRET'], {
      additionalVars: {
        TESTCONTAINERS_UID: environmentId,
        RAYON_NUM_THREADS: Math.min(os.availableParallelism(), 32).toString(10),
      },
    });

    const environment = new DockerComposeEnvironment(
      getComposeDirectory(),
      'docker-compose-dynamic.yml',
    ).withEnvironment(environmentVars);

    startedEnvironment = await environment.up();

    configuration = {
      indexerClientConnection: {
        indexerHttpUrl: `http://localhost:${startedEnvironment.getContainer(`indexer_${environmentId}`).getMappedPort(8088)}/api/v3/graphql`,
      },
      provingServerUrl: new URL(
        `http://localhost:${startedEnvironment.getContainer(`proof-server_${environmentId}`).getMappedPort(6300)}`,
      ),
      relayURL: new URL(
        `ws://127.0.0.1:${startedEnvironment.getContainer(`node_${environmentId}`).getMappedPort(9944)}`,
      ),
      networkId: NetworkId.NetworkId.Undeployed,
    };
  });

  afterEach(async () => {
    await startedEnvironment?.down();
  });

  let Wallet: WalletLike.BaseWalletClass<[Variant.VersionedVariant<DefaultV1Variant>], DefaultV1Configuration>;
  type Wallet = WalletLike.WalletOf<typeof Wallet>;
  let walletKeys: ledger.ZswapSecretKeys;
  let wallet2Keys: ledger.ZswapSecretKeys;
  let wallet: Wallet;
  let wallet2: Wallet;
  let coinsAndBalances: CoinsAndBalances.CoinsAndBalancesCapability<CoreWallet>;
  let keys: Keys.KeysCapability<CoreWallet>;

  const getShieldedAddress = (state: CoreWallet | ledger.ZswapSecretKeys): string => {
    const address =
      state instanceof ledger.ZswapSecretKeys
        ? new ShieldedAddress(
            ShieldedCoinPublicKey.fromHexString(state.coinPublicKey),
            ShieldedEncryptionPublicKey.fromHexString(state.encryptionPublicKey),
          )
        : keys!.getAddress(state);

    return ShieldedAddress.codec.encode(Wallet.configuration.networkId, address).asString();
  };

  const waitForSync = (wallet: Wallet): Promise<CoreWallet> => {
    return pipe(
      wallet.rawState,
      rx.map(ProtocolState.state),
      rx.skip(1),
      rx.filter((state: CoreWallet) => state.progress.isStrictlyComplete() && state.state.coins.size > 0),
      (a) => rx.firstValueFrom(a),
    );
  };

  const getCoinsAndBalances = (state: CoreWallet) => {
    return {
      coins: coinsAndBalances.getAvailableCoins(state),
      balances: coinsAndBalances.getAvailableBalances(state),
    };
  };

  const getBalanceChange = (
    before: { balances: CoinsAndBalances.Balances },
    after: { balances: CoinsAndBalances.Balances },
    tokenType: ledger.RawTokenType,
  ): bigint => {
    const balanceBefore = before.balances[tokenType] ?? 0n;
    const balanceAfter = after.balances[tokenType] ?? 0n;
    return balanceAfter - balanceBefore;
  };

  beforeEach(async () => {
    Wallet = WalletBuilder.init()
      .withVariant(ProtocolVersion.MinSupportedVersion, new V1Builder().withDefaults())
      .build(configuration);
    coinsAndBalances = Wallet.allVariantsRecord()[V1Tag].variant.coinsAndBalances;
    keys = Wallet.allVariantsRecord()[V1Tag].variant.keys;
    walletKeys = ledger.ZswapSecretKeys.fromSeed(
      getShieldedSeed('0000000000000000000000000000000000000000000000000000000000000001'),
    );
    wallet = Wallet.startFirst(Wallet, CoreWallet.initEmpty(walletKeys, Wallet.configuration.networkId));
    wallet2Keys = ledger.ZswapSecretKeys.fromSeed(
      getShieldedSeed('0000000000000000000000000000000000000000000000000000000000000002'),
    );
    wallet2 = Wallet.startFirst(Wallet, CoreWallet.initEmpty(wallet2Keys, Wallet.configuration.networkId));

    await wallet.runtime.dispatch({ [V1Tag]: (v1) => v1.startSyncInBackground(walletKeys) }).pipe(Effect.runPromise);
    await wallet2.runtime.dispatch({ [V1Tag]: (v1) => v1.startSyncInBackground(wallet2Keys) }).pipe(Effect.runPromise);
  });

  afterEach(async () => {
    if (wallet != null) {
      await wallet.stop();
    }

    if (wallet2 != null) {
      await wallet2.stop();
    }
  });

  it('should create & submit successful transfers transactions', async () => {
    const syncedState: CoreWallet = await pipe(
      wallet.rawState,
      rx.map(ProtocolState.state),
      rx.skip(1),
      rx.filter((state: CoreWallet) => state.progress.isStrictlyComplete() && state.state.coins.size > 0),
      (a) => rx.firstValueFrom(a),
    );

    const balances: Record<string, bigint> = coinsAndBalances.getAvailableBalances(syncedState);

    const rawOutputs = sampleValue(outputsArbitrary(balances, recipientArbitrary));
    const usedTokenTypes = new Set(rawOutputs.map((o) => o.type));

    const result = await wallet.runtime
      .dispatch({
        [V1Tag]: (v1: DefaultRunningV1) => {
          const transferOutputs = rawOutputs.map(({ amount, type, receiverAddress }): TokenTransfer => {
            return {
              amount,
              type,
              receiverAddress: getShieldedAddress(receiverAddress),
            };
          });
          return v1.transferTransaction(walletKeys, transferOutputs).pipe(
            Effect.flatMap((recipe) => v1.finalizeTransaction(recipe)),
            Effect.flatMap((tx) =>
              Effect.all({
                transaction: Effect.succeed(tx),
                submissionResult: v1.submitTransaction(tx, 'Finalized'),
              }),
            ),
          );
        },
      })
      .pipe(Effect.runPromise);

    const transaction = result.transaction;
    expect(transaction.guaranteedOffer!.outputs.length).toBeGreaterThanOrEqual(rawOutputs.length);
    usedTokenTypes.forEach((tokenType) => {
      const delta = transaction.guaranteedOffer!.deltas.get(tokenType);
      expect(delta == undefined || delta >= 0n).toBe(true);
    });
    // rawOutputs.forEach((rawOutput) => {
    //   const appliedState = new ledger.ZswapLocalState().applyTx(rawOutput.receiverAddress, transaction, 'success');
    //   expect(Array.from(appliedState.coins)).toMatchObject([{ value: rawOutput.amount, type: rawOutput.type }]);
    // });
    expect(result.submissionResult._tag).toBe('Finalized');
  });

  it('should create and submit a transfer, which is properly received', async () => {
    await rx.firstValueFrom(
      wallet.rawState.pipe(
        rx.map(ProtocolState.state),
        rx.skip(1),
        rx.filter((state: CoreWallet) => state.state.coins.size > 0),
      ),
    );
    const receiverState = await pipe(wallet2.rawState, rx.map(ProtocolState.state), (s) => rx.firstValueFrom(s));

    await wallet.runtime
      .dispatch({
        [V1Tag]: (v1) =>
          v1
            .transferTransaction(walletKeys, [
              {
                type: (ledger.shieldedToken() as { tag: 'shielded'; raw: string }).raw,
                amount: 42n,
                receiverAddress: getShieldedAddress(receiverState),
              },
            ])
            .pipe(
              Effect.flatMap((recipe) => v1.finalizeTransaction(recipe)),
              Effect.flatMap((tx) => v1.submitTransaction(tx, 'Finalized')),
            ),
      })
      .pipe(Effect.runPromise);

    const finalBalance = await pipe(
      wallet2.rawState,
      rx.skip(1),
      rx.map(ProtocolState.state),
      rx.filter((state) => state.progress.isStrictlyComplete()),
      rx.map((state) => coinsAndBalances.getAvailableBalances(state)[shieldedTokenType]),
      (a) => rx.firstValueFrom(a),
    );

    expect(finalBalance).toEqual(25000000000000000n + 42n); //initial balance + transferred 42
  });

  it('should init a swap, which could be successfully balanced with other wallet and submitted', async () => {
    const syncedState1: CoreWallet = await waitForSync(wallet);
    const syncedState2 = await waitForSync(wallet2);
    const balances = coinsAndBalances.getAvailableBalances(syncedState1);

    const swapParams = sampleValue(swapParamsArbitrary(balances, getShieldedAddress(syncedState1)));

    const finalTx = await wallet.runtime
      .dispatch({
        [V1Tag]: (v1) =>
          pipe(
            v1.initSwap(walletKeys, swapParams.inputs, swapParams.outputs),
            Effect.andThen((recipe) => v1.finalizeTransaction(recipe)),
          ),
      })
      .pipe(
        Effect.andThen((tx) => {
          return wallet2.runtime.dispatch({
            [V1Tag]: (v1) =>
              pipe(
                v1.balanceTransaction(wallet2Keys, tx),
                Effect.andThen((recipe) => v1.finalizeTransaction(recipe)),
                Effect.tap((tx) => v1.submitTransaction(tx, 'Finalized')),
              ),
          });
        }),
        Effect.runPromise,
      );

    // This is a bit of an overestimation, but given various decisions that can be made in the balancing process,
    // it's a good enough range to test against
    // adding overhead for each output because balancing won't create a change output if it does not make sense
    const stateAfter1 = await waitForSync(wallet);
    const stateAfter2 = await waitForSync(wallet2);

    const cABefore1 = getCoinsAndBalances(syncedState1);
    const cABefore2 = getCoinsAndBalances(syncedState2);
    const cAAfter1 = getCoinsAndBalances(stateAfter1);
    const cAAfter2 = getCoinsAndBalances(stateAfter2);

    Object.entries(swapParams.inputs).forEach(([type, value]) => {
      const change1 = getBalanceChange(cABefore1, cAAfter1, type);
      const change2 = getBalanceChange(cABefore2, cAAfter2, type);

      expect(change1).toEqual(value * -1n);
      expect(change2).toEqual(value);
    });

    swapParams.outputs.forEach((output) => {
      const change1 = getBalanceChange(cABefore1, cAAfter1, output.type);
      const change2 = getBalanceChange(cABefore2, cAAfter2, output.type);

      expect(change1).toEqual(output.amount);
      expect(change2).toEqual(output.amount * -1n);
    });

    expect(finalTx.guaranteedOffer!.deltas.get(shieldedTokenType)).toBeUndefined();
  });
});

================
File: packages/wallet-integration-tests/test/walletSync.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { WalletBuilder } from '@midnight-ntwrk/wallet-sdk-runtime';
import { NetworkId, ProtocolState, ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Variant, WalletLike } from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
import { afterAll, afterEach, beforeAll, beforeEach, describe, expect, it, vi } from 'vitest';
import {
  DefaultV1Configuration,
  DefaultV1Variant,
  V1Builder,
  CoreWallet,
  V1Tag,
} from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import { randomUUID } from 'node:crypto';
import { buildTestEnvironmentVariables, getComposeDirectory } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import * as rx from 'rxjs';
import { DockerComposeEnvironment, StartedDockerComposeEnvironment } from 'testcontainers';

import os from 'node:os';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Effect, pipe } from 'effect';
import { getShieldedSeed } from './utils.js';

vi.setConfig({ testTimeout: 600_000, hookTimeout: 120_000 });

const environmentId = randomUUID();

const environmentVars = buildTestEnvironmentVariables(['APP_INFRA_SECRET'], {
  additionalVars: {
    TESTCONTAINERS_UID: environmentId,
    RAYON_NUM_THREADS: Math.min(os.availableParallelism(), 32).toString(10),
  },
});

const environment = new DockerComposeEnvironment(getComposeDirectory(), 'docker-compose-dynamic.yml').withEnvironment(
  environmentVars,
);

describe('Wallet Sync', () => {
  let startedEnvironment: StartedDockerComposeEnvironment;
  let configuration: DefaultV1Configuration;

  beforeAll(async () => {
    startedEnvironment = await environment.up();

    configuration = {
      indexerClientConnection: {
        indexerHttpUrl: `http://localhost:${startedEnvironment.getContainer(`indexer_${environmentId}`).getMappedPort(8088)}/api/v3/graphql`,
      },
      provingServerUrl: new URL(
        `http://localhost:${startedEnvironment.getContainer(`proof-server_${environmentId}`).getMappedPort(6300)}`,
      ),
      relayURL: new URL(
        `ws://127.0.0.1:${startedEnvironment.getContainer(`node_${environmentId}`).getMappedPort(9944)}`,
      ),
      networkId: NetworkId.NetworkId.Undeployed,
    };
  });

  afterAll(async () => {
    await startedEnvironment?.down({ timeout: 10_000 });
  });

  let Wallet: WalletLike.BaseWalletClass<[Variant.VersionedVariant<DefaultV1Variant>]>;
  let wallet: WalletLike.WalletLike<[Variant.VersionedVariant<DefaultV1Variant>]>;
  type Wallet = WalletLike.WalletOf<typeof Wallet>;

  const waitForSync = (wallet: Wallet): Promise<CoreWallet> => {
    return pipe(
      wallet.rawState,
      rx.map(ProtocolState.state),
      rx.skip(1),
      rx.filter((state: CoreWallet) => state.progress.isStrictlyComplete() && state.state.coins.size > 0),
      (a) => rx.firstValueFrom(a),
    );
  };

  beforeEach(async () => {
    Wallet = WalletBuilder.init()
      .withVariant(ProtocolVersion.MinSupportedVersion, new V1Builder().withDefaults())
      .build(configuration);
    const walletKeys = ledger.ZswapSecretKeys.fromSeed(
      getShieldedSeed('0000000000000000000000000000000000000000000000000000000000000001'),
    );
    wallet = Wallet.startEmpty(Wallet);
    await wallet.runtime.dispatch({ [V1Tag]: (v1) => v1.startSyncInBackground(walletKeys) }).pipe(Effect.runPromise);
  });

  afterEach(async () => {
    if (wallet != null) {
      await wallet.stop();
    }
  });

  it('should resync an empty wallet', async () => {
    const syncedState = await waitForSync(wallet);

    const coinsAndBalancesCapability = Wallet.allVariantsRecord()[V1Tag].variant.coinsAndBalances;
    const balances = coinsAndBalancesCapability.getTotalBalances(syncedState);

    expect(balances).toStrictEqual({
      '0000000000000000000000000000000000000000000000000000000000000000': 2500000000000000n,
      '0000000000000000000000000000000000000000000000000000000000000001': 500000000000000n,
      '0000000000000000000000000000000000000000000000000000000000000002': 500000000000000n,
    });
  });
});

================
File: packages/wallet-integration-tests/.prettierignore
================
dist/
coverage/
reports/

================
File: packages/wallet-integration-tests/vitest.config.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/// <reference types="vitest" />
/// <reference types="vitest/globals" />
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    setupFiles: ['../../setup-env.ts'],
    environment: 'node',
    globals: true,
    include: ['test/*.test.ts'],
    exclude: ['node_modules', 'dist'],
    coverage: {
      provider: 'v8',
      enabled: true,
      clean: true,
      include: ['src/**/*.ts'],
      exclude: ['**/test/**'],
      reporter: ['clover', 'json', 'json-summary', 'lcov', 'text'],
      reportsDirectory: './coverage',
    },
    reporters: [
      'default',
      ['junit', { outputFile: `reports/report/test-report.xml` }],
      ['html', { outputFile: `reports/report/test-report.html` }],
    ],
  },
});

================
File: .gitignore
================
# Yarn
.pnp.*
**/.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions
node_modules
**/report.xml
.metals

# sbt
target
dist
wallet-engine/release

# Others
.DS_Store
*.log
result
.bsp/
.idea/
.nix/
.env
.direnv/
.vscode/*
!.vscode/.checkmarxIgnored
!.vscode/settings.json
!.vscode/extensions.json
.bloop/
metals.sbt
tmp

archive_info.txt
libmidnight_zswap_c_bindings_v*.*


# Build
*.tsbuildinfo
*.local
coverage
.turbo
packages/*/*.tgz
.rollup.cache/
packages/src/**/*.d.ts*
.clean-timestamp

# reports
reports
**/allure-results/*
!**/allure-results/categories.json

# user files
**/.sync_cache
/packages/e2e-tests/res

================
File: infra/compose/docker-compose.yml
================
services:
  indexer:
    image: 'ghcr.io/midnight-ntwrk/indexer-standalone:3.0.0-alpha.15'
    container_name: indexer_$TESTCONTAINERS_UID
    cap_drop:
      - ALL
    security_opt:
      - no-new-privileges:true
    ports:
      - '127.0.0.1::8088'
    environment:
      RUST_LOG: 'indexer=debug,chain_indexer=debug,indexer_api=debug,wallet_indexer=debug,indexer_common=debug,fastrace_opentelemetry=off,info'
      APP__INFRA__NODE__URL: 'ws://node:9944'
      APP__INFRA__SECRET: '${APP_INFRA_SECRET}'

    healthcheck:
      test: ['CMD-SHELL', 'cat /var/run/indexer-standalone/running']
      interval: 60s
      timeout: 5s
      retries: 3
      start_period: 60s
    depends_on:
      node:
        condition: service_healthy
  node:
    image: 'ghcr.io/midnight-ntwrk/midnight-node:0.18.0-rc.7'
    container_name: node_$TESTCONTAINERS_UID
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - DAC_OVERRIDE
      - FOWNER
    security_opt:
      - no-new-privileges:true
    volumes:
      - node-data:/data
    ports:
      - '127.0.0.1::9944'
    healthcheck:
      test: ['CMD', 'curl', '-f', 'http://localhost:9944/health']
      interval: 2s
      timeout: 5s
      retries: 5
      start_period: 5s
    environment:
      CFG_PRESET: 'dev'
      SIDECHAIN_BLOCK_BENEFICIARY: '04bcf7ad3be7a5c790460be82a713af570f22e0f801f6659ab8e84a52be6969e'

volumes:
  node-data:

================
File: packages/address-format/CHANGELOG.md
================
# @midnight-ntwrk/wallet-sdk-address-format

## 3.0.0-beta.9

### Patch Changes

- 3f14055: chore: bump ledger to version 6.1.0-alpha.6

## 3.0.0-beta.8

### Patch Changes

- fb55d52: Introduce more convenient API for Bech32m address encoding/decoding Remove network id from Dust wallet
  initialization methods (so they are read from the configuration) Introduce FacadeState and add a getter to check for
  sync status of whole facade wallet Introduce CompositeDerivation for HD wallet, so that it is possible to derive keys
  for multiple roles at once

## 3.0.0-beta.7

### Patch Changes

- 1db4280: chore: bump ledger to version 6.1.0-beta.5

## 3.0.0-beta.6

### Patch Changes

- 2a0d132: chore: force re-release after workspace failure

## 3.0.0-beta.5

### Patch Changes

- ae22baf: chore: initialize baseline release after introducing Changesets

================
File: packages/capabilities/CHANGELOG.md
================
# @midnight-ntwrk/wallet-sdk-capabilities

## 3.0.0-beta.9

### Patch Changes

- 3f14055: chore: bump ledger to version 6.1.0-alpha.6
- Updated dependencies [3f14055]
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.9

## 3.0.0-beta.8

### Patch Changes

- Updated dependencies [fb55d52]
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-hd@3.0.0-beta.7

## 3.0.0-beta.7

### Patch Changes

- 1db4280: chore: bump ledger to version 6.1.0-beta.5
- Updated dependencies [1db4280]
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.7

## 3.0.0-beta.6

### Patch Changes

- 2a0d132: chore: force re-release after workspace failure
- Updated dependencies [2a0d132]
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-hd@3.0.0-beta.6

## 3.0.0-beta.5

### Patch Changes

- ae22baf: chore: initialize baseline release after introducing Changesets
- Updated dependencies [ae22baf]
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.5
  - @midnight-ntwrk/wallet-sdk-hd@3.0.0-beta.5

================
File: packages/docs-snippets/src/test/test-snippets.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as childProcess from 'node:child_process';
import { randomUUID } from 'node:crypto';
import * as fs from 'node:fs';
import * as os from 'node:os';
import * as path from 'node:path';
import { buildTestEnvironmentVariables, getComposeDirectory } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import { DockerComposeEnvironment, StartedDockerComposeEnvironment, Wait } from 'testcontainers';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

vi.setConfig({ testTimeout: 900_000, hookTimeout: 200_000 });

const NO_NET_SUFFIX = 'no-net';
const DEBUG_LOG_ENABLED = (process.env['DEBUG'] ?? '').includes('wallet:snippet');

const currentDir = path.dirname(new URL(import.meta.url).pathname);
const packageDir = path.resolve(currentDir, '..', '..');
const snippetsDir = path.resolve(currentDir, '..', 'snippets');

type Snippet = { name: string; path: string };
const snippetFiles = fs.readdirSync(snippetsDir).reduce(
  (acc, file) => {
    const resolvedPath = path.resolve(snippetsDir, file);
    const parsed = file.split('.');
    const target = parsed.includes(NO_NET_SUFFIX) ? acc.noNet : acc.net;
    target.push({ name: parsed[0], path: resolvedPath });
    return acc;
  },
  { net: [] as Snippet[], noNet: [] as Snippet[] },
);

class SnippetError extends Error {
  public readonly snippet: Snippet;
  public readonly result: childProcess.SpawnSyncReturns<string>;

  constructor(snippet: Snippet, result: childProcess.SpawnSyncReturns<string>) {
    super(
      `Snippet ${snippet.name} failed:
        status: ${result.status}
        stdout: ${result.stdout}
        stderr: ${result.stderr}
    `,
      { cause: result },
    );
    this.snippet = snippet;
    this.result = result;
  }
}

const runSnippet = async (
  snippet: Snippet,
  envExtension: Record<string, string> = {},
): Promise<readonly (string | null)[]> => {
  return new Promise((resolve, reject) => {
    const child = childProcess.spawn('node', ['--experimental-strip-types', '--no-warnings', snippet.path], {
      cwd: packageDir,
      env: {
        ...process.env,
        ...envExtension,
      },
    });

    let stdout = '';
    let stderr = '';

    // Log and capture stdout
    if (child.stdout) {
      child.stdout.setEncoding('utf8');
      child.stdout.on('data', (data: string) => {
        if (DEBUG_LOG_ENABLED) {
          console.log(data);
        }
        stdout += data;
      });
    }

    // Log and capture stderr
    if (child.stderr) {
      child.stderr.setEncoding('utf8');
      child.stderr.on('data', (data: string) => {
        console.error(data);
        stderr += data;
      });
    }

    child.on('close', (code: number | null) => {
      // Format output to match spawnSync's result.output format
      // result.output should be [null, stdout, stderr], but we only return stdout to avoid capturing debug information
      const output: readonly (string | null)[] = [stdout];

      if (code !== 0 && code !== null) {
        const result = {
          status: code,
          stdout,
          stderr,
          output,
        } as childProcess.SpawnSyncReturns<string>;
        reject(new SnippetError(snippet, result));
      } else {
        resolve(output);
      }
    });

    child.on('error', (error: Error) => {
      reject(error);
    });
  });
};

const testSnippet = async (snippet: Snippet, envExtension: Record<string, string> = {}) => {
  const result = await runSnippet(snippet, envExtension);
  expect(result).toMatchSnapshot();
};

describe('Snippet outputs', () => {
  describe('without network', () => {
    it.each(snippetFiles.noNet)('should output the correct result for $name', (snippet) => testSnippet(snippet));
  });

  describe('with network', () => {
    let startedEnvironment: StartedDockerComposeEnvironment;
    let envExtension: Record<string, string>;

    beforeEach(async () => {
      const environmentId = randomUUID();

      const environmentVars = buildTestEnvironmentVariables(['APP_INFRA_SECRET'], {
        additionalVars: {
          TESTCONTAINERS_UID: environmentId,
          RAYON_NUM_THREADS: Math.min(os.availableParallelism(), 32).toString(10),
        },
      });

      const environment = new DockerComposeEnvironment(getComposeDirectory(), 'docker-compose-dynamic.yml')
        .withWaitStrategy(`indexer_${environmentId}`, Wait.forLogMessage(/block indexed".*height":1,.*/gm))
        .withEnvironment(environmentVars)
        .withStartupTimeout(100_000);

      startedEnvironment = await environment.up();

      envExtension = {
        INDEXER_PORT: startedEnvironment.getContainer(`indexer_${environmentId}`).getMappedPort(8088).toString(),
        NODE_PORT: startedEnvironment.getContainer(`node_${environmentId}`).getMappedPort(9944).toString(),
        PROOF_SERVER_PORT: startedEnvironment
          .getContainer(`proof-server_${environmentId}`)
          .getMappedPort(6300)
          .toString(),
      };
    });

    afterEach(async () => {
      await startedEnvironment?.down({ timeout: 10_000 });
    });

    it.each(snippetFiles.net)('should output the correct result for $name', (snippet) =>
      testSnippet(snippet, envExtension),
    );
  });
});

================
File: packages/docs-snippets/src/utils.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import type { DefaultV1Configuration as DustConfiguration } from '@midnight-ntwrk/wallet-sdk-dust-wallet';
import { DustWallet } from '@midnight-ntwrk/wallet-sdk-dust-wallet';
import { WalletFacade } from '@midnight-ntwrk/wallet-sdk-facade';
import { HDWallet, Roles } from '@midnight-ntwrk/wallet-sdk-hd';
import { ShieldedWallet } from '@midnight-ntwrk/wallet-sdk-shielded';
import type { DefaultV1Configuration as ShieldedConfiguration } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import {
  createKeystore,
  InMemoryTransactionHistoryStorage,
  PublicKey as UnshieldedPublicKey,
  type UnshieldedKeystore,
  UnshieldedWallet,
} from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';
import { Buffer } from 'buffer';

const INDEXER_PORT = Number.parseInt(process.env['INDEXER_PORT'] ?? '8088', 10);
const NODE_PORT = Number.parseInt(process.env['NODE_PORT'] ?? '9944', 10);
const PROOF_SERVER_PORT = Number.parseInt(process.env['PROOF_SERVER_PORT'] ?? '6300', 10);
const INDEXER_HTTP_URL = `http://localhost:${INDEXER_PORT}/api/v3/graphql`;
const INDEXER_WS_URL = `ws://localhost:${INDEXER_PORT}/api/v3/graphql/ws`;

const configuration: ShieldedConfiguration & DustConfiguration & { indexerUrl: string } = {
  networkId: 'undeployed',
  costParameters: {
    additionalFeeOverhead: 300_000_000_000_000_000n,
    feeBlocksMargin: 5,
  },
  relayURL: new URL(`ws://localhost:${NODE_PORT}`),
  provingServerUrl: new URL(`http://localhost:${PROOF_SERVER_PORT}`),
  indexerClientConnection: {
    indexerHttpUrl: INDEXER_HTTP_URL,
    indexerWsUrl: INDEXER_WS_URL,
  },
  indexerUrl: INDEXER_WS_URL,
};

export const initWalletWithSeed = async (
  seed: Buffer,
): Promise<{
  wallet: WalletFacade;
  shieldedSecretKeys: ledger.ZswapSecretKeys;
  dustSecretKey: ledger.DustSecretKey;
  unshieldedKeystore: UnshieldedKeystore;
}> => {
  const hdWallet = HDWallet.fromSeed(seed);

  if (hdWallet.type !== 'seedOk') {
    throw new Error('Failed to initialize HDWallet');
  }

  const derivationResult = hdWallet.hdWallet
    .selectAccount(0)
    .selectRoles([Roles.Zswap, Roles.NightExternal, Roles.Dust])
    .deriveKeysAt(0);

  if (derivationResult.type !== 'keysDerived') {
    throw new Error('Failed to derive keys');
  }

  hdWallet.hdWallet.clear();

  const shieldedSecretKeys = ledger.ZswapSecretKeys.fromSeed(derivationResult.keys[Roles.Zswap]);
  const dustSecretKey = ledger.DustSecretKey.fromSeed(derivationResult.keys[Roles.Dust]);
  const unshieldedKeystore = createKeystore(derivationResult.keys[Roles.NightExternal], configuration.networkId);

  const shieldedWallet = ShieldedWallet(configuration).startWithSecretKeys(shieldedSecretKeys);
  const dustWallet = DustWallet(configuration).startWithSecretKey(
    dustSecretKey,
    ledger.LedgerParameters.initialParameters().dust,
  );
  const unshieldedWallet = UnshieldedWallet({
    ...configuration,
    txHistoryStorage: new InMemoryTransactionHistoryStorage(),
  }).startWithPublicKey(UnshieldedPublicKey.fromKeyStore(unshieldedKeystore));

  const facade: WalletFacade = new WalletFacade(shieldedWallet, unshieldedWallet, dustWallet);
  await facade.start(shieldedSecretKeys, dustSecretKey);
  return { wallet: facade, shieldedSecretKeys, dustSecretKey, unshieldedKeystore };
};

================
File: packages/docs-snippets/package.json
================
{
  "name": "@midnight-ntwrk/wallet-sdk-docs-snippets",
  "description": "Documentation snippets for the wallet SDK",
  "version": "1.0.0-beta.1",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "author": "Midnight Foundation",
  "private": true,
  "license": "Apache-2.0",
  "publishConfig": {
    "registry": "https://npm.pkg.github.com/"
  },
  "files": [
    "dist/"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/midnight-ntwrk/artifacts.git"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  },
  "dependencies": {
    "@midnight-ntwrk/wallet-sdk-address-format": "workspace:*",
    "@midnight-ntwrk/wallet-sdk-dust-wallet": "workspace:*",
    "@midnight-ntwrk/wallet-sdk-facade": "workspace:*",
    "@midnight-ntwrk/wallet-sdk-hd": "workspace:*",
    "@midnight-ntwrk/wallet-sdk-shielded": "workspace:*",
    "@midnight-ntwrk/wallet-sdk-unshielded-wallet": "workspace:*",
    "buffer": "^6.0.3",
    "lodash-es": "^4.17.21"
  },
  "scripts": {
    "typecheck": "tsc -b ./tsconfig.json --noEmit",
    "test": "vitest run",
    "lint": "eslint --max-warnings 0",
    "format": "prettier --write \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format:check": "prettier --check \"**/*.{ts,js,json,yaml,yml,md}\"",
    "clean": "rimraf --glob dist 'tsconfig.*.tsbuildinfo' && date +%s > .clean-timestamp"
  },
  "devDependencies": {
    "@types/lodash-es": "^4",
    "eslint": "^9.37.0",
    "fast-check": "^4.2.0",
    "publint": "~0.3.14",
    "rimraf": "^6.0.1",
    "testcontainers": "^11.7.2",
    "typescript": "^5.9.3",
    "vitest": "^3.2.4"
  }
}

================
File: packages/dust-wallet/src/RunningV1Variant.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, SubscriptionRef, Stream, pipe, Scope, Sink, Console, Duration, Schedule } from 'effect';
import {
  DustSecretKey,
  nativeToken,
  Signature,
  SignatureVerifyingKey,
  updatedValue,
  FinalizedTransaction,
  UnprovenTransaction,
} from '@midnight-ntwrk/ledger-v6';
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Proving, ProvingRecipe, WalletError } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import { EitherOps, LedgerOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import {
  WalletRuntimeError,
  Variant,
  StateChange,
  VersionChangeType,
} from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
import { DustToken, UtxoWithMeta } from './types/Dust.js';
import { KeysCapability } from './Keys.js';
import { SyncCapability, SyncService } from './Sync.js';
import { SimulatorState } from './Simulator.js';
import { CoinsAndBalancesCapability, CoinSelection } from './CoinsAndBalances.js';
import { TransactingCapability } from './Transacting.js';
import { SubmissionService, SubmitTransactionMethod } from './Submission.js';
import { DustCoreWallet } from './DustCoreWallet.js';
import { SerializationCapability } from './Serialization.js';
import { AnyTransaction } from './types/ledger.js';

const progress = (state: DustCoreWallet): StateChange.StateChange<DustCoreWallet>[] => {
  const appliedIndex = state.progress?.appliedIndex ?? 0n;
  const highestRelevantWalletIndex = state.progress?.highestRelevantWalletIndex ?? 0n;
  const highestIndex = state.progress?.highestIndex ?? 0n;
  const highestRelevantIndex = state.progress?.highestRelevantIndex ?? 0n;

  const sourceGap = highestIndex - highestRelevantIndex;
  const applyGap = highestRelevantWalletIndex - appliedIndex;

  return [StateChange.ProgressUpdate({ sourceGap, applyGap })];
};

const protocolVersionChange = (
  previous: DustCoreWallet,
  current: DustCoreWallet,
): StateChange.StateChange<DustCoreWallet>[] => {
  return previous.protocolVersion != current.protocolVersion
    ? [
        StateChange.VersionChange({
          change: VersionChangeType.Version({
            version: ProtocolVersion.ProtocolVersion(current.protocolVersion),
          }),
        }),
      ]
    : [];
};

export declare namespace RunningV1Variant {
  export type Context<TSerialized, TSyncUpdate, TTransaction, TStartAux> = {
    serializationCapability: SerializationCapability<DustCoreWallet, null, TSerialized>;
    syncService: SyncService<DustCoreWallet, TStartAux, TSyncUpdate>;
    syncCapability: SyncCapability<DustCoreWallet, TSyncUpdate>;
    transactingCapability: TransactingCapability<DustSecretKey, DustCoreWallet, TTransaction>;
    provingService: Proving.ProvingService<TTransaction>;
    coinsAndBalancesCapability: CoinsAndBalancesCapability<DustCoreWallet>;
    keysCapability: KeysCapability<DustCoreWallet>;
    submissionService: SubmissionService<TTransaction>;
    coinSelection: CoinSelection<DustToken>;
  };
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  export type AnyContext = Context<any, any, any, any>;
}

export const V1Tag: unique symbol = Symbol('V1');

export type DefaultRunningV1 = RunningV1Variant<string, SimulatorState, FinalizedTransaction, DustSecretKey>;

export class RunningV1Variant<TSerialized, TSyncUpdate, TTransaction, TStartAux> implements Variant.RunningVariant<
  typeof V1Tag,
  DustCoreWallet
> {
  __polyTag__: typeof V1Tag = V1Tag;
  readonly #scope: Scope.Scope;
  readonly #context: Variant.VariantContext<DustCoreWallet>;
  readonly #v1Context: RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction, TStartAux>;

  readonly state: Stream.Stream<StateChange.StateChange<DustCoreWallet>, WalletRuntimeError>;

  constructor(
    scope: Scope.Scope,
    context: Variant.VariantContext<DustCoreWallet>,
    v1Context: RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction, TStartAux>,
  ) {
    this.#scope = scope;
    this.#context = context;
    this.#v1Context = v1Context;
    this.state = Stream.fromEffect(context.stateRef.get).pipe(
      Stream.flatMap((initialState) =>
        context.stateRef.changes.pipe(
          Stream.mapAccum(initialState, (previous: DustCoreWallet, current: DustCoreWallet) => {
            return [current, [previous, current]] as const;
          }),
        ),
      ),
      Stream.mapConcat(
        ([previous, current]: readonly [DustCoreWallet, DustCoreWallet]): StateChange.StateChange<DustCoreWallet>[] => {
          // TODO: emit progress only upon actual change
          return [
            StateChange.State({ state: current }),
            ...progress(current),
            ...protocolVersionChange(previous, current),
          ];
        },
      ),
    );
  }

  startSyncInBackground(startAux: TStartAux): Effect.Effect<void> {
    return this.startSync(startAux).pipe(
      Stream.runScoped(Sink.drain),
      Effect.forkScoped,
      Effect.provideService(Scope.Scope, this.#scope),
    );
  }

  startSync(startAux: TStartAux): Stream.Stream<void, WalletError.WalletError, Scope.Scope> {
    return pipe(
      SubscriptionRef.get(this.#context.stateRef),
      Stream.fromEffect,
      Stream.flatMap((state) => this.#v1Context.syncService.updates(state, startAux)),
      Stream.mapEffect((update) => {
        return SubscriptionRef.updateEffect(this.#context.stateRef, (state) =>
          Effect.try({
            try: () => this.#v1Context.syncCapability.applyUpdate(state, update),
            catch: (err) =>
              new WalletError.OtherWalletError({
                message: 'Error while applying sync update',
                cause: err,
              }),
          }),
        );
      }),
      Stream.tapError((error) => Console.error(error)),
      Stream.retry(
        pipe(
          Schedule.exponential(Duration.seconds(1), 2),
          Schedule.map((delay) => {
            const maxDelay = Duration.minutes(2);
            const jitter = Duration.millis(Math.floor(Math.random() * 1000));
            const delayWithJitter = Duration.toMillis(delay) + Duration.toMillis(jitter);

            return Duration.millis(Math.min(delayWithJitter, Duration.toMillis(maxDelay)));
          }),
        ),
      ),
    );
  }

  createDustGenerationTransaction(
    currentTime: Date | undefined,
    ttl: Date,
    nightUtxos: ReadonlyArray<UtxoWithMeta>,
    nightVerifyingKey: SignatureVerifyingKey,
    dustReceiverAddress: string | undefined,
  ): Effect.Effect<UnprovenTransaction, WalletError.WalletError> {
    if (nightUtxos.some((utxo) => utxo.type !== nativeToken().raw)) {
      return Effect.fail(WalletError.WalletError.other('Token of a non-Night type received'));
    }
    return Effect.Do.pipe(
      Effect.bind('currentState', () => SubscriptionRef.get(this.#context.stateRef)),
      Effect.bind('blockData', () => this.#v1Context.syncService.blockData()),
      Effect.bind('utxosWithDustValue', ({ currentState, blockData }) =>
        LedgerOps.ledgerTry(() => {
          const dustPublicKey = this.#v1Context.keysCapability.getDustPublicKey(currentState);
          return nightUtxos.map((utxo) => {
            const genInfo = {
              value: utxo.value,
              owner: dustPublicKey,
              nonce: LedgerOps.randomNonce(),
              dtime: undefined,
            };
            const dustValue = updatedValue(
              utxo.ctime,
              0n,
              genInfo,
              currentTime ?? blockData.timestamp,
              currentState.state.params,
            );
            return { token: utxo, value: dustValue };
          });
        }),
      ),
      Effect.flatMap(({ utxosWithDustValue, blockData }) => {
        return this.#v1Context.transactingCapability
          .createDustGenerationTransaction(
            currentTime ?? blockData.timestamp,
            ttl,
            utxosWithDustValue,
            nightVerifyingKey,
            dustReceiverAddress,
          )
          .pipe(EitherOps.toEffect);
      }),
    );
  }

  addDustGenerationSignature(
    transaction: UnprovenTransaction,
    signature: Signature,
  ): Effect.Effect<ProvingRecipe.ProvingRecipe<FinalizedTransaction>, WalletError.WalletError> {
    return this.#v1Context.transactingCapability
      .addDustGenerationSignature(transaction, signature)
      .pipe(EitherOps.toEffect);
  }

  calculateFee(transaction: AnyTransaction): Effect.Effect<bigint, WalletError.WalletError> {
    return pipe(
      this.#v1Context.syncService.blockData(),
      Effect.map((blockData) =>
        this.#v1Context.transactingCapability.calculateFee(transaction, blockData.ledgerParameters),
      ),
    );
  }

  addFeePayment(
    secretKey: DustSecretKey,
    transaction: UnprovenTransaction,
    ttl: Date,
    currentTime?: Date,
  ): Effect.Effect<ProvingRecipe.ProvingRecipe<FinalizedTransaction>, WalletError.WalletError> {
    return SubscriptionRef.modifyEffect(this.#context.stateRef, (state) => {
      return pipe(
        this.#v1Context.syncService.blockData(),
        Effect.flatMap((blockData) =>
          this.#v1Context.transactingCapability.addFeePayment(
            secretKey,
            state,
            transaction,
            ttl,
            currentTime ?? blockData.timestamp,
            blockData.ledgerParameters,
          ),
        ),
        Effect.map(({ recipe, newState }) => [recipe, newState] as const),
      );
    });
  }

  finalizeTransaction(
    recipe: ProvingRecipe.ProvingRecipe<TTransaction>,
  ): Effect.Effect<TTransaction, WalletError.WalletError> {
    return this.#v1Context.provingService
      .prove(recipe)
      .pipe(
        Effect.tapError(() =>
          SubscriptionRef.updateEffect(this.#context.stateRef, (state) =>
            EitherOps.toEffect(this.#v1Context.transactingCapability.revertRecipe(state, recipe)),
          ),
        ),
      );
  }

  submitTransaction: SubmitTransactionMethod<TTransaction> = ((
    transaction: TTransaction,
    waitForStatus: 'Submitted' | 'InBlock' | 'Finalized' = 'InBlock',
  ) => {
    return this.#v1Context.submissionService
      .submitTransaction(transaction, waitForStatus)
      .pipe(
        Effect.tapError(() =>
          SubscriptionRef.updateEffect(this.#context.stateRef, (state) =>
            EitherOps.toEffect(this.#v1Context.transactingCapability.revert(state, transaction)),
          ),
        ),
      );
  }) as SubmitTransactionMethod<TTransaction>;
}

================
File: packages/dust-wallet/src/Transacting.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Either } from 'effect';
import {
  DustActions,
  DustPublicKey,
  DustRegistration,
  DustSecretKey,
  Intent,
  PreBinding,
  PreProof,
  Signature,
  SignatureEnabled,
  SignatureVerifyingKey,
  Transaction,
  UnshieldedOffer,
  Utxo,
  UtxoOutput,
  UtxoSpend,
  FinalizedTransaction,
  ProofErasedTransaction,
  UnprovenTransaction,
  addressFromKey,
  LedgerParameters,
} from '@midnight-ntwrk/ledger-v6';
import { MidnightBech32m, DustAddress } from '@midnight-ntwrk/wallet-sdk-address-format';
import { ProvingRecipe, WalletError } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import { LedgerOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import { DustCoreWallet } from './DustCoreWallet.js';
import { AnyTransaction, DustToken, NetworkId, TotalCostParameters, UnprovenDustSpend } from './types/index.js';
import { CoinsAndBalancesCapability, CoinSelection, CoinWithValue } from './CoinsAndBalances.js';
import { KeysCapability } from './Keys.js';
import { BindingMarker, ProofMarker, SignatureMarker } from './Utils.js';

export interface TransactingCapability<TSecrets, TState, TTransaction> {
  readonly networkId: NetworkId;
  readonly costParams: TotalCostParameters;
  createDustGenerationTransaction(
    currentTime: Date,
    ttl: Date,
    nightUtxos: ReadonlyArray<CoinWithValue<Utxo>>,
    nightVerifyingKey: SignatureVerifyingKey,
    dustReceiverAddress: string | undefined,
  ): Either.Either<UnprovenTransaction, WalletError.WalletError>;

  addDustGenerationSignature(
    transaction: UnprovenTransaction,
    signature: Signature,
  ): Either.Either<ProvingRecipe.ProvingRecipe<FinalizedTransaction>, WalletError.WalletError>;

  calculateFee(transaction: AnyTransaction, ledgerParams: LedgerParameters): bigint;

  addFeePayment(
    secretKey: TSecrets,
    state: TState,
    transaction: UnprovenTransaction,
    ttl: Date,
    currentTime: Date,
    ledgerParams: LedgerParameters,
  ): Either.Either<
    { recipe: ProvingRecipe.ProvingRecipe<FinalizedTransaction>; newState: TState },
    WalletError.WalletError
  >;

  revert(state: TState, tx: TTransaction): Either.Either<TState, WalletError.WalletError>;

  revertRecipe(
    state: TState,
    recipe: ProvingRecipe.ProvingRecipe<TTransaction>,
  ): Either.Either<TState, WalletError.WalletError>;
}

export type DefaultTransactingConfiguration = {
  networkId: NetworkId;
  costParameters: TotalCostParameters;
};

export type DefaultTransactingContext = {
  coinSelection: CoinSelection<DustToken>;
  coinsAndBalancesCapability: CoinsAndBalancesCapability<DustCoreWallet>;
  keysCapability: KeysCapability<DustCoreWallet>;
};

export const makeDefaultTransactingCapability = (
  config: DefaultTransactingConfiguration,
  getContext: () => DefaultTransactingContext,
): TransactingCapability<DustSecretKey, DustCoreWallet, FinalizedTransaction> => {
  return new TransactingCapabilityImplementation(
    config.networkId,
    config.costParameters,
    () => getContext().coinSelection,
    () => getContext().coinsAndBalancesCapability,
    () => getContext().keysCapability,
  );
};

export const makeSimulatorTransactingCapability = (
  config: DefaultTransactingConfiguration,
  getContext: () => DefaultTransactingContext,
): TransactingCapability<DustSecretKey, DustCoreWallet, ProofErasedTransaction> => {
  return new TransactingCapabilityImplementation(
    config.networkId,
    config.costParameters,
    () => getContext().coinSelection,
    () => getContext().coinsAndBalancesCapability,
    () => getContext().keysCapability,
  );
};

export class TransactingCapabilityImplementation<TTransaction extends AnyTransaction> implements TransactingCapability<
  DustSecretKey,
  DustCoreWallet,
  TTransaction
> {
  public readonly networkId: string;
  public readonly costParams: TotalCostParameters;
  public readonly getCoinSelection: () => CoinSelection<DustToken>;
  readonly getCoins: () => CoinsAndBalancesCapability<DustCoreWallet>;
  readonly getKeys: () => KeysCapability<DustCoreWallet>;

  constructor(
    networkId: NetworkId,
    costParams: TotalCostParameters,
    getCoinSelection: () => CoinSelection<DustToken>,
    getCoins: () => CoinsAndBalancesCapability<DustCoreWallet>,
    getKeys: () => KeysCapability<DustCoreWallet>,
  ) {
    this.getCoins = getCoins;
    this.networkId = networkId;
    this.costParams = costParams;
    this.getCoinSelection = getCoinSelection;
    this.getKeys = getKeys;
  }

  createDustGenerationTransaction(
    currentTime: Date,
    ttl: Date,
    nightUtxos: ReadonlyArray<CoinWithValue<Utxo>>,
    nightVerifyingKey: SignatureVerifyingKey,
    dustReceiverAddress: string | undefined,
  ): Either.Either<UnprovenTransaction, WalletError.WalletError> {
    return Either.gen(this, function* () {
      const receiver = dustReceiverAddress ? yield* this.#parseAddress(dustReceiverAddress) : undefined;

      return yield* LedgerOps.ledgerTry(() => {
        const network = this.networkId;
        const intent = Intent.new(ttl);
        const totalDustValue = nightUtxos.reduce((total, { value }) => total + value, 0n);
        const inputs: UtxoSpend[] = nightUtxos.map(({ token: utxo }) => ({
          ...utxo,
          owner: nightVerifyingKey,
        }));

        const outputs: UtxoOutput[] = inputs.map((input) => ({
          owner: addressFromKey(nightVerifyingKey),
          type: input.type,
          value: input.value,
        }));

        intent.guaranteedUnshieldedOffer = UnshieldedOffer.new(inputs, outputs, []);

        const dustRegistration: DustRegistration<SignatureEnabled> = new DustRegistration(
          SignatureMarker.signature,
          nightVerifyingKey,
          receiver,
          dustReceiverAddress !== undefined ? totalDustValue : 0n,
        );

        intent.dustActions = new DustActions<SignatureEnabled, PreProof>(
          SignatureMarker.signature,
          ProofMarker.preProof,
          currentTime,
          [],
          [dustRegistration],
        );

        return Transaction.fromParts(network, undefined, undefined, intent);
      });
    });
  }

  addDustGenerationSignature(
    transaction: UnprovenTransaction,
    signatureData: Signature,
  ): Either.Either<ProvingRecipe.ProvingRecipe<FinalizedTransaction>, WalletError.WalletError> {
    return Either.gen(this, function* () {
      const intent = transaction.intents?.get(1);
      if (!intent) {
        return yield* Either.left(
          new WalletError.TransactingError({ message: 'No intent found in the transaction intents with segment = 1' }),
        );
      }

      const { dustActions, guaranteedUnshieldedOffer } = intent;
      if (!dustActions) {
        return yield* Either.left(new WalletError.TransactingError({ message: 'No dustActions found in intent' }));
      }

      if (!guaranteedUnshieldedOffer) {
        return yield* Either.left(
          new WalletError.TransactingError({ message: 'No guaranteedUnshieldedOffer found in intent' }),
        );
      }

      const [registration, ...restRegistrations] = dustActions.registrations;
      if (!registration) {
        return yield* Either.left(
          new WalletError.TransactingError({ message: 'No registrations found in dustActions' }),
        );
      }

      return yield* LedgerOps.ledgerTry(() => {
        const signature = new SignatureEnabled(signatureData);
        const registrationWithSignature = new DustRegistration(
          signature.instance,
          registration.nightKey,
          registration.dustAddress,
          registration.allowFeePayment,
          signature,
        );
        const newDustActions = new DustActions(
          signature.instance,
          ProofMarker.preProof,
          dustActions.ctime,
          dustActions.spends,
          [registrationWithSignature, ...restRegistrations],
        );

        // make a copy of intent to avoid mutation
        const newIntent = Intent.deserialize<SignatureEnabled, PreProof, PreBinding>(
          signature.instance,
          ProofMarker.preProof,
          BindingMarker.preBinding,
          intent.serialize(),
        );
        newIntent.dustActions = newDustActions;

        const inputsLen = guaranteedUnshieldedOffer.inputs.length;
        const signatures: Signature[] = [];
        for (let i = 0; i < inputsLen; ++i) {
          signatures.push(guaranteedUnshieldedOffer.signatures.at(i) ?? signatureData);
        }
        newIntent.guaranteedUnshieldedOffer = guaranteedUnshieldedOffer.addSignatures(signatures);

        // make a copy of transaction to avoid mutation
        const newTransaction = Transaction.deserialize<SignatureEnabled, PreProof, PreBinding>(
          signature.instance,
          ProofMarker.preProof,
          BindingMarker.preBinding,
          transaction.serialize(),
        );
        newTransaction.intents = newTransaction.intents!.set(1, newIntent);

        return {
          type: ProvingRecipe.TRANSACTION_TO_PROVE as typeof ProvingRecipe.TRANSACTION_TO_PROVE,
          transaction: newTransaction,
        };
      });
    });
  }

  calculateFee(transaction: AnyTransaction, ledgerParams: LedgerParameters): bigint {
    return (
      transaction.feesWithMargin(ledgerParams, this.costParams.feeBlocksMargin) + this.costParams.additionalFeeOverhead
    );
  }

  static feeImbalance(transaction: AnyTransaction, totalFee: bigint): bigint {
    const dustImbalance = transaction
      .imbalances(0, totalFee)
      .entries()
      .find(([tt, _]) => tt.tag === 'dust');
    return dustImbalance ? -dustImbalance[1] : totalFee;
  }

  addFeePayment(
    secretKey: DustSecretKey,
    state: DustCoreWallet,
    transaction: UnprovenTransaction,
    ttl: Date,
    currentTime: Date,
    ledgerParams: LedgerParameters,
  ): Either.Either<
    { recipe: ProvingRecipe.ProvingRecipe<FinalizedTransaction>; newState: DustCoreWallet },
    WalletError.WalletError
  > {
    const network = this.networkId;
    const feeLeft = TransactingCapabilityImplementation.feeImbalance(
      transaction,
      this.calculateFee(transaction, ledgerParams),
    );

    const dustTokens = this.getCoins().getAvailableCoinsWithGeneratedDust(state, currentTime);
    const selectedTokens = this.getCoinSelection()(dustTokens, feeLeft);
    if (!selectedTokens.length) {
      return Either.left(new WalletError.TransactingError({ message: 'No dust tokens found in the wallet state' }));
    }

    const totalFeeInSelected = selectedTokens.reduce((total, { value }) => total + value, 0n);
    const feeDiff = totalFeeInSelected - feeLeft;
    if (feeDiff < 0n) {
      return Either.left(new WalletError.TransactingError({ message: 'Not enough Dust generated to pay the fee' }));
    }

    // reduce the largest token's value by `feeDiff`
    const tokensWithFeeToTake = selectedTokens.toSorted((a, b) => Number(b.value - a.value));
    if (feeDiff > 0n) {
      const highestByValue = tokensWithFeeToTake[0];
      tokensWithFeeToTake[0] = {
        value: highestByValue.value - feeDiff,
        token: highestByValue.token,
      };
    }
    return LedgerOps.ledgerTry(() => {
      const intent = Intent.new(ttl);
      const [spends, updatedState] = state.spendCoins(secretKey, tokensWithFeeToTake, currentTime);

      intent.dustActions = new DustActions<SignatureEnabled, PreProof>(
        SignatureMarker.signature,
        ProofMarker.preProof,
        currentTime,
        spends as UnprovenDustSpend[],
        [],
      );

      const feeTransaction = Transaction.fromPartsRandomized(network, undefined, undefined, intent);

      return {
        newState: updatedState,
        recipe: {
          type: ProvingRecipe.TRANSACTION_TO_PROVE,
          transaction: transaction.merge(feeTransaction),
        },
      };
    });
  }

  revert(state: DustCoreWallet, tx: TTransaction): Either.Either<DustCoreWallet, WalletError.WalletError> {
    return Either.try({
      try: () => state.revertTransaction(tx),
      catch: (err) => {
        return new WalletError.OtherWalletError({
          message: `Error while reverting transaction ${tx.identifiers().at(0)!}`,
          cause: err,
        });
      },
    });
  }

  revertRecipe(
    state: DustCoreWallet,
    recipe: ProvingRecipe.ProvingRecipe<TTransaction>,
  ): Either.Either<DustCoreWallet, WalletError.WalletError> {
    const doRevert = (tx: UnprovenTransaction) => {
      return Either.try({
        try: () => state.revertTransaction(tx),
        catch: (err) => {
          return new WalletError.OtherWalletError({
            message: `Error while reverting transaction ${tx.identifiers().at(0)!}`,
            cause: err,
          });
        },
      });
    };

    switch (recipe.type) {
      case ProvingRecipe.TRANSACTION_TO_PROVE:
        return doRevert(recipe.transaction);
      case ProvingRecipe.BALANCE_TRANSACTION_TO_PROVE:
        return doRevert(recipe.transactionToProve);
      case ProvingRecipe.NOTHING_TO_PROVE:
        return Either.right(state);
    }
  }

  #parseAddress(addr: string): Either.Either<DustPublicKey, WalletError.AddressError> {
    return Either.try({
      try: () => {
        const repr = MidnightBech32m.parse(addr);
        return DustAddress.codec.decode(this.networkId, repr).data;
      },
      catch: (err) => {
        return new WalletError.AddressError({
          message: `Address parsing error: ${addr}`,
          originalAddress: addr,
          cause: err,
        });
      },
    });
  }
}

================
File: packages/e2e-tests/src/tests/test-fixture.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
import { exit } from 'process';
import { randomUUID } from 'node:crypto';
import { DockerComposeEnvironment, StartedDockerComposeEnvironment, Wait } from 'testcontainers';
import { StartedGenericContainer } from 'testcontainers/build/generic-container/started-generic-container';
import { MidnightNetwork } from './utils.js';
import { logger } from './logger.js';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { DefaultV1Configuration } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import { DefaultV1Configuration as DefaultDustV1Configuration } from '@midnight-ntwrk/wallet-sdk-dust-wallet';
import { getComposeDirectory, buildTestEnvironmentVariables } from '@midnight-ntwrk/wallet-sdk-utilities/testing';

export function useTestContainersFixture() {
  let fixture: TestContainersFixture | undefined;

  beforeAll(async () => {
    logger.info(`Spinning up ${process.env['NETWORK']} test environment...`);
    const uid = randomUUID();
    const network = process.env['NETWORK'] as MidnightNetwork;
    let composeEnvironment: StartedDockerComposeEnvironment;

    const envVarsToPass = ['APP_INFRA_SECRET'] as const;

    switch (network) {
      case 'undeployed': {
        const environmentVars = buildTestEnvironmentVariables(envVarsToPass, {
          additionalVars: {
            TESTCONTAINERS_UID: uid,
          },
        });

        composeEnvironment = await new DockerComposeEnvironment(getComposeDirectory(), 'docker-compose-dynamic.yml')
          .withWaitStrategy(`proof-server_${uid}`, Wait.forListeningPorts())
          .withWaitStrategy(`node_${uid}`, Wait.forListeningPorts())
          .withWaitStrategy(`indexer_${uid}`, Wait.forListeningPorts())
          .withEnvironment(environmentVars)
          .up();
        break;
      }
      case 'devnet':
      case 'qanet':
      case 'testnet':
      case 'preview':
      case 'preprod': {
        const environmentVars = buildTestEnvironmentVariables(envVarsToPass, {
          additionalVars: {
            TESTCONTAINERS_UID: uid,
            NETWORK_ID: network,
          },
        });

        composeEnvironment = await new DockerComposeEnvironment(
          getComposeDirectory(),
          'docker-compose-remote-dynamic.yml',
        )
          .withWaitStrategy(`proof-server_${uid}`, Wait.forLogMessage('Actix runtime found; starting in Actix runtime'))
          .withEnvironment(environmentVars)
          .up();
        break;
      }
      default: {
        logger.warn(`Unrecognized network: ${network}`);
        exit(1);
      }
    }
    logger.info('Test environment started');
    fixture = new TestContainersFixture(composeEnvironment, uid);
  }, 120_000);

  afterAll(async () => {
    logger.info('Tearing down test environment...');
    await fixture?.down();
    logger.info('Test environment torn down');
  }, 60_000);

  return () => fixture!;
}

export class TestContainersFixture {
  public readonly composeEnvironment: StartedDockerComposeEnvironment;
  private readonly uid: string | undefined;

  constructor(composeEnvironment: StartedDockerComposeEnvironment, uid?: string) {
    this.composeEnvironment = composeEnvironment;
    this.uid = uid;
  }

  public async down() {
    await this.composeEnvironment.down({ timeout: 10_000, removeVolumes: true });
  }

  public static readonly PROOF_SERVER_PORT = 6300;
  public static readonly NODE_PORT_RPC = 9944;
  public static readonly INDEXER_PORT = 8088;
  static readonly network = process.env['NETWORK'] as MidnightNetwork;

  public getProofServerContainer(): StartedGenericContainer {
    return this.composeEnvironment.getContainer(`proof-server_${this.uid}`);
  }

  public getNodeContainer(): StartedGenericContainer {
    return this.composeEnvironment.getContainer(`node_${this.uid}`);
  }

  public getIndexerContainer(): StartedGenericContainer {
    return this.composeEnvironment.getContainer(`indexer_${this.uid}`);
  }

  public getProverUri(): string {
    const proofServerPort = this.getProofServerContainer().getMappedPort(TestContainersFixture.PROOF_SERVER_PORT);
    return `http://localhost:${proofServerPort}`;
  }

  private getIndexerPort(): number {
    return this.getIndexerContainer().getMappedPort(TestContainersFixture.INDEXER_PORT);
  }

  public getIndexerUri(): string {
    switch (TestContainersFixture.network) {
      case 'testnet': {
        return 'https://indexer.testnet-02.midnight.network/api/v3/graphql';
      }
      case 'qanet': {
        return 'https://indexer.qanet.dev.midnight.network/api/v3/graphql';
      }
      case 'preview': {
        return 'https://indexer.preview.midnight.network/api/v3/graphql';
      }
      case 'preprod': {
        return 'https://indexer.preprod.midnight.network/api/v3/graphql';
      }
      case 'node-dev-01': {
        return 'https://indexer.node-dev-01.midnight.network/api/v3/graphql';
      }
      case 'undeployed': {
        const indexerPort = this.getIndexerPort();
        return `http://localhost:${indexerPort}/api/v3/graphql`;
      }
      default: {
        throw new Error(`Unrecognized network: ${String(TestContainersFixture.network)}`);
      }
    }
  }

  public getIndexerWsUri(): string {
    switch (TestContainersFixture.network) {
      case 'testnet': {
        return 'wss://indexer.testnet-02.midnight.network/api/v3/graphql/ws';
      }
      case 'qanet': {
        return 'wss://indexer.qanet.dev.midnight.network/api/v3/graphql/ws';
      }
      case 'preview': {
        return 'wss://indexer.preview.midnight.network/api/v3/graphql/ws';
      }
      case 'preprod': {
        return 'wss://indexer.preprod.midnight.network/api/v3/graphql/ws';
      }
      case 'node-dev-01': {
        return 'wss://indexer.node-dev-01.midnight.network/api/v3/graphql/ws';
      }
      case 'undeployed': {
        const indexerPort = this.getIndexerPort();
        return `ws://localhost:${indexerPort}/api/v3/graphql/ws`;
      }
      default: {
        throw new Error(`Unrecognized network: ${String(TestContainersFixture.network)}`);
      }
    }
  }

  public getNodeUri(): string {
    switch (TestContainersFixture.network) {
      case 'testnet': {
        return 'https://rpc.testnet-02.midnight.network';
      }
      case 'qanet': {
        return 'https://rpc.qanet.dev.midnight.network';
      }
      case 'preview': {
        return 'https://rpc.preview.midnight.network';
      }
      case 'preprod': {
        return 'https://rpc.preprod.midnight.network';
      }
      case 'node-dev-01': {
        return 'https://rpc.node-dev-01.midnight.network';
      }
      case 'undeployed': {
        const nodePortRpc = this.getNodeContainer().getMappedPort(TestContainersFixture.NODE_PORT_RPC);
        return `ws://localhost:${nodePortRpc}`;
      }
      default: {
        throw new Error(`Unrecognized network: ${String(TestContainersFixture.network)}`);
      }
    }
  }

  public getNetworkId(): NetworkId.NetworkId {
    switch (TestContainersFixture.network) {
      case 'undeployed':
        return NetworkId.NetworkId.Undeployed;
      case 'devnet':
        return NetworkId.NetworkId.DevNet;
      case 'qanet':
        return NetworkId.NetworkId.QaNet;
      case 'testnet':
        return NetworkId.NetworkId.TestNet;
      case 'preview':
        return NetworkId.NetworkId.Preview;
      case 'preprod':
        return NetworkId.NetworkId.PreProd;
      default:
        throw new Error(`Unrecognized network: ${String(TestContainersFixture.network)}`);
    }
  }

  public getWalletConfig(): DefaultV1Configuration {
    return {
      indexerClientConnection: {
        indexerHttpUrl: this.getIndexerUri(),
        indexerWsUrl: this.getIndexerWsUri(),
      },
      provingServerUrl: new URL(this.getProverUri()),
      relayURL: new URL(this.getNodeUri()),
      networkId: this.getNetworkId(),
    };
  }

  public getDustWalletConfig(): DefaultDustV1Configuration {
    return {
      networkId: this.getNetworkId(),
      costParameters: {
        additionalFeeOverhead: 300_000_000_000_000n,
        feeBlocksMargin: 5,
      },
    };
  }
}

================
File: packages/hd/package.json
================
{
  "name": "@midnight-ntwrk/wallet-sdk-hd",
  "version": "3.0.0-beta.7",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "author": "Midnight Foundation",
  "license": "Apache-2.0",
  "publishConfig": {
    "registry": "https://npm.pkg.github.com/"
  },
  "files": [
    "dist/"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/midnight-ntwrk/artifacts.git"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  },
  "dependencies": {
    "@scure/base": "^1.1.9",
    "@scure/bip32": "^1.6.2",
    "@scure/bip39": "^1.5.4"
  },
  "devDependencies": {
    "@ethereumjs/wallet": "^3.0.0-alpha.1",
    "eslint": "^9.37.0",
    "fast-check": "^4.2.0",
    "publint": "~0.3.14",
    "rimraf": "^6.0.1",
    "typescript": "^5.9.3",
    "vitest": "^3.2.4"
  },
  "scripts": {
    "typecheck": "tsc -b ./tsconfig.json --noEmit",
    "test": "vitest run",
    "lint": "eslint --max-warnings 0",
    "format": "prettier --write \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format:check": "prettier --check \"**/*.{ts,js,json,yaml,yml,md}\"",
    "dist": "tsc -b ./tsconfig.build.json",
    "dist:publish": "tsc -b ./tsconfig.publish.json",
    "clean": "rimraf --glob dist 'tsconfig.*.tsbuildinfo' && date +%s > .clean-timestamp",
    "publint": "publint --strict"
  }
}

================
File: packages/indexer-client/src/graphql/generated/fragment-masking.ts
================
/* eslint-disable */
import type { ResultOf, DocumentTypeDecoration, TypedDocumentNode } from '@graphql-typed-document-node/core';
import type { FragmentDefinitionNode } from 'graphql';
import type { Incremental } from './graphql.js';


export type FragmentType<TDocumentType extends DocumentTypeDecoration<any, any>> = TDocumentType extends DocumentTypeDecoration<
  infer TType,
  any
>
  ? [TType] extends [{ ' $fragmentName'?: infer TKey }]
    ? TKey extends string
      ? { ' $fragmentRefs'?: { [key in TKey]: TType } }
      : never
    : never
  : never;

// return non-nullable if `fragmentType` is non-nullable
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>>
): TType;
// return nullable if `fragmentType` is undefined
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>> | undefined
): TType | undefined;
// return nullable if `fragmentType` is nullable
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>> | null
): TType | null;
// return nullable if `fragmentType` is nullable or undefined
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>> | null | undefined
): TType | null | undefined;
// return array of non-nullable if `fragmentType` is array of non-nullable
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: Array<FragmentType<DocumentTypeDecoration<TType, any>>>
): Array<TType>;
// return array of nullable if `fragmentType` is array of nullable
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: Array<FragmentType<DocumentTypeDecoration<TType, any>>> | null | undefined
): Array<TType> | null | undefined;
// return readonly array of non-nullable if `fragmentType` is array of non-nullable
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: ReadonlyArray<FragmentType<DocumentTypeDecoration<TType, any>>>
): ReadonlyArray<TType>;
// return readonly array of nullable if `fragmentType` is array of nullable
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: ReadonlyArray<FragmentType<DocumentTypeDecoration<TType, any>>> | null | undefined
): ReadonlyArray<TType> | null | undefined;
export function useFragment<TType>(
  _documentNode: DocumentTypeDecoration<TType, any>,
  fragmentType: FragmentType<DocumentTypeDecoration<TType, any>> | Array<FragmentType<DocumentTypeDecoration<TType, any>>> | ReadonlyArray<FragmentType<DocumentTypeDecoration<TType, any>>> | null | undefined
): TType | Array<TType> | ReadonlyArray<TType> | null | undefined {
  return fragmentType as any;
}


export function makeFragmentData<
  F extends DocumentTypeDecoration<any, any>,
  FT extends ResultOf<F>
>(data: FT, _fragment: F): FragmentType<F> {
  return data as FragmentType<F>;
}
export function isFragmentReady<TQuery, TFrag>(
  queryNode: DocumentTypeDecoration<TQuery, any>,
  fragmentNode: TypedDocumentNode<TFrag>,
  data: FragmentType<TypedDocumentNode<Incremental<TFrag>, any>> | null | undefined
): data is FragmentType<typeof fragmentNode> {
  const deferredFields = (queryNode as { __meta__?: { deferredFields: Record<string, (keyof TFrag)[]> } }).__meta__
    ?.deferredFields;

  if (!deferredFields) return true;

  const fragDef = fragmentNode.definitions[0] as FragmentDefinitionNode | undefined;
  const fragName = fragDef?.name?.value;

  const fields = (fragName && deferredFields[fragName]) || [];
  return fields.length > 0 && fields.every(field => data && field in data);
}

================
File: packages/indexer-client/src/graphql/generated/gql.ts
================
/* eslint-disable */
import * as types from './graphql.js';
import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 * Learn more about it here: https://the-guild.dev/graphql/codegen/plugins/presets/preset-client#reducing-bundle-size
 */
type Documents = {
    "\n    query BlockHash($offset: BlockOffset) {\n      block(offset: $offset) {\n        height\n        hash\n        ledgerParameters\n        timestamp\n      }\n    }\n  ": typeof types.BlockHashDocument,
    "\n    mutation Connect($viewingKey: ViewingKey!) {\n      connect(viewingKey: $viewingKey)\n    }\n  ": typeof types.ConnectDocument,
    "\n    mutation Disconnect($sessionId: HexEncoded!) {\n      disconnect(sessionId: $sessionId)\n    }\n  ": typeof types.DisconnectDocument,
    "\n    subscription DustLedgerEvents($id: Int) {\n      dustLedgerEvents(id: $id) {\n        type: __typename\n        id\n        raw\n        maxId\n      }\n    }\n  ": typeof types.DustLedgerEventsDocument,
    "\n    subscription ShieldedTransactions($sessionId: HexEncoded!, $index: Int) {\n      shieldedTransactions(sessionId: $sessionId, index: $index) {\n        __typename\n        ... on ShieldedTransactionsProgress {\n          highestEndIndex\n          highestCheckedEndIndex\n          highestRelevantEndIndex\n        }\n        ... on RelevantTransaction {\n          transaction {\n            id\n            raw\n            hash\n            protocolVersion\n            identifiers\n            startIndex\n            endIndex\n            fees {\n              paidFees\n              estimatedFees\n            }\n            transactionResult {\n              status\n              segments {\n                id\n                success\n              }\n            }\n          }\n          collapsedMerkleTree {\n            startIndex\n            endIndex\n            update\n            protocolVersion\n          }\n        }\n      }\n    }\n  ": typeof types.ShieldedTransactionsDocument,
    "\n    subscription UnshieldedTransactions($address: UnshieldedAddress!, $transactionId: Int) {\n      unshieldedTransactions(address: $address, transactionId: $transactionId) {\n        ... on UnshieldedTransaction {\n          type: __typename\n          transaction {\n            type: __typename\n            id\n            hash\n            protocolVersion\n            block {\n              timestamp\n            }\n            ... on RegularTransaction {\n              identifiers\n              fees {\n                paidFees\n                estimatedFees\n              }\n              transactionResult {\n                status\n                segments {\n                  id\n                  success\n                }\n              }\n            }\n          }\n          createdUtxos {\n            owner\n            tokenType\n            value\n            outputIndex\n            intentHash\n            ctime\n            registeredForDustGeneration\n          }\n          spentUtxos {\n            owner\n            tokenType\n            value\n            outputIndex\n            intentHash\n            ctime\n            registeredForDustGeneration\n          }\n        }\n        ... on UnshieldedTransactionsProgress {\n          type: __typename\n          highestTransactionId\n        }\n      }\n    }\n  ": typeof types.UnshieldedTransactionsDocument,
    "\n    subscription ZswapEvents($id: Int) {\n      zswapLedgerEvents(id: $id) {\n        id\n        raw\n        maxId\n      }\n    }\n  ": typeof types.ZswapEventsDocument,
};
const documents: Documents = {
    "\n    query BlockHash($offset: BlockOffset) {\n      block(offset: $offset) {\n        height\n        hash\n        ledgerParameters\n        timestamp\n      }\n    }\n  ": types.BlockHashDocument,
    "\n    mutation Connect($viewingKey: ViewingKey!) {\n      connect(viewingKey: $viewingKey)\n    }\n  ": types.ConnectDocument,
    "\n    mutation Disconnect($sessionId: HexEncoded!) {\n      disconnect(sessionId: $sessionId)\n    }\n  ": types.DisconnectDocument,
    "\n    subscription DustLedgerEvents($id: Int) {\n      dustLedgerEvents(id: $id) {\n        type: __typename\n        id\n        raw\n        maxId\n      }\n    }\n  ": types.DustLedgerEventsDocument,
    "\n    subscription ShieldedTransactions($sessionId: HexEncoded!, $index: Int) {\n      shieldedTransactions(sessionId: $sessionId, index: $index) {\n        __typename\n        ... on ShieldedTransactionsProgress {\n          highestEndIndex\n          highestCheckedEndIndex\n          highestRelevantEndIndex\n        }\n        ... on RelevantTransaction {\n          transaction {\n            id\n            raw\n            hash\n            protocolVersion\n            identifiers\n            startIndex\n            endIndex\n            fees {\n              paidFees\n              estimatedFees\n            }\n            transactionResult {\n              status\n              segments {\n                id\n                success\n              }\n            }\n          }\n          collapsedMerkleTree {\n            startIndex\n            endIndex\n            update\n            protocolVersion\n          }\n        }\n      }\n    }\n  ": types.ShieldedTransactionsDocument,
    "\n    subscription UnshieldedTransactions($address: UnshieldedAddress!, $transactionId: Int) {\n      unshieldedTransactions(address: $address, transactionId: $transactionId) {\n        ... on UnshieldedTransaction {\n          type: __typename\n          transaction {\n            type: __typename\n            id\n            hash\n            protocolVersion\n            block {\n              timestamp\n            }\n            ... on RegularTransaction {\n              identifiers\n              fees {\n                paidFees\n                estimatedFees\n              }\n              transactionResult {\n                status\n                segments {\n                  id\n                  success\n                }\n              }\n            }\n          }\n          createdUtxos {\n            owner\n            tokenType\n            value\n            outputIndex\n            intentHash\n            ctime\n            registeredForDustGeneration\n          }\n          spentUtxos {\n            owner\n            tokenType\n            value\n            outputIndex\n            intentHash\n            ctime\n            registeredForDustGeneration\n          }\n        }\n        ... on UnshieldedTransactionsProgress {\n          type: __typename\n          highestTransactionId\n        }\n      }\n    }\n  ": types.UnshieldedTransactionsDocument,
    "\n    subscription ZswapEvents($id: Int) {\n      zswapLedgerEvents(id: $id) {\n        id\n        raw\n        maxId\n      }\n    }\n  ": types.ZswapEventsDocument,
};

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = gql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function gql(source: string): unknown;

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n    query BlockHash($offset: BlockOffset) {\n      block(offset: $offset) {\n        height\n        hash\n        ledgerParameters\n        timestamp\n      }\n    }\n  "): (typeof documents)["\n    query BlockHash($offset: BlockOffset) {\n      block(offset: $offset) {\n        height\n        hash\n        ledgerParameters\n        timestamp\n      }\n    }\n  "];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n    mutation Connect($viewingKey: ViewingKey!) {\n      connect(viewingKey: $viewingKey)\n    }\n  "): (typeof documents)["\n    mutation Connect($viewingKey: ViewingKey!) {\n      connect(viewingKey: $viewingKey)\n    }\n  "];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n    mutation Disconnect($sessionId: HexEncoded!) {\n      disconnect(sessionId: $sessionId)\n    }\n  "): (typeof documents)["\n    mutation Disconnect($sessionId: HexEncoded!) {\n      disconnect(sessionId: $sessionId)\n    }\n  "];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n    subscription DustLedgerEvents($id: Int) {\n      dustLedgerEvents(id: $id) {\n        type: __typename\n        id\n        raw\n        maxId\n      }\n    }\n  "): (typeof documents)["\n    subscription DustLedgerEvents($id: Int) {\n      dustLedgerEvents(id: $id) {\n        type: __typename\n        id\n        raw\n        maxId\n      }\n    }\n  "];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n    subscription ShieldedTransactions($sessionId: HexEncoded!, $index: Int) {\n      shieldedTransactions(sessionId: $sessionId, index: $index) {\n        __typename\n        ... on ShieldedTransactionsProgress {\n          highestEndIndex\n          highestCheckedEndIndex\n          highestRelevantEndIndex\n        }\n        ... on RelevantTransaction {\n          transaction {\n            id\n            raw\n            hash\n            protocolVersion\n            identifiers\n            startIndex\n            endIndex\n            fees {\n              paidFees\n              estimatedFees\n            }\n            transactionResult {\n              status\n              segments {\n                id\n                success\n              }\n            }\n          }\n          collapsedMerkleTree {\n            startIndex\n            endIndex\n            update\n            protocolVersion\n          }\n        }\n      }\n    }\n  "): (typeof documents)["\n    subscription ShieldedTransactions($sessionId: HexEncoded!, $index: Int) {\n      shieldedTransactions(sessionId: $sessionId, index: $index) {\n        __typename\n        ... on ShieldedTransactionsProgress {\n          highestEndIndex\n          highestCheckedEndIndex\n          highestRelevantEndIndex\n        }\n        ... on RelevantTransaction {\n          transaction {\n            id\n            raw\n            hash\n            protocolVersion\n            identifiers\n            startIndex\n            endIndex\n            fees {\n              paidFees\n              estimatedFees\n            }\n            transactionResult {\n              status\n              segments {\n                id\n                success\n              }\n            }\n          }\n          collapsedMerkleTree {\n            startIndex\n            endIndex\n            update\n            protocolVersion\n          }\n        }\n      }\n    }\n  "];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n    subscription UnshieldedTransactions($address: UnshieldedAddress!, $transactionId: Int) {\n      unshieldedTransactions(address: $address, transactionId: $transactionId) {\n        ... on UnshieldedTransaction {\n          type: __typename\n          transaction {\n            type: __typename\n            id\n            hash\n            protocolVersion\n            block {\n              timestamp\n            }\n            ... on RegularTransaction {\n              identifiers\n              fees {\n                paidFees\n                estimatedFees\n              }\n              transactionResult {\n                status\n                segments {\n                  id\n                  success\n                }\n              }\n            }\n          }\n          createdUtxos {\n            owner\n            tokenType\n            value\n            outputIndex\n            intentHash\n            ctime\n            registeredForDustGeneration\n          }\n          spentUtxos {\n            owner\n            tokenType\n            value\n            outputIndex\n            intentHash\n            ctime\n            registeredForDustGeneration\n          }\n        }\n        ... on UnshieldedTransactionsProgress {\n          type: __typename\n          highestTransactionId\n        }\n      }\n    }\n  "): (typeof documents)["\n    subscription UnshieldedTransactions($address: UnshieldedAddress!, $transactionId: Int) {\n      unshieldedTransactions(address: $address, transactionId: $transactionId) {\n        ... on UnshieldedTransaction {\n          type: __typename\n          transaction {\n            type: __typename\n            id\n            hash\n            protocolVersion\n            block {\n              timestamp\n            }\n            ... on RegularTransaction {\n              identifiers\n              fees {\n                paidFees\n                estimatedFees\n              }\n              transactionResult {\n                status\n                segments {\n                  id\n                  success\n                }\n              }\n            }\n          }\n          createdUtxos {\n            owner\n            tokenType\n            value\n            outputIndex\n            intentHash\n            ctime\n            registeredForDustGeneration\n          }\n          spentUtxos {\n            owner\n            tokenType\n            value\n            outputIndex\n            intentHash\n            ctime\n            registeredForDustGeneration\n          }\n        }\n        ... on UnshieldedTransactionsProgress {\n          type: __typename\n          highestTransactionId\n        }\n      }\n    }\n  "];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "\n    subscription ZswapEvents($id: Int) {\n      zswapLedgerEvents(id: $id) {\n        id\n        raw\n        maxId\n      }\n    }\n  "): (typeof documents)["\n    subscription ZswapEvents($id: Int) {\n      zswapLedgerEvents(id: $id) {\n        id\n        raw\n        maxId\n      }\n    }\n  "];

export function gql(source: string) {
  return (documents as any)[source] ?? {};
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;

================
File: packages/indexer-client/src/graphql/generated/graphql.ts
================
/* eslint-disable */
import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  HexEncoded: { input: string; output: string; }
  Unit: { input: null; output: null; }
  UnshieldedAddress: { input: string; output: string; }
  ViewingKey: { input: string; output: string; }
};

/** A block with its relevant data. */
export type Block = {
  /** The hex-encoded block author. */
  author: Maybe<Scalars['HexEncoded']['output']>;
  /** The block hash. */
  hash: Scalars['HexEncoded']['output'];
  /** The block height. */
  height: Scalars['Int']['output'];
  /** The hex-encoded ledger parameters for this block. */
  ledgerParameters: Scalars['HexEncoded']['output'];
  /** The parent of this block. */
  parent: Maybe<Block>;
  /** The protocol version. */
  protocolVersion: Scalars['Int']['output'];
  /** The UNIX timestamp. */
  timestamp: Scalars['Int']['output'];
  /** The transactions within this block. */
  transactions: Array<Transaction>;
};

/** Either a block hash or a block height. */
export type BlockOffset =
  /** A hex-encoded block hash. */
  { hash: Scalars['HexEncoded']['input']; height?: never; }
  |  /** A block height. */
  { hash?: never; height: Scalars['Int']['input']; };

export type CollapsedMerkleTree = {
  /** The zswap state end index. */
  endIndex: Scalars['Int']['output'];
  /** The protocol version. */
  protocolVersion: Scalars['Int']['output'];
  /** The zswap state start index. */
  startIndex: Scalars['Int']['output'];
  /** The hex-encoded value. */
  update: Scalars['HexEncoded']['output'];
};

/** A contract action. */
export type ContractAction = {
  address: Scalars['HexEncoded']['output'];
  chainState: Scalars['HexEncoded']['output'];
  state: Scalars['HexEncoded']['output'];
  transaction: Transaction;
  unshieldedBalances: Array<ContractBalance>;
};

/** Either a block offset or a transaction offset. */
export type ContractActionOffset =
  /** Either a block hash or a block height. */
  { blockOffset: BlockOffset; transactionOffset?: never; }
  |  /** Either a transaction hash or a transaction identifier. */
  { blockOffset?: never; transactionOffset: TransactionOffset; };

/**
 * Represents a token balance held by a contract.
 * This type is exposed through the GraphQL API to allow clients to query
 * unshielded token balances for any contract action (Deploy, Call, Update).
 */
export type ContractBalance = {
  /** Balance amount as string to support larger integer values (up to 16 bytes). */
  amount: Scalars['String']['output'];
  /** Hex-encoded token type identifier. */
  tokenType: Scalars['HexEncoded']['output'];
};

/** A contract call. */
export type ContractCall = ContractAction & {
  /** The hex-encoded serialized address. */
  address: Scalars['HexEncoded']['output'];
  /** The hex-encoded serialized contract-specific zswap state. */
  chainState: Scalars['HexEncoded']['output'];
  /** Contract deploy for this contract call. */
  deploy: ContractDeploy;
  /** The entry point. */
  entryPoint: Scalars['String']['output'];
  /** The hex-encoded serialized state. */
  state: Scalars['HexEncoded']['output'];
  /** Transaction for this contract call. */
  transaction: Transaction;
  /** Unshielded token balances held by this contract. */
  unshieldedBalances: Array<ContractBalance>;
};

/** A contract deployment. */
export type ContractDeploy = ContractAction & {
  /** The hex-encoded serialized address. */
  address: Scalars['HexEncoded']['output'];
  /** The hex-encoded serialized contract-specific zswap state. */
  chainState: Scalars['HexEncoded']['output'];
  /** The hex-encoded serialized state. */
  state: Scalars['HexEncoded']['output'];
  /** Transaction for this contract deploy. */
  transaction: Transaction;
  /** Unshielded token balances held by this contract. */
  unshieldedBalances: Array<ContractBalance>;
};

/** A contract update. */
export type ContractUpdate = ContractAction & {
  /** The hex-encoded serialized address. */
  address: Scalars['HexEncoded']['output'];
  /** The hex-encoded serialized contract-specific zswap state. */
  chainState: Scalars['HexEncoded']['output'];
  /** The hex-encoded serialized state. */
  state: Scalars['HexEncoded']['output'];
  /** Transaction for this contract update. */
  transaction: Transaction;
  /** Unshielded token balances held by this contract after the update. */
  unshieldedBalances: Array<ContractBalance>;
};

export type DustGenerationDtimeUpdate = DustLedgerEvent & {
  /** The ID of this dust ledger event. */
  id: Scalars['Int']['output'];
  /** The maximum ID of all dust ledger events. */
  maxId: Scalars['Int']['output'];
  /** The hex-encoded serialized event. */
  raw: Scalars['HexEncoded']['output'];
};

/** DUST generation status for a specific Cardano stake key. */
export type DustGenerationStatus = {
  /** The hex-encoded Cardano stake key. */
  cardanoStakeKey: Scalars['HexEncoded']['output'];
  /** Current DUST capacity. */
  currentCapacity: Scalars['String']['output'];
  /** The hex-encoded associated DUST address if registered. */
  dustAddress: Maybe<Scalars['HexEncoded']['output']>;
  /** Generation rate in Specks per second. */
  generationRate: Scalars['String']['output'];
  /** NIGHT balance backing generation. */
  nightBalance: Scalars['String']['output'];
  /** Whether this stake key is registered. */
  registered: Scalars['Boolean']['output'];
};

export type DustInitialUtxo = DustLedgerEvent & {
  /** The ID of this dust ledger event. */
  id: Scalars['Int']['output'];
  /** The maximum ID of all dust ledger events. */
  maxId: Scalars['Int']['output'];
  /** The dust output. */
  output: DustOutput;
  /** The hex-encoded serialized event. */
  raw: Scalars['HexEncoded']['output'];
};

/** A dust related ledger event. */
export type DustLedgerEvent = {
  id: Scalars['Int']['output'];
  maxId: Scalars['Int']['output'];
  raw: Scalars['HexEncoded']['output'];
};

/** A dust output. */
export type DustOutput = {
  /** The hex-encoded 32-byte nonce. */
  nonce: Scalars['HexEncoded']['output'];
};

export type DustSpendProcessed = DustLedgerEvent & {
  /** The ID of this dust ledger event. */
  id: Scalars['Int']['output'];
  /** The maximum ID of all dust ledger events. */
  maxId: Scalars['Int']['output'];
  /** The hex-encoded serialized event. */
  raw: Scalars['HexEncoded']['output'];
};

export type Mutation = {
  /** Connect the wallet with the given viewing key and return a session ID. */
  connect: Scalars['HexEncoded']['output'];
  /** Disconnect the wallet with the given session ID. */
  disconnect: Scalars['Unit']['output'];
};


export type MutationConnectArgs = {
  viewingKey: Scalars['ViewingKey']['input'];
};


export type MutationDisconnectArgs = {
  sessionId: Scalars['HexEncoded']['input'];
};

export type ParamChange = DustLedgerEvent & {
  /** The ID of this dust ledger event. */
  id: Scalars['Int']['output'];
  /** The maximum ID of all dust ledger events. */
  maxId: Scalars['Int']['output'];
  /** The hex-encoded serialized event. */
  raw: Scalars['HexEncoded']['output'];
};

export type Query = {
  /** Find a block for the given optional offset; if not present, the latest block is returned. */
  block: Maybe<Block>;
  /** Find a contract action for the given address and optional offset. */
  contractAction: Maybe<ContractAction>;
  /** Get DUST generation status for specific Cardano stake keys. */
  dustGenerationStatus: Array<DustGenerationStatus>;
  /** Find transactions for the given offset. */
  transactions: Array<Transaction>;
};


export type QueryBlockArgs = {
  offset: InputMaybe<BlockOffset>;
};


export type QueryContractActionArgs = {
  address: Scalars['HexEncoded']['input'];
  offset: InputMaybe<ContractActionOffset>;
};


export type QueryDustGenerationStatusArgs = {
  cardanoStakeKeys: Array<Scalars['HexEncoded']['input']>;
};


export type QueryTransactionsArgs = {
  offset: TransactionOffset;
};

/** A regular Midnight transaction. */
export type RegularTransaction = Transaction & {
  /** The block for this transaction. */
  block: Block;
  /** The contract actions for this transaction. */
  contractActions: Array<ContractAction>;
  /** Dust ledger events of this transaction. */
  dustLedgerEvents: Array<DustLedgerEvent>;
  /** The zswap state end index. */
  endIndex: Scalars['Int']['output'];
  /** Fee information for this transaction. */
  fees: TransactionFees;
  /** The hex-encoded transaction hash. */
  hash: Scalars['HexEncoded']['output'];
  /** The transaction ID. */
  id: Scalars['Int']['output'];
  /** The hex-encoded serialized transaction identifiers. */
  identifiers: Array<Scalars['HexEncoded']['output']>;
  /** The hex-encoded serialized merkle-tree root. */
  merkleTreeRoot: Scalars['HexEncoded']['output'];
  /** The protocol version. */
  protocolVersion: Scalars['Int']['output'];
  /** The hex-encoded serialized transaction content. */
  raw: Scalars['HexEncoded']['output'];
  /** The zswap state start index. */
  startIndex: Scalars['Int']['output'];
  /** The result of applying this transaction to the ledger state. */
  transactionResult: TransactionResult;
  /** Unshielded UTXOs created by this transaction. */
  unshieldedCreatedOutputs: Array<UnshieldedUtxo>;
  /** Unshielded UTXOs spent (consumed) by this transaction. */
  unshieldedSpentOutputs: Array<UnshieldedUtxo>;
  /** Zswap ledger events of this transaction. */
  zswapLedgerEvents: Array<ZswapLedgerEvent>;
};

/** A transaction relevant for the subscribing wallet and an optional collapsed merkle tree. */
export type RelevantTransaction = {
  /** An optional collapsed merkle tree. */
  collapsedMerkleTree: Maybe<CollapsedMerkleTree>;
  /** A transaction relevant for the subscribing wallet. */
  transaction: RegularTransaction;
};

/**
 * One of many segments for a partially successful transaction result showing success for some
 * segment.
 */
export type Segment = {
  /** Segment ID. */
  id: Scalars['Int']['output'];
  /** Successful or not. */
  success: Scalars['Boolean']['output'];
};

/** An event of the shielded transactions subscription. */
export type ShieldedTransactionsEvent = RelevantTransaction | ShieldedTransactionsProgress;

/** Information about the shielded transactions indexing progress. */
export type ShieldedTransactionsProgress = {
  /**
   * The highest zswap state end index (see `endIndex` of `Transaction`) of all transactions
   * checked for relevance. Initially less than and eventually (when some wallet has been fully
   * indexed) equal to `highest_end_index`. A value of zero (very unlikely) means that no wallet
   * has subscribed before and indexing for the subscribing wallet has not yet started.
   */
  highestCheckedEndIndex: Scalars['Int']['output'];
  /**
   * The highest zswap state end index (see `endIndex` of `Transaction`) of all transactions. It
   * represents the known state of the blockchain. A value of zero (completely unlikely) means
   * that no shielded transactions have been indexed yet.
   */
  highestEndIndex: Scalars['Int']['output'];
  /**
   * The highest zswap state end index (see `endIndex` of `Transaction`) of all relevant
   * transactions for the subscribing wallet. Usually less than `highest_checked_end_index`
   * unless the latest checked transaction is relevant for the subscribing wallet. A value of
   * zero means that no relevant transactions have been indexed for the subscribing wallet.
   */
  highestRelevantEndIndex: Scalars['Int']['output'];
};

export type Subscription = {
  /**
   * Subscribe to blocks starting at the given offset or at the latest block if the offset is
   * omitted.
   */
  blocks: Block;
  /**
   * Subscribe to contract actions with the given address starting at the given offset or at the
   * latest block if the offset is omitted.
   */
  contractActions: ContractAction;
  /** Subscribe to dust ledger events starting at the given ID or at the very start if omitted. */
  dustLedgerEvents: DustLedgerEvent;
  /**
   * Subscribe to shielded transaction events for the given session ID starting at the given
   * index or at zero if omitted.
   */
  shieldedTransactions: ShieldedTransactionsEvent;
  /**
   * Subscribe unshielded transaction events for the given address and the given transaction ID
   * or zero if omitted.
   */
  unshieldedTransactions: UnshieldedTransactionsEvent;
  /** Subscribe to zswap ledger events starting at the given ID or at the very start if omitted. */
  zswapLedgerEvents: ZswapLedgerEvent;
};


export type SubscriptionBlocksArgs = {
  offset: InputMaybe<BlockOffset>;
};


export type SubscriptionContractActionsArgs = {
  address: Scalars['HexEncoded']['input'];
  offset: InputMaybe<BlockOffset>;
};


export type SubscriptionDustLedgerEventsArgs = {
  id: InputMaybe<Scalars['Int']['input']>;
};


export type SubscriptionShieldedTransactionsArgs = {
  index: InputMaybe<Scalars['Int']['input']>;
  sessionId: Scalars['HexEncoded']['input'];
};


export type SubscriptionUnshieldedTransactionsArgs = {
  address: Scalars['UnshieldedAddress']['input'];
  transactionId: InputMaybe<Scalars['Int']['input']>;
};


export type SubscriptionZswapLedgerEventsArgs = {
  id: InputMaybe<Scalars['Int']['input']>;
};

/** A system Midnight transaction. */
export type SystemTransaction = Transaction & {
  /** The block for this transaction. */
  block: Block;
  /** The contract actions for this transaction. */
  contractActions: Array<ContractAction>;
  /** Dust ledger events of this transaction. */
  dustLedgerEvents: Array<DustLedgerEvent>;
  /** The hex-encoded transaction hash. */
  hash: Scalars['HexEncoded']['output'];
  /** The transaction ID. */
  id: Scalars['Int']['output'];
  /** The protocol version. */
  protocolVersion: Scalars['Int']['output'];
  /** The hex-encoded serialized transaction content. */
  raw: Scalars['HexEncoded']['output'];
  /** Unshielded UTXOs created by this transaction. */
  unshieldedCreatedOutputs: Array<UnshieldedUtxo>;
  /** Unshielded UTXOs spent (consumed) by this transaction. */
  unshieldedSpentOutputs: Array<UnshieldedUtxo>;
  /** Zswap ledger events of this transaction. */
  zswapLedgerEvents: Array<ZswapLedgerEvent>;
};

/** A Midnight transaction. */
export type Transaction = {
  block: Block;
  contractActions: Array<ContractAction>;
  dustLedgerEvents: Array<DustLedgerEvent>;
  hash: Scalars['HexEncoded']['output'];
  id: Scalars['Int']['output'];
  protocolVersion: Scalars['Int']['output'];
  raw: Scalars['HexEncoded']['output'];
  unshieldedCreatedOutputs: Array<UnshieldedUtxo>;
  unshieldedSpentOutputs: Array<UnshieldedUtxo>;
  zswapLedgerEvents: Array<ZswapLedgerEvent>;
};

/** Fees information for a transaction, including both paid and estimated fees. */
export type TransactionFees = {
  /** The estimated fees that was calculated for this transaction in DUST. */
  estimatedFees: Scalars['String']['output'];
  /** The actual fees paid for this transaction in DUST. */
  paidFees: Scalars['String']['output'];
};

/** Either a transaction hash or a transaction identifier. */
export type TransactionOffset =
  /** A hex-encoded transaction hash. */
  { hash: Scalars['HexEncoded']['input']; identifier?: never; }
  |  /** A hex-encoded transaction identifier. */
  { hash?: never; identifier: Scalars['HexEncoded']['input']; };

/**
 * The result of applying a transaction to the ledger state. In case of a partial success (status),
 * there will be segments.
 */
export type TransactionResult = {
  segments: Maybe<Array<Segment>>;
  status: TransactionResultStatus;
};

/** The status of the transaction result: success, partial success or failure. */
export type TransactionResultStatus =
  | 'FAILURE'
  | 'PARTIAL_SUCCESS'
  | 'SUCCESS'
  | '%future added value';

/** A transaction that created and/or spent UTXOs alongside these and other information. */
export type UnshieldedTransaction = {
  /** UTXOs created in the above transaction, possibly empty. */
  createdUtxos: Array<UnshieldedUtxo>;
  /** UTXOs spent in the above transaction, possibly empty. */
  spentUtxos: Array<UnshieldedUtxo>;
  /** The transaction that created and/or spent UTXOs. */
  transaction: Transaction;
};

/** An event of the unshielded transactions subscription. */
export type UnshieldedTransactionsEvent = UnshieldedTransaction | UnshieldedTransactionsProgress;

/** Information about the unshielded indexing progress. */
export type UnshieldedTransactionsProgress = {
  /** The highest transaction ID of all currently known transactions for a subscribed address. */
  highestTransactionId: Scalars['Int']['output'];
};

/** Represents an unshielded UTXO. */
export type UnshieldedUtxo = {
  /** Transaction that created this UTXO. */
  createdAtTransaction: Transaction;
  /** The creation time in seconds. */
  ctime: Maybe<Scalars['Int']['output']>;
  /** The hex-encoded initial nonce for DUST generation tracking. */
  initialNonce: Scalars['HexEncoded']['output'];
  /** The hex-encoded serialized intent hash. */
  intentHash: Scalars['HexEncoded']['output'];
  /** Index of this output within its creating transaction. */
  outputIndex: Scalars['Int']['output'];
  /** Owner Bech32m-encoded address. */
  owner: Scalars['UnshieldedAddress']['output'];
  /** Whether this UTXO is registered for DUST generation. */
  registeredForDustGeneration: Scalars['Boolean']['output'];
  /** Transaction that spent this UTXO. */
  spentAtTransaction: Maybe<Transaction>;
  /** Token hex-encoded serialized token type. */
  tokenType: Scalars['HexEncoded']['output'];
  /** UTXO value (quantity) as a string to support u128. */
  value: Scalars['String']['output'];
};

/** A zswap related ledger event. */
export type ZswapLedgerEvent = {
  /** The ID of this zswap ledger event. */
  id: Scalars['Int']['output'];
  /** The maximum ID of all zswap ledger events. */
  maxId: Scalars['Int']['output'];
  /** The hex-encoded serialized event. */
  raw: Scalars['HexEncoded']['output'];
};

export type BlockHashQueryVariables = Exact<{
  offset: InputMaybe<BlockOffset>;
}>;


export type BlockHashQuery = { block: { height: number, hash: string, ledgerParameters: string, timestamp: number } | null };

export type ConnectMutationVariables = Exact<{
  viewingKey: Scalars['ViewingKey']['input'];
}>;


export type ConnectMutation = { connect: string };

export type DisconnectMutationVariables = Exact<{
  sessionId: Scalars['HexEncoded']['input'];
}>;


export type DisconnectMutation = { disconnect: null };

export type DustLedgerEventsSubscriptionVariables = Exact<{
  id: InputMaybe<Scalars['Int']['input']>;
}>;


export type DustLedgerEventsSubscription = { dustLedgerEvents: { id: number, raw: string, maxId: number, type: 'DustGenerationDtimeUpdate' } | { id: number, raw: string, maxId: number, type: 'DustInitialUtxo' } | { id: number, raw: string, maxId: number, type: 'DustSpendProcessed' } | { id: number, raw: string, maxId: number, type: 'ParamChange' } };

export type ShieldedTransactionsSubscriptionVariables = Exact<{
  sessionId: Scalars['HexEncoded']['input'];
  index: InputMaybe<Scalars['Int']['input']>;
}>;


export type ShieldedTransactionsSubscription = { shieldedTransactions: { __typename: 'RelevantTransaction', transaction: { id: number, raw: string, hash: string, protocolVersion: number, identifiers: Array<string>, startIndex: number, endIndex: number, fees: { paidFees: string, estimatedFees: string }, transactionResult: { status: TransactionResultStatus, segments: Array<{ id: number, success: boolean }> | null } }, collapsedMerkleTree: { startIndex: number, endIndex: number, update: string, protocolVersion: number } | null } | { __typename: 'ShieldedTransactionsProgress', highestEndIndex: number, highestCheckedEndIndex: number, highestRelevantEndIndex: number } };

export type UnshieldedTransactionsSubscriptionVariables = Exact<{
  address: Scalars['UnshieldedAddress']['input'];
  transactionId: InputMaybe<Scalars['Int']['input']>;
}>;


export type UnshieldedTransactionsSubscription = { unshieldedTransactions: { type: 'UnshieldedTransaction', transaction: { identifiers: Array<string>, id: number, hash: string, protocolVersion: number, type: 'RegularTransaction', fees: { paidFees: string, estimatedFees: string }, transactionResult: { status: TransactionResultStatus, segments: Array<{ id: number, success: boolean }> | null }, block: { timestamp: number } } | { id: number, hash: string, protocolVersion: number, type: 'SystemTransaction', block: { timestamp: number } }, createdUtxos: Array<{ owner: string, tokenType: string, value: string, outputIndex: number, intentHash: string, ctime: number | null, registeredForDustGeneration: boolean }>, spentUtxos: Array<{ owner: string, tokenType: string, value: string, outputIndex: number, intentHash: string, ctime: number | null, registeredForDustGeneration: boolean }> } | { highestTransactionId: number, type: 'UnshieldedTransactionsProgress' } };

export type ZswapEventsSubscriptionVariables = Exact<{
  id: InputMaybe<Scalars['Int']['input']>;
}>;


export type ZswapEventsSubscription = { zswapLedgerEvents: { id: number, raw: string, maxId: number } };


export const BlockHashDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"BlockHash"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"offset"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"BlockOffset"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"block"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"offset"},"value":{"kind":"Variable","name":{"kind":"Name","value":"offset"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"height"}},{"kind":"Field","name":{"kind":"Name","value":"hash"}},{"kind":"Field","name":{"kind":"Name","value":"ledgerParameters"}},{"kind":"Field","name":{"kind":"Name","value":"timestamp"}}]}}]}}]} as unknown as DocumentNode<BlockHashQuery, BlockHashQueryVariables>;
export const ConnectDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"Connect"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"viewingKey"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ViewingKey"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"connect"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"viewingKey"},"value":{"kind":"Variable","name":{"kind":"Name","value":"viewingKey"}}}]}]}}]} as unknown as DocumentNode<ConnectMutation, ConnectMutationVariables>;
export const DisconnectDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"Disconnect"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"sessionId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"HexEncoded"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"disconnect"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"sessionId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"sessionId"}}}]}]}}]} as unknown as DocumentNode<DisconnectMutation, DisconnectMutationVariables>;
export const DustLedgerEventsDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"subscription","name":{"kind":"Name","value":"DustLedgerEvents"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"dustLedgerEvents"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","alias":{"kind":"Name","value":"type"},"name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"raw"}},{"kind":"Field","name":{"kind":"Name","value":"maxId"}}]}}]}}]} as unknown as DocumentNode<DustLedgerEventsSubscription, DustLedgerEventsSubscriptionVariables>;
export const ShieldedTransactionsDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"subscription","name":{"kind":"Name","value":"ShieldedTransactions"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"sessionId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"HexEncoded"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"index"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"shieldedTransactions"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"sessionId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"sessionId"}}},{"kind":"Argument","name":{"kind":"Name","value":"index"},"value":{"kind":"Variable","name":{"kind":"Name","value":"index"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"ShieldedTransactionsProgress"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"highestEndIndex"}},{"kind":"Field","name":{"kind":"Name","value":"highestCheckedEndIndex"}},{"kind":"Field","name":{"kind":"Name","value":"highestRelevantEndIndex"}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"RelevantTransaction"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"transaction"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"raw"}},{"kind":"Field","name":{"kind":"Name","value":"hash"}},{"kind":"Field","name":{"kind":"Name","value":"protocolVersion"}},{"kind":"Field","name":{"kind":"Name","value":"identifiers"}},{"kind":"Field","name":{"kind":"Name","value":"startIndex"}},{"kind":"Field","name":{"kind":"Name","value":"endIndex"}},{"kind":"Field","name":{"kind":"Name","value":"fees"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"paidFees"}},{"kind":"Field","name":{"kind":"Name","value":"estimatedFees"}}]}},{"kind":"Field","name":{"kind":"Name","value":"transactionResult"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"status"}},{"kind":"Field","name":{"kind":"Name","value":"segments"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"success"}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"collapsedMerkleTree"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"startIndex"}},{"kind":"Field","name":{"kind":"Name","value":"endIndex"}},{"kind":"Field","name":{"kind":"Name","value":"update"}},{"kind":"Field","name":{"kind":"Name","value":"protocolVersion"}}]}}]}}]}}]}}]} as unknown as DocumentNode<ShieldedTransactionsSubscription, ShieldedTransactionsSubscriptionVariables>;
export const UnshieldedTransactionsDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"subscription","name":{"kind":"Name","value":"UnshieldedTransactions"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"address"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"UnshieldedAddress"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"transactionId"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"unshieldedTransactions"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"address"},"value":{"kind":"Variable","name":{"kind":"Name","value":"address"}}},{"kind":"Argument","name":{"kind":"Name","value":"transactionId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"transactionId"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"UnshieldedTransaction"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","alias":{"kind":"Name","value":"type"},"name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"transaction"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","alias":{"kind":"Name","value":"type"},"name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"hash"}},{"kind":"Field","name":{"kind":"Name","value":"protocolVersion"}},{"kind":"Field","name":{"kind":"Name","value":"block"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"timestamp"}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"RegularTransaction"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"identifiers"}},{"kind":"Field","name":{"kind":"Name","value":"fees"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"paidFees"}},{"kind":"Field","name":{"kind":"Name","value":"estimatedFees"}}]}},{"kind":"Field","name":{"kind":"Name","value":"transactionResult"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"status"}},{"kind":"Field","name":{"kind":"Name","value":"segments"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"success"}}]}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"createdUtxos"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"owner"}},{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"value"}},{"kind":"Field","name":{"kind":"Name","value":"outputIndex"}},{"kind":"Field","name":{"kind":"Name","value":"intentHash"}},{"kind":"Field","name":{"kind":"Name","value":"ctime"}},{"kind":"Field","name":{"kind":"Name","value":"registeredForDustGeneration"}}]}},{"kind":"Field","name":{"kind":"Name","value":"spentUtxos"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"owner"}},{"kind":"Field","name":{"kind":"Name","value":"tokenType"}},{"kind":"Field","name":{"kind":"Name","value":"value"}},{"kind":"Field","name":{"kind":"Name","value":"outputIndex"}},{"kind":"Field","name":{"kind":"Name","value":"intentHash"}},{"kind":"Field","name":{"kind":"Name","value":"ctime"}},{"kind":"Field","name":{"kind":"Name","value":"registeredForDustGeneration"}}]}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"UnshieldedTransactionsProgress"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","alias":{"kind":"Name","value":"type"},"name":{"kind":"Name","value":"__typename"}},{"kind":"Field","name":{"kind":"Name","value":"highestTransactionId"}}]}}]}}]}}]} as unknown as DocumentNode<UnshieldedTransactionsSubscription, UnshieldedTransactionsSubscriptionVariables>;
export const ZswapEventsDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"subscription","name":{"kind":"Name","value":"ZswapEvents"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"zswapLedgerEvents"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"raw"}},{"kind":"Field","name":{"kind":"Name","value":"maxId"}}]}}]}}]} as unknown as DocumentNode<ZswapEventsSubscription, ZswapEventsSubscriptionVariables>;

================
File: packages/indexer-client/src/graphql/queries/test/BlockHash.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { Effect, Option } from 'effect';
import { randomUUID } from 'node:crypto';
import { buildTestEnvironmentVariables, getComposeDirectory } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import { DockerComposeEnvironment, Wait, type StartedDockerComposeEnvironment } from 'testcontainers';
import { Mock, afterAll, beforeAll, describe, expect, it, vi } from 'vitest';
import { HttpQueryClient } from '../../../effect/index.js';
import { BlockHashQuery, BlockHashQueryVariables } from '../../generated/graphql.js';
import { BlockHash } from '../BlockHash.js';

const timeout_minutes = (mins: number) => 1_000 * 60 * mins;

const environmentId = randomUUID();

const environmentVars = buildTestEnvironmentVariables(['APP_INFRA_SECRET'], {
  additionalVars: {
    TESTCONTAINERS_UID: environmentId,
  },
});

const environment = new DockerComposeEnvironment(getComposeDirectory(), 'docker-compose.yml')
  // The test below assumes indexer is able to serve blocks, so we wait for it to index at least one block
  // Otherwise the test below would be flakey or not precise enough to be useful
  // Inspecting logs is not the best idea, but here it's the only way
  .withWaitStrategy(`indexer_${environmentId}`, Wait.forLogMessage(/block indexed/))
  .withEnvironment(environmentVars);

describe('BlockHash query', () => {
  describe('with available Indexer Server', () => {
    let startedEnvironment: StartedDockerComposeEnvironment | undefined = undefined;
    const getIndexerPort = () =>
      startedEnvironment?.getContainer(`indexer_${environmentId}`)?.getMappedPort(8088) ?? 8088;

    beforeAll(async () => {
      startedEnvironment = await environment.up();
    }, timeout_minutes(3));

    afterAll(async () => {
      await startedEnvironment?.down();
    }, timeout_minutes(1));

    it(
      'should fail with ClientError for unknown URL',
      async () => {
        await BlockHash.run({ offset: null }).pipe(
          Effect.catchSome((err) => (err._tag === 'ClientError' ? Option.some(Effect.succeed(void 0)) : Option.none())),
          Effect.catchAll((err) => Effect.fail(`Encountered unexpected '${err._tag}' error: ${err.message}`)),
          Effect.flatMap((data) => (data ? Effect.fail('Unexpectedly received data') : Effect.succeed(void 0))),
          Effect.provide(HttpQueryClient.layer({ url: `http://127.0.0.1:${getIndexerPort()}/a__p__i/v3/graphql` })),
          Effect.scoped,
          Effect.runPromise,
        );
      },
      timeout_minutes(1),
    );

    it(
      'should invoke GraphQL query',
      async () => {
        // Expect a result containing a block with any height and hash value.
        const blockExpectation = expect.objectContaining({
          block: expect.objectContaining({
            height: expect.any(Number),
            hash: expect.any(String),
          }),
        });

        await Effect.gen(function* () {
          const query = yield* BlockHash;
          const result = yield* query({ offset: null });

          expect(result).toEqual(blockExpectation);
        }).pipe(
          Effect.provide(HttpQueryClient.layer({ url: `http://127.0.0.1:${getIndexerPort()}/api/v3/graphql` })),
          Effect.scoped,
          Effect.catchAll((err) => Effect.fail(`Encountered unexpected error: ${err.message}`)),
          Effect.runPromise,
        );
      },
      timeout_minutes(1),
    );
  });

  it('should support query function injection', async () => {
    const block = { block: { height: 1_000, hash: 'SOME_HASH', ledgerParameters: '0x0', timestamp: 1 } };
    const blockExpectation = expect.objectContaining({
      block: expect.objectContaining({
        height: block.block.height,
        hash: block.block.hash,
        ledgerParameters: block.block.ledgerParameters,
        timestamp: block.block.timestamp,
      }),
    });
    const mockedQueryFn: Mock<(v: BlockHashQueryVariables) => Effect.Effect<BlockHashQuery>> = vi.fn();

    mockedQueryFn.mockReturnValue(Effect.succeed(block));

    await Effect.gen(function* () {
      const query = yield* BlockHash;
      const result = yield* query({ offset: null });

      expect(result).toEqual(blockExpectation);
    }).pipe(
      Effect.provideService(BlockHash.tag, mockedQueryFn),
      Effect.provide(HttpQueryClient.layer({ url: 'http://127.0.0.1:8088/a__p__i/v3/graphql' })),
      Effect.scoped,
      Effect.catchAll((err) => Effect.fail(`Encountered unexpected error: ${err.message}`)),
      Effect.runPromise,
    );

    await Effect.gen(function* () {
      const result = yield* BlockHash.run({ offset: null });

      expect(result).toEqual(blockExpectation);
    }).pipe(
      Effect.provideService(BlockHash.tag, mockedQueryFn),
      Effect.provide(HttpQueryClient.layer({ url: 'http://127.0.0.1:8088/a__p__i/v3/graphql' })),
      Effect.scoped,
      Effect.catchAll((err) => Effect.fail(`Encountered unexpected error: ${err.message}`)),
      Effect.runPromise,
    );
  });
});

================
File: packages/indexer-client/CHANGELOG.md
================
# @midnight-ntwrk/wallet-sdk-indexer-client

## 1.0.0-beta.13

### Patch Changes

- b9865cf: feat: rewrite unshielded wallet runtime

## 1.0.0-beta.12

### Patch Changes

- Updated dependencies [a06ccf3]
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.9

## 1.0.0-beta.11

### Patch Changes

- 1db4280: chore: bump ledger to version 6.1.0-beta.5
- Updated dependencies [976628a]
- Updated dependencies [1db4280]
- Updated dependencies [646c8df]
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.8

## 1.0.0-beta.10

### Patch Changes

- 2a0d132: chore: force re-release after workspace failure
- Updated dependencies [2a0d132]
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.6

## 1.0.0-beta.9

### Patch Changes

- ae22baf: chore: initialize baseline release after introducing Changesets
- Updated dependencies [ae22baf]
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.5

================
File: packages/prover-client/CHANGELOG.md
================
# @midnight-ntwrk/wallet-sdk-prover-client

## 1.0.0-beta.10

### Patch Changes

- 3f14055: chore: bump ledger to version 6.1.0-alpha.6

## 1.0.0-beta.9

### Patch Changes

- Updated dependencies [a06ccf3]
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.9

## 1.0.0-beta.8

### Patch Changes

- 976628a: Provide getBytes to allow browser compliant bytes for Blob
- 1db4280: chore: bump ledger to version 6.1.0-beta.5
- Updated dependencies [976628a]
- Updated dependencies [1db4280]
- Updated dependencies [646c8df]
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.8

## 1.0.0-beta.7

### Patch Changes

- 2a0d132: chore: force re-release after workspace failure
- Updated dependencies [2a0d132]
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.6

## 1.0.0-beta.6

### Patch Changes

- ae22baf: chore: initialize baseline release after introducing Changesets
- Updated dependencies [ae22baf]
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.5

================
File: packages/runtime/package.json
================
{
  "name": "@midnight-ntwrk/wallet-sdk-runtime",
  "description": "Runtime for the wallet variants",
  "version": "1.0.0-beta.8",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "author": "Midnight Foundation",
  "license": "Apache-2.0",
  "publishConfig": {
    "registry": "https://npm.pkg.github.com/"
  },
  "files": [
    "dist/"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/midnight-ntwrk/artifacts.git"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    },
    "./abstractions": {
      "types": "./dist/abstractions/index.d.ts",
      "import": "./dist/abstractions/index.js"
    }
  },
  "dependencies": {
    "@midnight-ntwrk/wallet-sdk-abstractions": "1.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-utilities": "1.0.0-beta.7",
    "effect": "^3.17.3",
    "rxjs": "^7.5"
  },
  "scripts": {
    "typecheck": "tsc -b ./tsconfig.json --noEmit",
    "test": "vitest run",
    "lint": "eslint --max-warnings 0",
    "format": "prettier --write \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format:check": "prettier --check \"**/*.{ts,js,json,yaml,yml,md}\"",
    "dist": "tsc -b ./tsconfig.build.json",
    "dist:publish": "tsc -b ./tsconfig.publish.json",
    "clean": "rimraf --glob dist 'tsconfig.*.tsbuildinfo' && date +%s > .clean-timestamp",
    "publint": "publint --strict"
  },
  "devDependencies": {
    "eslint": "^9.32.0",
    "fast-check": "^4.2.0",
    "publint": "~0.3.14",
    "rimraf": "^6.0.1",
    "typescript": "^5.9.3",
    "vitest": "^3.2.4"
  }
}

================
File: packages/unshielded-wallet/src/storage/TransactionHistoryStorage.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Schema } from 'effect';

const TransactionHashSchema = Schema.String;

export type TransactionHash = Schema.Schema.Type<typeof TransactionHashSchema>;

export const TransactionHistoryEntrySchema = Schema.Struct({
  id: Schema.Number,
  hash: TransactionHashSchema,
  protocolVersion: Schema.Number,
  identifiers: Schema.Array(Schema.String),
  timestamp: Schema.Date,
  fees: Schema.NullOr(Schema.BigInt),
  status: Schema.Literal('SUCCESS', 'FAILURE', 'PARTIAL_SUCCESS'),
});

export type TransactionHistoryEntry = Schema.Schema.Type<typeof TransactionHistoryEntrySchema>;

export interface TransactionHistoryStorage {
  create(entry: TransactionHistoryEntry): Promise<void>;
  delete(hash: TransactionHash): Promise<TransactionHistoryEntry | undefined>;
  getAll(): AsyncIterableIterator<TransactionHistoryEntry>;
  get(hash: TransactionHash): Promise<TransactionHistoryEntry | undefined>;
}

================
File: packages/unshielded-wallet/src/v1/TransactionImbalances.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Imbalances } from '@midnight-ntwrk/wallet-sdk-capabilities';

export type TransactionImbalances = Readonly<{
  guaranteed: Imbalances;
  fallible: Imbalances;
}>;
export const TransactionImbalances = new (class {
  empty = (): TransactionImbalances => {
    return {
      guaranteed: Imbalances.empty(),
      fallible: Imbalances.empty(),
    };
  };
})();

================
File: README.md
================
# Midnight Wallet SDK

Implementation of
[Midnight Wallet Specification](https://github.com/midnightntwrk/midnight-architecture/blob/main/components/WalletEngine/Specification.md).
It provides components for:

- generating keys and addresses
- formatting keys and addresses
- building transactions
- submitting transactions to a [node](https://github.com/midnightntwrk/midnight-node)
- handling swaps
- syncing state with [indexer](https://github.com/midnightntwrk/midnight-indexer)
- testing without external infrastructure

## Modules structure

This project is a yarn workspaces combined with Turborepo. In many of them `package.json` files can be found and they
are registered as workspaces in yarn, so yarn can resolve the dependencies. Main packages/sub-projects are:

- `wallet/v1` - the shielded wallet variant
- `wallet` - wallet runtime and builder - allows orchestrating variants of a wallet across migration points (most
  importantly - hard-forks)
- `abstractions` - common abstractions and definitions - variants need to implement specific interfaces to be used
  through wallet builder, but can't depend on the builder itself
- `address-format` - implementation of Bech32m formatting for Midnight keys and addresses
- `hd` - implementation of HD-wallet API for Midnight
- `capabilities` - shared and universal definitions and implementations for capabilities. E.g. balancing or coin
  selection
- `wallet-integration-tests` - tests examining public APIs

For a reference about structure and internal rules to follow, consult [Design Doc](./docs//Design.md) and
[IcePanel component diagram](https://app.icepanel.io/landscapes/yERCUolKk91aYF1pzsql/versions/latest/diagrams/editor?diagram=JwWBu6RYGg&model=onccvco5c4p&overlay_tab=tags&x1=-1463.3&y1=-888&x2=2295.3&y2=1072)

## Development setup

### Tools

We use [nvm](https://github.com/nvm-sh/nvm) to manage the node version and the version of yarn is managed by
[.yarnrc.yml](.yarnrc.yml).

To start development from a new machine it is recommended to run the following

```shell
nvm use
corepack enable
```

Another option is to use [Nix](https://nixos.org). This project provides a [flake](flake.nix) with a devshell
definition. In such case [direnv](https://direnv.net) is strongly recommended.

**Environment Variables**: Environment variables can be configured via a `.env` file in the repository root for local
test execution.

We also support loading environment variables via [direnv](https://direnv.net).

See the [Test Environment Setup](#test) section below for setup instructions.

Additionally, it is worth installing turborepo as a global npm package (`npm install -g turbo`), for easier access for
turbo command.

### Internal private registry and credentials

Follow all authentication steps from the
[Authentication setup document](https://input-output.atlassian.net/wiki/spaces/MN/pages/3696001685/Authentication+setup).

## Install dependencies

Install all project dependencies using Yarn.

```shell
yarn
```

## Build

Build the projects once, generated Javascript code is written to the project's `dist` directory.

```shell
turbo dist
```

## Build and watch

Build the project and watch for changes to automatically rebuild. Generated Javascript code is written to the project's
`dist` directory

```shell
turbo watch dist
```

## Clean

Clean exiting `dist` directories.

```shell
turbo clean
```

## Format

Formats source code.

```shell
turbo format
```

## Test

### Environment Setup

Tests that require environment variables (such as those using Docker Compose for local infrastructure) need to be
configured. The repository includes a `.env.example` file that serves as a template showing all available configuration
options. To configure your environment:

1. Copy `.env.example` to `.env`:

   ```shell
   cp .env.example .env
   ```

2. Edit `.env` and fill in the required values for your environment (see `.env.example` for descriptions of each
   variable).

The `.env` file is automatically loaded by test setup files for tests that require environment variables (such as those
using Docker Compose).

If you're using [direnv](https://direnv.net), the `.env` file will also be loaded into your shell environment when you
enter the directory, making the variables available to any commands you run in that shell.

### Unit tests

```shell
turbo test
```

### Integration tests

```shell
sbt integrationTests/test
```

### CI verification

To run the same checks as CI does, run

```shell
turbo verify
```

It runs across all workspaces:

- necessary builds and typechecking
- lints
- unit tests
- integration tests

## Contributing

All new features must branch off the default branch `main`.

It's recommended to enable automatic scalafmt formatting in your text editor upon save, in order to avoid CI errors due
to incorrect format.

To execute the same verifications that are enabled on the CI, you should run `CI Verifications` as documented above.

## Release a new version

Please read our [git workflow](https://input-output.atlassian.net/wiki/spaces/MN/pages/3378086090/Git+Workflow) for how
to branch and tag releases.

After that, use the [Releases](https://github.com/midnightntwrk/midnight-wallet/releases/new) feature from GitHub to
create a tag with a name following the pattern `vX.Y.Z`. A GitHub action will automatically build and publish the new
version.

### LICENSE

Apache 2.0.

### README.md

Provides a brief description for users and developers who want to understand the purpose, setup, and usage of the
repository.

### SECURITY.md

Provides a brief description of the Midnight Foundation's security policy and how to properly disclose security issues.

### CONTRIBUTING.md

Provides guidelines for how people can contribute to the Midnight project.

### CODEOWNERS

Defines repository ownership rules.

### ISSUE_TEMPLATE

Provides templates for reporting various types of issues, such as: bug report, documentation improvement and feature
request.

### PULL_REQUEST_TEMPLATE

Provides a template for a pull request.

### CLA Assistant

The Midnight Foundation appreciates contributions, and like many other open source projects asks contributors to sign a
contributor License Agreement before accepting contributions. We use CLA assistant
(https://github.com/cla-assistant/cla-assistant) to streamline the CLA signing process, enabling contributors to sign
our CLAs directly within a GitHub pull request.

### Dependabot

The Midnight Foundation uses GitHub Dependabot feature to keep our projects dependencies up-to-date and address
potential security vulnerabilities.

### Checkmarx

The Midnight Foundation uses Checkmarx for application security (AppSec) to identify and fix security vulnerabilities.
All repositories are scanned with Checkmarx's suite of tools including: Static Application Security Testing (SAST),
Infrastructure as Code (IaC), Software Composition Analysis (SCA), API Security, Container Security and Supply Chain
Scans (SCS).

### Unito

Facilitates two-way data synchronization, automated workflows and streamline processes between: Jira, GitHub issues and
Github project Kanban board.

================
File: infra/compose/docker-compose-dynamic.yml
================
services:
  proof-server:
    image: 'ghcr.io/midnight-ntwrk/proof-server:6.1.0-alpha.5'
    container_name: proof-server_$TESTCONTAINERS_UID
    cap_drop:
      - ALL
    security_opt:
      - no-new-privileges:true
    ports:
      - '127.0.0.1::6300'
    environment:
      RUST_BACKTRACE: 'full'
      EXTRA_ARGS: -v
    healthcheck:
      test: ['CMD', 'curl', '-f', 'http://localhost:6300/version']
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

  indexer:
    image: 'ghcr.io/midnight-ntwrk/indexer-standalone:3.0.0-alpha.15'
    container_name: indexer_$TESTCONTAINERS_UID
    cap_drop:
      - ALL
    security_opt:
      - no-new-privileges:true
    ports:
      - '127.0.0.1::8088'
    environment:
      RUST_LOG: 'indexer=debug,chain_indexer=debug,indexer_api=debug,wallet_indexer=debug,indexer_common=debug,fastrace_opentelemetry=off,info'
      APP__INFRA__NODE__URL: 'ws://node:9944'
      APP__APPLICATION__NETWORK_ID: 'undeployed'
      APP__INFRA__SECRET: '${APP_INFRA_SECRET}'

    healthcheck:
      test: ['CMD-SHELL', 'cat /var/run/indexer-standalone/running']
      interval: 60s
      timeout: 5s
      retries: 3
      start_period: 60s
    depends_on:
      node:
        condition: service_healthy
  node:
    image: 'ghcr.io/midnight-ntwrk/midnight-node:0.18.0-rc.7'
    container_name: node_$TESTCONTAINERS_UID
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - DAC_OVERRIDE
      - FOWNER
    ports:
      - '127.0.0.1::9944'
    volumes:
      - node-data:/data
    healthcheck:
      test: ['CMD', 'curl', '-f', 'http://localhost:9944/health']
      interval: 2s
      timeout: 5s
      retries: 5
      start_period: 5s
    environment:
      CFG_PRESET: 'dev'
      SIDECHAIN_BLOCK_BENEFICIARY: '04bcf7ad3be7a5c790460be82a713af570f22e0f801f6659ab8e84a52be6969e'

volumes:
  node-data:

================
File: packages/abstractions/package.json
================
{
  "name": "@midnight-ntwrk/wallet-sdk-abstractions",
  "description": "Domain-specific abstractions for the wallet SDK",
  "version": "1.0.0-beta.9",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "author": "Midnight Foundation",
  "license": "Apache-2.0",
  "publishConfig": {
    "registry": "https://npm.pkg.github.com/"
  },
  "files": [
    "dist/"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/midnight-ntwrk/artifacts.git"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  },
  "dependencies": {
    "effect": "^3.17.3"
  },
  "devDependencies": {
    "eslint": "^9.37.0",
    "fast-check": "^4.2.0",
    "publint": "~0.3.14",
    "rimraf": "^6.0.1",
    "to-words": "^4.5.1",
    "typescript": "^5.9.3",
    "vitest": "^3.2.4"
  },
  "scripts": {
    "typecheck": "tsc -b ./tsconfig.json --noEmit",
    "test": "vitest run",
    "lint": "eslint --max-warnings 0",
    "format": "prettier --write \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format:check": "prettier --check \"**/*.{ts,js,json,yaml,yml,md}\"",
    "dist": "tsc -b ./tsconfig.build.json",
    "dist:publish": "tsc -b ./tsconfig.publish.json",
    "clean": "rimraf --glob dist 'tsconfig.*.tsbuildinfo' && date +%s > .clean-timestamp",
    "publint": "publint --strict"
  }
}

================
File: packages/docs-snippets/src/snippets/initialization.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import type { DefaultV1Configuration as DustConfiguration } from '@midnight-ntwrk/wallet-sdk-dust-wallet';
import { DustWallet } from '@midnight-ntwrk/wallet-sdk-dust-wallet';
import { WalletFacade } from '@midnight-ntwrk/wallet-sdk-facade';
import { HDWallet, Roles } from '@midnight-ntwrk/wallet-sdk-hd';
import { ShieldedWallet } from '@midnight-ntwrk/wallet-sdk-shielded';
import type { DefaultV1Configuration as ShieldedConfiguration } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import {
  createKeystore,
  InMemoryTransactionHistoryStorage,
  PublicKey,
  UnshieldedWallet,
} from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';
import { Buffer } from 'buffer';
import * as rx from 'rxjs';
import { pick } from 'lodash-es';

const INDEXER_PORT = Number.parseInt(process.env['INDEXER_PORT'] ?? '8088', 10);
const NODE_PORT = Number.parseInt(process.env['NODE_PORT'] ?? '9944', 10);
const PROOF_SERVER_PORT = Number.parseInt(process.env['PROOF_SERVER_PORT'] ?? '6300', 10);
const INDEXER_HTTP_URL = `http://localhost:${INDEXER_PORT}/api/v3/graphql`;
const INDEXER_WS_URL = `ws://localhost:${INDEXER_PORT}/api/v3/graphql/ws`;

const configuration: ShieldedConfiguration & DustConfiguration & { indexerUrl: string } = {
  networkId: 'undeployed',
  costParameters: {
    additionalFeeOverhead: 300_000_000_000_000n,
    feeBlocksMargin: 5,
  },
  relayURL: new URL(`ws://localhost:${NODE_PORT}`),
  provingServerUrl: new URL(`http://localhost:${PROOF_SERVER_PORT}`),
  indexerClientConnection: {
    indexerHttpUrl: INDEXER_HTTP_URL,
    indexerWsUrl: INDEXER_WS_URL,
  },
  indexerUrl: INDEXER_WS_URL,
};

const initWalletWithSeed = async (seed: Buffer) => {
  const hdWallet = HDWallet.fromSeed(seed);

  if (hdWallet.type !== 'seedOk') {
    throw new Error('Failed to initialize HDWallet');
  }

  const derivationResult = hdWallet.hdWallet
    .selectAccount(0)
    .selectRoles([Roles.Zswap, Roles.NightExternal, Roles.Dust])
    .deriveKeysAt(0);

  if (derivationResult.type !== 'keysDerived') {
    throw new Error('Failed to derive keys');
  }

  hdWallet.hdWallet.clear();

  const shieldedSecretKeys = ledger.ZswapSecretKeys.fromSeed(derivationResult.keys[Roles.Zswap]);
  const dustSecretKey = ledger.DustSecretKey.fromSeed(derivationResult.keys[Roles.Dust]);
  const unshieldedKeystore = createKeystore(derivationResult.keys[Roles.NightExternal], configuration.networkId);

  const shieldedWallet = ShieldedWallet(configuration).startWithSecretKeys(shieldedSecretKeys);
  const dustWallet = DustWallet(configuration).startWithSecretKey(
    dustSecretKey,
    ledger.LedgerParameters.initialParameters().dust,
  );
  const unshieldedWallet = UnshieldedWallet({
    ...configuration,
    txHistoryStorage: new InMemoryTransactionHistoryStorage(),
  }).startWithPublicKey(PublicKey.fromKeyStore(unshieldedKeystore));

  const wallet: WalletFacade = new WalletFacade(shieldedWallet, unshieldedWallet, dustWallet);
  await wallet.start(shieldedSecretKeys, dustSecretKey);
  return { wallet, shieldedSecretKeys, dustSecretKey, unshieldedKeystore };
};

const { wallet } = await initWalletWithSeed(
  Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex'),
);
const syncedState = await rx.firstValueFrom(wallet.state().pipe(rx.filter((s) => s.isSynced)));
console.log('Synced state:');
console.dir(
  {
    shielded: pick(syncedState.shielded, [
      'balances',
      'availableCoins',
      'pendingCoins',
      'totalCoins',
      'progress',
      'transactionHistory',
      'coinPublicKey',
      'encryptionPublicKey',
      'address',
    ]),
    unshielded: pick(syncedState.unshielded, [
      'balances',
      'availableCoins',
      'pendingCoins',
      'totalCoins',
      'progress',
      'transactionHistory',
      'address',
    ]),
    dust: pick(syncedState.dust, [
      'totalCoins',
      'availableCoins',
      'pendingCoins',
      'progress',
      'dustPublicKey',
      'dustAddress',
    ]),
  },
  { depth: null },
);
await wallet.stop();

================
File: packages/dust-wallet/CHANGELOG.md
================
# @midnight-ntwrk/wallet-sdk-dust-wallet

## 1.0.0-beta.11

### Patch Changes

- Updated dependencies [b9865cf]
  - @midnight-ntwrk/wallet-sdk-indexer-client@1.0.0-beta.13
  - @midnight-ntwrk/wallet-sdk-shielded@1.0.0-beta.12

## 1.0.0-beta.10

### Patch Changes

- 3f14055: chore: bump ledger to version 6.1.0-alpha.6
- Updated dependencies [3f14055]
  - @midnight-ntwrk/wallet-sdk-shielded@1.0.0-beta.11
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-prover-client@1.0.0-beta.10
  - @midnight-ntwrk/wallet-sdk-capabilities@3.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-node-client@1.0.0-beta.10

## 1.0.0-beta.9

### Patch Changes

- fb55d52: Introduce more convenient API for Bech32m address encoding/decoding Remove network id from Dust wallet
  initialization methods (so they are read from the configuration) Introduce FacadeState and add a getter to check for
  sync status of whole facade wallet Introduce CompositeDerivation for HD wallet, so that it is possible to derive keys
  for multiple roles at once
- Updated dependencies [fb55d52]
- Updated dependencies [a06ccf3]
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-hd@3.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-capabilities@3.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-shielded@1.0.0-beta.10
  - @midnight-ntwrk/wallet-sdk-indexer-client@1.0.0-beta.12
  - @midnight-ntwrk/wallet-sdk-prover-client@1.0.0-beta.9

## 1.0.0-beta.8

### Patch Changes

- f967d17: chore: remove wallet api dep from dust wallet
- 1db4280: chore: bump ledger to version 6.1.0-beta.5
- Updated dependencies [976628a]
- Updated dependencies [0838f04]
- Updated dependencies [f6618f1]
- Updated dependencies [1db4280]
- Updated dependencies [646c8df]
  - @midnight-ntwrk/wallet-sdk-prover-client@1.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-shielded@1.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-indexer-client@1.0.0-beta.11
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-capabilities@3.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-node-client@1.0.0-beta.9

## 1.0.0-beta.7

### Patch Changes

- 2a0d132: chore: force re-release after workspace failure
- Updated dependencies [2a0d132]
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-indexer-client@1.0.0-beta.10
  - @midnight-ntwrk/wallet-sdk-prover-client@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-capabilities@3.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-node-client@1.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-shielded@1.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-hd@3.0.0-beta.6

## 1.0.0-beta.6

### Patch Changes

- ae22baf: chore: initialize baseline release after introducing Changesets
- Updated dependencies [ae22baf]
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.5
  - @midnight-ntwrk/wallet-sdk-capabilities@3.0.0-beta.5
  - @midnight-ntwrk/wallet-sdk-hd@3.0.0-beta.5
  - @midnight-ntwrk/wallet-sdk-indexer-client@1.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-node-client@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-prover-client@1.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.5
  - @midnight-ntwrk/wallet-sdk-shielded@1.0.0-beta.7

================
File: packages/e2e-tests/package.json
================
{
  "name": "@midnight/wallet-e2e-tests",
  "version": "0.0.1",
  "description": "Typescript wallet tests",
  "author": "Midnight Foundation",
  "private": true,
  "type": "module",
  "scripts": {
    "pretest-e2e": "rimraf ./allure-results",
    "test-e2e": "docker compose -f ../../infra/compose/docker-compose-dynamic.yml pull && NODE_OPTIONS='--experimental-vm-modules --experimental-specifier-resolution=node --max-old-space-size=8192' vitest run",
    "test-undeployed": "yarn test-e2e --project undeployed",
    "test-remote": "yarn test-e2e --project remote",
    "typecheck": "tsc -b ./tsconfig.json --noEmit",
    "format": "prettier --write \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format:check": "prettier --check \"**/*.{ts,js,json,yaml,yml,md}\"",
    "lint": "eslint --max-warnings 0",
    "allure-generate": "allure generate ./allure-results --clean -o ./reports/allure-report",
    "allure-history": "shx mkdir -p reports/allure-results/history && shx cp reports/allure-report/history/* reports/allure-results/history",
    "allure-open": "allure open ./reports/allure-report",
    "allure-report": "yarn allure-generate && yarn allure-history && yarn allure-open"
  },
  "devDependencies": {
    "@cardano-sdk/key-management": "0.29.11",
    "@midnight-ntwrk/ledger-v6": "6.1.0-alpha.6",
    "@midnight-ntwrk/midnight-js-network-id": "0.2.5",
    "@midnight-ntwrk/wallet": "npm:@midnight-ntwrk/wallet@5.0.0",
    "@midnight-ntwrk/wallet-api": "^5.0.0",
    "@midnight-ntwrk/wallet-sdk-abstractions": "workspace:*",
    "@midnight-ntwrk/wallet-sdk-address-format": "workspace:*",
    "@midnight-ntwrk/wallet-sdk-facade": "workspace:^",
    "@midnight-ntwrk/wallet-sdk-hd": "workspace:^",
    "@midnight-ntwrk/wallet-sdk-shielded": "workspace:^",
    "@midnight-ntwrk/wallet-sdk-unshielded-wallet": "workspace:^",
    "@midnight-ntwrk/wallet_qanet": "npm:@midnight-ntwrk/wallet@3.7.4",
    "@midnight-ntwrk/wallet_testnet": "npm:@midnight-ntwrk/wallet@3.7.4",
    "@types/node": "^22.17.0",
    "@types/ws": "^8.5.4",
    "@vitest/coverage-v8": "3.2.4",
    "@vitest/runner": "^3.2.4",
    "@vitest/ui": "4.0.8",
    "allure-commandline": "^2.27.0",
    "allure-js-commons": "^3.3.0",
    "allure-vitest": "^3.3.0",
    "eslint": "^9.37.0",
    "fp-ts": "^2.13.1",
    "pino": "^9.5.0",
    "pino-pretty": "^11.3.0",
    "prettier": "^3.6.2",
    "rimraf": "^6.0.1",
    "rxjs": "^7.5",
    "shx": "^0.4.0",
    "testcontainers": "^11.8.1",
    "tsc-watch": "^6.0.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.38.0",
    "vitest": "^3.2.4",
    "vitest-ctrf-json-reporter": "^0.0.2",
    "ws": "^8.18.3"
  }
}

================
File: packages/facade/src/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { combineLatest, map, Observable } from 'rxjs';
import { ShieldedWalletState, type ShieldedWallet } from '@midnight-ntwrk/wallet-sdk-shielded';
import { type UnshieldedWallet, UnshieldedWalletState } from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';
import { AnyTransaction, DustWallet, DustWalletState } from '@midnight-ntwrk/wallet-sdk-dust-wallet';
import { ProvingRecipe } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import * as ledger from '@midnight-ntwrk/ledger-v6';

export interface TokenTransfer {
  type: ledger.RawTokenType;
  receiverAddress: string;
  amount: bigint;
}

export type CombinedTokenTransfer = {
  type: 'shielded' | 'unshielded';
  outputs: TokenTransfer[];
};

export type CombinedSwapInputs = {
  shielded?: Record<ledger.RawTokenType, bigint>;
  unshielded?: Record<ledger.RawTokenType, bigint>;
};

export type CombinedSwapOutputs = CombinedTokenTransfer;

export type TransactionIdentifier = string;

export type UtxoWithMeta = {
  utxo: ledger.Utxo;
  meta: {
    ctime: Date;
  };
};

export class FacadeState {
  public readonly shielded: ShieldedWalletState;
  public readonly unshielded: UnshieldedWalletState;
  public readonly dust: DustWalletState;

  public get isSynced(): boolean {
    return (
      this.shielded.state.progress.isStrictlyComplete() &&
      this.dust.state.progress.isStrictlyComplete() &&
      this.unshielded.progress.isStrictlyComplete()
    );
  }

  constructor(shielded: ShieldedWalletState, unshielded: UnshieldedWalletState, dust: DustWalletState) {
    this.shielded = shielded;
    this.unshielded = unshielded;
    this.dust = dust;
  }
}

export class WalletFacade {
  shielded: ShieldedWallet;
  unshielded: UnshieldedWallet;
  dust: DustWallet;

  constructor(shieldedWallet: ShieldedWallet, unshieldedWallet: UnshieldedWallet, dustWallet: DustWallet) {
    this.shielded = shieldedWallet;
    this.unshielded = unshieldedWallet;
    this.dust = dustWallet;
  }

  state(): Observable<FacadeState> {
    return combineLatest([this.shielded.state, this.unshielded.state, this.dust.state]).pipe(
      map(([shieldedState, unshieldedState, dustState]) => new FacadeState(shieldedState, unshieldedState, dustState)),
    );
  }

  async submitTransaction(tx: ledger.FinalizedTransaction): Promise<TransactionIdentifier> {
    await this.shielded.submitTransaction(tx, 'Finalized');

    return tx.identifiers().at(-1)!;
  }

  async balanceTransaction(
    zswapSecretKeys: ledger.ZswapSecretKeys,
    dustSecretKeys: ledger.DustSecretKey,
    tx: ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>,
    ttl: Date,
  ): Promise<ProvingRecipe.ProvingRecipe<ledger.FinalizedTransaction>> {
    const unshieldedBalancedTx = await this.unshielded.balanceTransaction(tx);

    const recipe = await this.shielded.balanceTransaction(zswapSecretKeys, unshieldedBalancedTx, []);

    switch (recipe.type) {
      case ProvingRecipe.TRANSACTION_TO_PROVE:
        return await this.dust.addFeePayment(dustSecretKeys, recipe.transaction, ttl);
      case ProvingRecipe.BALANCE_TRANSACTION_TO_PROVE: {
        // if the shielded wallet returned a proven transaction, we need to pay fees with the dust wallet
        const balancedTx = await this.dust.addFeePayment(dustSecretKeys, recipe.transactionToProve, ttl);

        if (balancedTx.type !== ProvingRecipe.TRANSACTION_TO_PROVE) {
          throw Error('Unexpected transaction type after adding fee payment.');
        }

        return {
          ...recipe,
          transactionToProve: balancedTx.transaction,
        };
      }
      case ProvingRecipe.NOTHING_TO_PROVE: {
        // @TODO fix casting
        const txToBalance = recipe.transaction as unknown as ledger.UnprovenTransaction;
        return await this.dust.addFeePayment(dustSecretKeys, txToBalance, ttl);
      }
    }
  }

  async finalizeTransaction(
    recipe: ProvingRecipe.ProvingRecipe<ledger.FinalizedTransaction>,
  ): Promise<ledger.FinalizedTransaction> {
    return await this.shielded.finalizeTransaction(recipe);
  }

  async signTransaction(
    tx: ledger.UnprovenTransaction,
    signSegment: (data: Uint8Array) => ledger.Signature,
  ): Promise<ledger.UnprovenTransaction> {
    return await this.unshielded.signTransaction(tx, signSegment);
  }

  async calculateTransactionFee(tx: AnyTransaction): Promise<bigint> {
    return await this.dust.calculateFee(tx);
  }

  async transferTransaction(
    zswapSecretKeys: ledger.ZswapSecretKeys,
    dustSecretKey: ledger.DustSecretKey,
    outputs: CombinedTokenTransfer[],
    ttl: Date,
  ): Promise<ProvingRecipe.TransactionToProve> {
    const unshieldedOutputs = outputs
      .filter((output) => output.type === 'unshielded')
      .flatMap((output) => output.outputs);

    const shieldedOutputs = outputs.filter((output) => output.type === 'shielded').flatMap((output) => output.outputs);

    if (unshieldedOutputs.length === 0 && shieldedOutputs.length === 0) {
      throw Error('At least one shielded or unshielded output is required.');
    }

    let shieldedTxRecipe = undefined;
    let unshieldedTx = undefined;

    if (unshieldedOutputs.length > 0) {
      unshieldedTx = await this.unshielded.transferTransaction(unshieldedOutputs, ttl);
    }

    if (shieldedOutputs.length > 0) {
      shieldedTxRecipe = await this.shielded.transferTransaction(zswapSecretKeys, shieldedOutputs);
    }

    // if there's a shielded tx only, return it as it's already balanced
    if (shieldedTxRecipe !== undefined && unshieldedTx === undefined) {
      if (shieldedTxRecipe.type !== 'TransactionToProve') {
        throw Error('Unexpected transaction type.');
      }

      const recipe = await this.dust.addFeePayment(dustSecretKey, shieldedTxRecipe.transaction, ttl);

      if (recipe.type !== 'TransactionToProve') {
        throw Error('Unexpected transaction type after adding fee payment.');
      }

      return recipe;
    }

    // if there's an unshielded tx only, pay fees (balance) with shielded wallet
    if (shieldedTxRecipe === undefined && unshieldedTx !== undefined) {
      const recipe = await this.dust.addFeePayment(dustSecretKey, unshieldedTx, ttl);
      if (recipe.type !== 'TransactionToProve') {
        throw Error('Unexpected transaction type after adding fee payment.');
      }
      return recipe;
    }

    // if there's a shielded and unshielded tx, pay fees for unshielded and merge them
    if (shieldedTxRecipe !== undefined && unshieldedTx !== undefined) {
      if (shieldedTxRecipe.type !== 'TransactionToProve') {
        throw Error('Unexpected transaction type.');
      }
      const txToBalance = shieldedTxRecipe.transaction.merge(unshieldedTx);

      const recipe = await this.dust.addFeePayment(dustSecretKey, txToBalance, ttl);

      if (recipe.type !== 'TransactionToProve') {
        throw Error('Unexpected transaction type after adding fee payment.');
      }

      return recipe;
    }

    throw Error('Unexpected transaction state.');
  }

  async registerNightUtxosForDustGeneration(
    nightUtxos: readonly UtxoWithMeta[],
    nightVerifyingKey: ledger.SignatureVerifyingKey,
    signDustRegistration: (payload: Uint8Array) => Promise<ledger.Signature> | ledger.Signature,
    dustReceiverAddress?: string,
  ): Promise<ProvingRecipe.TransactionToProve> {
    if (nightUtxos.length === 0) {
      throw Error('At least one Night UTXO is required.');
    }

    const dustState = await this.dust.waitForSyncedState();
    const receiverAddress = dustReceiverAddress ?? dustState.dustAddress;
    const ttl = new Date(Date.now() + 60 * 60 * 1000);

    const transaction = await this.dust.createDustGenerationTransaction(
      undefined,
      ttl,
      nightUtxos.map(({ utxo, meta }) => ({ ...utxo, ctime: meta.ctime })),
      nightVerifyingKey,
      receiverAddress,
    );

    const intent = transaction.intents?.get(1);
    if (!intent) {
      throw Error('Dust generation transaction is missing intent segment 1.');
    }

    const signatureData = intent.signatureData(1);
    const signature = await Promise.resolve(signDustRegistration(signatureData));

    const recipe = await this.dust.addDustGenerationSignature(transaction, signature);
    if (recipe.type !== ProvingRecipe.TRANSACTION_TO_PROVE) {
      throw Error('Unexpected recipe type returned when registering Night UTXOs.');
    }

    return recipe;
  }

  async initSwap(
    zswapSecretKeys: ledger.ZswapSecretKeys,
    desiredInputs: CombinedSwapInputs,
    desiredOutputs: CombinedSwapOutputs[],
    ttl: Date,
  ): Promise<ledger.UnprovenTransaction> {
    const { shielded: shieldedInputs, unshielded: unshieldedInputs } = desiredInputs;

    const shieldedOutputs = desiredOutputs
      .filter((output) => output.type === 'shielded')
      .flatMap((output) => output.outputs);

    const unshieldedOutputs = desiredOutputs
      .filter((output) => output.type === 'unshielded')
      .flatMap((output) => output.outputs);

    const hasShieldedPart = (shieldedInputs && Object.keys(shieldedInputs).length > 0) || shieldedOutputs.length > 0;

    const hasUnshieldedPart =
      (unshieldedInputs && Object.keys(unshieldedInputs).length > 0) || unshieldedOutputs.length > 0;

    if (!hasShieldedPart && !hasUnshieldedPart) {
      throw Error('At least one shielded or unshielded swap is required.');
    }

    const shieldedTxRecipe =
      hasShieldedPart && shieldedInputs !== undefined
        ? await this.shielded.initSwap(zswapSecretKeys, shieldedInputs, shieldedOutputs)
        : undefined;

    const unshieldedTx =
      hasUnshieldedPart && unshieldedInputs !== undefined
        ? await this.unshielded.initSwap(unshieldedInputs, unshieldedOutputs, ttl)
        : undefined;

    if (shieldedTxRecipe !== undefined && shieldedTxRecipe.type !== ProvingRecipe.TRANSACTION_TO_PROVE) {
      throw Error('Unexpected transaction type.');
    }

    if (shieldedTxRecipe && unshieldedTx) {
      return shieldedTxRecipe.transaction.merge(unshieldedTx);
    }

    if (shieldedTxRecipe) {
      return shieldedTxRecipe.transaction;
    }

    if (unshieldedTx) {
      return unshieldedTx;
    }

    throw Error('Unexpected transaction state.');
  }

  async deregisterFromDustGeneration(
    nightUtxos: UtxoWithMeta[],
    nightVerifyingKey: ledger.SignatureVerifyingKey,
    signDustRegistration: (payload: Uint8Array) => Promise<ledger.Signature> | ledger.Signature,
  ): Promise<ProvingRecipe.TransactionToProve> {
    const ttl = new Date(Date.now() + 60 * 60 * 1000);

    const transaction = await this.dust.createDustGenerationTransaction(
      undefined,
      ttl,
      nightUtxos.map(({ utxo, meta }) => ({ ...utxo, ctime: meta.ctime })),
      nightVerifyingKey,
      undefined,
    );

    const intent = transaction.intents?.get(1);
    if (!intent) {
      throw Error('Dust generation transaction is missing intent segment 1.');
    }

    const signatureData = intent.signatureData(1);
    const signature = await Promise.resolve(signDustRegistration(signatureData));

    const recipe = await this.dust.addDustGenerationSignature(transaction, signature);
    if (recipe.type !== ProvingRecipe.TRANSACTION_TO_PROVE) {
      throw Error('Unexpected recipe type returned when registering Night UTXOs.');
    }

    return recipe;
  }

  async start(zswapSecretKeys: ledger.ZswapSecretKeys, dustSecretKey: ledger.DustSecretKey): Promise<void> {
    await Promise.all([this.shielded.start(zswapSecretKeys), this.unshielded.start(), this.dust.start(dustSecretKey)]);
  }

  async stop(): Promise<void> {
    await Promise.all([this.shielded.stop(), this.unshielded.stop(), this.dust.stop()]);
  }
}

================
File: packages/facade/CHANGELOG.md
================
# @midnight-ntwrk/wallet-sdk-facade

## 1.0.0-beta.12

### Patch Changes

- b9865cf: feat: rewrite unshielded wallet runtime
- Updated dependencies [283ff55]
- Updated dependencies [b9865cf]
  - @midnight-ntwrk/wallet-sdk-unshielded-wallet@1.0.0-beta.14
  - @midnight-ntwrk/wallet-sdk-dust-wallet@1.0.0-beta.11
  - @midnight-ntwrk/wallet-sdk-shielded@1.0.0-beta.12

## 1.0.0-beta.11

### Patch Changes

- 3f14055: chore: bump ledger to version 6.1.0-alpha.6
- 2c4a115: fix: fixes unshielded state sync update
- Updated dependencies [3f14055]
  - @midnight-ntwrk/wallet-sdk-unshielded-wallet@1.0.0-beta.13
  - @midnight-ntwrk/wallet-sdk-shielded@1.0.0-beta.11
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-dust-wallet@1.0.0-beta.10

## 1.0.0-beta.10

### Patch Changes

- fb55d52: Introduce more convenient API for Bech32m address encoding/decoding Remove network id from Dust wallet
  initialization methods (so they are read from the configuration) Introduce FacadeState and add a getter to check for
  sync status of whole facade wallet Introduce CompositeDerivation for HD wallet, so that it is possible to derive keys
  for multiple roles at once
- Updated dependencies [fb55d52]
- Updated dependencies [a06ccf3]
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-dust-wallet@1.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-hd@3.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-shielded@1.0.0-beta.10
  - @midnight-ntwrk/wallet-sdk-unshielded-wallet@1.0.0-beta.12

## 1.0.0-beta.9

### Patch Changes

- 1db4280: chore: bump ledger to version 6.1.0-beta.5
- Updated dependencies [0838f04]
- Updated dependencies [f967d17]
- Updated dependencies [f6618f1]
- Updated dependencies [1db4280]
- Updated dependencies [646c8df]
  - @midnight-ntwrk/wallet-sdk-shielded@1.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-dust-wallet@1.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-unshielded-wallet@1.0.0-beta.11
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.8

## 1.0.0-beta.8

### Patch Changes

- 2a0d132: chore: force re-release after workspace failure
- Updated dependencies [2a0d132]
  - @midnight-ntwrk/wallet-sdk-unshielded-wallet@1.0.0-beta.10
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-dust-wallet@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-shielded@1.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-hd@3.0.0-beta.6

## 1.0.0-beta.7

### Patch Changes

- ae22baf: chore: initialize baseline release after introducing Changesets
- Updated dependencies [ae22baf]
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.5
  - @midnight-ntwrk/wallet-sdk-dust-wallet@1.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-hd@3.0.0-beta.5
  - @midnight-ntwrk/wallet-sdk-unshielded-wallet@1.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-shielded@1.0.0-beta.7

================
File: packages/indexer-client/package.json
================
{
  "name": "@midnight-ntwrk/wallet-sdk-indexer-client",
  "version": "1.0.0-beta.13",
  "type": "module",
  "module": "dist/index.js",
  "types": "dist/index.d.ts",
  "author": "Midnight Foundation",
  "license": "Apache-2.0",
  "publishConfig": {
    "registry": "https://npm.pkg.github.com/"
  },
  "files": [
    "dist/"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/midnight-ntwrk/artifacts.git"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    },
    "./effect": {
      "types": "./dist/effect/index.d.ts",
      "import": "./dist/effect/index.js"
    }
  },
  "dependencies": {
    "@effect/platform": "^0.90.0",
    "@graphql-typed-document-node/core": "^3.2.0",
    "@midnight-ntwrk/wallet-sdk-abstractions": "1.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-utilities": "1.0.0-beta.7",
    "effect": "^3.17.3",
    "graphql": "^16.11.0",
    "graphql-http": "^1.22.4",
    "graphql-ws": "^6.0.5"
  },
  "devDependencies": {
    "@graphql-codegen/cli": "^5.0.7",
    "@graphql-codegen/client-preset": "^4.8.2",
    "@graphql-codegen/typescript": "^4.1.6",
    "@graphql-codegen/typescript-operations": "^4.6.1",
    "eslint": "^9.37.0",
    "publint": "~0.3.14",
    "rimraf": "^6.0.1",
    "testcontainers": "^11.8.1",
    "typescript": "^5.9.3",
    "vitest": "^3.2.4"
  },
  "scripts": {
    "gql:codegen": "graphql-codegen",
    "typecheck": "tsc -b ./tsconfig.json --noEmit",
    "format": "prettier --write \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format:check": "prettier --check \"**/*.{ts,js,json,yaml,yml,md}\"",
    "test": "vitest run",
    "lint": "eslint",
    "dist": "tsc -b ./tsconfig.build.json",
    "dist:publish": "tsc -b ./tsconfig.publish.json",
    "clean": "rimraf --glob dist 'tsconfig.*.tsbuildinfo' && date +%s > .clean-timestamp",
    "publint": "publint --strict"
  }
}

================
File: packages/shielded-wallet/CHANGELOG.md
================
# @midnight-ntwrk/wallet-sdk-shielded

## 1.0.0-beta.12

### Patch Changes

- Updated dependencies [b9865cf]
  - @midnight-ntwrk/wallet-sdk-indexer-client@1.0.0-beta.13

## 1.0.0-beta.11

### Patch Changes

- 3f14055: chore: bump ledger to version 6.1.0-alpha.6
- Updated dependencies [3f14055]
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-prover-client@1.0.0-beta.10
  - @midnight-ntwrk/wallet-sdk-capabilities@3.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-node-client@1.0.0-beta.10

## 1.0.0-beta.10

### Patch Changes

- Updated dependencies [fb55d52]
- Updated dependencies [a06ccf3]
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-capabilities@3.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-indexer-client@1.0.0-beta.12
  - @midnight-ntwrk/wallet-sdk-prover-client@1.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-runtime@1.0.0-beta.8

## 1.0.0-beta.9

### Patch Changes

- 0838f04: [PM-20041] Ensure shielded wallet throws an error when empty or no positive transfers
- f6618f1: feat: remove new coins from shielded tx balancer api
- 1db4280: chore: bump ledger to version 6.1.0-beta.5
- Updated dependencies [976628a]
- Updated dependencies [1db4280]
- Updated dependencies [646c8df]
  - @midnight-ntwrk/wallet-sdk-prover-client@1.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-indexer-client@1.0.0-beta.11
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-capabilities@3.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-node-client@1.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-runtime@1.0.0-beta.7

## 1.0.0-beta.8

### Patch Changes

- 2a0d132: chore: force re-release after workspace failure
- Updated dependencies [2a0d132]
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-indexer-client@1.0.0-beta.10
  - @midnight-ntwrk/wallet-sdk-prover-client@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-capabilities@3.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-node-client@1.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-runtime@1.0.0-beta.6

## 1.0.0-beta.7

### Patch Changes

- ae22baf: chore: initialize baseline release after introducing Changesets
- Updated dependencies [ae22baf]
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.5
  - @midnight-ntwrk/wallet-sdk-capabilities@3.0.0-beta.5
  - @midnight-ntwrk/wallet-sdk-indexer-client@1.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-node-client@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-prover-client@1.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-runtime@1.0.0-beta.5
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.5

================
File: packages/unshielded-wallet/src/v1/CoinsAndBalances.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { CoreWallet } from './CoreWallet.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { pipe } from 'effect';
import { RecordOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import { UnshieldedState, UtxoWithMeta } from './UnshieldedState.js';

export type Balances = Record<ledger.RawTokenType, bigint>;

export type CoinsAndBalancesCapability<TState> = {
  getAvailableBalances(state: TState): Balances;
  getPendingBalances(state: TState): Balances;
  getTotalBalances(state: TState): Balances;

  getAvailableCoins(state: TState): readonly UtxoWithMeta[];
  getPendingCoins(state: TState): readonly UtxoWithMeta[];
  getTotalCoins(state: TState): ReadonlyArray<UtxoWithMeta>;
};

const calculateBalances = (utxos: readonly UtxoWithMeta[]): Balances =>
  utxos.reduce(
    (acc: Balances, { utxo }) => ({
      ...acc,
      [utxo.type]: acc[utxo.type] === undefined ? utxo.value : acc[utxo.type] + utxo.value,
    }),
    {},
  );

export const makeDefaultCoinsAndBalancesCapability = (): CoinsAndBalancesCapability<CoreWallet> => {
  const getAvailableBalances = (state: CoreWallet): Balances => {
    const availableCoins = getAvailableCoins(state);

    return calculateBalances(availableCoins);
  };

  const getPendingBalances = (state: CoreWallet): Balances => {
    const pendingCoins = getPendingCoins(state);

    return calculateBalances(pendingCoins);
  };

  const getTotalBalances = (state: CoreWallet): Balances => {
    const availableBalances = getAvailableBalances(state);
    const pendingBalances = getPendingBalances(state);

    return pipe(
      [availableBalances, pendingBalances],
      RecordOps.mergeWithAccumulator(0n, (a, b) => a + b),
    );
  };

  const getAvailableCoins = (state: CoreWallet): readonly UtxoWithMeta[] =>
    UnshieldedState.toArrays(state.state).availableUtxos;

  const getPendingCoins = (state: CoreWallet): readonly UtxoWithMeta[] =>
    UnshieldedState.toArrays(state.state).pendingUtxos;

  const getTotalCoins = (state: CoreWallet): readonly UtxoWithMeta[] => [
    ...getAvailableCoins(state),
    ...getPendingCoins(state),
  ];

  return {
    getAvailableBalances,
    getPendingBalances,
    getTotalBalances,
    getAvailableCoins,
    getPendingCoins,
    getTotalCoins,
  };
};

================
File: packages/unshielded-wallet/src/v1/SyncSchema.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, Schema, ParseResult } from 'effect';

export const BigIntSchema = Schema.declare((input: unknown): input is bigint => typeof input === 'bigint').annotations({
  identifier: 'BigIntSchema',
});

export const SafeBigInt: Schema.Schema<bigint, string> = Schema.transformOrFail(Schema.String, BigIntSchema, {
  decode: (value) =>
    Effect.try({
      try: () => BigInt(value),
      catch: (err) => new ParseResult.Unexpected(err, 'Could not parse bigint'),
    }),
  encode: (value) => Effect.succeed(value.toString()),
});

const DateFromMillis = Schema.transform(Schema.Number, Schema.DateFromSelf, {
  strict: true,
  decode: (millis) => new Date(millis),
  encode: (date) => date.getTime(),
});

const WireUtxoSchema = Schema.Struct({
  value: SafeBigInt,
  owner: Schema.String,
  tokenType: Schema.String,
  intentHash: Schema.String,
  outputIndex: Schema.Number,
  ctime: Schema.Number,
  registeredForDustGeneration: Schema.Boolean,
});

const UtxoWithMetaSchema = Schema.transform(
  WireUtxoSchema,
  Schema.typeSchema(
    Schema.Struct({
      utxo: Schema.Struct({
        value: BigIntSchema,
        owner: Schema.String,
        type: Schema.String,
        intentHash: Schema.String,
        outputNo: Schema.Number,
      }),
      meta: Schema.Struct({
        ctime: Schema.DateFromSelf,
        registeredForDustGeneration: Schema.Boolean,
      }),
    }),
  ),
  {
    strict: true,
    decode: (wire) => ({
      utxo: {
        value: wire.value,
        owner: wire.owner,
        type: wire.tokenType,
        intentHash: wire.intentHash,
        outputNo: wire.outputIndex,
      },
      meta: {
        ctime: new Date(wire.ctime * 1000),
        registeredForDustGeneration: wire.registeredForDustGeneration,
      },
    }),
    encode: (domain) => ({
      value: domain.utxo.value,
      owner: domain.utxo.owner,
      tokenType: domain.utxo.type,
      intentHash: domain.utxo.intentHash,
      outputIndex: domain.utxo.outputNo,
      ctime: Math.floor(domain.meta.ctime.getTime() / 1000),
      registeredForDustGeneration: domain.meta.registeredForDustGeneration,
    }),
  },
);

export type UtxoWithMeta = Schema.Schema.Type<typeof UtxoWithMetaSchema>;

export const UnshieldedTransactionSchema = Schema.Data(
  Schema.Struct({
    id: Schema.Number,
    hash: Schema.String,
    type: Schema.Literal('RegularTransaction', 'SystemTransaction'),
    protocolVersion: Schema.Number,
    identifiers: Schema.optional(Schema.Array(Schema.String)),
    block: Schema.Struct({
      timestamp: DateFromMillis,
    }),
    fees: Schema.optional(
      Schema.Struct({
        paidFees: SafeBigInt,
        estimatedFees: SafeBigInt,
      }),
    ),
    transactionResult: Schema.optional(
      Schema.Struct({
        status: Schema.Literal('SUCCESS', 'FAILURE', 'PARTIAL_SUCCESS'),
        segments: Schema.NullOr(
          Schema.Array(
            Schema.Struct({
              id: Schema.Number,
              success: Schema.Boolean,
            }),
          ),
        ),
      }),
    ),
  }),
);

export type UnshieldedTransaction = Schema.Schema.Type<typeof UnshieldedTransactionSchema>;

const UnshieldedUpdateWireSchema = Schema.Struct({
  type: Schema.Literal('UnshieldedTransaction'),
  transaction: UnshieldedTransactionSchema,
  createdUtxos: Schema.Array(UtxoWithMetaSchema),
  spentUtxos: Schema.Array(UtxoWithMetaSchema),
});

export const UnshieldedUpdateSchema = Schema.transform(
  UnshieldedUpdateWireSchema,
  Schema.typeSchema(
    Schema.Struct({
      type: Schema.Literal('UnshieldedTransaction'),
      transaction: UnshieldedTransactionSchema,
      createdUtxos: Schema.Array(Schema.typeSchema(UtxoWithMetaSchema)),
      spentUtxos: Schema.Array(Schema.typeSchema(UtxoWithMetaSchema)),
      status: Schema.Literal('SUCCESS', 'FAILURE', 'PARTIAL_SUCCESS'),
    }),
  ),
  {
    strict: true,
    decode: (wire) => {
      const isSystemTransaction = wire.transaction.type === 'SystemTransaction';
      return {
        ...wire,
        status: isSystemTransaction ? 'SUCCESS' : wire.transaction.transactionResult!.status,
      };
    },
    encode: ({ status: _status, ...rest }) => rest,
  },
);

export type UnshieldedUpdate = Schema.Schema.Type<typeof UnshieldedUpdateSchema>;

export const ProgressSchema = Schema.Struct({
  type: Schema.Literal('UnshieldedTransactionsProgress'),
  highestTransactionId: Schema.Number,
});

export const WalletSyncUpdateSchema = Schema.Union(UnshieldedUpdateSchema, ProgressSchema);

export type WalletSyncUpdate = Schema.Schema.Type<typeof WalletSyncUpdateSchema>;

================
File: packages/unshielded-wallet/src/v1/WalletError.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Data } from 'effect';
import * as ledger from '@midnight-ntwrk/ledger-v6';

export const WalletError = {
  other(err: unknown): WalletError {
    let message: string;
    if (err) {
      if (typeof err == 'object' && 'message' in err) {
        message = String(err.message);
      } else if (typeof err == 'string') {
        message = err;
      } else {
        message = '';
      }
    } else {
      message = '';
    }
    return new OtherWalletError({ message: `Other wallet error: ${message}`, cause: err });
  },
};
export type WalletError =
  | OtherWalletError
  | InsufficientFundsError
  | AddressError
  | SyncWalletError
  | TransactingError
  | SignError
  | ApplyTransactionError
  | RollbackUtxoError
  | SpendUtxoError;

export class OtherWalletError extends Data.TaggedError('Wallet.Other')<{
  message: string;
  cause?: unknown;
}> {}

export class SyncWalletError extends Data.TaggedError('Wallet.Sync')<{
  message: string;
  cause?: unknown;
}> {}

export class InsufficientFundsError extends Data.TaggedError('Wallet.InsufficientFunds')<{
  message: string;
  tokenType: ledger.RawTokenType;
  amount: bigint;
}> {}

export class AddressError extends Data.TaggedError('Wallet.Address')<{
  message: string;
  originalAddress: string;
  cause?: unknown;
}> {}

export class TransactingError extends Data.TaggedError('Wallet.Transacting')<{
  message: string;
  cause?: unknown;
}> {}

export class SignError extends Data.TaggedError('Wallet.Sign')<{
  message: string;
  cause?: unknown;
}> {}

export class ApplyTransactionError extends Data.TaggedError('Wallet.ApplyTransaction')<{
  message: string;
  cause?: unknown;
}> {}

export class RollbackUtxoError extends Data.TaggedError('Wallet.RollbackUtxo')<{
  message: string;
  utxo: ledger.Utxo;
  cause?: unknown;
}> {}

export class SpendUtxoError extends Data.TaggedError('Wallet.SpendUtxo')<{
  message: string;
  utxo: ledger.Utxo;
  cause?: unknown;
}> {}

export class UtxoNotFoundError extends Data.TaggedError('UtxoNotFoundError')<{
  readonly utxo: ledger.Utxo;
}> {}

================
File: packages/unshielded-wallet/src/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * from './UnshieldedWallet.js';
export * from './storage/index.js';
export * from './KeyStore.js';

================
File: packages/unshielded-wallet/src/KeyStore.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { UnshieldedAddress, MidnightBech32m } from '@midnight-ntwrk/wallet-sdk-address-format';
import {
  addressFromKey,
  Signature,
  SignatureVerifyingKey,
  signData,
  UserAddress,
  signatureVerifyingKey,
} from '@midnight-ntwrk/ledger-v6';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';

export type PublicKey = {
  publicKey: SignatureVerifyingKey;
  addressHex: UserAddress;
  address: string;
};

export const PublicKey = {
  fromKeyStore: (keystore: UnshieldedKeystore): PublicKey => {
    return {
      publicKey: keystore.getPublicKey(),
      addressHex: keystore.getAddress(),
      address: keystore.getBech32Address().asString(),
    };
  },
};

export interface UnshieldedKeystore {
  getSecretKey(): Buffer;
  getBech32Address(): MidnightBech32m;
  getPublicKey(): SignatureVerifyingKey;
  getAddress(): UserAddress;
  signData(data: Uint8Array): Signature;
}

export const createKeystore = (
  secretKey: Uint8Array<ArrayBufferLike>,
  networkId: NetworkId.NetworkId,
): UnshieldedKeystore => {
  const keystore: UnshieldedKeystore = {
    getSecretKey: () => Buffer.from(secretKey),

    getBech32Address: () => {
      const address = keystore.getAddress();
      const addressBuffer = Buffer.from(address, 'hex');
      return UnshieldedAddress.codec.encode(networkId, new UnshieldedAddress(addressBuffer));
    },

    getPublicKey: () => signatureVerifyingKey(keystore.getSecretKey().toString('hex')),

    getAddress: () => addressFromKey(keystore.getPublicKey()),

    signData: (data: Uint8Array) => signData(keystore.getSecretKey().toString('hex'), data),
  };

  return keystore;
};

================
File: packages/unshielded-wallet/test/testUtils.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { sampleIntentHash } from '@midnight-ntwrk/ledger-v6';
import { HDWallet, Roles } from '@midnight-ntwrk/wallet-sdk-hd';
import { UnshieldedUpdate, UtxoWithMeta } from '../src/v1/SyncSchema.js';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { DefaultV1Configuration } from '../src/v1/index.js';
import { InMemoryTransactionHistoryStorage } from '../src/storage/index.js';

/**
 * TODO: place in separate package with more additional mock functions
 */
export const generateMockTransaction = (
  owner: string,
  type: string,
  applyStage: 'SUCCESS' | 'FAILURE',
  createdOutputsAmount: number,
  spentOutputsAmount: number,
): UnshieldedUpdate => {
  const createdUtxos = Array.from({ length: createdOutputsAmount }, () => generateMockUtxoWithMeta(owner, type));
  const spentUtxos = Array.from({ length: spentOutputsAmount }, () => generateMockUtxoWithMeta(owner, type));

  return {
    type: 'UnshieldedTransaction',
    transaction: {
      id: Math.floor(Math.random() * 1000),
      hash: crypto.randomUUID(),
      type: 'RegularTransaction',
      protocolVersion: 1,
      identifiers: createdUtxos.map((u) => u.utxo.intentHash),
      block: {
        timestamp: new Date(),
      },
      fees: {
        paidFees: 0n,
        estimatedFees: 0n,
      },
      transactionResult: {
        status: applyStage,
        segments: [{ id: 1, success: applyStage === 'SUCCESS' }],
      },
    },
    createdUtxos,
    spentUtxos,
    status: applyStage,
  };
};

export const generateMockUtxoWithMeta = (owner: string, type: string): UtxoWithMeta => ({
  utxo: {
    value: BigInt(Math.ceil(Math.random() * 100)),
    owner,
    type,
    intentHash: sampleIntentHash(),
    outputNo: Math.floor(Math.random() * 100),
  },
  meta: {
    ctime: new Date(),
    registeredForDustGeneration: true,
  },
});

export const seedHex = (length: number = 64, seed: number = 42): string =>
  Array.from({ length }, (_, i) => ((seed + i) % 16).toString(16)).join('');

export const blockTime = (blockTime: Date): bigint => BigInt(Math.ceil(+blockTime / 1000));

export const getUnshieldedSeed = (seed: string): Uint8Array => {
  const seedBuffer = Buffer.from(seed, 'hex');
  const hdWalletResult = HDWallet.fromSeed(seedBuffer);

  const { hdWallet } = hdWalletResult as {
    type: 'seedOk';
    hdWallet: HDWallet;
  };

  const derivationResult = hdWallet.selectAccount(0).selectRole(Roles.NightExternal).deriveKeyAt(0);

  if (derivationResult.type === 'keyOutOfBounds') {
    throw new Error('Key derivation out of bounds');
  }

  return Buffer.from(derivationResult.key);
};

/**
 * Creates a default wallet configuration for testing.
 * This encapsulates the common configuration pattern used across tests.
 *
 * @param indexerPort - The port number for the indexer service
 * @param overrides - Optional partial configuration to override defaults
 * @returns A complete DefaultV1Configuration object
 */
export const createWalletConfig = (
  indexerPort: number,
  overrides?: Partial<DefaultV1Configuration>,
): DefaultV1Configuration => {
  const defaultConfig: DefaultV1Configuration = {
    indexerClientConnection: {
      indexerWsUrl: `ws://localhost:${indexerPort}/api/v3/graphql/ws`,
      indexerHttpUrl: `http://localhost:${indexerPort}/api/v3/graphql`,
    },
    networkId: NetworkId.NetworkId.Undeployed,
    txHistoryStorage: new InMemoryTransactionHistoryStorage(),
  };

  return { ...defaultConfig, ...overrides };
};

================
File: packages/unshielded-wallet/CHANGELOG.md
================
# @midnight-ntwrk/wallet-sdk-unshielded-wallet

## 1.0.0-beta.14

### Patch Changes

- 283ff55: fix: unshielded state update bug
- b9865cf: feat: rewrite unshielded wallet runtime
- Updated dependencies [b9865cf]
  - @midnight-ntwrk/wallet-sdk-indexer-client@1.0.0-beta.13

## 1.0.0-beta.13

### Patch Changes

- 3f14055: chore: bump ledger to version 6.1.0-alpha.6
- Updated dependencies [3f14055]
- Updated dependencies [2c4a115]
  - @midnight-ntwrk/wallet-sdk-unshielded-state@1.0.0-beta.11
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-capabilities@3.0.0-beta.9

## 1.0.0-beta.12

### Patch Changes

- Updated dependencies [fb55d52]
- Updated dependencies [a06ccf3]
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-hd@3.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-capabilities@3.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-indexer-client@1.0.0-beta.12

## 1.0.0-beta.11

### Patch Changes

- 1db4280: chore: bump ledger to version 6.1.0-beta.5
- Updated dependencies [976628a]
- Updated dependencies [1db4280]
- Updated dependencies [646c8df]
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-unshielded-state@1.0.0-beta.10
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-indexer-client@1.0.0-beta.11
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-capabilities@3.0.0-beta.7

## 1.0.0-beta.10

### Patch Changes

- 2a0d132: chore: force re-release after workspace failure
- Updated dependencies [2a0d132]
  - @midnight-ntwrk/wallet-sdk-unshielded-state@1.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-indexer-client@1.0.0-beta.10
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.7
  - @midnight-ntwrk/wallet-sdk-capabilities@3.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-hd@3.0.0-beta.6

## 1.0.0-beta.9

### Patch Changes

- ae22baf: chore: initialize baseline release after introducing Changesets
- Updated dependencies [ae22baf]
  - @midnight-ntwrk/wallet-sdk-abstractions@1.0.0-beta.6
  - @midnight-ntwrk/wallet-sdk-address-format@3.0.0-beta.5
  - @midnight-ntwrk/wallet-sdk-capabilities@3.0.0-beta.5
  - @midnight-ntwrk/wallet-sdk-hd@3.0.0-beta.5
  - @midnight-ntwrk/wallet-sdk-indexer-client@1.0.0-beta.9
  - @midnight-ntwrk/wallet-sdk-unshielded-state@1.0.0-beta.8
  - @midnight-ntwrk/wallet-sdk-utilities@1.0.0-beta.5

================
File: packages/wallet-integration-tests/test/proving.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { HttpProverClient, ProverClient } from '@midnight-ntwrk/wallet-sdk-prover-client/effect';
import { Proving, ProvingRecipe, WalletError } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Effect, Either, Layer, pipe } from 'effect';
import { GenericContainer, Wait } from 'testcontainers';
import { describe, expect, it, vi } from 'vitest';
import { getNonDustImbalance } from './utils.js';

const PROOF_SERVER_IMAGE: string = 'ghcr.io/midnight-ntwrk/proof-server:6.1.0-alpha.5';
const PROOF_SERVER_PORT: number = 6300;

vi.setConfig({ testTimeout: 300_000, hookTimeout: 300_000 });

const shieldedTokenType = (ledger.shieldedToken() as { tag: 'shielded'; raw: string }).raw;

const makeTransaction = () => {
  const seed = Buffer.alloc(32, 0);
  const recipient = ledger.ZswapSecretKeys.fromSeed(seed);
  const amount = 42n;
  const coin = ledger.createShieldedCoinInfo(shieldedTokenType, amount);
  const output = ledger.ZswapOutput.new(coin, 0, recipient.coinPublicKey, recipient.encryptionPublicKey);
  const offer = ledger.ZswapOffer.fromOutput(output, shieldedTokenType, amount);
  return ledger.Transaction.fromParts(NetworkId.NetworkId.Undeployed, offer);
};

const proofServerContainerResource = Effect.acquireRelease(
  Effect.promise(async () => {
    return await new GenericContainer(PROOF_SERVER_IMAGE)
      .withExposedPorts(PROOF_SERVER_PORT)
      .withWaitStrategy(Wait.forListeningPorts())
      .withStartupTimeout(120_000)
      .start();
  }),
  (container) => Effect.promise(() => container.stop()),
).pipe(
  Effect.map((proofServerContainer) => {
    const proofServerPort = proofServerContainer.getMappedPort(PROOF_SERVER_PORT);
    return new URL(`http://localhost:${proofServerPort}`);
  }),
);

describe('Default Proving Service', () => {
  const adHocProve = (tx: ledger.UnprovenTransaction): Effect.Effect<ledger.FinalizedTransaction> =>
    pipe(
      ProverClient.ProverClient,
      Effect.flatMap((client) => client.proveTransaction(tx, ledger.CostModel.initialCostModel())),
      Effect.map((tx) => tx.bind()),
      Effect.provide(
        proofServerContainerResource.pipe(
          Effect.map((url) =>
            HttpProverClient.layer({
              url,
            }),
          ),
          Layer.unwrapEffect,
        ),
      ),
      Effect.scoped,
      Effect.orDie,
    );

  const testProvenTxEffect = pipe(makeTransaction(), adHocProve, Effect.cached, Effect.flatten);
  const testUnprovenTx = makeTransaction();

  const recipes: ReadonlyArray<{
    recipe: Effect.Effect<ProvingRecipe.ProvingRecipe<ledger.FinalizedTransaction>>;
    expectedImbalance: bigint;
  }> = [
    {
      recipe: pipe(
        testProvenTxEffect,
        Effect.map((testProvenTx) => ({ type: ProvingRecipe.NOTHING_TO_PROVE, transaction: testProvenTx })),
      ),
      expectedImbalance: -42n,
    },
    {
      recipe: pipe(
        testProvenTxEffect,
        Effect.map((testProvenTx) => ({
          type: ProvingRecipe.BALANCE_TRANSACTION_TO_PROVE,
          transactionToBalance: testProvenTx,
          transactionToProve: testUnprovenTx,
        })),
      ),
      expectedImbalance: -84n,
    },
    {
      recipe: Effect.succeed({ type: ProvingRecipe.TRANSACTION_TO_PROVE, transaction: testUnprovenTx }),
      expectedImbalance: -42n,
    },
  ] as const;
  it.each(recipes)(
    'does transform proving recipe into final, proven transaction',
    async ({ recipe, expectedImbalance }) => {
      const finalTx = await Effect.gen(function* () {
        const readyRecipe = yield* recipe;
        const proofServerUrl = yield* proofServerContainerResource;
        const service = Proving.makeDefaultProvingService({
          provingServerUrl: proofServerUrl,
        });

        return yield* service.prove(readyRecipe);
      }).pipe(Effect.scoped, Effect.runPromise);

      expect(finalTx).toBeInstanceOf(ledger.Transaction);
      expect(getNonDustImbalance(finalTx.imbalances(0), shieldedTokenType)).toEqual(expectedImbalance);
    },
  );

  it('does fail with wallet error instance when proving fails (e.g. due to misconfiguration)', async () => {
    const recipe = { type: ProvingRecipe.TRANSACTION_TO_PROVE, transaction: testUnprovenTx } as const;
    const result = await Effect.gen(function* () {
      const misconfiguredService = Proving.makeDefaultProvingService({
        provingServerUrl: new URL('http://localhost:12345'), // Invalid URL to simulate misconfiguration
      });
      return yield* misconfiguredService.prove(recipe);
    }).pipe(Effect.scoped, Effect.either, Effect.runPromise);

    Either.match(result, {
      onRight: (result) => {
        throw new Error(`Unexpected success: ${result.toString()}`);
      },
      onLeft: (error) => {
        expect(error).toBeInstanceOf(WalletError.ProvingError);
      },
    });
  });

  it('does fail with wallet error instance when proving fails (e.g. due to connection error)', async () => {
    const recipe = { type: ProvingRecipe.TRANSACTION_TO_PROVE, transaction: testUnprovenTx } as const;
    const result = await Effect.gen(function* () {
      const proofServerUrl = yield* proofServerContainerResource.pipe(Effect.scoped); //This makes the container stop immediately
      const misconfiguredService = Proving.makeDefaultProvingService({
        provingServerUrl: proofServerUrl,
      });
      return yield* misconfiguredService.prove(recipe);
    }).pipe(Effect.either, Effect.runPromise);

    Either.match(result, {
      onRight: (result) => {
        throw new Error(`Unexpected success: ${result.toString()}`);
      },
      onLeft: (error) => {
        expect(error).toBeInstanceOf(WalletError.ProvingError);
      },
    });
  });
});

================
File: packages/address-format/package.json
================
{
  "name": "@midnight-ntwrk/wallet-sdk-address-format",
  "version": "3.0.0-beta.9",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "author": "Midnight Foundation",
  "license": "Apache-2.0",
  "publishConfig": {
    "registry": "https://npm.pkg.github.com/"
  },
  "files": [
    "dist/"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/midnight-ntwrk/artifacts.git"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  },
  "dependencies": {
    "@midnight-ntwrk/ledger-v6": "6.1.0-alpha.6",
    "@scure/base": "^1.2.6",
    "@subsquid/scale-codec": "^4.0.1"
  },
  "devDependencies": {
    "@types/node": "22.17.0",
    "eslint": "^9.37.0",
    "publint": "~0.3.14",
    "rimraf": "^6.0.1",
    "typescript": "^5.9.3",
    "vitest": "^3.2.4"
  },
  "scripts": {
    "typecheck": "tsc -b ./tsconfig.json --noEmit",
    "test": "vitest run",
    "lint": "eslint --max-warnings 0",
    "format": "prettier --write \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format:check": "prettier --check \"**/*.{ts,js,json,yaml,yml,md}\"",
    "dist": "tsc -b ./tsconfig.build.json",
    "dist:publish": "tsc -b ./tsconfig.publish.json",
    "clean": "rimraf --glob dist 'tsconfig.*.tsbuildinfo' && date +%s > .clean-timestamp",
    "publint": "publint --strict"
  }
}

================
File: packages/capabilities/package.json
================
{
  "name": "@midnight-ntwrk/wallet-sdk-capabilities",
  "version": "3.0.0-beta.9",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "author": "Midnight Foundation",
  "license": "Apache-2.0",
  "publishConfig": {
    "registry": "https://npm.pkg.github.com/"
  },
  "files": [
    "dist/"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/midnight-ntwrk/artifacts.git"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  },
  "dependencies": {
    "@midnight-ntwrk/wallet-sdk-address-format": "3.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-hd": "3.0.0-beta.7",
    "effect": "^3.17.3"
  },
  "devDependencies": {
    "@midnight-ntwrk/ledger-v6": "6.1.0-alpha.6",
    "eslint": "^9.37.0",
    "fast-check": "^4.2.0",
    "publint": "~0.3.14",
    "rimraf": "^6.0.1",
    "typescript": "^5.9.3",
    "vitest": "^3.2.4"
  },
  "scripts": {
    "typecheck": "tsc -b ./tsconfig.json --noEmit",
    "test": "vitest run",
    "lint": "eslint --max-warnings 0",
    "format": "prettier --write \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format:check": "prettier --check \"**/*.{ts,js,json,yaml,yml,md}\"",
    "dist": "tsc -b ./tsconfig.build.json",
    "dist:publish": "tsc -b ./tsconfig.publish.json",
    "clean": "rimraf --glob dist 'tsconfig.*.tsbuildinfo' && date +%s > .clean-timestamp",
    "publint": "publint --strict"
  }
}

================
File: packages/node-client/package.json
================
{
  "name": "@midnight-ntwrk/wallet-sdk-node-client",
  "version": "1.0.0-beta.10",
  "type": "module",
  "module": "dist/index.js",
  "types": "dist/index.d.ts",
  "author": "Midnight Foundation",
  "license": "Apache-2.0",
  "publishConfig": {
    "registry": "https://npm.pkg.github.com/"
  },
  "files": [
    "dist/"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/midnight-ntwrk/artifacts.git"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    },
    "./effect": {
      "types": "./dist/effect/index.d.ts",
      "import": "./dist/effect/index.js"
    },
    "./testing": {
      "types": "./dist/testing/index.d.ts",
      "import": "./dist/testing/index.js"
    }
  },
  "dependencies": {
    "@polkadot/api": "^16.3.1",
    "@polkadot/api-augment": "^16.3.1",
    "@polkadot/api-base": "^16.3.1",
    "@polkadot/rpc-augment": "^16.3.1",
    "@polkadot/rpc-core": "^16.3.1",
    "@polkadot/types": "^16.3.1",
    "@polkadot/types-augment": "^16.3.1",
    "@polkadot/types-codec": "^16.3.1",
    "@polkadot/types-known": "^16.3.1",
    "@polkadot/types-support": "^16.3.1",
    "@types/bn.js": "^5.2.0",
    "bn.js": "^5.2.2",
    "effect": "^3.17.3",
    "rxjs": "^7.5",
    "testcontainers": "^11.8.1"
  },
  "devDependencies": {
    "@effect/cluster": "^0.46.2",
    "@effect/experimental": "^0.54.2",
    "@effect/platform": "^0.90.0",
    "@effect/platform-node": "^0.94.0",
    "@effect/rpc": "^0.68.0",
    "@effect/sql": "^0.44.0",
    "@effect/workflow": "^0.8.1",
    "@midnight-ntwrk/ledger-v6": "6.1.0-alpha.6",
    "@midnight-ntwrk/wallet-sdk-abstractions": "1.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-prover-client": "1.0.0-beta.10",
    "@midnight-ntwrk/wallet-sdk-utilities": "1.0.0-beta.7",
    "@polkadot/typegen": "^16.3.1",
    "@types/yargs": "^17.0.33",
    "eslint": "^9.37.0",
    "publint": "~0.3.14",
    "rimraf": "^6.0.1",
    "tsx": "^4.20.4",
    "typescript": "^5.9.3",
    "vitest": "^3.2.4",
    "yargs": "^18.0.0"
  },
  "scripts": {
    "typecheck-script": "tsc -b ./tsconfig.script.json --noEmit",
    "polkadot-typegen": "tsx ./scripts/generate-types.ts",
    "typecheck": "tsc -b ./tsconfig.json --noEmit",
    "test": "vitest run",
    "lint": "eslint --max-warnings 0",
    "format": "prettier --write \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format:check": "prettier --check \"**/*.{ts,js,json,yaml,yml,md}\"",
    "dist": "tsc -b ./tsconfig.build.json",
    "dist:publish": "tsc -b ./tsconfig.publish.json",
    "clean": "rimraf --glob dist 'tsconfig.*.tsbuildinfo' && date +%s > .clean-timestamp",
    "publint": "publint --strict"
  }
}

================
File: packages/prover-client/package.json
================
{
  "name": "@midnight-ntwrk/wallet-sdk-prover-client",
  "version": "1.0.0-beta.10",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "author": "Midnight Foundation",
  "license": "Apache-2.0",
  "publishConfig": {
    "registry": "https://npm.pkg.github.com/"
  },
  "files": [
    "dist/"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/midnight-ntwrk/artifacts.git"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    },
    "./effect": {
      "types": "./dist/effect/index.d.ts",
      "import": "./dist/effect/index.js"
    }
  },
  "dependencies": {
    "@effect/platform": "^0.90.0",
    "@midnight-ntwrk/ledger-v6": "6.1.0-alpha.6",
    "@midnight-ntwrk/wallet-sdk-abstractions": "1.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-utilities": "1.0.0-beta.7",
    "effect": "^3.17.3"
  },
  "devDependencies": {
    "eslint": "^9.37.0",
    "publint": "~0.3.14",
    "rimraf": "^6.0.1",
    "testcontainers": "^11.8.1",
    "typescript": "^5.9.3",
    "vitest": "^3.2.4"
  },
  "scripts": {
    "typecheck": "tsc -b ./tsconfig.json --noEmit",
    "test": "vitest run",
    "lint": "eslint --max-warnings 0",
    "format": "prettier --write \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format:check": "prettier --check \"**/*.{ts,js,json,yaml,yml,md}\"",
    "dist": "tsc -b ./tsconfig.build.json",
    "dist:publish": "tsc -b ./tsconfig.publish.json",
    "clean": "rimraf --glob dist 'tsconfig.*.tsbuildinfo' && date +%s > .clean-timestamp",
    "publint": "publint --strict"
  }
}

================
File: packages/unshielded-wallet/src/v1/Keys.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { UnshieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';
import type { CoreWallet } from './CoreWallet.js';
import { SignatureVerifyingKey } from '@midnight-ntwrk/ledger-v6';

export type KeysCapability<TState> = {
  getPublicKey(state: TState): SignatureVerifyingKey;
  getAddress(state: TState): UnshieldedAddress;
};

export const makeDefaultKeysCapability = (): KeysCapability<CoreWallet> => {
  return {
    getPublicKey: (state: CoreWallet): SignatureVerifyingKey => {
      return state.publicKey.publicKey;
    },
    getAddress: (state: CoreWallet): UnshieldedAddress => {
      return new UnshieldedAddress(Buffer.from(state.publicKey.addressHex, 'hex'));
    },
  };
};

================
File: packages/unshielded-wallet/src/v1/Transaction.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Either, pipe } from 'effect';
import { Imbalances } from '@midnight-ntwrk/wallet-sdk-capabilities';
import { TransactionImbalances } from './TransactionImbalances.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { TransactingError, WalletError } from './WalletError.js';

export const isIntentBound = (
  intent: ledger.Intent<ledger.Signaturish, ledger.Proofish, ledger.Bindingish>,
): boolean => {
  return intent.binding instanceof ledger.Binding;
};

export type TransactionTrait<Tx> = {
  id(tx: Tx): string;
  getOfferSignatureData: (transaction: Tx, segment: number) => Either.Either<Uint8Array, WalletError>;
  getSegments(transaction: Tx): number[];
  addOfferSignature(transaction: Tx, signature: ledger.Signature, segment: number): Either.Either<Tx, WalletError>;
  bindTransaction(
    transaction: ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.PreBinding>,
  ): Either.Either<ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Binding>, WalletError>;
};

export const TransactionTrait = new (class {
  default: TransactionTrait<ledger.UnprovenTransaction> = {
    getOfferSignatureData(tx, segment) {
      return TransactionTrait.shared.getOfferSignatureData(tx, segment);
    },
    getSegments(tx) {
      return TransactionTrait.shared.getSegments(tx);
    },
    addOfferSignature(transaction, signature, segment) {
      return TransactionTrait.shared.addOfferSignature(transaction, signature, segment);
    },
    bindTransaction(transaction) {
      return TransactionTrait.shared.bindTransaction(transaction);
    },
    id(tx) {
      return tx.identifiers().at(0)!;
    },
  };

  shared = {
    getOfferSignatureData(
      tx: ledger.UnprovenTransaction,
      segment: number,
    ): Either.Either<Uint8Array<ArrayBufferLike>, WalletError> {
      return Either.try({
        try: () => {
          if (!tx.intents) {
            throw new TransactingError({ message: 'Transaction has no intents' });
          }

          const intent = tx.intents.get(segment);

          if (!intent) {
            throw new TransactingError({ message: `Intent with segment ${segment} was not found` });
          }

          return pipe(isIntentBound(intent) ? intent : intent.bind(segment), (boundIntent) =>
            boundIntent.signatureData(segment),
          );
        },
        catch: (error) =>
          error instanceof TransactingError
            ? error
            : new TransactingError({ message: 'Failed to get offer signature data', cause: error }),
      });
    },
    addOfferSignature(
      transaction: ledger.UnprovenTransaction,
      signature: ledger.Signature,
      segment: number = 1,
    ): Either.Either<ledger.UnprovenTransaction, WalletError> {
      return Either.gen(function* () {
        if (!transaction.intents || !transaction.intents.size) {
          throw new TransactingError({ message: 'No intents found in the provided transaction' });
        }

        const intent = transaction.intents.get(segment);

        if (!intent) {
          throw new TransactingError({ message: 'Intent with a given segment was not found' });
        }

        const isBound = isIntentBound(intent);
        if (isBound) return transaction;

        let updatedIntent = intent;
        if (intent.guaranteedUnshieldedOffer) {
          const offer = intent.guaranteedUnshieldedOffer;
          const inputsLen = offer.inputs.length;
          const signatures: ledger.Signature[] = [];
          for (let i = 0; i < inputsLen; ++i) {
            signatures.push(offer.signatures.at(i) ?? signature);
          }

          updatedIntent = yield* Either.try({
            try: () => {
              const offerWithSignatures = offer.addSignatures(signatures);
              updatedIntent.guaranteedUnshieldedOffer = offerWithSignatures;
              return updatedIntent;
            },
            catch: (error) =>
              new TransactingError({
                message: `Failed to add guaranteed signature at segment ${segment}`,
                cause: error,
              }),
          });
        }

        if (intent.fallibleUnshieldedOffer) {
          const offer = intent.fallibleUnshieldedOffer;
          const inputsLen = offer.inputs.length;
          const signatures: ledger.Signature[] = [];
          for (let i = 0; i < inputsLen; ++i) {
            signatures.push(offer.signatures.at(i) ?? signature);
          }

          updatedIntent = yield* Either.try({
            try: () => {
              const offerWithSignatures = offer.addSignatures(signatures);
              updatedIntent.fallibleUnshieldedOffer = offerWithSignatures;
              return updatedIntent;
            },
            catch: (error) =>
              new TransactingError({
                message: `Failed to add fallible signature at segment ${segment}`,
                cause: error,
              }),
          });
        }

        transaction.intents = transaction.intents.set(segment, updatedIntent);

        return transaction;
      });
    },
    getSegments(transaction: ledger.UnprovenTransaction): number[] {
      return transaction.intents && transaction.intents.size > 0 ? transaction.intents.keys().toArray() : [];
    },
    bindTransaction(transaction: ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.PreBinding>) {
      return Either.try({
        try: () => transaction.bind(),
        catch: (error) => new TransactingError({ message: 'Failed to bind transaction', cause: error }),
      });
    },
    getImbalances(
      tx: ledger.FinalizedTransaction | ledger.UnprovenTransaction | ledger.ProofErasedTransaction,
    ): TransactionImbalances {
      const guaranteedImbalances = TransactionTrait.shared.getGuaranteedImbalances(tx);
      const fallibleImbalances = TransactionTrait.shared.getFallibleImbalances(tx);

      return pipe({
        guaranteed: guaranteedImbalances,
        fallible: fallibleImbalances,
        fees: 0n,
      });
    },
    getGuaranteedImbalances: (
      tx: ledger.FinalizedTransaction | ledger.UnprovenTransaction | ledger.ProofErasedTransaction,
    ): Imbalances => {
      const rawGuaranteedImbalances = tx
        .imbalances(0)
        .entries()
        .filter(([token]) => token.tag === 'shielded')
        .map(([token, value]) => {
          return [(token as { tag: 'shielded'; raw: string }).raw.toString(), value] as [string, bigint];
        });

      return Imbalances.fromEntries(rawGuaranteedImbalances);
    },
    getFallibleImbalances: (
      tx: ledger.FinalizedTransaction | ledger.UnprovenTransaction | ledger.ProofErasedTransaction,
    ): Imbalances => {
      try {
        const rawFallibleImbalances = tx
          .imbalances(1)
          .entries()
          .filter(([token]) => token.tag === 'shielded')
          .map(([token, value]) => {
            return [(token as { tag: 'shielded'; raw: string }).raw.toString(), value] as [string, bigint];
          });
        return Imbalances.fromEntries(rawFallibleImbalances);
      } catch {
        return Imbalances.empty();
      }
    },
  };
})();

================
File: package.json
================
{
  "packageManager": "yarn@4.10.3",
  "name": "@midnight-ntwrk/wallet-sdk-monorepo",
  "type": "module",
  "private": true,
  "workspaces": [
    "packages/*"
  ],
  "devDependencies": {
    "@changesets/cli": "^2.29.7",
    "@effect/language-service": "^0.43.2",
    "@eslint/compat": "^1.3.1",
    "@eslint/js": "^9.21.0",
    "@tsconfig/node20": "^20.1.4",
    "@types/node": "^22.17.0",
    "@vitest/coverage-v8": "^3.2.4",
    "@vitest/runner": "^3.2.4",
    "@vitest/ui": "4.0.8",
    "allure-js-commons": "^3.3.0",
    "allure-vitest": "^3.3.0",
    "dotenv": "^16.0.0",
    "eslint": "^9.32.0",
    "eslint-config-prettier": "^10.0.2",
    "eslint-plugin-prettier": "^5.2.3",
    "extensionless": "^1.9.9",
    "prettier": "^3.6.2",
    "rimraf": "^6.0.1",
    "tslib": "^2.8.1",
    "turbo": "^2.5.5",
    "typescript": "^5.9.3",
    "typescript-eslint": "^8.38.0",
    "vitest": "^3.2.4"
  },
  "resolutions": {
    "vite": "^7.1.11"
  },
  "scripts": {
    "format:root": "prettier --write --ignore-path .prettierignore.root \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format:check:root": "prettier --check --ignore-path .prettierignore.root \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format": "turbo run format",
    "format:check": "turbo run format:check",
    "verify": "turbo run verify",
    "verify:check": "turbo run verify:check",
    "verify:test": "turbo run verify:test",
    "publint": "turbo run publint",
    "typecheck": "turbo run typecheck",
    "lint": "turbo run lint",
    "test": "turbo run test",
    "dist": "turbo run dist",
    "dist:publish": "turbo run dist:publish",
    "changeset:publish": "yarn dist:publish && yarn changeset publish",
    "changeset:version": "yarn changeset version && yarn install --mode=update-lockfile",
    "changeset:check": "yarn changeset status --since=origin/main --verbose",
    "clean": "turbo run clean"
  }
}

================
File: packages/dust-wallet/package.json
================
{
  "name": "@midnight-ntwrk/wallet-sdk-dust-wallet",
  "version": "1.0.0-beta.11",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "author": "Midnight Foundation",
  "license": "Apache-2.0",
  "publishConfig": {
    "registry": "https://npm.pkg.github.com/"
  },
  "files": [
    "dist/"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/midnight-ntwrk/artifacts.git"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  },
  "dependencies": {
    "@midnight-ntwrk/ledger-v6": "6.1.0-alpha.6",
    "@midnight-ntwrk/wallet-sdk-abstractions": "1.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-address-format": "3.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-capabilities": "3.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-hd": "3.0.0-beta.7",
    "@midnight-ntwrk/wallet-sdk-indexer-client": "1.0.0-beta.13",
    "@midnight-ntwrk/wallet-sdk-node-client": "1.0.0-beta.10",
    "@midnight-ntwrk/wallet-sdk-prover-client": "1.0.0-beta.10",
    "@midnight-ntwrk/wallet-sdk-shielded": "1.0.0-beta.12",
    "@midnight-ntwrk/wallet-sdk-utilities": "1.0.0-beta.7",
    "effect": "^3.17.3",
    "rxjs": "^7.5"
  },
  "scripts": {
    "typecheck": "tsc -b ./tsconfig.json --noEmit",
    "test": "vitest run",
    "lint": "eslint --max-warnings 0",
    "format": "prettier --write \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format:check": "prettier --check \"**/*.{ts,js,json,yaml,yml,md}\"",
    "dist": "tsc -b ./tsconfig.build.json",
    "dist:publish": "tsc -b ./tsconfig.publish.json",
    "clean": "rimraf --glob dist 'tsconfig.*.tsbuildinfo' && date +%s > .clean-timestamp",
    "publint": "publint --strict"
  },
  "devDependencies": {
    "@types/node": "22.17.0",
    "eslint": "^9.37.0",
    "publint": "~0.3.14",
    "rimraf": "^6.0.1",
    "testcontainers": "^11.8.1",
    "typescript": "^5.9.3",
    "vitest": "^3.2.4"
  }
}

================
File: packages/facade/test/dustDeregistration.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ShieldedWallet } from '@midnight-ntwrk/wallet-sdk-shielded';
import { DefaultV1Configuration } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { randomUUID } from 'node:crypto';
import os from 'node:os';
import { DockerComposeEnvironment, StartedDockerComposeEnvironment, Wait } from 'testcontainers';
import { afterAll, afterEach, beforeAll, beforeEach, describe, expect, it, vi } from 'vitest';
import { getShieldedSeed, getUnshieldedSeed, getDustSeed, waitForFullySynced } from './utils.js';
import { buildTestEnvironmentVariables, getComposeDirectory } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import {
  createKeystore,
  PublicKey,
  InMemoryTransactionHistoryStorage,
  UnshieldedWallet,
} from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';
import * as rx from 'rxjs';
import { WalletFacade } from '../src/index.js';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { DustWallet } from '@midnight-ntwrk/wallet-sdk-dust-wallet';

vi.setConfig({ testTimeout: 200_000, hookTimeout: 120_000 });

const environmentId = randomUUID();

const environmentVars = buildTestEnvironmentVariables(['APP_INFRA_SECRET'], {
  additionalVars: {
    TESTCONTAINERS_UID: environmentId,
    RAYON_NUM_THREADS: Math.min(os.availableParallelism(), 32).toString(10),
  },
});

const environment = new DockerComposeEnvironment(getComposeDirectory(), 'docker-compose-dynamic.yml')
  .withWaitStrategy(
    `proof-server_${environmentId}`,
    Wait.forLogMessage('Actix runtime found; starting in Actix runtime'),
  )
  .withWaitStrategy(`node_${environmentId}`, Wait.forListeningPorts())
  .withWaitStrategy(`indexer_${environmentId}`, Wait.forLogMessage(/block indexed".*height":1,.*/gm))
  .withEnvironment(environmentVars)
  .withStartupTimeout(100_000);

describe('Dust Deregistration', () => {
  const SEED = '0000000000000000000000000000000000000000000000000000000000000003';

  const shieldedWalletSeed = getShieldedSeed(SEED);
  const unshieldedWalletSeed = getUnshieldedSeed(SEED);
  const dustWalletSeed = getDustSeed(SEED);

  const unshieldedWalletKeystore = createKeystore(unshieldedWalletSeed, NetworkId.NetworkId.Undeployed);

  let startedEnvironment: StartedDockerComposeEnvironment;
  let configuration: DefaultV1Configuration;

  beforeAll(async () => {
    startedEnvironment = await environment.up();

    configuration = {
      indexerClientConnection: {
        indexerHttpUrl: `http://localhost:${startedEnvironment.getContainer(`indexer_${environmentId}`).getMappedPort(8088)}/api/v3/graphql`,
        indexerWsUrl: `ws://localhost:${startedEnvironment.getContainer(`indexer_${environmentId}`).getMappedPort(8088)}/api/v3/graphql/ws`,
      },
      provingServerUrl: new URL(
        `http://localhost:${startedEnvironment.getContainer(`proof-server_${environmentId}`).getMappedPort(6300)}`,
      ),
      relayURL: new URL(
        `ws://127.0.0.1:${startedEnvironment.getContainer(`node_${environmentId}`).getMappedPort(9944)}`,
      ),
      networkId: NetworkId.NetworkId.Undeployed,
    };
  });

  afterAll(async () => {
    await startedEnvironment?.down({ timeout: 10_000 });
  });

  let walletFacade: WalletFacade;

  beforeEach(async () => {
    const Shielded = ShieldedWallet(configuration);
    const shieldedWallet = Shielded.startWithShieldedSeed(shieldedWalletSeed);

    const Dust = DustWallet({
      ...configuration,
      costParameters: {
        additionalFeeOverhead: 300_000_000_000_000n,
        feeBlocksMargin: 5,
      },
    });
    const dustParameters = ledger.LedgerParameters.initialParameters().dust;
    const dustWallet = Dust.startWithSeed(dustWalletSeed, dustParameters);

    const unshieldedWallet = UnshieldedWallet({
      ...configuration,
      txHistoryStorage: new InMemoryTransactionHistoryStorage(),
    }).startWithPublicKey(PublicKey.fromKeyStore(unshieldedWalletKeystore));

    walletFacade = new WalletFacade(shieldedWallet, unshieldedWallet, dustWallet);

    await walletFacade.start(
      ledger.ZswapSecretKeys.fromSeed(shieldedWalletSeed),
      ledger.DustSecretKey.fromSeed(dustWalletSeed),
    );
  });

  afterEach(async () => {
    await walletFacade.stop();
  });

  it('deregisters from dust generation', async () => {
    // NOTE: by default, our test account is already registered for Dust generation
    await waitForFullySynced(walletFacade);

    const walletStateWithNight = await rx.firstValueFrom(
      walletFacade.state().pipe(rx.filter((s) => s.unshielded.availableCoins.length > 0)),
    );

    const availableCoins = walletStateWithNight.dust.availableCoinsWithFullInfo(new Date());
    expect(availableCoins.every((availableCoins) => availableCoins.dtime === undefined)).toBeTruthy();

    const nightUtxos = walletStateWithNight.unshielded.availableCoins.filter(
      (coin) => coin.meta.registeredForDustGeneration === true,
    );

    const deregisterTokens = 2;
    const dustDeregistrationRecipe = await walletFacade.deregisterFromDustGeneration(
      nightUtxos.slice(0, deregisterTokens),
      unshieldedWalletKeystore.getPublicKey(),
      (payload) => unshieldedWalletKeystore.signData(payload),
    );

    const balancedTransactionRecipe = await walletFacade.balanceTransaction(
      ledger.ZswapSecretKeys.fromSeed(shieldedWalletSeed),
      ledger.DustSecretKey.fromSeed(dustWalletSeed),
      dustDeregistrationRecipe.transaction,
      new Date(Date.now() + 30 * 60 * 1000),
    );

    if (balancedTransactionRecipe.type !== 'TransactionToProve') {
      throw new Error('Expected a transaction to prove');
    }

    // NOTE: we don't sign the transaction via "walletFacade.signTransaction" as
    // the (de)registerFromDustGeneration method already adds the required signatures
    const finalizedDustTx = await walletFacade.finalizeTransaction(balancedTransactionRecipe);
    const dustDeregistrationTxHash = await walletFacade.submitTransaction(finalizedDustTx);

    expect(dustDeregistrationTxHash).toBeTypeOf('string');

    const newWalletState = await rx.firstValueFrom(
      walletFacade
        .state()
        .pipe(
          rx.filter((s) => s.unshielded.availableCoins.some((coin) => coin.meta.registeredForDustGeneration === false)),
        ),
    );

    const availableCoinsWithInfo = newWalletState.dust.availableCoinsWithFullInfo(new Date());
    expect(availableCoinsWithInfo.filter((coin) => coin.dtime !== undefined).length).toBe(deregisterTokens);
  });
});

================
File: packages/facade/test/swap.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ShieldedWallet } from '@midnight-ntwrk/wallet-sdk-shielded';
import { DefaultV1Configuration } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { randomUUID } from 'node:crypto';
import os from 'node:os';
import { DockerComposeEnvironment, StartedDockerComposeEnvironment, Wait } from 'testcontainers';
import { afterAll, afterEach, beforeAll, beforeEach, describe, expect, it, vi } from 'vitest';
import { getShieldedSeed, getUnshieldedSeed, getDustSeed, tokenValue, waitForFullySynced } from './utils.js';
import { buildTestEnvironmentVariables, getComposeDirectory } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import {
  InMemoryTransactionHistoryStorage,
  PublicKey,
  UnshieldedWallet,
  createKeystore,
} from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';
import * as rx from 'rxjs';
import { CombinedSwapInputs, CombinedSwapOutputs, WalletFacade } from '../src/index.js';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { DustWallet } from '@midnight-ntwrk/wallet-sdk-dust-wallet';
import { ShieldedAddress, UnshieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';

vi.setConfig({ testTimeout: 200_000, hookTimeout: 120_000 });

const environmentId = randomUUID();

const environmentVars = buildTestEnvironmentVariables(['APP_INFRA_SECRET'], {
  additionalVars: {
    TESTCONTAINERS_UID: environmentId,
    RAYON_NUM_THREADS: Math.min(os.availableParallelism(), 32).toString(10),
  },
});

const environment = new DockerComposeEnvironment(getComposeDirectory(), 'docker-compose-dynamic.yml')
  .withWaitStrategy(
    `proof-server_${environmentId}`,
    Wait.forLogMessage('Actix runtime found; starting in Actix runtime'),
  )
  .withWaitStrategy(`node_${environmentId}`, Wait.forListeningPorts())
  .withWaitStrategy(`indexer_${environmentId}`, Wait.forLogMessage(/block indexed".*height":1,.*/gm))
  .withEnvironment(environmentVars)
  .withStartupTimeout(100_000);

describe('Swaps', () => {
  const walletASeed = '0000000000000000000000000000000000000000000000000000000000000002';
  const walletBSeed = '0000000000000000000000000000000000000000000000000000000000000001';

  const shieldedWalletASeed = getShieldedSeed(walletASeed);
  const shieldedWalletBSeed = getShieldedSeed(walletBSeed);

  const unshieldedWalletASeed = getUnshieldedSeed(walletASeed);
  const unshieldedWalletBSeed = getUnshieldedSeed(walletBSeed);

  const dustWalletASeed = getDustSeed(walletASeed);
  const dustWalletBSeed = getDustSeed(walletBSeed);

  const unshieldedWalletAKeystore = createKeystore(unshieldedWalletASeed, NetworkId.NetworkId.Undeployed);
  const unshieldedWalletBKeystore = createKeystore(unshieldedWalletBSeed, NetworkId.NetworkId.Undeployed);

  let startedEnvironment: StartedDockerComposeEnvironment;
  let configuration: DefaultV1Configuration;

  beforeAll(async () => {
    startedEnvironment = await environment.up();

    configuration = {
      indexerClientConnection: {
        indexerHttpUrl: `http://localhost:${startedEnvironment.getContainer(`indexer_${environmentId}`).getMappedPort(8088)}/api/v3/graphql`,
        indexerWsUrl: `ws://localhost:${startedEnvironment.getContainer(`indexer_${environmentId}`).getMappedPort(8088)}/api/v3/graphql/ws`,
      },
      provingServerUrl: new URL(
        `http://localhost:${startedEnvironment.getContainer(`proof-server_${environmentId}`).getMappedPort(6300)}`,
      ),
      relayURL: new URL(
        `ws://127.0.0.1:${startedEnvironment.getContainer(`node_${environmentId}`).getMappedPort(9944)}`,
      ),
      networkId: NetworkId.NetworkId.Undeployed,
    };
  });

  afterAll(async () => {
    await startedEnvironment?.down({ timeout: 10_000 });
  });

  let walletAFacade: WalletFacade;
  let walletBFacade: WalletFacade;

  beforeEach(async () => {
    const Shielded = ShieldedWallet(configuration);
    const shieldedWalletA = Shielded.startWithShieldedSeed(shieldedWalletASeed);
    const shieldedWalletB = Shielded.startWithShieldedSeed(shieldedWalletBSeed);

    const unshieldedWalletA = UnshieldedWallet({
      ...configuration,
      txHistoryStorage: new InMemoryTransactionHistoryStorage(),
    }).startWithPublicKey(PublicKey.fromKeyStore(unshieldedWalletAKeystore));

    const unshieldedWalletB = UnshieldedWallet({
      ...configuration,
      txHistoryStorage: new InMemoryTransactionHistoryStorage(),
    }).startWithPublicKey(PublicKey.fromKeyStore(unshieldedWalletBKeystore));

    const Dust = DustWallet({
      ...configuration,
      costParameters: {
        additionalFeeOverhead: 900_000_000_000_000n,
        feeBlocksMargin: 5,
      },
    });
    const dustParameters = ledger.LedgerParameters.initialParameters().dust;
    const dustWalletA = Dust.startWithSeed(dustWalletASeed, dustParameters);
    const dustWalletB = Dust.startWithSeed(dustWalletBSeed, dustParameters);

    walletAFacade = new WalletFacade(shieldedWalletA, unshieldedWalletA, dustWalletA);
    walletBFacade = new WalletFacade(shieldedWalletB, unshieldedWalletB, dustWalletB);

    await Promise.all([
      walletAFacade.start(
        ledger.ZswapSecretKeys.fromSeed(shieldedWalletASeed),
        ledger.DustSecretKey.fromSeed(dustWalletASeed),
      ),
      walletBFacade.start(
        ledger.ZswapSecretKeys.fromSeed(shieldedWalletBSeed),
        ledger.DustSecretKey.fromSeed(dustWalletBSeed),
      ),
    ]);
  });

  afterEach(async () => {
    await Promise.all([walletAFacade.stop(), walletBFacade.stop()]);
  });

  it('can perform a shielded swap', async () => {
    await Promise.all([waitForFullySynced(walletAFacade), waitForFullySynced(walletBFacade)]);

    const { shielded: walletAShieldedStateBefore } = await rx.firstValueFrom(walletAFacade.state());
    const { shielded: walletBShieldedStateBefore } = await rx.firstValueFrom(walletBFacade.state());

    const nativeShieldedTokenType = '0000000000000000000000000000000000000000000000000000000000000002';
    const nativeShieldedTokenAmount = tokenValue(10n);

    const shieldedTokenType = ledger.shieldedToken().raw;
    const shieldedTokenAmount = tokenValue(10n);

    const ttl = new Date(Date.now() + 60 * 60 * 1000);

    const shieldedWalletAAddress = ShieldedAddress.codec
      .encode(NetworkId.NetworkId.Undeployed, await walletAFacade.shielded.getAddress())
      .asString();

    const desiredInputs: CombinedSwapInputs = {
      shielded: {
        [shieldedTokenType]: shieldedTokenAmount,
      },
    };

    const desiredOutputs: CombinedSwapOutputs[] = [
      {
        type: 'shielded',
        outputs: [
          {
            type: nativeShieldedTokenType,
            amount: nativeShieldedTokenAmount,
            receiverAddress: shieldedWalletAAddress,
          },
        ],
      },
    ];

    const swapTx = await walletAFacade.initSwap(
      ledger.ZswapSecretKeys.fromSeed(shieldedWalletASeed),
      desiredInputs,
      desiredOutputs,
      ttl,
    );

    const finalizedSwapTx = await walletAFacade.finalizeTransaction({
      type: 'TransactionToProve',
      transaction: swapTx,
    });

    // assuming the tx is submitted to a dex pool and another wallet (wallet B) picks it up

    const walletBBalancedTx = await walletBFacade.balanceTransaction(
      ledger.ZswapSecretKeys.fromSeed(shieldedWalletBSeed),
      ledger.DustSecretKey.fromSeed(dustWalletBSeed),
      finalizedSwapTx,
      new Date(Date.now() + 60 * 60 * 1000),
    );

    const finalizedTx = await walletBFacade.finalizeTransaction(walletBBalancedTx);

    const txHash = await walletBFacade.submitTransaction(finalizedTx);

    expect(txHash).toBeTypeOf('string');

    await Promise.all([
      rx.firstValueFrom(walletAFacade.state().pipe(rx.filter(({ shielded }) => shielded.pendingCoins.length === 0))),
      rx.firstValueFrom(walletBFacade.state().pipe(rx.filter(({ shielded }) => shielded.pendingCoins.length === 0))),
    ]);

    const { shielded: walletAShieldedStateAfter } = await rx.firstValueFrom(walletAFacade.state());
    const { shielded: walletBShieldedStateAfter } = await rx.firstValueFrom(walletBFacade.state());

    expect(walletAShieldedStateAfter.balances[shieldedTokenType]).toBe(
      walletAShieldedStateBefore.balances[shieldedTokenType] - shieldedTokenAmount,
    );
    expect(walletAShieldedStateAfter.balances[nativeShieldedTokenType]).toBe(
      walletAShieldedStateBefore.balances[nativeShieldedTokenType] + nativeShieldedTokenAmount,
    );

    expect(walletBShieldedStateAfter.balances[shieldedTokenType]).toBe(
      walletBShieldedStateBefore.balances[shieldedTokenType] + shieldedTokenAmount,
    );
    expect(walletBShieldedStateAfter.balances[nativeShieldedTokenType]).toBe(
      walletBShieldedStateBefore.balances[nativeShieldedTokenType] - nativeShieldedTokenAmount,
    );
  });

  /**
   * Disabled due to error validating Transaction: FeeCalculation(OutsideTimeToDismiss { time_to_dismiss: 15.494ms, allowed_time_to_dismiss: 15.000ms, size: 4601 })
   * We'll likely need to allow user to set payments in the fallible section of the transaction in order to avoid the issue above
   */
  it.skip('can perform an unshielded swap', async () => {
    await Promise.all([waitForFullySynced(walletAFacade), waitForFullySynced(walletBFacade)]);

    const ttl = new Date(Date.now() + 60 * 60 * 1000);

    const { unshielded: walletAUnshieldedStateBefore } = await rx.firstValueFrom(walletAFacade.state());
    const { unshielded: walletBUnshieldedStateBefore } = await rx.firstValueFrom(walletBFacade.state());

    const unshieldedTokenType = ledger.unshieldedToken().raw;
    const swapAmount = 1n;
    const swapForAmount = 2n;

    const desiredInputs: CombinedSwapInputs = {
      unshielded: {
        [unshieldedTokenType]: swapAmount,
      },
    };

    const desiredOutputs: CombinedSwapOutputs[] = [
      {
        type: 'unshielded',
        outputs: [
          {
            type: unshieldedTokenType,
            amount: swapForAmount,
            receiverAddress: UnshieldedAddress.codec
              .encode(configuration.networkId, walletAUnshieldedStateBefore.address)
              .asString(),
          },
        ],
      },
    ];

    const swapTx = await walletAFacade.initSwap(
      ledger.ZswapSecretKeys.fromSeed(shieldedWalletASeed),
      desiredInputs,
      desiredOutputs,
      ttl,
    );

    const signedSwapTx = await walletAFacade.signTransaction(swapTx, (payload) => {
      return unshieldedWalletAKeystore.signData(payload);
    });

    // assuming the tx is added to a pool and wallet B picks it up

    const walletBBalancedTx = await walletBFacade.balanceTransaction(
      ledger.ZswapSecretKeys.fromSeed(shieldedWalletBSeed),
      ledger.DustSecretKey.fromSeed(dustWalletBSeed),
      signedSwapTx,
      ttl,
    );

    if (walletBBalancedTx.type !== 'TransactionToProve') {
      throw new Error('Expected TransactionToProve');
    }

    const walletBSignedTx = await walletBFacade.signTransaction(walletBBalancedTx.transaction, (payload) => {
      return unshieldedWalletBKeystore.signData(payload);
    });

    const finalizedTx = await walletBFacade.finalizeTransaction({
      ...walletBBalancedTx,
      transaction: walletBSignedTx,
    });

    const txHash = await walletAFacade.submitTransaction(finalizedTx);

    expect(txHash).toBeTypeOf('string');

    await Promise.all([
      rx.firstValueFrom(
        walletAFacade.state().pipe(rx.filter(({ unshielded }) => unshielded.pendingCoins.length === 0)),
      ),
      rx.firstValueFrom(
        walletBFacade.state().pipe(rx.filter(({ unshielded }) => unshielded.pendingCoins.length === 0)),
      ),
    ]);

    const { unshielded: walletAUnshieldedStateAfter } = await rx.firstValueFrom(walletAFacade.state());
    const { unshielded: walletBUnshieldedStateAfter } = await rx.firstValueFrom(walletBFacade.state());

    expect(walletAUnshieldedStateAfter.balances[unshieldedTokenType]).toBe(
      walletAUnshieldedStateBefore.balances[unshieldedTokenType] - swapAmount + swapForAmount,
    );

    expect(walletBUnshieldedStateAfter.balances[unshieldedTokenType]).toBe(
      walletBUnshieldedStateBefore.balances[unshieldedTokenType] + swapAmount - swapForAmount,
    );
  });

  it.skip('can perform a combined shielded and unshielded swap', () => {
    throw new Error('Not supported yet. Will be implemented in future PR.');
  });
});

================
File: packages/facade/test/transfer.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ShieldedWallet } from '@midnight-ntwrk/wallet-sdk-shielded';
import { DefaultV1Configuration } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { randomUUID } from 'node:crypto';
import os from 'node:os';
import { DockerComposeEnvironment, StartedDockerComposeEnvironment, Wait } from 'testcontainers';
import { afterAll, afterEach, beforeAll, beforeEach, describe, expect, it, vi } from 'vitest';
import { getShieldedSeed, getUnshieldedSeed, getDustSeed, tokenValue, waitForFullySynced } from './utils.js';
import { buildTestEnvironmentVariables, getComposeDirectory } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import {
  InMemoryTransactionHistoryStorage,
  PublicKey,
  UnshieldedWallet,
  createKeystore,
} from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';
import * as rx from 'rxjs';
import { CombinedTokenTransfer, WalletFacade } from '../src/index.js';
import { ShieldedAddress, UnshieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { DustWallet } from '@midnight-ntwrk/wallet-sdk-dust-wallet';

vi.setConfig({ testTimeout: 200_000, hookTimeout: 200_000 });

const environmentId = randomUUID();

const environmentVars = buildTestEnvironmentVariables(['APP_INFRA_SECRET'], {
  additionalVars: {
    TESTCONTAINERS_UID: environmentId,
    RAYON_NUM_THREADS: Math.min(os.availableParallelism(), 32).toString(10),
  },
});

const environment = new DockerComposeEnvironment(getComposeDirectory(), 'docker-compose-dynamic.yml')
  .withWaitStrategy(
    `proof-server_${environmentId}`,
    Wait.forLogMessage('Actix runtime found; starting in Actix runtime'),
  )
  .withWaitStrategy(`node_${environmentId}`, Wait.forListeningPorts())
  .withWaitStrategy(`indexer_${environmentId}`, Wait.forLogMessage(/block indexed".*height":1,.*/gm))
  .withEnvironment(environmentVars)
  .withStartupTimeout(100_000);

describe('Wallet Facade Transfer', () => {
  const SENDER_SEED = '0000000000000000000000000000000000000000000000000000000000000001';
  const RECEIVER_SEED = '0000000000000000000000000000000000000000000000000000000000001111';

  const shieldedSenderSeed = getShieldedSeed(SENDER_SEED);
  const shieldedReceiverSeed = getShieldedSeed(RECEIVER_SEED);

  const unshieldedSenderSeed = getUnshieldedSeed(SENDER_SEED);
  const unshieldedReceiverSeed = getUnshieldedSeed(RECEIVER_SEED);

  const dustSenderSeed = getDustSeed(SENDER_SEED);
  const dustReceiverSeed = getDustSeed(RECEIVER_SEED);

  const unshieldedSenderKeystore = createKeystore(unshieldedSenderSeed, NetworkId.NetworkId.Undeployed);
  const unshieldedReceiverKeystore = createKeystore(unshieldedReceiverSeed, NetworkId.NetworkId.Undeployed);

  let startedEnvironment: StartedDockerComposeEnvironment;
  let configuration: DefaultV1Configuration;

  beforeAll(async () => {
    startedEnvironment = await environment.up();

    configuration = {
      indexerClientConnection: {
        indexerHttpUrl: `http://localhost:${startedEnvironment.getContainer(`indexer_${environmentId}`).getMappedPort(8088)}/api/v3/graphql`,
        indexerWsUrl: `ws://localhost:${startedEnvironment.getContainer(`indexer_${environmentId}`).getMappedPort(8088)}/api/v3/graphql/ws`,
      },
      provingServerUrl: new URL(
        `http://localhost:${startedEnvironment.getContainer(`proof-server_${environmentId}`).getMappedPort(6300)}`,
      ),
      relayURL: new URL(
        `ws://127.0.0.1:${startedEnvironment.getContainer(`node_${environmentId}`).getMappedPort(9944)}`,
      ),
      networkId: NetworkId.NetworkId.Undeployed,
    };
  });

  afterAll(async () => {
    await startedEnvironment?.down({ timeout: 10_000 });
  });

  let senderFacade: WalletFacade;
  let receiverFacade: WalletFacade;

  beforeEach(async () => {
    const Shielded = ShieldedWallet(configuration);
    const shieldedSender = Shielded.startWithShieldedSeed(shieldedSenderSeed);
    const shieldedReceiver = Shielded.startWithShieldedSeed(shieldedReceiverSeed);

    const Dust = DustWallet({
      ...configuration,
      costParameters: {
        additionalFeeOverhead: 300_000_000_000_000n,
        feeBlocksMargin: 5,
      },
    });
    const dustParameters = ledger.LedgerParameters.initialParameters().dust;
    const dustSender = Dust.startWithSeed(dustSenderSeed, dustParameters);
    const dustReceiver = Dust.startWithSeed(dustReceiverSeed, dustParameters);

    const unshieldedSender = UnshieldedWallet({
      ...configuration,
      txHistoryStorage: new InMemoryTransactionHistoryStorage(),
    }).startWithPublicKey(PublicKey.fromKeyStore(unshieldedSenderKeystore));

    const unshieldedReceiver = UnshieldedWallet({
      ...configuration,
      txHistoryStorage: new InMemoryTransactionHistoryStorage(),
    }).startWithPublicKey(PublicKey.fromKeyStore(unshieldedReceiverKeystore));

    senderFacade = new WalletFacade(shieldedSender, unshieldedSender, dustSender);
    receiverFacade = new WalletFacade(shieldedReceiver, unshieldedReceiver, dustReceiver);

    await Promise.all([
      senderFacade.start(
        ledger.ZswapSecretKeys.fromSeed(shieldedSenderSeed),
        ledger.DustSecretKey.fromSeed(dustSenderSeed),
      ),
      receiverFacade.start(
        ledger.ZswapSecretKeys.fromSeed(shieldedReceiverSeed),
        ledger.DustSecretKey.fromSeed(dustReceiverSeed),
      ),
    ]);
  });

  afterEach(async () => {
    await Promise.all([senderFacade.stop(), receiverFacade.stop()]);
  });

  it('allows to transfer shielded tokens only', async () => {
    await Promise.all([waitForFullySynced(senderFacade), waitForFullySynced(receiverFacade)]);

    const ledgerReceiverAddress = ShieldedAddress.codec
      .encode(configuration.networkId, await receiverFacade.shielded.getAddress())
      .asString();

    const ttl = new Date(Date.now() + 60 * 60 * 1000);
    const transfer = await senderFacade.transferTransaction(
      ledger.ZswapSecretKeys.fromSeed(shieldedSenderSeed),
      ledger.DustSecretKey.fromSeed(dustSenderSeed),
      [
        {
          type: 'shielded',
          outputs: [
            {
              type: ledger.shieldedToken().raw,
              receiverAddress: ledgerReceiverAddress,
              amount: tokenValue(1n),
            },
          ],
        },
      ],
      ttl,
    );

    const finalizedTx = await senderFacade.finalizeTransaction(transfer);

    const submittedTxHash = await senderFacade.submitTransaction(finalizedTx);

    expect(submittedTxHash).toBeTypeOf('string');

    const isValid = await rx.firstValueFrom(
      receiverFacade
        .state()
        .pipe(rx.filter((s) => s.shielded.availableCoins.some((c) => c.coin.value === tokenValue(1n)))),
    );

    expect(isValid).toBeTruthy();
  });

  it('allows to transfer unshielded tokens', async () => {
    await Promise.all([waitForFullySynced(senderFacade), waitForFullySynced(receiverFacade)]);

    const unshieldedReceiverState = await rx.firstValueFrom(receiverFacade.unshielded.state);

    const tokenTransfer: CombinedTokenTransfer[] = [
      {
        type: 'unshielded',
        outputs: [
          {
            amount: tokenValue(1n),
            receiverAddress: UnshieldedAddress.codec
              .encode(configuration.networkId, unshieldedReceiverState.address)
              .asString(),
            type: ledger.unshieldedToken().raw,
          },
        ],
      },
    ];

    const ttl = new Date(Date.now() + 30 * 60 * 1000);
    const recipe = await senderFacade.transferTransaction(
      ledger.ZswapSecretKeys.fromSeed(shieldedSenderSeed),
      ledger.DustSecretKey.fromSeed(dustSenderSeed),
      tokenTransfer,
      ttl,
    );

    const signedTx = await senderFacade.signTransaction(recipe.transaction, (payload) =>
      unshieldedSenderKeystore.signData(payload),
    );

    const finalizedTx = await senderFacade.finalizeTransaction({
      ...recipe,
      transaction: signedTx,
    });

    const submittedTxHash = await senderFacade.submitTransaction(finalizedTx);

    expect(submittedTxHash).toBeTruthy();

    const isValid = await rx.firstValueFrom(
      receiverFacade
        .state()
        .pipe(rx.filter((s) => s.unshielded.availableCoins.some((c) => c.utxo.value === tokenValue(1n)))),
    );

    expect(isValid).toBeTruthy();
  });

  it('allows to balance and submit an arbitrary shielded transaction', async () => {
    await waitForFullySynced(senderFacade);

    const shieldedReceiverState = await rx.firstValueFrom(receiverFacade.shielded.state);

    const transfer = {
      type: ledger.shieldedToken().raw,
      amount: tokenValue(1n),
    };

    const coin = ledger.createShieldedCoinInfo(transfer.type, transfer.amount);

    const output = ledger.ZswapOutput.new(
      coin,
      0,
      shieldedReceiverState.address.coinPublicKey.toHexString(),
      shieldedReceiverState.address.encryptionPublicKey.toHexString(),
    );

    const outputOffer = ledger.ZswapOffer.fromOutput(output, transfer.type, transfer.amount);

    const arbitraryTx = ledger.Transaction.fromParts(configuration.networkId, outputOffer);

    const provenArbitraryTx = await senderFacade.shielded.finalizeTransaction({
      type: 'TransactionToProve',
      transaction: arbitraryTx,
    });

    const balancedTx = await senderFacade.balanceTransaction(
      ledger.ZswapSecretKeys.fromSeed(shieldedSenderSeed),
      ledger.DustSecretKey.fromSeed(dustSenderSeed),
      provenArbitraryTx,
      new Date(Date.now() + 30 * 60 * 1000),
    );

    const finalizedTx = await senderFacade.finalizeTransaction(balancedTx);

    const submittedTxHash = await senderFacade.submitTransaction(finalizedTx);

    expect(submittedTxHash).toBeTypeOf('string');

    const isValid = await rx.firstValueFrom(
      receiverFacade
        .state()
        .pipe(rx.filter((s) => s.shielded.availableCoins.some((c) => c.coin.value === tokenValue(1n)))),
    );

    expect(isValid).toBeTruthy();
  });

  it('allows to balance and submit an arbitrary unshielded transaction', async () => {
    await waitForFullySynced(senderFacade);

    const outputs = [
      {
        type: ledger.unshieldedToken().raw,
        value: tokenValue(1n),
        owner: unshieldedReceiverKeystore.getAddress(),
      },
    ];

    const intent = ledger.Intent.new(new Date(Date.now() + 30 * 60 * 1000));
    intent.guaranteedUnshieldedOffer = ledger.UnshieldedOffer.new([], outputs, []);

    const arbitraryTx = ledger.Transaction.fromParts(NetworkId.NetworkId.Undeployed, undefined, undefined, intent);

    const recipe = await senderFacade.balanceTransaction(
      ledger.ZswapSecretKeys.fromSeed(shieldedSenderSeed),
      ledger.DustSecretKey.fromSeed(dustSenderSeed),
      arbitraryTx,
      new Date(Date.now() + 30 * 60 * 1000),
    );

    if (recipe.type !== 'TransactionToProve') {
      throw new Error('Expected a transaction to prove');
    }

    const signedTx = await senderFacade.signTransaction(recipe.transaction, (payload) =>
      unshieldedSenderKeystore.signData(payload),
    );

    const finalizedTx = await senderFacade.finalizeTransaction({
      ...recipe,
      transaction: signedTx,
    });

    const submittedTxHash = await senderFacade.submitTransaction(finalizedTx);

    expect(submittedTxHash).toBeTypeOf('string');

    const isValid = await rx.firstValueFrom(
      receiverFacade
        .state()
        .pipe(rx.filter((s) => s.unshielded.availableCoins.some((c) => c.utxo.value === tokenValue(1n)))),
    );

    expect(isValid).toBeTruthy();
  });
});

================
File: packages/facade/package.json
================
{
  "name": "@midnight-ntwrk/wallet-sdk-facade",
  "version": "1.0.0-beta.12",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "author": "Midnight Foundation",
  "license": "Apache-2.0",
  "publishConfig": {
    "registry": "https://npm.pkg.github.com/"
  },
  "files": [
    "dist/"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/midnight-ntwrk/artifacts.git"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  },
  "dependencies": {
    "@midnight-ntwrk/ledger-v6": "6.1.0-alpha.6",
    "@midnight-ntwrk/wallet-sdk-abstractions": "1.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-address-format": "3.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-dust-wallet": "1.0.0-beta.11",
    "@midnight-ntwrk/wallet-sdk-hd": "3.0.0-beta.7",
    "@midnight-ntwrk/wallet-sdk-shielded": "1.0.0-beta.12",
    "@midnight-ntwrk/wallet-sdk-unshielded-wallet": "1.0.0-beta.14",
    "rxjs": "^7.5"
  },
  "devDependencies": {
    "eslint": "^9.37.0",
    "publint": "~0.3.14",
    "rimraf": "^6.0.1",
    "testcontainers": "^11.8.1",
    "typescript": "^5.9.3",
    "vitest": "^3.2.4"
  },
  "scripts": {
    "typecheck": "tsc -b ./tsconfig.json --noEmit",
    "test": "vitest run",
    "lint": "eslint --max-warnings 0",
    "format": "prettier --write \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format:check": "prettier --check \"**/*.{ts,js,json,yaml,yml,md}\"",
    "dist": "tsc -b ./tsconfig.build.json",
    "dist:publish": "tsc -b ./tsconfig.publish.json",
    "clean": "rimraf --glob dist 'tsconfig.*.tsbuildinfo' && date +%s > .clean-timestamp",
    "publint": "publint --strict"
  }
}

================
File: packages/shielded-wallet/package.json
================
{
  "name": "@midnight-ntwrk/wallet-sdk-shielded",
  "version": "1.0.0-beta.12",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "author": "Midnight Foundation",
  "license": "Apache-2.0",
  "publishConfig": {
    "registry": "https://npm.pkg.github.com/"
  },
  "files": [
    "dist/"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/midnight-ntwrk/artifacts.git"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    },
    "./v1": {
      "types": "./dist/v1/index.d.ts",
      "import": "./dist/v1/index.js"
    }
  },
  "dependencies": {
    "@midnight-ntwrk/ledger-v6": "6.1.0-alpha.6",
    "@midnight-ntwrk/wallet-sdk-abstractions": "1.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-address-format": "3.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-capabilities": "3.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-indexer-client": "1.0.0-beta.13",
    "@midnight-ntwrk/wallet-sdk-node-client": "1.0.0-beta.10",
    "@midnight-ntwrk/wallet-sdk-prover-client": "1.0.0-beta.10",
    "@midnight-ntwrk/wallet-sdk-runtime": "1.0.0-beta.8",
    "@midnight-ntwrk/wallet-sdk-utilities": "1.0.0-beta.7",
    "@scure/base": "^1.1.9",
    "effect": "^3.17.3",
    "isomorphic-ws": "^5.0.0",
    "node-fetch": "3.3.2",
    "rxjs": "^7.5",
    "scale-ts": "^1.1.0",
    "ws": "^8.18.3"
  },
  "scripts": {
    "typecheck": "tsc -b ./tsconfig.json --noEmit",
    "test": "vitest run",
    "lint": "eslint --max-warnings 0",
    "format": "prettier --write \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format:check": "prettier --check \"**/*.{ts,js,json,yaml,yml,md}\"",
    "dist": "tsc -b ./tsconfig.build.json",
    "dist:publish": "tsc -b ./tsconfig.publish.json",
    "clean": "rimraf --glob dist 'tsconfig.*.tsbuildinfo' && date +%s > .clean-timestamp",
    "publint": "publint --strict"
  },
  "devDependencies": {
    "@effect/cluster": "^0.46.2",
    "@effect/experimental": "^0.54.2",
    "@effect/platform": "^0.90.0",
    "@effect/platform-node": "^0.94.0",
    "@effect/rpc": "^0.68.0",
    "@effect/sql": "^0.44.0",
    "@effect/workflow": "^0.8.1",
    "@polkadot/types": "^16.4.1",
    "eslint": "^9.37.0",
    "fast-check": "^4.2.0",
    "publint": "~0.3.14",
    "rimraf": "^6.0.1",
    "testcontainers": "^11.8.1",
    "to-words": "^4.5.1",
    "typescript": "^5.9.3",
    "vitest": "^3.2.4"
  }
}

================
File: packages/unshielded-wallet/src/v1/CoreWallet.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { createSyncProgress, SyncProgress, SyncProgressData } from './SyncProgress.js';
import { PublicKey } from '../KeyStore.js';
import { UnshieldedState, UnshieldedUpdate } from './UnshieldedState.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Either, Array as Arr, pipe } from 'effect';
import { ApplyTransactionError, RollbackUtxoError, SpendUtxoError, WalletError } from './WalletError.js';

export type CoreWallet = Readonly<{
  state: UnshieldedState;
  publicKey: PublicKey;
  protocolVersion: ProtocolVersion.ProtocolVersion;
  progress: SyncProgress;
  networkId: string;
}>;

export const CoreWallet = {
  init(publicKey: PublicKey, networkId: string): CoreWallet {
    return {
      state: UnshieldedState.empty(),
      publicKey,
      protocolVersion: ProtocolVersion.MinSupportedVersion,
      progress: createSyncProgress(),
      networkId,
    };
  },

  restore(
    state: UnshieldedState,
    publicKey: PublicKey,
    syncProgress: Omit<SyncProgressData, 'isConnected'>,
    protocolVersion: ProtocolVersion.ProtocolVersion,
    networkId: string,
  ): CoreWallet {
    return {
      state,
      publicKey,
      protocolVersion,
      progress: createSyncProgress(syncProgress),
      networkId,
    };
  },

  updateProgress(
    wallet: CoreWallet,
    { appliedId, highestTransactionId, isConnected }: Partial<SyncProgressData>,
  ): CoreWallet {
    const progress = createSyncProgress({
      appliedId: appliedId ?? wallet.progress.appliedId,
      highestTransactionId: highestTransactionId ?? wallet.progress.highestTransactionId,
      isConnected: isConnected ?? wallet.progress.isConnected,
    });
    return { ...wallet, progress };
  },

  applyUpdate(coreWallet: CoreWallet, update: UnshieldedUpdate): Either.Either<CoreWallet, WalletError> {
    return UnshieldedState.applyUpdate(coreWallet.state, update).pipe(
      Either.map((state) => ({ ...coreWallet, state })),
      Either.mapLeft((error) => new ApplyTransactionError(error)),
    );
  },

  applyFailedUpdate(coreWallet: CoreWallet, update: UnshieldedUpdate): Either.Either<CoreWallet, WalletError> {
    return UnshieldedState.applyFailedUpdate(coreWallet.state, update).pipe(
      Either.map((state) => ({ ...coreWallet, state })),
      Either.mapLeft((error) => new ApplyTransactionError(error)),
    );
  },

  rollbackUtxo(coreWallet: CoreWallet, utxo: ledger.Utxo): Either.Either<CoreWallet, WalletError> {
    return UnshieldedState.rollbackSpendByUtxo(coreWallet.state, utxo).pipe(
      Either.map((state) => ({ ...coreWallet, state })),
      Either.mapLeft((error) => new RollbackUtxoError(error)),
    );
  },

  spend(coreWallet: CoreWallet, utxo: ledger.Utxo): Either.Either<CoreWallet, WalletError> {
    return UnshieldedState.spendByUtxo(coreWallet.state, utxo).pipe(
      Either.map((state) => ({ ...coreWallet, state })),
      Either.mapLeft((error) => new SpendUtxoError(error)),
    );
  },

  spendUtxos(
    wallet: CoreWallet,
    utxos: ReadonlyArray<ledger.Utxo>,
  ): Either.Either<[ReadonlyArray<ledger.Utxo>, CoreWallet], WalletError> {
    return pipe(
      utxos,
      Arr.reduce(
        Either.right([[], wallet.state]) as Either.Either<[ledger.Utxo[], UnshieldedState], WalletError>,
        (acc, utxoToSpend) =>
          acc.pipe(
            Either.flatMap(([accUtxos, state]) =>
              UnshieldedState.spendByUtxo(state, utxoToSpend).pipe(
                Either.map(
                  (nextState) => [accUtxos.concat([utxoToSpend]), nextState] as [ledger.Utxo[], UnshieldedState],
                ),
                Either.mapLeft((error) => new SpendUtxoError(error)),
              ),
            ),
          ),
      ),
      Either.map(
        ([spentUtxos, state]) => [spentUtxos, { ...wallet, state }] as [ReadonlyArray<ledger.Utxo>, CoreWallet],
      ),
    );
  },
};

================
File: packages/unshielded-wallet/src/v1/index.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
export * from './V1Builder.js';
export * as Sync from './Sync.js';
export * as SyncProgress from './SyncProgress.js';
export * as Transacting from './Transacting.js';
export * as TransactionHistory from './TransactionHistory.js';
export * as Serialization from './Serialization.js';
export * as CoinsAndBalances from './CoinsAndBalances.js';
export * as Keys from './Keys.js';
export * from './RunningV1Variant.js';
export * as Simulator from './Simulator.js';
export * as WalletError from './WalletError.js';
export * from './CoreWallet.js';
export * from './Transaction.js';
export * as TransactionHistoryStorage from '../storage/index.js';
export * as UnshieldedState from './UnshieldedState.js';

================
File: packages/unshielded-wallet/src/v1/Serialization.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Either, pipe, Schema } from 'effect';
import { WalletError } from './WalletError.js';
import { CoreWallet } from './CoreWallet.js';
import { NetworkId, ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { UnshieldedState } from './UnshieldedState.js';

export type SerializationCapability<TWallet, TSerialized> = {
  serialize(wallet: TWallet): TSerialized;
  deserialize(data: TSerialized): Either.Either<TWallet, WalletError>;
};

export type DefaultSerializationConfiguration = {
  networkId: NetworkId.NetworkId;
};

export const makeDefaultV1SerializationCapability = (): SerializationCapability<CoreWallet, string> => {
  const UtxoWithMetaSchema = Schema.Struct({
    utxo: Schema.Struct({
      value: Schema.BigInt,
      owner: Schema.String,
      type: Schema.String,
      intentHash: Schema.String,
      outputNo: Schema.Number,
    }),
    meta: Schema.Struct({
      ctime: Schema.Date,
      registeredForDustGeneration: Schema.Boolean,
    }),
  });

  const SnapshotSchema = Schema.Struct({
    publicKey: Schema.Struct({
      publicKey: Schema.String,
      addressHex: Schema.String,
      address: Schema.String,
    }),
    state: Schema.Struct({
      availableUtxos: Schema.Array(UtxoWithMetaSchema),
      pendingUtxos: Schema.Array(UtxoWithMetaSchema),
    }),
    protocolVersion: Schema.BigInt,
    appliedId: Schema.optional(Schema.BigInt),
    networkId: Schema.String,
  });

  type Snapshot = Schema.Schema.Type<typeof SnapshotSchema>;
  return {
    serialize: (wallet) => {
      const buildSnapshot = (w: CoreWallet): Snapshot => ({
        publicKey: w.publicKey,
        state: UnshieldedState.toArrays(w.state),
        protocolVersion: w.protocolVersion,
        networkId: w.networkId,
        appliedId: w.progress?.appliedId,
      });

      return pipe(wallet, buildSnapshot, Schema.encodeSync(SnapshotSchema), JSON.stringify);
    },
    deserialize: (serialized): Either.Either<CoreWallet, WalletError> =>
      pipe(
        serialized,
        Schema.decodeUnknownEither(Schema.parseJson(SnapshotSchema)),
        Either.mapLeft((err) => WalletError.other(err)),
        Either.map((snapshot) => {
          return CoreWallet.restore(
            UnshieldedState.restore(snapshot.state.availableUtxos, snapshot.state.pendingUtxos),
            snapshot.publicKey,
            {
              highestTransactionId: snapshot.appliedId ?? 0n,
              appliedId: snapshot.appliedId ?? 0n,
            },
            ProtocolVersion.ProtocolVersion(snapshot.protocolVersion),
            snapshot.networkId,
          );
        }),
      ),
  };
};

================
File: packages/unshielded-wallet/src/v1/Sync.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Scope, Stream, Schema, pipe, Either } from 'effect';
import { CoreWallet } from './CoreWallet.js';
import { Simulator, SimulatorState } from './Simulator.js';
import { UnshieldedTransactions } from '@midnight-ntwrk/wallet-sdk-indexer-client';
import { WsSubscriptionClient, ConnectionHelper } from '@midnight-ntwrk/wallet-sdk-indexer-client/effect';
import { SyncWalletError, WalletError } from './WalletError.js';
import { WsURL } from '@midnight-ntwrk/wallet-sdk-utilities/networking';
import { TransactionHistoryService } from './TransactionHistory.js';
import { EitherOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import { WalletSyncUpdate, WalletSyncUpdateSchema } from './SyncSchema.js';

export interface SyncService<TState, TUpdate> {
  updates: (state: TState) => Stream.Stream<TUpdate, WalletError, Scope.Scope>;
}

export interface SyncCapability<TState, TUpdate> {
  applyUpdate: (state: TState, update: TUpdate) => Either.Either<TState, WalletError>;
}

export type IndexerClientConnection = {
  indexerHttpUrl: string;
  indexerWsUrl?: string;
};

export type DefaultSyncConfiguration = {
  indexerClientConnection: IndexerClientConnection;
};

export type DefaultSyncContext = {
  transactionHistoryService: TransactionHistoryService<WalletSyncUpdate>;
};

export const makeDefaultSyncService = (config: DefaultSyncConfiguration): SyncService<CoreWallet, WalletSyncUpdate> => {
  return {
    updates: (state: CoreWallet): Stream.Stream<WalletSyncUpdate, WalletError, Scope.Scope> => {
      const { indexerClientConnection } = config;

      const webSocketUrlResult = ConnectionHelper.createWebSocketUrl(
        indexerClientConnection.indexerHttpUrl,
        indexerClientConnection.indexerWsUrl,
      );

      if (Either.isLeft(webSocketUrlResult)) {
        return Stream.fail(
          new SyncWalletError(
            new Error(`Could not derive WebSocket URL from indexer HTTP URL: ${webSocketUrlResult.left.message}`),
          ),
        );
      }

      const indexerWsUrlResult = WsURL.make(webSocketUrlResult.right);

      if (Either.isLeft(indexerWsUrlResult)) {
        return Stream.fail(
          new SyncWalletError(new Error(`Invalid indexer WS URL: ${indexerWsUrlResult.left.message}`)),
        );
      }

      const indexerWsUrl = indexerWsUrlResult.right;

      const { appliedId } = state.progress;
      const { address } = state.publicKey;

      return pipe(
        UnshieldedTransactions.run({ address, transactionId: Number(appliedId) }),
        Stream.provideLayer(WsSubscriptionClient.layer({ url: indexerWsUrl })),
        Stream.mapError((error) => new SyncWalletError(error)),
        Stream.mapEffect((subscription) => {
          const { unshieldedTransactions } = subscription;

          return pipe(
            Schema.decodeUnknownEither(WalletSyncUpdateSchema)(unshieldedTransactions),
            Either.mapLeft((err) => new SyncWalletError(err)),
            EitherOps.toEffect,
          );
        }),
      );
    },
  };
};

export const makeDefaultSyncCapability = (
  _config: DefaultSyncConfiguration,
  getContext: () => DefaultSyncContext,
): SyncCapability<CoreWallet, WalletSyncUpdate> => {
  return {
    applyUpdate: (state: CoreWallet, update: WalletSyncUpdate): Either.Either<CoreWallet, WalletError> => {
      if (update.type === 'UnshieldedTransactionsProgress') {
        return Either.right(
          CoreWallet.updateProgress(state, {
            highestTransactionId: BigInt(update.highestTransactionId),
            isConnected: true,
          }),
        );
      } else {
        const updatePayload = {
          createdUtxos: update.createdUtxos,
          spentUtxos: update.spentUtxos,
          status: update.status,
        };

        const stateAfterApplyingUpdate =
          update.status === 'FAILURE'
            ? CoreWallet.applyFailedUpdate(state, updatePayload)
            : CoreWallet.applyUpdate(state, updatePayload);

        return stateAfterApplyingUpdate.pipe(
          Either.map((wallet) => {
            const stateAfterUpdatingProgress = CoreWallet.updateProgress(wallet, {
              appliedId: BigInt(update.transaction.id),
            });

            const { transactionHistoryService } = getContext();
            void transactionHistoryService.create(update);

            return stateAfterUpdatingProgress;
          }),
        );
      }
    },
  };
};

export type SimulatorSyncConfiguration = {
  simulator: Simulator;
};

export type SimulatorSyncUpdate = {
  update: SimulatorState;
};

export const makeSimulatorSyncService = (
  config: SimulatorSyncConfiguration,
): SyncService<CoreWallet, SimulatorSyncUpdate> => {
  return {
    updates: (_state: CoreWallet) => config.simulator.state$.pipe(Stream.map((state) => ({ update: state }))),
  };
};

export const makeSimulatorSyncCapability = (): SyncCapability<CoreWallet, SimulatorSyncUpdate> => {
  return {
    applyUpdate: (state: CoreWallet, _update: SimulatorSyncUpdate) => {
      return Either.right(state);
      // return CoreWallet.replayEvents(state, secretKeys, events);
    },
  };
};

================
File: packages/unshielded-wallet/src/v1/TransactionHistory.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { TransactionHistoryStorage, TransactionHistoryEntry, TransactionHash } from '../storage/index.js';
import { UnshieldedUpdate } from './SyncSchema.js';

export interface TransactionHistoryService<SyncUpdate> {
  create(update: SyncUpdate): Promise<void>;
  get(hash: TransactionHash): Promise<TransactionHistoryEntry | undefined>;
  getAll(): AsyncIterableIterator<TransactionHistoryEntry>;
  delete(hash: TransactionHash): Promise<TransactionHistoryEntry | undefined>;
}

export type DefaultTransactionHistoryConfiguration = {
  txHistoryStorage: TransactionHistoryStorage;
};

const convertUpdateToEntry = ({ transaction, status }: UnshieldedUpdate): TransactionHistoryEntry => {
  return {
    id: transaction.id,
    hash: transaction.hash,
    protocolVersion: transaction.protocolVersion,
    identifiers: transaction.identifiers ? transaction.identifiers : [],
    status,
    timestamp: transaction.block?.timestamp ?? null,
    fees: transaction.fees?.paidFees ?? null,
  };
};

export const makeDefaultTransactionHistoryService = (
  config: DefaultTransactionHistoryConfiguration,
  _getContext: () => unknown,
): TransactionHistoryService<UnshieldedUpdate> => {
  const { txHistoryStorage } = config;

  return {
    create: async (update: UnshieldedUpdate): Promise<void> => {
      const entry = convertUpdateToEntry(update);
      await txHistoryStorage.create(entry);
    },
    get: async (hash: TransactionHash): Promise<TransactionHistoryEntry | undefined> => {
      return await txHistoryStorage.get(hash);
    },
    getAll: (): AsyncIterableIterator<TransactionHistoryEntry> => {
      return txHistoryStorage.getAll();
    },
    delete: async (hash: TransactionHash): Promise<TransactionHistoryEntry | undefined> => {
      return txHistoryStorage.delete(hash);
    },
  };
};

================
File: packages/unshielded-wallet/src/v1/UnshieldedState.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Data, Either, HashMap } from 'effect';
import { ApplyTransactionError, UtxoNotFoundError } from './WalletError.js';

export interface UtxoMeta {
  readonly ctime: Date;
  readonly registeredForDustGeneration: boolean;
}

export type UtxoHash = string;

export class UtxoWithMeta extends Data.Class<{
  readonly utxo: ledger.Utxo;
  readonly meta: UtxoMeta;
}> {}

export type UpdateStatus = 'SUCCESS' | 'FAILURE' | 'PARTIAL_SUCCESS';

export interface UnshieldedUpdate {
  readonly createdUtxos: readonly UtxoWithMeta[];
  readonly spentUtxos: readonly UtxoWithMeta[];
  readonly status: UpdateStatus;
}

export interface UnshieldedState {
  readonly availableUtxos: HashMap.HashMap<UtxoHash, UtxoWithMeta>;
  readonly pendingUtxos: HashMap.HashMap<UtxoHash, UtxoWithMeta>;
}

const UtxoHash = (utxo: ledger.Utxo): UtxoHash => `${utxo.intentHash}#${utxo.outputNo}`;

export const UnshieldedState = {
  empty: (): UnshieldedState => ({
    availableUtxos: HashMap.empty(),
    pendingUtxos: HashMap.empty(),
  }),

  restore: (availableUtxos: readonly UtxoWithMeta[], pendingUtxos: readonly UtxoWithMeta[]): UnshieldedState => ({
    availableUtxos: HashMap.fromIterable(availableUtxos.map((utxo) => [UtxoHash(utxo.utxo), utxo])),
    pendingUtxos: HashMap.fromIterable(pendingUtxos.map((utxo) => [UtxoHash(utxo.utxo), utxo])),
  }),

  spend: (state: UnshieldedState, utxo: UtxoWithMeta): Either.Either<UnshieldedState, UtxoNotFoundError> =>
    Either.gen(function* () {
      const hash = UtxoHash(utxo.utxo);
      if (!HashMap.has(state.availableUtxos, hash)) {
        return yield* Either.left(new UtxoNotFoundError({ utxo: utxo.utxo }));
      }
      return {
        availableUtxos: HashMap.remove(state.availableUtxos, hash),
        pendingUtxos: HashMap.set(state.pendingUtxos, hash, utxo),
      };
    }),

  rollbackSpend: (state: UnshieldedState, utxo: UtxoWithMeta): Either.Either<UnshieldedState, UtxoNotFoundError> =>
    Either.gen(function* () {
      const hash = UtxoHash(utxo.utxo);
      if (!HashMap.has(state.pendingUtxos, hash)) {
        return yield* Either.left(new UtxoNotFoundError({ utxo: utxo.utxo }));
      }
      return {
        availableUtxos: HashMap.set(state.availableUtxos, hash, utxo),
        pendingUtxos: HashMap.remove(state.pendingUtxos, hash),
      };
    }),

  spendByUtxo: (state: UnshieldedState, utxo: ledger.Utxo): Either.Either<UnshieldedState, UtxoNotFoundError> =>
    Either.gen(function* () {
      const hash = UtxoHash(utxo);
      const found = yield* Either.fromOption(
        HashMap.get(state.availableUtxos, hash),
        () => new UtxoNotFoundError({ utxo }),
      );
      return yield* UnshieldedState.spend(state, found);
    }),

  rollbackSpendByUtxo: (state: UnshieldedState, utxo: ledger.Utxo): Either.Either<UnshieldedState, UtxoNotFoundError> =>
    Either.gen(function* () {
      const hash = UtxoHash(utxo);
      const found = yield* Either.fromOption(
        HashMap.get(state.pendingUtxos, hash),
        () => new UtxoNotFoundError({ utxo }),
      );
      return yield* UnshieldedState.rollbackSpend(state, found);
    }),

  applyUpdate: (
    state: UnshieldedState,
    update: UnshieldedUpdate,
  ): Either.Either<UnshieldedState, ApplyTransactionError> =>
    Either.gen(function* () {
      if (!['SUCCESS', 'PARTIAL_SUCCESS'].includes(update.status)) {
        return yield* Either.left(new ApplyTransactionError({ message: `Invalid status: ${update.status}` }));
      }

      return {
        availableUtxos: HashMap.union(
          HashMap.removeMany(
            state.availableUtxos,
            update.spentUtxos.map((utxo) => UtxoHash(utxo.utxo)),
          ),
          HashMap.fromIterable(update.createdUtxos.map((utxo) => [UtxoHash(utxo.utxo), utxo])),
        ),
        pendingUtxos: HashMap.removeMany(
          state.pendingUtxos,
          update.spentUtxos.map((utxo) => UtxoHash(utxo.utxo)),
        ),
      };
    }),

  applyFailedUpdate: (
    state: UnshieldedState,
    update: UnshieldedUpdate,
  ): Either.Either<UnshieldedState, ApplyTransactionError> =>
    Either.gen(function* () {
      if (update.status !== 'FAILURE') {
        return yield* Either.left(new ApplyTransactionError({ message: `Invalid status: ${update.status}` }));
      }

      return {
        availableUtxos: HashMap.union(
          state.availableUtxos,
          HashMap.fromIterable(update.spentUtxos.map((utxo) => [UtxoHash(utxo.utxo), utxo])),
        ),
        pendingUtxos: HashMap.removeMany(
          state.pendingUtxos,
          update.spentUtxos.map((utxo) => UtxoHash(utxo.utxo)),
        ),
      };
    }),

  toArrays: (
    state: UnshieldedState,
  ): {
    readonly availableUtxos: readonly UtxoWithMeta[];
    readonly pendingUtxos: readonly UtxoWithMeta[];
  } => ({
    availableUtxos: HashMap.toValues(state.availableUtxos),
    pendingUtxos: HashMap.toValues(state.pendingUtxos),
  }),
} as const;

================
File: packages/wallet-integration-tests/package.json
================
{
  "name": "@midnight-ntwrk/wallet-integration-tests",
  "version": "0.0.1",
  "type": "module",
  "private": true,
  "scripts": {
    "typecheck": "tsc -b ./tsconfig.json --noEmit",
    "format": "prettier --write \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format:check": "prettier --check \"**/*.{ts,js,json,yaml,yml,md}\"",
    "test": "NODE_OPTIONS='--experimental-vm-modules --experimental-specifier-resolution=node --max-old-space-size=8192' vitest run",
    "lint": "eslint"
  },
  "dependencies": {
    "@midnight-ntwrk/ledger-v6": "6.1.0-alpha.6",
    "@midnight-ntwrk/wallet-api": "^5.0.0",
    "@midnight-ntwrk/wallet-sdk-abstractions": "1.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-address-format": "3.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-hd": "3.0.0-beta.7",
    "@midnight-ntwrk/wallet-sdk-prover-client": "1.0.0-beta.10",
    "@midnight-ntwrk/wallet-sdk-runtime": "1.0.0-beta.8",
    "@midnight-ntwrk/wallet-sdk-shielded": "1.0.0-beta.12",
    "@types/node": "^22.17.0",
    "effect": "^3.17.3",
    "fast-check": "^4.2.0",
    "pure-rand": "^7.0.1",
    "rxjs": "^7.5.5",
    "testcontainers": "^11.8.1"
  },
  "devDependencies": {
    "eslint": "^9.32.0",
    "typescript": "^5.9.3",
    "vitest": "^3.2.4"
  }
}

================
File: packages/unshielded-wallet/package.json
================
{
  "name": "@midnight-ntwrk/wallet-sdk-unshielded-wallet",
  "version": "1.0.0-beta.14",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "author": "Midnight Foundation",
  "license": "Apache-2.0",
  "publishConfig": {
    "registry": "https://npm.pkg.github.com/"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/midnight-ntwrk/artifacts.git"
  },
  "files": [
    "dist/"
  ],
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  },
  "dependencies": {
    "@midnight-ntwrk/ledger-v6": "6.1.0-alpha.6",
    "@midnight-ntwrk/wallet-sdk-abstractions": "1.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-address-format": "3.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-capabilities": "3.0.0-beta.9",
    "@midnight-ntwrk/wallet-sdk-hd": "3.0.0-beta.7",
    "@midnight-ntwrk/wallet-sdk-indexer-client": "1.0.0-beta.13",
    "@midnight-ntwrk/wallet-sdk-unshielded-state": "1.0.0-beta.11",
    "@midnight-ntwrk/wallet-sdk-utilities": "1.0.0-beta.7",
    "effect": "^3.17.3",
    "rxjs": "^7.5"
  },
  "scripts": {
    "typecheck": "tsc -b ./tsconfig.json --noEmit",
    "test": "vitest run",
    "lint": "eslint --max-warnings 0",
    "format": "prettier --write \"**/*.{ts,js,json,yaml,yml,md}\"",
    "format:check": "prettier --check \"**/*.{ts,js,json,yaml,yml,md}\"",
    "dist": "tsc -b ./tsconfig.build.json",
    "dist:publish": "tsc -b ./tsconfig.publish.json",
    "clean": "rimraf --glob dist 'tsconfig.*.tsbuildinfo' && date +%s > .clean-timestamp",
    "publint": "publint --strict"
  },
  "devDependencies": {
    "eslint": "^9.37.0",
    "publint": "~0.3.14",
    "rimraf": "^6.0.1",
    "testcontainers": "^11.8.1",
    "typescript": "^5.9.3",
    "vitest": "^3.2.4"
  }
}

================
File: packages/unshielded-wallet/src/v1/V1Builder.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Effect, Either, Scope, Types } from 'effect';
import { WalletSeed, NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Variant, VariantBuilder, WalletRuntimeError } from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
import { RunningV1Variant, V1Tag } from './RunningV1Variant.js';
import { makeDefaultV1SerializationCapability, SerializationCapability } from './Serialization.js';
import {
  DefaultSyncContext,
  DefaultSyncConfiguration,
  SyncCapability,
  SyncService,
  makeDefaultSyncService,
  makeDefaultSyncCapability,
} from './Sync.js';
import { WalletSyncUpdate, UnshieldedUpdate } from './SyncSchema.js';
import {
  DefaultTransactingConfiguration,
  DefaultTransactingContext,
  makeDefaultTransactingCapability,
  TransactingCapability,
} from './Transacting.js';
import { WalletError } from './WalletError.js';
import { CoinsAndBalancesCapability, makeDefaultCoinsAndBalancesCapability } from './CoinsAndBalances.js';
import { KeysCapability, makeDefaultKeysCapability } from './Keys.js';
import { CoinSelection, chooseCoin } from '@midnight-ntwrk/wallet-sdk-capabilities';
import { CoreWallet } from './CoreWallet.js';
import {
  DefaultTransactionHistoryConfiguration,
  TransactionHistoryService,
  makeDefaultTransactionHistoryService,
} from './TransactionHistory.js';
import { Expect, Equal, ItemType } from '@midnight-ntwrk/wallet-sdk-utilities/types';
import { createKeystore, PublicKey } from '../KeyStore.js';

export type BaseV1Configuration = {
  networkId: NetworkId.NetworkId;
};

export type DefaultV1Configuration = BaseV1Configuration &
  DefaultSyncConfiguration &
  DefaultTransactingConfiguration &
  DefaultTransactionHistoryConfiguration;

const V1BuilderSymbol: {
  readonly typeId: unique symbol;
} = {
  typeId: Symbol('@midnight-ntwrk/unshielded-wallet#V1Builder') as (typeof V1BuilderSymbol)['typeId'],
} as const;

export type V1Variant<TSerialized, TSyncUpdate, TTransaction> = Variant.Variant<
  typeof V1Tag,
  CoreWallet,
  null,
  RunningV1Variant<TSerialized, TSyncUpdate, TTransaction>
> & {
  deserializeState: (serialized: TSerialized) => Either.Either<CoreWallet, WalletError>;
  coinsAndBalances: CoinsAndBalancesCapability<CoreWallet>;
  keys: KeysCapability<CoreWallet>;
  serialization: SerializationCapability<CoreWallet, TSerialized>;
  transactionHistory: TransactionHistoryService<UnshieldedUpdate>;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type AnyV1Variant = V1Variant<any, any, any>;
export type DefaultV1Variant = V1Variant<
  string,
  WalletSyncUpdate,
  ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>
>;

export type TransactionOf<T extends AnyV1Variant> =
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  T extends V1Variant<any, any, infer TTransaction> ? TTransaction : never;

export type SerializedStateOf<T extends AnyV1Variant> =
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  T extends V1Variant<infer TSerialized, any, any> ? TSerialized : never;

export type DefaultV1Builder = V1Builder<
  DefaultV1Configuration,
  RunningV1Variant.Context<
    string,
    WalletSyncUpdate,
    ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>
  >,
  string,
  WalletSyncUpdate,
  ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>
>;

export class V1Builder<
  TConfig extends BaseV1Configuration = BaseV1Configuration,
  TContext extends Partial<RunningV1Variant.AnyContext> = object,
  TSerialized = never,
  TSyncUpdate = never,
  TTransaction = never,
> implements VariantBuilder.VariantBuilder<V1Variant<TSerialized, TSyncUpdate, TTransaction>, TConfig> {
  readonly #buildState: V1Builder.PartialBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction>;

  constructor(buildState: V1Builder.PartialBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction> = {}) {
    this.#buildState = buildState;
  }

  withDefaults(): DefaultV1Builder {
    return this.withDefaultTransactionType()
      .withSyncDefaults()
      .withSerializationDefaults()
      .withTransactingDefaults()
      .withCoinsAndBalancesDefaults()
      .withTransactionHistoryDefaults()
      .withKeysDefaults()
      .withCoinSelectionDefaults() as DefaultV1Builder;
  }

  withTransactionType<Transaction>(): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, Transaction> {
    return new V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, Transaction>({
      ...this.#buildState,
      transactingCapability: undefined,
      transactionHistoryService: undefined,
    });
  }

  withDefaultTransactionType(): V1Builder<
    TConfig,
    TContext,
    TSerialized,
    TSyncUpdate,
    ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>
  > {
    return this.withTransactionType<ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>>();
  }

  withSyncDefaults(): V1Builder<
    TConfig & DefaultSyncConfiguration,
    TContext & DefaultSyncContext,
    TSerialized,
    WalletSyncUpdate,
    TTransaction
  > {
    return this.withSync(makeDefaultSyncService, makeDefaultSyncCapability);
  }

  withSync<TSyncConfig, TSyncContext extends Partial<RunningV1Variant.AnyContext>, TSyncUpdate>(
    syncService: (configuration: TSyncConfig, getContext: () => TSyncContext) => SyncService<CoreWallet, TSyncUpdate>,
    syncCapability: (
      configuration: TSyncConfig,
      getContext: () => TSyncContext,
    ) => SyncCapability<CoreWallet, TSyncUpdate>,
  ): V1Builder<TConfig & TSyncConfig, TContext & TSyncContext, TSerialized, TSyncUpdate, TTransaction> {
    return new V1Builder<TConfig & TSyncConfig, TContext & TSyncContext, TSerialized, TSyncUpdate, TTransaction>({
      ...this.#buildState,
      syncService,
      syncCapability,
    });
  }

  withSerializationDefaults(): V1Builder<TConfig, TContext, string, TSyncUpdate, TTransaction> {
    return this.withSerialization(makeDefaultV1SerializationCapability);
  }

  withSerialization<
    TSerializationConfig,
    TSerializationContext extends Partial<RunningV1Variant.AnyContext>,
    TSerialized,
  >(
    serializationCapability: (
      configuration: TSerializationConfig,
      getContext: () => TSerializationContext,
    ) => SerializationCapability<CoreWallet, TSerialized>,
  ): V1Builder<
    TConfig & TSerializationConfig,
    TContext & TSerializationContext,
    TSerialized,
    TSyncUpdate,
    TTransaction
  > {
    return new V1Builder<
      TConfig & TSerializationConfig,
      TContext & TSerializationContext,
      TSerialized,
      TSyncUpdate,
      TTransaction
    >({
      ...this.#buildState,
      serializationCapability,
    });
  }

  withTransactingDefaults(
    this: V1Builder<
      TConfig,
      TContext,
      TSerialized,
      TSyncUpdate,
      ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>
    >,
  ): V1Builder<
    TConfig & DefaultTransactingConfiguration,
    TContext & DefaultTransactingContext,
    TSerialized,
    TSyncUpdate,
    ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>
  > {
    return this.withTransacting(makeDefaultTransactingCapability);
  }

  withTransacting<TTransactingConfig, TTransactingContext extends Partial<RunningV1Variant.AnyContext>>(
    transactingCapability: (
      config: TTransactingConfig,
      getContext: () => TTransactingContext,
    ) => TransactingCapability<TTransaction, CoreWallet>,
  ): V1Builder<TConfig & TTransactingConfig, TContext & TTransactingContext, TSerialized, TSyncUpdate, TTransaction> {
    return new V1Builder<
      TConfig & TTransactingConfig,
      TContext & TTransactingContext,
      TSerialized,
      TSyncUpdate,
      TTransaction
    >({
      ...this.#buildState,
      transactingCapability,
    });
  }

  withCoinSelection<TCoinSelectionConfig, TCoinSelectionContext extends Partial<RunningV1Variant.AnyContext>>(
    coinSelection: (
      config: TCoinSelectionConfig,
      getContext: () => TCoinSelectionContext,
    ) => CoinSelection<ledger.Utxo>,
  ): V1Builder<
    TConfig & TCoinSelectionConfig,
    TContext & TCoinSelectionContext,
    TSerialized,
    TSyncUpdate,
    TTransaction
  > {
    return new V1Builder<
      TConfig & TCoinSelectionConfig,
      TContext & TCoinSelectionContext,
      TSerialized,
      TSyncUpdate,
      TTransaction
    >({
      ...this.#buildState,
      coinSelection,
    });
  }

  withCoinSelectionDefaults(): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction> {
    return this.withCoinSelection(() => chooseCoin);
  }

  withCoinsAndBalancesDefaults(): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction> {
    return this.withCoinsAndBalances(makeDefaultCoinsAndBalancesCapability);
  }

  withCoinsAndBalances<TBalancesConfig, TBalancesContext extends Partial<RunningV1Variant.AnyContext>>(
    coinsAndBalancesCapability: (
      configuration: TBalancesConfig,
      getContext: () => TBalancesContext,
    ) => CoinsAndBalancesCapability<CoreWallet>,
  ): V1Builder<TConfig & TBalancesConfig, TContext & TBalancesContext, TSerialized, TSyncUpdate, TTransaction> {
    return new V1Builder<
      TConfig & TBalancesConfig,
      TContext & TBalancesContext,
      TSerialized,
      TSyncUpdate,
      TTransaction
    >({
      ...this.#buildState,
      coinsAndBalancesCapability,
    });
  }

  withTransactionHistoryDefaults(
    this: V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, ledger.FinalizedTransaction>,
  ): V1Builder<
    TConfig & DefaultTransactionHistoryConfiguration,
    TContext,
    TSerialized,
    TSyncUpdate,
    ledger.FinalizedTransaction
  > {
    return this.withTransactionHistory(makeDefaultTransactionHistoryService);
  }

  withTransactionHistory<
    TTransactionHistoryConfig,
    TTransactionHistoryContext extends Partial<RunningV1Variant.AnyContext>,
  >(
    transactionHistoryService: (
      configuration: TTransactionHistoryConfig,
      getContext: () => TTransactionHistoryContext,
    ) => TransactionHistoryService<UnshieldedUpdate>,
  ): V1Builder<
    TConfig & TTransactionHistoryConfig,
    TContext & TTransactionHistoryContext,
    TSerialized,
    TSyncUpdate,
    TTransaction
  > {
    return new V1Builder<
      TConfig & TTransactionHistoryConfig,
      TContext & TTransactionHistoryContext,
      TSerialized,
      TSyncUpdate,
      TTransaction
    >({
      ...this.#buildState,
      transactionHistoryService,
    });
  }

  withKeysDefaults(): V1Builder<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction> {
    return this.withKeys(makeDefaultKeysCapability);
  }

  withKeys<TKeysConfig, TKeysContext extends Partial<RunningV1Variant.AnyContext>>(
    keysCapability: (configuration: TKeysConfig, getContext: () => TKeysContext) => KeysCapability<CoreWallet>,
  ): V1Builder<TConfig & TKeysConfig, TContext & TKeysContext, TSerialized, TSyncUpdate, TTransaction> {
    return new V1Builder<TConfig & TKeysConfig, TContext & TKeysContext, TSerialized, TSyncUpdate, TTransaction>({
      ...this.#buildState,
      keysCapability,
    });
  }

  build(
    this: V1Builder<
      TConfig,
      RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction>,
      TSerialized,
      TSyncUpdate,
      TTransaction
    >,
    configuration: TConfig,
  ): V1Variant<TSerialized, TSyncUpdate, TTransaction> {
    const v1Context = this.#buildContextFromBuildState(configuration);
    const { networkId } = configuration;

    return {
      __polyTag__: V1Tag,
      coinsAndBalances: v1Context.coinsAndBalancesCapability,
      keys: v1Context.keysCapability,
      serialization: v1Context.serializationCapability,
      transactionHistory: v1Context.transactionHistoryService,
      start(
        context: Variant.VariantContext<CoreWallet>,
      ): Effect.Effect<RunningV1Variant<TSerialized, TSyncUpdate, TTransaction>, WalletRuntimeError, Scope.Scope> {
        return Effect.gen(function* () {
          const scope = yield* Scope.Scope;
          return new RunningV1Variant(scope, context, v1Context);
        });
      },
      migrateState(_previousState) {
        const seed = WalletSeed.fromString('0000000000000000000000000000000000000000000000000000000000000001');

        return Effect.succeed(CoreWallet.init(PublicKey.fromKeyStore(createKeystore(seed, networkId)), networkId));
      },

      deserializeState: (serialized: TSerialized): Either.Either<CoreWallet, WalletError> => {
        return v1Context.serializationCapability.deserialize(serialized);
      },
    };
  }

  #buildContextFromBuildState(
    this: V1Builder<
      TConfig,
      RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction>,
      TSerialized,
      TSyncUpdate,
      TTransaction
    >,
    configuration: TConfig,
  ): RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction> {
    if (!isBuildStateFull(this.#buildState)) {
      throw new Error('Not all components are configured in V1 Builder');
    }

    const {
      syncCapability,
      syncService,
      transactingCapability,
      serializationCapability,
      coinSelection,
      coinsAndBalancesCapability,
      keysCapability,
      transactionHistoryService,
    } = this.#buildState;

    const getContext = (): RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction> => context;

    const context = {
      serializationCapability: serializationCapability(configuration, getContext),
      syncCapability: syncCapability(configuration, getContext),
      syncService: syncService(configuration, getContext),
      transactingCapability: transactingCapability(configuration, getContext),
      coinsAndBalancesCapability: coinsAndBalancesCapability(configuration, getContext),
      keysCapability: keysCapability(configuration, getContext),
      coinSelection: coinSelection(configuration, getContext),
      transactionHistoryService: transactionHistoryService(configuration, getContext),
    };

    return context;
  }
}

/** @internal */
declare namespace V1Builder {
  type HasSync<TConfig, TContext, TSyncUpdate> = {
    readonly syncService: (configuration: TConfig, getContext: () => TContext) => SyncService<CoreWallet, TSyncUpdate>;
    readonly syncCapability: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => SyncCapability<CoreWallet, TSyncUpdate>;
  };

  type HasTransacting<TConfig, TContext, TTransaction> = {
    readonly transactingCapability: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => TransactingCapability<TTransaction, CoreWallet>;
  };

  type HasCoinSelection<TConfig, TContext> = {
    readonly coinSelection: (configuration: TConfig, getContext: () => TContext) => CoinSelection<ledger.Utxo>;
  };

  type HasSerialization<TConfig, TContext, TSerialized> = {
    readonly serializationCapability: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => SerializationCapability<CoreWallet, TSerialized>;
  };

  type HasCoinsAndBalances<TConfig, TContext> = {
    readonly coinsAndBalancesCapability: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => CoinsAndBalancesCapability<CoreWallet>;
  };

  type HasTransactionHistory<TConfig, TContext> = {
    readonly transactionHistoryService: (
      configuration: TConfig,
      getContext: () => TContext,
    ) => TransactionHistoryService<UnshieldedUpdate>;
  };

  type HasKeys<TConfig, TContext> = {
    readonly keysCapability: (configuration: TConfig, getContext: () => TContext) => KeysCapability<CoreWallet>;
  };

  /**
   * The internal build state of {@link V1Builder}.
   */
  type FullBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction> = Types.Simplify<
    HasSync<TConfig, TContext, TSyncUpdate> &
      HasSerialization<TConfig, TContext, TSerialized> &
      HasTransacting<TConfig, TContext, TTransaction> &
      HasCoinSelection<TConfig, TContext> &
      HasCoinsAndBalances<TConfig, TContext> &
      HasKeys<TConfig, TContext> &
      HasTransactionHistory<TConfig, TContext>
  >;
  type PartialBuildState<
    TConfig = object,
    TContext = object,
    TSerialized = never,
    TSyncUpdate = never,
    TTransaction = never,
  > = {
    [K in keyof FullBuildState<never, never, never, never, never>]?:
      | FullBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction>[K]
      | undefined;
  };

  /**
   * Utility interface that manages the type variance of {@link V1Builder}.
   */
  interface Variance<R> {
    readonly [V1BuilderSymbol.typeId]: {
      readonly _R: Types.Covariant<R>;
    };
  }
}

const isBuildStateFull = <TConfig, TContext, TSerialized, TSyncUpdate, TTransaction>(
  buildState: V1Builder.PartialBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction>,
): buildState is V1Builder.FullBuildState<TConfig, TContext, TSerialized, TSyncUpdate, TTransaction> => {
  const allBuildStateKeys = [
    'syncService',
    'syncCapability',
    'transactingCapability',
    'coinSelection',
    'serializationCapability',
    'coinsAndBalancesCapability',
    'keysCapability',
    'transactionHistoryService',
  ] as const;
  /**
   * This type will fail compilation if any key is omitted, letting the `isFull` check work properly
   */
  type _1 = Expect<
    Equal<keyof V1Builder.FullBuildState<never, never, never, never, never>, ItemType<typeof allBuildStateKeys>>
  >;
  return allBuildStateKeys.every((key) => typeof buildState[key] == 'function');
};

/** @internal */
declare namespace _V1BuilderMethods {
  type WithSyncDefaults = 'withSyncDefaults';
  type WithSyncMethod = 'withSync';
  type WithTransactingMethod = 'withTransacting';
  type WithTransactingDefaults = 'withTransactingDefaults';
  type WithSerializationMethod = 'withSerialization';
  type WithSerializationDefaults = 'withSerializationDefaults';
  type WithCoinsAndBalancesDefaults = 'withCoinsAndBalancesDefaults';
  type WithKeysDefaults = 'withKeysDefaults';
  type WithTransactionHistoryDefaults = 'withTransactionHistoryDefaults';
  type AllSyncMethods = WithSyncDefaults | WithSyncMethod;
  type AllTransactingMethods = WithTransactingMethod | WithTransactingDefaults;
  type AllSerializationMethods = WithSerializationMethod | WithSerializationDefaults;
  type AllCoinsAndBalancesMethods = 'withCoinsAndBalancesDefaults';
  type AllKeysMethods = 'withKeysDefaults';
  type AllTransactionHistoryMethods = 'withTransactionHistoryDefaults';
  type AllMethods =
    | AllSyncMethods
    | AllTransactingMethods
    | AllSerializationMethods
    | AllCoinsAndBalancesMethods
    | AllKeysMethods
    | AllTransactionHistoryMethods;
}

================
File: packages/unshielded-wallet/test/UnshieldedWallet.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { buildTestEnvironmentVariables, getComposeDirectory } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import { firstValueFrom } from 'rxjs';
import { randomUUID } from 'node:crypto';
import { DockerComposeEnvironment, StartedDockerComposeEnvironment, Wait } from 'testcontainers';
import { afterAll, beforeAll, describe, expect, it, vi } from 'vitest';
import { UnshieldedWallet } from '../src/index.js';
import { getUnshieldedSeed, createWalletConfig } from './testUtils.js';
import { createKeystore, PublicKey } from '../src/KeyStore.js';
import { InMemoryTransactionHistoryStorage, NoOpTransactionHistoryStorage } from '../src/storage/index.js';
import { UnshieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';

vi.setConfig({ testTimeout: 100_000, hookTimeout: 100_000 });

const environmentId = randomUUID();

const environmentVars = buildTestEnvironmentVariables(['APP_INFRA_SECRET'], {
  additionalVars: {
    TESTCONTAINERS_UID: environmentId,
  },
});

const environment = new DockerComposeEnvironment(getComposeDirectory(), 'docker-compose.yml')
  .withWaitStrategy(`node_${environmentId}`, Wait.forListeningPorts())
  .withWaitStrategy(`indexer_${environmentId}`, Wait.forListeningPorts())
  .withEnvironment(environmentVars);

describe('UnshieldedWallet', () => {
  let indexerPort: number;
  let startedEnvironment: StartedDockerComposeEnvironment;
  const unshieldedSeed = getUnshieldedSeed('0000000000000000000000000000000000000000000000000000000000000002');

  beforeAll(async () => {
    startedEnvironment = await environment.up();
    indexerPort = startedEnvironment.getContainer(`indexer_${environmentId}`).getMappedPort(8088);
  });

  it('should build', async () => {
    const txHistoryStorage = new InMemoryTransactionHistoryStorage();
    const config = createWalletConfig(indexerPort, { txHistoryStorage });
    const keystore = createKeystore(unshieldedSeed, config.networkId);

    const unshieldedWallet = UnshieldedWallet(config).startWithPublicKey(PublicKey.fromKeyStore(keystore));

    await unshieldedWallet.start();

    await unshieldedWallet.waitForSyncedState(0n);

    const state = await firstValueFrom(unshieldedWallet.state);

    expect(UnshieldedAddress.codec.encode(config.networkId, state.address).asString()).toBe(
      'mn_addr_undeployed1gkasr3z3vwyscy2jpp53nzr37v7n4r3lsfgj6v5g584dakjzt0xqun4d4r',
    );
    expect(state.availableCoins.length).toBeGreaterThan(0);
    expect(state.pendingCoins).toHaveLength(0);

    const transactionHistory = await Array.fromAsync(state.transactionHistory.getAll());

    expect(transactionHistory.length).toBeGreaterThan(1);
  });

  it('should restore from serialized state with tx history', async () => {
    const txHistoryStorage = new InMemoryTransactionHistoryStorage();
    const initialConfig = createWalletConfig(indexerPort, { txHistoryStorage });
    const keystore = createKeystore(unshieldedSeed, initialConfig.networkId);

    const initialWallet = UnshieldedWallet(initialConfig).startWithPublicKey(PublicKey.fromKeyStore(keystore));

    await initialWallet.start();

    await initialWallet.waitForSyncedState();

    const initialState = await firstValueFrom(initialWallet.state);

    expect(initialState.availableCoins.length).toBeGreaterThan(0);
    expect(initialState.pendingCoins.length).toBe(0);

    const serializedState = await initialWallet.serializeState();

    const serializedTxHistory = txHistoryStorage.serialize();

    await initialWallet.stop();

    const restoredTxHistoryStorage = InMemoryTransactionHistoryStorage.fromSerialized(serializedTxHistory);

    const restoredConfig = createWalletConfig(indexerPort, { txHistoryStorage: restoredTxHistoryStorage });

    const restoredWallet = UnshieldedWallet(restoredConfig).restore(serializedState);

    await restoredWallet.start();

    await restoredWallet.waitForSyncedState();

    const restoredState = await firstValueFrom(restoredWallet.state);

    expect(UnshieldedAddress.codec.encode(initialConfig.networkId, restoredState.address).asString()).toBe(
      UnshieldedAddress.codec.encode(initialConfig.networkId, initialState.address).asString(),
    );
    expect(restoredState.availableCoins.length).toBe(initialState.availableCoins.length);
    expect(restoredState.pendingCoins.length).toBe(initialState.pendingCoins.length);

    await restoredWallet.stop();
  });

  it('should instantiate without transaction history service', async () => {
    const initialConfig = createWalletConfig(indexerPort, { txHistoryStorage: new NoOpTransactionHistoryStorage() });
    const keystore = createKeystore(unshieldedSeed, initialConfig.networkId);
    const initialWallet = UnshieldedWallet(initialConfig).startWithPublicKey(PublicKey.fromKeyStore(keystore));

    await initialWallet.start();

    await initialWallet.waitForSyncedState();

    const initialState = await firstValueFrom(initialWallet.state);

    expect(initialState.availableCoins.length).toBeGreaterThan(0);
    expect(initialState.pendingCoins.length).toBe(0);

    await initialWallet.stop();
  });

  it('should restore from serialized state', async () => {
    const txHistoryStorage = new InMemoryTransactionHistoryStorage();
    const initialConfig = createWalletConfig(indexerPort, {
      txHistoryStorage,
    });
    const keystore = createKeystore(unshieldedSeed, initialConfig.networkId);
    const initialWallet = UnshieldedWallet(initialConfig).startWithPublicKey(PublicKey.fromKeyStore(keystore));

    await initialWallet.start();

    await initialWallet.waitForSyncedState();

    const initialState = await firstValueFrom(initialWallet.state);

    expect(initialState.availableCoins.length).toBe(initialState.availableCoins.length);
    expect(initialState.pendingCoins.length).toBe(initialState.pendingCoins.length);

    const serializedState = await initialWallet.serializeState();

    await initialWallet.stop();

    const restoreConfig = createWalletConfig(indexerPort, { txHistoryStorage });
    const restoredWallet = UnshieldedWallet(restoreConfig).restore(serializedState);
    await restoredWallet.start();

    await restoredWallet.waitForSyncedState();

    const restoredState = await firstValueFrom(restoredWallet.state);

    expect(UnshieldedAddress.codec.encode(restoreConfig.networkId, restoredState.address).asString()).toBe(
      UnshieldedAddress.codec.encode(restoreConfig.networkId, initialState.address).asString(),
    );
    expect(restoredState.availableCoins.length).toBe(initialState.availableCoins.length);
    expect(restoredState.pendingCoins.length).toBe(initialState.pendingCoins.length);

    await restoredWallet.stop();
  });

  afterAll(async () => {
    if (startedEnvironment) {
      await startedEnvironment.down();
    }
  });
});

================
File: packages/facade/test/dustRegistration.test.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ShieldedWallet } from '@midnight-ntwrk/wallet-sdk-shielded';
import { DefaultV1Configuration } from '@midnight-ntwrk/wallet-sdk-shielded/v1';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { randomUUID } from 'node:crypto';
import os from 'node:os';
import { DockerComposeEnvironment, StartedDockerComposeEnvironment, Wait } from 'testcontainers';
import { afterAll, afterEach, beforeAll, beforeEach, describe, expect, it, vi } from 'vitest';
import {
  getShieldedSeed,
  getUnshieldedSeed,
  getDustSeed,
  tokenValue,
  waitForFullySynced,
  waitForDustGenerated,
} from './utils.js';
import { buildTestEnvironmentVariables, getComposeDirectory } from '@midnight-ntwrk/wallet-sdk-utilities/testing';
import {
  createKeystore,
  UnshieldedWallet,
  InMemoryTransactionHistoryStorage,
  PublicKey,
} from '@midnight-ntwrk/wallet-sdk-unshielded-wallet';
import * as rx from 'rxjs';
import { CombinedTokenTransfer, WalletFacade } from '../src/index.js';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { DustWallet } from '@midnight-ntwrk/wallet-sdk-dust-wallet';
import { UnshieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';
import { ArrayOps } from '@midnight-ntwrk/wallet-sdk-utilities';

vi.setConfig({ testTimeout: 200_000, hookTimeout: 200_000 });

const environmentId = randomUUID();

const environmentVars = buildTestEnvironmentVariables(['APP_INFRA_SECRET'], {
  additionalVars: {
    TESTCONTAINERS_UID: environmentId,
    RAYON_NUM_THREADS: Math.min(os.availableParallelism(), 32).toString(10),
  },
});

const environment = new DockerComposeEnvironment(getComposeDirectory(), 'docker-compose-dynamic.yml')
  .withWaitStrategy(
    `proof-server_${environmentId}`,
    Wait.forLogMessage('Actix runtime found; starting in Actix runtime'),
  )
  .withWaitStrategy(`node_${environmentId}`, Wait.forListeningPorts())
  .withWaitStrategy(`indexer_${environmentId}`, Wait.forLogMessage(/block indexed".*height":1,.*/gm))
  .withEnvironment(environmentVars)
  .withStartupTimeout(100_000);

describe('Dust Registration', () => {
  const SENDER_SEED = '0000000000000000000000000000000000000000000000000000000000000002';
  const RECEIVER_SEED = '0000000000000000000000000000000000000000000000000000000000001111';

  const shieldedSenderSeed = getShieldedSeed(SENDER_SEED);
  const shieldedReceiverSeed = getShieldedSeed(RECEIVER_SEED);

  const unshieldedSenderSeed = getUnshieldedSeed(SENDER_SEED);
  const unshieldedReceiverSeed = getUnshieldedSeed(RECEIVER_SEED);

  const dustSenderSeed = getDustSeed(SENDER_SEED);
  const dustReceiverSeed = getDustSeed(RECEIVER_SEED);

  const unshieldedSenderKeystore = createKeystore(unshieldedSenderSeed, NetworkId.NetworkId.Undeployed);
  const unshieldedReceiverKeystore = createKeystore(unshieldedReceiverSeed, NetworkId.NetworkId.Undeployed);

  const unshieldedTxHistoryStorage = new InMemoryTransactionHistoryStorage();

  let startedEnvironment: StartedDockerComposeEnvironment;
  let configuration: DefaultV1Configuration;

  beforeAll(async () => {
    startedEnvironment = await environment.up();

    configuration = {
      indexerClientConnection: {
        indexerHttpUrl: `http://localhost:${startedEnvironment.getContainer(`indexer_${environmentId}`).getMappedPort(8088)}/api/v3/graphql`,
        indexerWsUrl: `ws://localhost:${startedEnvironment.getContainer(`indexer_${environmentId}`).getMappedPort(8088)}/api/v3/graphql/ws`,
      },
      provingServerUrl: new URL(
        `http://localhost:${startedEnvironment.getContainer(`proof-server_${environmentId}`).getMappedPort(6300)}`,
      ),
      relayURL: new URL(
        `ws://127.0.0.1:${startedEnvironment.getContainer(`node_${environmentId}`).getMappedPort(9944)}`,
      ),
      networkId: NetworkId.NetworkId.Undeployed,
    };
  });

  afterAll(async () => {
    await startedEnvironment?.down({ timeout: 10_000 });
  });

  let senderFacade: WalletFacade;
  let receiverFacade: WalletFacade;

  beforeEach(async () => {
    const Shielded = ShieldedWallet(configuration);
    const shieldedSender = Shielded.startWithShieldedSeed(shieldedSenderSeed);
    const shieldedReceiver = Shielded.startWithShieldedSeed(shieldedReceiverSeed);

    const Dust = DustWallet({
      ...configuration,
      costParameters: {
        additionalFeeOverhead: 300_000_000_000_000n,
        feeBlocksMargin: 5,
      },
    });
    const dustParameters = ledger.LedgerParameters.initialParameters().dust;
    const dustSender = Dust.startWithSeed(dustSenderSeed, dustParameters);
    const dustReceiver = Dust.startWithSeed(dustReceiverSeed, dustParameters);

    const unshieldedSender = UnshieldedWallet({
      ...configuration,
      txHistoryStorage: new InMemoryTransactionHistoryStorage(),
    }).startWithPublicKey(PublicKey.fromKeyStore(unshieldedSenderKeystore));

    const unshieldedReceiver = UnshieldedWallet({
      ...configuration,
      txHistoryStorage: unshieldedTxHistoryStorage,
    }).startWithPublicKey(PublicKey.fromKeyStore(unshieldedReceiverKeystore));

    senderFacade = new WalletFacade(shieldedSender, unshieldedSender, dustSender);
    receiverFacade = new WalletFacade(shieldedReceiver, unshieldedReceiver, dustReceiver);

    await Promise.all([
      senderFacade.start(
        ledger.ZswapSecretKeys.fromSeed(shieldedSenderSeed),
        ledger.DustSecretKey.fromSeed(dustSenderSeed),
      ),
      receiverFacade.start(
        ledger.ZswapSecretKeys.fromSeed(shieldedReceiverSeed),
        ledger.DustSecretKey.fromSeed(dustReceiverSeed),
      ),
    ]);
  });

  afterEach(async () => {
    await Promise.all([senderFacade.stop(), receiverFacade.stop()]);
  });

  it('registers dust generation after receiving unshielded tokens', async () => {
    await Promise.all([waitForFullySynced(senderFacade), waitForFullySynced(receiverFacade)]);

    const unshieldedReceiverState = await rx.firstValueFrom(receiverFacade.unshielded.state);

    const tokenTransfer: CombinedTokenTransfer[] = [
      {
        type: 'unshielded',
        outputs: [
          {
            amount: tokenValue(150_000_000n),
            receiverAddress: UnshieldedAddress.codec
              .encode(configuration.networkId, unshieldedReceiverState.address)
              .asString(),
            type: ledger.unshieldedToken().raw,
          },
        ],
      },
    ];

    const ttl = new Date(Date.now() + 30 * 60 * 1000);
    const transferRecipe = await senderFacade.transferTransaction(
      ledger.ZswapSecretKeys.fromSeed(shieldedSenderSeed),
      ledger.DustSecretKey.fromSeed(dustSenderSeed),
      tokenTransfer,
      ttl,
    );

    const signedTransferTx = await senderFacade.signTransaction(transferRecipe.transaction, (payload) =>
      unshieldedSenderKeystore.signData(payload),
    );

    const finalizedTransferTx = await senderFacade.finalizeTransaction({
      ...transferRecipe,
      transaction: signedTransferTx,
    });

    const transferTxHash = await senderFacade.submitTransaction(finalizedTransferTx);
    expect(transferTxHash).toBeTypeOf('string');

    const receiverStateWithNight = await rx.firstValueFrom(
      receiverFacade
        .state()
        .pipe(
          rx.filter(
            (s) =>
              s.unshielded.availableCoins.length > 0 &&
              s.unshielded.availableCoins.some((coin) => coin.meta.registeredForDustGeneration === false),
          ),
        ),
    );

    const nightBalanceBeforeRegistration = receiverStateWithNight.unshielded.balances[ledger.nativeToken().raw];

    const nightUtxos = receiverStateWithNight.unshielded.availableCoins.filter(
      (coin) => coin.meta.registeredForDustGeneration === false && coin.utxo.type === ledger.nativeToken().raw,
    );

    expect(ArrayOps.sumBigInt(nightUtxos.map(({ utxo }) => utxo.value))).toEqual(nightBalanceBeforeRegistration);

    await waitForDustGenerated();

    const dustRegistrationRecipe = await receiverFacade.registerNightUtxosForDustGeneration(
      nightUtxos,
      unshieldedReceiverKeystore.getPublicKey(),
      (payload) => unshieldedReceiverKeystore.signData(payload),
    );

    const finalizedDustTx = await receiverFacade.finalizeTransaction(dustRegistrationRecipe);

    const dustRegistrationTxHash = await receiverFacade.submitTransaction(finalizedDustTx);

    expect(dustRegistrationTxHash).toBeTypeOf('string');

    const receiverStateAfterRegistration = await rx.firstValueFrom(
      receiverFacade.state().pipe(
        rx.mergeMap(async (state) => {
          const txInHistory = await state.unshielded.transactionHistory.get(finalizedDustTx.transactionHash());

          return {
            state,
            txFound: txInHistory !== undefined,
          };
        }),
        rx.filter(({ state, txFound }) => txFound && state.isSynced && state.dust.availableCoins.length > 0),
        rx.map(({ state }) => state),
      ),
    );

    expect(receiverStateAfterRegistration.dust.walletBalance(new Date())).toBeGreaterThan(0n);

    const nightBalanceAfterRegistration = receiverStateAfterRegistration.unshielded.balances[ledger.nativeToken().raw];

    expect(nightBalanceAfterRegistration).toEqual(nightBalanceBeforeRegistration);
  });
});

================
File: packages/unshielded-wallet/src/v1/RunningV1Variant.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Effect, pipe, Record, Scope, Stream, SubscriptionRef, Schedule, Duration, Sink, Console } from 'effect';
import { ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import {
  WalletRuntimeError,
  Variant,
  StateChange,
  VersionChangeType,
} from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
import { EitherOps } from '@midnight-ntwrk/wallet-sdk-utilities';
import { SerializationCapability } from './Serialization.js';
import { SyncCapability, SyncService } from './Sync.js';
import { WalletSyncUpdate } from './SyncSchema.js';
import { TransactingCapability, TokenTransfer } from './Transacting.js';
import { WalletError } from './WalletError.js';
import { CoinsAndBalancesCapability } from './CoinsAndBalances.js';
import { KeysCapability } from './Keys.js';
import { CoinSelection } from '@midnight-ntwrk/wallet-sdk-capabilities';
import { CoreWallet } from './CoreWallet.js';
import { TransactionHistoryService } from './TransactionHistory.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';

const progress = (state: CoreWallet): StateChange.StateChange<CoreWallet>[] => {
  const appliedId = state.progress?.appliedId ?? 0n;
  const highestTransactionId = state.progress?.highestTransactionId ?? 0n;

  const sourceGap = highestTransactionId - appliedId;
  const applyGap = appliedId - appliedId;

  return [StateChange.ProgressUpdate({ sourceGap, applyGap })];
};

const protocolVersionChange = (previous: CoreWallet, current: CoreWallet): StateChange.StateChange<CoreWallet>[] => {
  return previous.protocolVersion != current.protocolVersion
    ? [
        StateChange.VersionChange({
          change: VersionChangeType.Version({
            version: ProtocolVersion.ProtocolVersion(current.protocolVersion),
          }),
        }),
      ]
    : [];
};

export declare namespace RunningV1Variant {
  export type Context<TSerialized, TSyncUpdate, TTransaction> = {
    serializationCapability: SerializationCapability<CoreWallet, TSerialized>;
    syncService: SyncService<CoreWallet, TSyncUpdate>;
    syncCapability: SyncCapability<CoreWallet, TSyncUpdate>;
    transactingCapability: TransactingCapability<TTransaction, CoreWallet>;
    coinsAndBalancesCapability: CoinsAndBalancesCapability<CoreWallet>;
    keysCapability: KeysCapability<CoreWallet>;
    coinSelection: CoinSelection<ledger.Utxo>;
    transactionHistoryService: TransactionHistoryService<WalletSyncUpdate>;
  };
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  export type AnyContext = Context<any, any, any>;
}

export const V1Tag: unique symbol = Symbol('V1');

export type DefaultRunningV1 = RunningV1Variant<string, WalletSyncUpdate, ledger.FinalizedTransaction>;

export class RunningV1Variant<TSerialized, TSyncUpdate, TTransaction> implements Variant.RunningVariant<
  typeof V1Tag,
  CoreWallet
> {
  readonly __polyTag__: typeof V1Tag = V1Tag;
  readonly #scope: Scope.Scope;
  readonly #context: Variant.VariantContext<CoreWallet>;
  readonly #v1Context: RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction>;

  readonly state: Stream.Stream<StateChange.StateChange<CoreWallet>, WalletRuntimeError>;

  constructor(
    scope: Scope.Scope,
    context: Variant.VariantContext<CoreWallet>,
    v1Context: RunningV1Variant.Context<TSerialized, TSyncUpdate, TTransaction>,
  ) {
    this.#scope = scope;
    this.#context = context;
    this.#v1Context = v1Context;
    this.state = Stream.fromEffect(context.stateRef.get).pipe(
      Stream.flatMap((initialState) =>
        context.stateRef.changes.pipe(
          Stream.mapAccum(initialState, (previous: CoreWallet, current: CoreWallet) => {
            return [current, [previous, current]] as const;
          }),
        ),
      ),
      Stream.mapConcat(
        ([previous, current]: readonly [CoreWallet, CoreWallet]): StateChange.StateChange<CoreWallet>[] => {
          // TODO: emit progress only upon actual change
          return [
            StateChange.State({ state: current }),
            ...progress(current),
            ...protocolVersionChange(previous, current),
          ];
        },
      ),
    );
  }

  startSyncInBackground(): Effect.Effect<void> {
    return this.startSync().pipe(
      Stream.runScoped(Sink.drain),
      Effect.forkScoped,
      Effect.provideService(Scope.Scope, this.#scope),
    );
  }

  startSync(): Stream.Stream<void, WalletError, Scope.Scope> {
    return pipe(
      SubscriptionRef.get(this.#context.stateRef),
      Stream.fromEffect,
      Stream.flatMap((state) => this.#v1Context.syncService.updates(state)),
      Stream.mapEffect((update) => {
        return SubscriptionRef.updateEffect(this.#context.stateRef, (state) =>
          pipe(this.#v1Context.syncCapability.applyUpdate(state, update), EitherOps.toEffect),
        );
      }),
      Stream.tapError((error) => Console.error(error)),
      Stream.retry(
        pipe(
          Schedule.exponential(Duration.seconds(1), 2),
          Schedule.map((delay) => {
            const maxDelay = Duration.minutes(2);
            const jitter = Duration.millis(Math.floor(Math.random() * 1000));
            const delayWithJitter = Duration.toMillis(delay) + Duration.toMillis(jitter);

            return Duration.millis(Math.min(delayWithJitter, Duration.toMillis(maxDelay)));
          }),
        ),
      ),
    );
  }

  balanceTransaction(
    tx: ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>,
  ): Effect.Effect<ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>, WalletError> {
    return SubscriptionRef.modifyEffect(this.#context.stateRef, (state) => {
      return pipe(
        this.#v1Context.transactingCapability.balanceTransaction(state, tx),
        EitherOps.toEffect,
        Effect.map(({ transaction, newState }) => [transaction, newState]),
      );
    });
  }

  transferTransaction(
    outputs: ReadonlyArray<TokenTransfer>,
    ttl: Date,
  ): Effect.Effect<ledger.UnprovenTransaction, WalletError> {
    return SubscriptionRef.modifyEffect(this.#context.stateRef, (state) => {
      return pipe(
        this.#v1Context.transactingCapability.makeTransfer(state, outputs, ttl),
        EitherOps.toEffect,
        Effect.flatMap(({ transaction, newState }) =>
          pipe(
            this.#v1Context.transactingCapability.balanceTransaction(newState, transaction),
            EitherOps.toEffect,
            Effect.map(({ transaction, newState }) => [transaction as ledger.UnprovenTransaction, newState]),
          ),
        ),
      );
    });
  }

  initSwap(
    desiredInputs: Record<string, bigint>,
    desiredOutputs: ReadonlyArray<TokenTransfer>,
    ttl: Date,
  ): Effect.Effect<ledger.UnprovenTransaction, WalletError> {
    return SubscriptionRef.modifyEffect(this.#context.stateRef, (state) => {
      return pipe(
        this.#v1Context.transactingCapability.initSwap(state, desiredInputs, desiredOutputs, ttl),
        Effect.map(({ transaction, newState }) => [transaction, newState]),
      );
    });
  }

  signTransaction(
    transaction: ledger.UnprovenTransaction,
    signSegment: (data: Uint8Array) => ledger.Signature,
  ): Effect.Effect<ledger.UnprovenTransaction, WalletError> {
    return this.#v1Context.transactingCapability.signTransaction(transaction, signSegment);
  }

  serializeState(state: CoreWallet): TSerialized {
    return this.#v1Context.serializationCapability.serialize(state);
  }
}

================
File: packages/unshielded-wallet/src/UnshieldedWallet.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { ProtocolState, ProtocolVersion } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { BaseV1Configuration, DefaultV1Configuration, V1Builder, V1Tag, V1Variant, CoreWallet } from './v1/index.js';
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { Effect, Either, Scope } from 'effect';
import * as rx from 'rxjs';
import { SerializationCapability } from './v1/Serialization.js';
import { TransactionHistoryService } from './v1/TransactionHistory.js';
import { CoinsAndBalancesCapability } from './v1/CoinsAndBalances.js';
import { KeysCapability } from './v1/Keys.js';
import { TokenTransfer } from './v1/Transacting.js';
import { WalletSyncUpdate } from './v1/SyncSchema.js';
import { UtxoWithMeta } from './v1/UnshieldedState.js';
import { Variant, VariantBuilder, WalletLike } from '@midnight-ntwrk/wallet-sdk-runtime/abstractions';
import { Runtime, WalletBuilder } from '@midnight-ntwrk/wallet-sdk-runtime';
import { PublicKey } from './KeyStore.js';
import { SyncProgress } from './v1/SyncProgress.js';
import { UnshieldedUpdate } from './v1/SyncSchema.js';
import { UnshieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';

export type UnshieldedWalletCapabilities<TSerialized = string> = {
  serialization: SerializationCapability<CoreWallet, TSerialized>;
  coinsAndBalances: CoinsAndBalancesCapability<CoreWallet>;
  keys: KeysCapability<CoreWallet>;
  transactionHistory: TransactionHistoryService<UnshieldedUpdate>;
};

export class UnshieldedWalletState<TSerialized = string> {
  static readonly mapState =
    <TSerialized = string>(capabilities: UnshieldedWalletCapabilities<TSerialized>) =>
    (state: ProtocolState.ProtocolState<CoreWallet>): UnshieldedWalletState<TSerialized> => {
      return new UnshieldedWalletState(state, capabilities);
    };

  readonly protocolVersion: ProtocolVersion.ProtocolVersion;
  readonly state: CoreWallet;
  readonly capabilities: UnshieldedWalletCapabilities<TSerialized>;

  get balances(): Record<ledger.RawTokenType, bigint> {
    return this.capabilities.coinsAndBalances.getAvailableBalances(this.state);
  }

  get totalCoins(): readonly UtxoWithMeta[] {
    return this.capabilities.coinsAndBalances.getTotalCoins(this.state);
  }

  get availableCoins(): readonly UtxoWithMeta[] {
    return this.capabilities.coinsAndBalances.getAvailableCoins(this.state);
  }

  get pendingCoins(): readonly UtxoWithMeta[] {
    return this.capabilities.coinsAndBalances.getPendingCoins(this.state);
  }

  get address(): UnshieldedAddress {
    return this.capabilities.keys.getAddress(this.state);
  }

  get progress(): SyncProgress {
    return this.state.progress;
  }

  get transactionHistory(): TransactionHistoryService<UnshieldedUpdate> {
    return this.capabilities.transactionHistory;
  }

  constructor(state: ProtocolState.ProtocolState<CoreWallet>, capabilities: UnshieldedWalletCapabilities<TSerialized>) {
    this.protocolVersion = state.version;
    this.state = state.state;
    this.capabilities = capabilities;
  }

  serialize(): TSerialized {
    return this.capabilities.serialization.serialize(this.state);
  }
}

export type UnshieldedWallet = CustomizedUnshieldedWallet<ledger.FinalizedTransaction, WalletSyncUpdate, string>;

export type UnshieldedWalletClass = CustomizedUnshieldedWalletClass<
  ledger.FinalizedTransaction,
  WalletSyncUpdate,
  string
>;

export interface CustomizedUnshieldedWallet<
  TTransaction = ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>,
  TSyncUpdate = WalletSyncUpdate,
  TSerialized = string,
> extends WalletLike.WalletLike<[Variant.VersionedVariant<V1Variant<TSerialized, TSyncUpdate, TTransaction>>]> {
  readonly state: rx.Observable<UnshieldedWalletState<TSerialized>>;

  start(): Promise<void>;

  balanceTransaction(
    tx: ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>,
  ): Promise<ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>>;

  transferTransaction(outputs: readonly TokenTransfer[], ttl: Date): Promise<ledger.UnprovenTransaction>;

  initSwap(
    desiredInputs: Record<ledger.RawTokenType, bigint>,
    desiredOutputs: readonly TokenTransfer[],
    ttl: Date,
  ): Promise<ledger.UnprovenTransaction>;

  signTransaction(
    transaction: ledger.UnprovenTransaction,
    signSegment: (data: Uint8Array) => ledger.Signature,
  ): Promise<ledger.UnprovenTransaction>;

  serializeState(): Promise<TSerialized>;

  waitForSyncedState(allowedGap?: bigint): Promise<UnshieldedWalletState<TSerialized>>;

  getAddress(): Promise<UnshieldedAddress>;
}

export interface CustomizedUnshieldedWalletClass<
  TTransaction = ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>,
  TSyncUpdate = WalletSyncUpdate,
  TSerialized = string,
  TConfig extends BaseV1Configuration = DefaultV1Configuration,
> extends WalletLike.BaseWalletClass<[Variant.VersionedVariant<V1Variant<TSerialized, TSyncUpdate, TTransaction>>]> {
  configuration: TConfig;
  startWithPublicKey(publicKey: PublicKey): CustomizedUnshieldedWallet<TTransaction, TSyncUpdate, TSerialized>;
  restore(serializedState: TSerialized): CustomizedUnshieldedWallet<TTransaction, TSyncUpdate, TSerialized>;
}

export function UnshieldedWallet(configuration: DefaultV1Configuration): UnshieldedWalletClass {
  return CustomUnshieldedWallet(configuration, new V1Builder().withDefaults());
}

export function CustomUnshieldedWallet<
  TConfig extends BaseV1Configuration = DefaultV1Configuration,
  TTransaction = ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>,
  TSyncUpdate = WalletSyncUpdate,
  TSerialized = string,
>(
  configuration: TConfig,
  builder: VariantBuilder.VariantBuilder<V1Variant<TSerialized, TSyncUpdate, TTransaction>, TConfig>,
): CustomizedUnshieldedWalletClass<TTransaction, TSyncUpdate, TSerialized, TConfig> {
  const buildArgs = [configuration] as WalletBuilder.BuildArguments<
    [
      VariantBuilder.VersionedVariantBuilder<
        VariantBuilder.VariantBuilder<V1Variant<TSerialized, TSyncUpdate, TTransaction>, TConfig>
      >,
    ]
  >;
  const BaseWallet = WalletBuilder.init()
    .withVariant(ProtocolVersion.MinSupportedVersion, builder)
    .build(...buildArgs) as WalletLike.BaseWalletClass<
    [Variant.VersionedVariant<V1Variant<TSerialized, TSyncUpdate, TTransaction>>],
    TConfig
  >;

  return class CustomUnshieldedWalletImplementation
    extends BaseWallet
    implements CustomizedUnshieldedWallet<TTransaction, TSyncUpdate, TSerialized>
  {
    static startWithPublicKey(publicKeys: PublicKey): CustomUnshieldedWalletImplementation {
      return CustomUnshieldedWalletImplementation.startFirst(
        CustomUnshieldedWalletImplementation,
        CoreWallet.init(publicKeys, configuration.networkId),
      );
    }

    static restore(serializedState: TSerialized): CustomUnshieldedWalletImplementation {
      const deserialized: CoreWallet = CustomUnshieldedWalletImplementation.allVariantsRecord()
        [V1Tag].variant.deserializeState(serializedState)
        .pipe(Either.getOrThrow);
      return CustomUnshieldedWalletImplementation.startFirst(CustomUnshieldedWalletImplementation, deserialized);
    }

    readonly state: rx.Observable<UnshieldedWalletState<TSerialized>>;

    constructor(
      runtime: Runtime.Runtime<[Variant.VersionedVariant<V1Variant<TSerialized, TSyncUpdate, TTransaction>>]>,
      scope: Scope.CloseableScope,
    ) {
      super(runtime, scope);
      this.state = this.rawState.pipe(
        rx.map(
          UnshieldedWalletState.mapState<TSerialized>(
            CustomUnshieldedWalletImplementation.allVariantsRecord()[V1Tag].variant,
          ),
        ),
        rx.shareReplay({ refCount: true, bufferSize: 1 }),
      );
    }

    start(): Promise<void> {
      return this.runtime.dispatch({ [V1Tag]: (v1) => v1.startSyncInBackground() }).pipe(Effect.runPromise);
    }

    balanceTransaction(
      tx: ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>,
    ): Promise<ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>> {
      return this.runtime
        .dispatch({
          [V1Tag]: (v1) => v1.balanceTransaction(tx),
        })
        .pipe(Effect.runPromise);
    }

    transferTransaction(outputs: readonly TokenTransfer[], ttl: Date): Promise<ledger.UnprovenTransaction> {
      return this.runtime
        .dispatch({
          [V1Tag]: (v1) => v1.transferTransaction(outputs, ttl),
        })
        .pipe(Effect.runPromise);
    }

    initSwap(
      desiredInputs: Record<ledger.RawTokenType, bigint>,
      desiredOutputs: readonly TokenTransfer[],
      ttl: Date,
    ): Promise<ledger.UnprovenTransaction> {
      return this.runtime
        .dispatch({ [V1Tag]: (v1) => v1.initSwap(desiredInputs, desiredOutputs, ttl) })
        .pipe(Effect.runPromise);
    }

    signTransaction(
      transaction: ledger.UnprovenTransaction,
      signSegment: (data: Uint8Array) => ledger.Signature,
    ): Promise<ledger.UnprovenTransaction> {
      return this.runtime
        .dispatch({
          [V1Tag]: (v1) => v1.signTransaction(transaction, signSegment),
        })
        .pipe(Effect.runPromise);
    }

    waitForSyncedState(allowedGap: bigint = 0n): Promise<UnshieldedWalletState<TSerialized>> {
      return rx.firstValueFrom(
        this.state.pipe(rx.filter((state) => state.state.progress.isCompleteWithin(allowedGap))),
      );
    }

    /**
     * Serializes the most recent state
     * It's preferable to use [[UnshieldedWalletState.serialize]] instead, to know exactly, which state is serialized
     */
    serializeState(): Promise<TSerialized> {
      return rx.firstValueFrom(this.state).then((state) => state.serialize());
    }

    getAddress(): Promise<UnshieldedAddress> {
      return rx.firstValueFrom(this.state).then((state) => state.address);
    }
  };
}

================
File: packages/unshielded-wallet/src/v1/Transacting.ts
================
// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ledger from '@midnight-ntwrk/ledger-v6';
import { NetworkId } from '@midnight-ntwrk/wallet-sdk-abstractions';
import { Either, Option, pipe } from 'effect';
import { CoreWallet } from './CoreWallet.js';
import { SignError, TransactingError, WalletError } from './WalletError.js';
import { CoinSelection, getBalanceRecipe, Imbalances } from '@midnight-ntwrk/wallet-sdk-capabilities';
import { isIntentBound, TransactionTrait } from './Transaction.js';
import { CoinsAndBalancesCapability } from './CoinsAndBalances.js';
import { KeysCapability } from './Keys.js';
import { MidnightBech32m, UnshieldedAddress } from '@midnight-ntwrk/wallet-sdk-address-format';

const GUARANTEED_SEGMENT = 0;

export interface TokenTransfer {
  readonly amount: bigint;
  readonly type: ledger.RawTokenType;
  readonly receiverAddress: string;
}

export type TransactingResult<TTransaction, TState> = {
  readonly newState: TState;
  readonly transaction: TTransaction;
};

const mergeCounterOffer = (
  counterOffer: ledger.UnshieldedOffer<ledger.SignatureEnabled>,
  currentOffer?: ledger.UnshieldedOffer<ledger.SignatureEnabled>,
): Either.Either<ledger.UnshieldedOffer<ledger.SignatureEnabled>, WalletError> =>
  pipe(
    Option.fromNullable(currentOffer),
    Option.match({
      onNone: () => Either.right(counterOffer),
      onSome: (currentOffer) =>
        Either.try({
          try: () =>
            ledger.UnshieldedOffer.new(
              [...currentOffer.inputs, ...counterOffer.inputs],
              [...currentOffer.outputs, ...counterOffer.outputs],
              [...currentOffer.signatures, ...counterOffer.signatures],
            ),
          catch: (error) => new TransactingError({ message: 'Failed to merge counter offers', cause: error }),
        }),
    }),
  );

export interface TransactingCapability<_TTransaction, TState> {
  makeTransfer(
    wallet: CoreWallet,
    outputs: ReadonlyArray<TokenTransfer>,
    ttl: Date,
  ): Either.Either<TransactingResult<ledger.UnprovenTransaction, TState>, WalletError>;

  initSwap(
    wallet: CoreWallet,
    desiredInputs: Record<string, bigint>,
    outputs: ReadonlyArray<TokenTransfer>,
    ttl: Date,
  ): Either.Either<TransactingResult<ledger.UnprovenTransaction, TState>, WalletError>;

  balanceTransaction(
    wallet: CoreWallet,
    transaction: ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>,
  ): Either.Either<
    TransactingResult<ledger.Transaction<ledger.SignatureEnabled, ledger.Proofish, ledger.Bindingish>, TState>,
    WalletError
  >;

  signTransaction(
    transaction: ledger.UnprovenTransaction,
    signSegment: (data: Uint8Array) => ledger.Signature,
  ): Either.Either<ledger.UnprovenTransaction, WalletError>;
}

export type DefaultTransactingConfiguration = {
  networkId: NetworkId.NetworkId;
};

export type DefaultTransactingContext = {
  coinSelection: CoinSelection<ledger.Utxo>;
  coinsAndBalancesCapability: CoinsAndBalancesCapability<CoreWallet>;
  keysCapability: KeysCapability<CoreWallet>;
};

export const makeDefaultTransactingCapability = (
  config: DefaultTransactingConfiguration,
  getContext: () => DefaultTransactingContext,
): TransactingCapability<ledger.UnprovenTransaction, CoreWallet> => {
  return new TransactingCapabilityImplementation(
    config.networkId,
    () => getContext().coinSelection,
    () => getContext().coinsAndBalancesCapability,
    () => getContext().keysCapability,
    TransactionTrait.default,
  );
};

export class TransactingCapabilityImplementation<
  TTransaction extends ledger.UnprovenTransaction,
> implements TransactingCapability<ledger.UnprovenTransaction, CoreWallet> {
  public readonly networkId: NetworkId.NetworkId;
  public readonly getCoinSelection: () => CoinSelection<ledger.Utxo>;
  public readonly txTrait: TransactionTrait<TTransaction>;
  readonly getCoins: () => CoinsAndBalancesCapability<CoreWallet>;
  readonly getKeys: () => KeysCapability<CoreWallet>;

  constructor(
    networkId: NetworkId.NetworkId,
    getCoinSelection: () => CoinSelection<ledger.Utxo>,
    getCoins: () => CoinsAndBalancesCapability<CoreWallet>,
    getKeys: () => KeysCapability<CoreWallet>,
    txTrait: TransactionTrait<TTransaction>,
  ) {
    this.getCoins = getCoins;
    this.networkId = networkId;
    this.getCoinSelection = getCoinSelection;
    this.getKeys = getKeys;
    this.txTrait = txTrait;
  }

  balanceTransaction(
    wallet: CoreWallet,
    transaction: TTransaction,
  ): Either.Either<TransactingResult<TTransaction, CoreWallet>, WalletError> {
    return Either.gen(this, function* () {
      const segments = TransactionTrait.default.getSegments(transaction);

      if (!transaction.intents || !transaction.intents.size || !segments.length) {
        return {
          newState: wallet,
          transaction,
        };
      }

      const { addressHex, publicKey } = wallet.publicKey;

      for (const segment of [...segments, GUARANTEED_SEGMENT]) {
        const allIntentImbalances = yield* Either.try({
          try: () => transaction.imbalances(segment),
          catch: (error) => new TransactingError({ message: 'Failed to get intent imbalances', cause: error }),
        });
        const imbalances = allIntentImbalances
          .entries()
          .filter(([token, value]) => token.tag === 'unshielded' && value !== 0n)
          .map(([token, value]) => [token, value] as [ledger.UnshieldedTokenType, bigint])
          .map(([token, value]) => {
            return [token.raw, value] as [string, bigint];
          })
          .toArray();

        // // intent is balanced
        if (!imbalances.length) continue;

        const availableCoins = this.getCoins().getAvailableCoins(wallet);

        if (!availableCoins.length) {
          return yield* Either.left(new TransactingError({ message: 'No available coins to spend' }));
        }

        // select inputs, receive the change outputs
        const { inputs, outputs: changeOutputs } = yield* Either.try({
          try: () =>
            getBalanceRecipe<ledger.Utxo, ledger.UtxoOutput>({
              coins: availableCoins.map(({ utxo }) => utxo),
              initialImbalances: Imbalances.fromEntries(imbalances),
              feeTokenType: '',
              transactionCostModel: {
                inputFeeOverhead: 0n,
                outputFeeOverhead: 0n,
              },
              createOutput: (coin) => ({
                ...coin,
                owner: addressHex,
              }),
              isCoinEqual: (a, b) => a.intentHash === b.intentHash && a.outputNo === b.outputNo,
            }),
          catch: (error) => {
            const message = error instanceof Error ? error.message : error?.toString() || '';
            return new TransactingError({ message });
          },
        });

        // mark the coins as spent
        const [spentInputs] = yield* CoreWallet.spendUtxos(wallet, inputs);

        const ledgerInputs = spentInputs.map((input) => ({
          ...input,
          intentHash: input.intentHash,
          owner: publicKey,
        }));

        const counterOffer = yield* Either.try({
          try: () => ledger.UnshieldedOffer.new(ledgerInputs, changeOutputs, []),
          catch: (error) => new TransactingError({ message: 'Failed to create counter offer', cause: error }),
        });

        // NOTE: for the segment === 0 we insert the counter-offer into any intent's guaranteed section
        if (segment !== GUARANTEED_SEGMENT) {
          const intent = transaction.intents.get(segment)!;

          const isBound = isIntentBound(intent);
          if (!isBound && intent.fallibleUnshieldedOffer) {
            const mergedOffer = yield* mergeCounterOffer(counterOffer, intent.fallibleUnshieldedOffer);
            intent.fallibleUnshieldedOffer = mergedOffer;
            transaction.intents = transaction.intents.set(segment, intent);
          } else {
            // create a new offer if the intent is bound
            const nextSegment = Math.max(...TransactionTrait.default.getSegments(transaction)) + 1;
            const newIntent = ledger.Intent.new(intent.ttl);
            newIntent.fallibleUnshieldedOffer = counterOffer;
            transaction.intents = transaction.intents.set(nextSegment, newIntent);
          }
        } else {
          let ttl: Date = new Date();
          let updated = false;

          // try to find and modify any unbound intent first
          const segments = TransactionTrait.default.getSegments(transaction);
          for (const segment of segments) {
            const intent = transaction.intents.get(segment)!;
            ttl = intent.ttl;
            const isBound = isIntentBound(intent);
            if (!isBound) {
              const mergedOffer = yield* mergeCounterOffer(counterOffer, intent.guaranteedUnshieldedOffer);

              intent.guaranteedUnshieldedOffer = mergedOffer;
              transaction.intents = transaction.intents.set(segment, intent);

              updated = true;
              break;
            }
          }

          // no unbound intents found, insert a new one
          if (!updated) {
            const nextSegment = Math.max(...segments) + 1;
            const newIntent = ledger.Intent.new(ttl);
            newIntent.guaranteedUnshieldedOffer = counterOffer;
            transaction.intents = transaction.intents.set(nextSegment, newIntent);
          }
        }
      }
      return {
        newState: wallet,
        transaction: transaction,
      };
    });
  }

  makeTransfer(
    wallet: CoreWallet,
    outputs: ReadonlyArray<TokenTransfer>,
    ttl: Date,
  ): Either.Either<TransactingResult<TTransaction, CoreWallet>, WalletError> {
    const networkId = this.networkId;
    const isValid = outputs.every((output) => output.amount > 0n);
    if (!isValid) {
      throw new TransactingError({ message: 'The amount needs to be positive' });
    }

    const ledgerOutputs = outputs.map((output) => {
      return {
        value: output.amount,
        owner: UnshieldedAddress.codec
          .decode(networkId, MidnightBech32m.parse(output.receiverAddress))
          .data.toString('hex'),
        type: output.type,
      };
    });

    return Either.try({
      try: () => {
        const intent = ledger.Intent.new(ttl);
        intent.guaranteedUnshieldedOffer = ledger.UnshieldedOffer.new([], ledgerOutputs, []);
        return {
          newState: wallet,
          transaction: ledger.Transaction.fromParts(networkId, undefined, undefined, intent) as TTransaction,
        };
      },
      catch: (error) => new TransactingError({ message: 'Failed to create transaction', cause: error }),
    });
  }

  initSwap(
    wallet: CoreWallet,
    desiredInputs: Record<ledger.RawTokenType, bigint>,
    desiredOutputs: ReadonlyArray<TokenTransfer>,
    ttl: Date,
  ): Either.Either<TransactingResult<TTransaction, CoreWallet>, WalletError> {
    return Either.gen(this, function* () {
      const networkId = this.networkId;
      const outputsValid = desiredOutputs.every((output) => output.amount > 0n);
      if (!outputsValid) {
        return yield* Either.left(new TransactingError({ message: 'The amount needs to be positive' }));
      }

      const inputsValid = Object.entries(desiredInputs).every(([, amount]) => amount > 0n);
      if (!inputsValid) {
        return yield* Either.left(new TransactingError({ message: 'The input amounts need to be positive' }));
      }

      const ledgerOutputs = desiredOutputs.map((output) => ({
        value: output.amount,
        owner: UnshieldedAddress.codec
          .decode(networkId, MidnightBech32m.parse(output.receiverAddress))
          .data.toString('hex'),
        type: output.type,
      }));

      const targetImbalances = Imbalances.fromEntries(Object.entries(desiredInputs));

      const availableCoins = this.getCoins().getAvailableCoins(wallet);

      const { inputs, outputs: changeOutputs } = yield* Either.try({
        try: () =>
          getBalanceRecipe<ledger.Utxo, ledger.UtxoOutput>({
            coins: availableCoins.map(({ utxo }) => utxo),
            initialImbalances: Imbalances.empty(),
            feeTokenType: '',
            transactionCostModel: {
              inputFeeOverhead: 0n,
              outputFeeOverhead: 0n,
            },
            createOutput: (coin) => ({
              ...coin,
              owner: wallet.publicKey.addressHex,
            }),
            isCoinEqual: (a, b) => a.intentHash === b.intentHash && a.outputNo === b.outputNo,
            targetImbalances,
          }),
        catch: (error) => {
          const message = error instanceof Error ? error.message : error?.toString() || '';
          return new TransactingError({ message });
        },
      });

      const [spentInputs, updatedWallet] = yield* CoreWallet.spendUtxos(wallet, inputs);

      const ledgerInputs = spentInputs.map((input) => ({
        ...input,
        owner: wallet.publicKey.publicKey,
      }));

      const offer = ledger.UnshieldedOffer.new(ledgerInputs, [...changeOutputs, ...ledgerOutputs], []);
      const intent = ledger.Intent.new(ttl);
      intent.guaranteedUnshieldedOffer = offer;

      const tx = ledger.Transaction.fromParts(networkId, undefined, undefined, intent) as TTransaction;

      return {
        newState: updatedWallet,
        transaction: tx,
      };
    });
  }

  signTransaction(
    transaction: ledger.UnprovenTransaction,
    signSegment: (data: Uint8Array) => ledger.Signature,
  ): Either.Either<ledger.UnprovenTransaction, WalletError> {
    return Either.gen(function* () {
      const segments = TransactionTrait.default.getSegments(transaction);
      if (!segments.length) {
        throw new SignError({ message: 'No segments found in the provided transaction' });
      }

      for (const segment of segments) {
        const signedData = yield* TransactionTrait.default.getOfferSignatureData(transaction, segment);
        const signature = signSegment(signedData);
        transaction = yield* TransactionTrait.default.addOfferSignature(transaction, signature, segment);
      }
      return transaction;
    });
  }
}





================================================================
End of Codebase
================================================================
